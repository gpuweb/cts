{"version":3,"file":"device_allocation.spec.js","names":["description","Fixture","makeTestGroup","attemptGarbageCollection","keysOf","getGPU","assert","iterRange","getDefaultLimitsForCTS","g","kAdapterTypeOptions","powerPreference","forceFallbackAdapter","undefined","kAdapterTypes","createDeviceAndComputeCommands","t","adapter","limitInfo","kNumPipelines","kNumBindgroups","kNumBufferElements","maxComputeWorkgroupSizeX","default","maxComputeWorkgroupSizeY","kBufferSize","kBufferData","Uint32Array","x","device","requestDeviceTracked","commands","pipelineIndex","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindgroupIndex","buffer","trackForCleanup","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","queue","writeBuffer","length","bindgroup","createBindGroup","getBindGroupLayout","entries","binding","resource","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","push","finish","objects","createDeviceAndRenderCommands","kSize","createRenderPipeline","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","visibility","GPUShaderStage","VERTEX","type","vertex","buffers","primitive","topology","fragment","targets","format","UNIFORM","texture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","draw","createDeviceAndBuffers","kTotalMemorySize","kMemoryBlockSize","kMemoryBlockData","Uint8Array","memory","test","desc","params","u","combine","fn","adapterType","rec","requestAdapter","kNumDevices","devices","i","kFunctions","deviceList","objectLists","expect","destroy","requestDevice"],"sources":["../../../src/stress/adapter/device_allocation.spec.ts"],"sourcesContent":["export const description = `\nStress tests for GPUAdapter.requestDevice.\n`;\n\nimport { Fixture } from '../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { keysOf } from '../../common/util/data_tables.js';\nimport { getGPU } from '../../common/util/navigator_gpu.js';\nimport { assert, iterRange } from '../../common/util/util.js';\nimport { getDefaultLimitsForCTS } from '../../webgpu/capability_info.js';\n\nexport const g = makeTestGroup(Fixture);\n\n/** Adapter preference identifier to option. */\nconst kAdapterTypeOptions: {\n  readonly [k in GPUPowerPreference | 'fallback']: GPURequestAdapterOptions;\n} =\n  /* prettier-ignore */ {\n  'low-power':        { powerPreference:        'low-power', forceFallbackAdapter: false },\n  'high-performance': { powerPreference: 'high-performance', forceFallbackAdapter: false },\n  'fallback':         { powerPreference:          undefined, forceFallbackAdapter:  true },\n};\n/** List of all adapter hint types. */\nconst kAdapterTypes = keysOf(kAdapterTypeOptions);\n\n/**\n * Creates a device, a valid compute pipeline, valid resources for the pipeline, and\n * ties them together into a set of compute commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndComputeCommands(t: Fixture, adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const limitInfo = getDefaultLimitsForCTS();\n  const kNumPipelines = 64;\n  const kNumBindgroups = 128;\n  const kNumBufferElements =\n    limitInfo.maxComputeWorkgroupSizeX.default * limitInfo.maxComputeWorkgroupSizeY.default;\n  const kBufferSize = kNumBufferElements * 4;\n  const kBufferData = new Uint32Array([...iterRange(kNumBufferElements, x => x)]);\n\n  const device: GPUDevice = await t.requestDeviceTracked(adapter);\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: device.createShaderModule({\n          code: `\n              struct Buffer { data: array<u32>, };\n\n              @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n              @compute @workgroup_size(1) fn main(\n                  @builtin(global_invocation_id) id: vec3<u32>) {\n                buffer.data[id.x * ${limitInfo.maxComputeWorkgroupSizeX.default}u + id.y] =\n                  buffer.data[id.x * ${limitInfo.maxComputeWorkgroupSizeX.default}u + id.y] +\n                    ${pipelineIndex}u;\n              }\n            `,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = t.trackForCleanup(\n        device.createBuffer({\n          size: kBufferSize,\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        })\n      );\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.dispatchWorkgroups(\n        limitInfo.maxComputeWorkgroupSizeX.default,\n        limitInfo.maxComputeWorkgroupSizeY.default\n      );\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device, a valid render pipeline, valid resources for the pipeline, and\n * ties them together into a set of render commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndRenderCommands(t: Fixture, adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const kNumPipelines = 128;\n  const kNumBindgroups = 128;\n  const kSize = 128;\n  const kBufferData = new Uint32Array([...iterRange(kSize * kSize, x => x)]);\n\n  const device: GPUDevice = await t.requestDeviceTracked(adapter);\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const module = device.createShaderModule({\n      code: `\n          struct Buffer { data: array<vec4<u32>, ${(kSize * kSize) / 4}>, };\n\n          @group(0) @binding(0) var<uniform> buffer: Buffer;\n          @vertex fn vmain(\n            @builtin(vertex_index) vertexIndex: u32\n          ) -> @builtin(position) vec4<f32> {\n            let index = buffer.data[vertexIndex / 4u][vertexIndex % 4u];\n            let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n            let r = vec2<f32>(1.0 / f32(${kSize}));\n            let a = 2.0 * r;\n            let b = r - vec2<f32>(1.0);\n            return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n          }\n\n          @fragment fn fmain() -> @location(0) vec4<f32> {\n            return vec4<f32>(${pipelineIndex}.0 / ${kNumPipelines}.0, 0.0, 0.0, 1.0);\n          }\n        `,\n    });\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [\n          device.createBindGroupLayout({\n            entries: [\n              {\n                binding: 0,\n                visibility: GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n              },\n            ],\n          }),\n        ],\n      }),\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = t.trackForCleanup(\n        device.createBuffer({\n          size: kSize * kSize * 4,\n          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        })\n      );\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n      const texture = t.trackForCleanup(\n        device.createTexture({\n          size: [kSize, kSize],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n          format: 'rgba8unorm',\n        })\n      );\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: texture.createView(),\n            loadOp: 'load',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.draw(kSize * kSize);\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device and a large number of buffers which are immediately written to. The\n * buffers are expected to be kept alive until they or the device are destroyed.\n */\nasync function createDeviceAndBuffers(t: Fixture, adapter: GPUAdapter) {\n  // Currently we just allocate 2G of memory using 512MB blocks. We may be able to\n  // increase this to hit OOM instead, but on integrated GPUs on Metal, this can cause\n  // kernel panics at the moment, and it can greatly increase the time needed.\n  const kTotalMemorySize = 2 * 1024 * 1024 * 1024;\n  const kMemoryBlockSize = 512 * 1024 * 1024;\n  const kMemoryBlockData = new Uint8Array(kMemoryBlockSize);\n\n  const device: GPUDevice = await t.requestDeviceTracked(adapter);\n  const buffers = [];\n  for (let memory = 0; memory < kTotalMemorySize; memory += kMemoryBlockSize) {\n    const buffer = t.trackForCleanup(\n      device.createBuffer({\n        size: kMemoryBlockSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      })\n    );\n\n    // Write out to the buffer to make sure that it has backing memory.\n    device.queue.writeBuffer(buffer, 0, kMemoryBlockData, 0, kMemoryBlockData.length);\n    buffers.push(buffer);\n  }\n  return { device, objects: buffers };\n}\n\ng.test('coexisting')\n  .desc(`Tests allocation of many coexisting GPUDevice objects.`)\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU(t.rec).requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Based on Vulkan conformance test requirement to be able to create multiple devices.\n    const kNumDevices = 5;\n\n    const devices = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const device = await t.requestDeviceTracked(adapter);\n      devices.push(device);\n    }\n  });\n\ng.test('continuous,with_destroy')\n  .desc(\n    `Tests allocation and destruction of many GPUDevice objects over time. Device objects\nare sequentially requested with a series of device allocated objects created on each\ndevice. The devices are then destroyed to verify that the device and the device allocated\nobjects are recycled over a very large number of iterations.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU(t.rec).requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Since devices are being destroyed, we should be able to create many devices.\n    const kNumDevices = 100;\n    const kFunctions = [\n      createDeviceAndBuffers,\n      createDeviceAndComputeCommands,\n      createDeviceAndRenderCommands,\n    ];\n\n    const deviceList = [];\n    const objectLists = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const { device, objects } = await kFunctions[i % kFunctions.length](t, adapter);\n      t.expect(objects.length > 0, 'unable to allocate any objects');\n      deviceList.push(device);\n      objectLists.push(objects);\n      device.destroy();\n    }\n  });\n\ng.test('continuous,no_destroy')\n  .desc(\n    `Tests allocation and implicit GC of many GPUDevice objects over time. Objects are\nsequentially requested and dropped for GC over a very large number of iterations. Note\nthat without destroy, we do not create device allocated objects because that will\nimplicitly keep the device in scope.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU(t.rec).requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    const kNumDevices = 10_000;\n    for (let i = 1; i <= kNumDevices; ++i) {\n      await (async () => {\n        // No trackForCleanup because it would prevent the GPUDevice from being GCed.\n        // eslint-disable-next-line no-restricted-syntax\n        t.expect((await adapter.requestDevice()) !== null, 'unexpected null device');\n      })();\n      if (i % 10 === 0) {\n        // We need to occasionally wait for GC to clear out stale devices.\n        await attemptGarbageCollection();\n      }\n    }\n  });\n"],"mappings":"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"}