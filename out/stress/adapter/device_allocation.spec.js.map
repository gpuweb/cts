{"version":3,"file":"device_allocation.spec.js","names":["description","Fixture","makeTestGroup","attemptGarbageCollection","keysOf","getGPU","assert","iterRange","kLimitInfo","g","kAdapterTypeOptions","powerPreference","forceFallbackAdapter","undefined","kAdapterTypes","createDeviceAndComputeCommands","adapter","kNumPipelines","kNumBindgroups","kNumBufferElements","maxComputeWorkgroupSizeX","default","maxComputeWorkgroupSizeY","kBufferSize","kBufferData","Uint32Array","x","device","requestDevice","commands","pipelineIndex","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindgroupIndex","buffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","queue","writeBuffer","length","bindgroup","createBindGroup","getBindGroupLayout","entries","binding","resource","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","push","finish","objects","createDeviceAndRenderCommands","kSize","createRenderPipeline","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","visibility","GPUShaderStage","VERTEX","type","vertex","buffers","primitive","topology","fragment","targets","format","UNIFORM","texture","createTexture","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","draw","createDeviceAndBuffers","kTotalMemorySize","kMemoryBlockSize","kMemoryBlockData","Uint8Array","memory","test","desc","params","u","combine","fn","t","adapterType","requestAdapter","kNumDevices","devices","i","kFunctions","deviceList","objectLists","expect","destroy"],"sources":["../../../src/stress/adapter/device_allocation.spec.ts"],"sourcesContent":["export const description = `\nStress tests for GPUAdapter.requestDevice.\n`;\n\nimport { Fixture } from '../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { keysOf } from '../../common/util/data_tables.js';\nimport { getGPU } from '../../common/util/navigator_gpu.js';\nimport { assert, iterRange } from '../../common/util/util.js';\nimport { kLimitInfo } from '../../webgpu/capability_info.js';\n\nexport const g = makeTestGroup(Fixture);\n\n/** Adapter preference identifier to option. */\nconst kAdapterTypeOptions: {\n  readonly [k in GPUPowerPreference | 'fallback']: GPURequestAdapterOptions;\n} = /* prettier-ignore */ {\n  'low-power':        { powerPreference:        'low-power', forceFallbackAdapter: false },\n  'high-performance': { powerPreference: 'high-performance', forceFallbackAdapter: false },\n  'fallback':         { powerPreference:          undefined, forceFallbackAdapter:  true },\n};\n/** List of all adapter hint types. */\nconst kAdapterTypes = keysOf(kAdapterTypeOptions);\n\n/**\n * Creates a device, a valid compute pipeline, valid resources for the pipeline, and\n * ties them together into a set of compute commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndComputeCommands(adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const kNumPipelines = 64;\n  const kNumBindgroups = 128;\n  const kNumBufferElements =\n    kLimitInfo.maxComputeWorkgroupSizeX.default * kLimitInfo.maxComputeWorkgroupSizeY.default;\n  const kBufferSize = kNumBufferElements * 4;\n  const kBufferData = new Uint32Array([...iterRange(kNumBufferElements, x => x)]);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: device.createShaderModule({\n          code: `\n              struct Buffer { data: array<u32>, };\n\n              @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n              @compute @workgroup_size(1) fn main(\n                  @builtin(global_invocation_id) id: vec3<u32>) {\n                buffer.data[id.x * ${kLimitInfo.maxComputeWorkgroupSizeX.default}u + id.y] =\n                  buffer.data[id.x * ${kLimitInfo.maxComputeWorkgroupSizeX.default}u + id.y] +\n                    ${pipelineIndex}u;\n              }\n            `,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = device.createBuffer({\n        size: kBufferSize,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n      });\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.dispatch(\n        kLimitInfo.maxComputeWorkgroupSizeX.default,\n        kLimitInfo.maxComputeWorkgroupSizeY.default\n      );\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device, a valid render pipeline, valid resources for the pipeline, and\n * ties them together into a set of render commands ready to be submitted to the GPU\n * queue. Does not submit the commands in order to make sure that all resources are\n * kept alive until the device is destroyed.\n */\nasync function createDeviceAndRenderCommands(adapter: GPUAdapter) {\n  // Constants are computed such that per run, this function should allocate roughly 2G\n  // worth of data. This should be sufficient as we run these creation functions many\n  // times. If the data backing the created objects is not recycled we should OOM.\n  const kNumPipelines = 128;\n  const kNumBindgroups = 128;\n  const kSize = 128;\n  const kBufferData = new Uint32Array([...iterRange(kSize * kSize, x => x)]);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const commands = [];\n\n  for (let pipelineIndex = 0; pipelineIndex < kNumPipelines; ++pipelineIndex) {\n    const module = device.createShaderModule({\n      code: `\n          struct Buffer { data: array<vec4<u32>, ${(kSize * kSize) / 4}>, };\n\n          @group(0) @binding(0) var<uniform> buffer: Buffer;\n          @vertex fn vmain(\n            @builtin(vertex_index) vertexIndex: u32\n          ) -> @builtin(position) vec4<f32> {\n            let index = buffer.data[vertexIndex / 4u][vertexIndex % 4u];\n            let position = vec2<f32>(f32(index % ${kSize}u), f32(index / ${kSize}u));\n            let r = vec2<f32>(1.0 / f32(${kSize}));\n            let a = 2.0 * r;\n            let b = r - vec2<f32>(1.0);\n            return vec4<f32>(fma(position, a, b), 0.0, 1.0);\n          }\n\n          @fragment fn fmain() -> @location(0) vec4<f32> {\n            return vec4<f32>(${pipelineIndex}.0 / ${kNumPipelines}.0, 0.0, 0.0, 1.0);\n          }\n        `,\n    });\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [\n          device.createBindGroupLayout({\n            entries: [\n              {\n                binding: 0,\n                visibility: GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n              },\n            ],\n          }),\n        ],\n      }),\n      vertex: { module, entryPoint: 'vmain', buffers: [] },\n      primitive: { topology: 'point-list' },\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module,\n        entryPoint: 'fmain',\n      },\n    });\n    for (let bindgroupIndex = 0; bindgroupIndex < kNumBindgroups; ++bindgroupIndex) {\n      const buffer = device.createBuffer({\n        size: kSize * kSize * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n      device.queue.writeBuffer(buffer, 0, kBufferData, 0, kBufferData.length);\n      const bindgroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n      const texture = device.createTexture({\n        size: [kSize, kSize],\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n        format: 'rgba8unorm',\n      });\n\n      const encoder = device.createCommandEncoder();\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: texture.createView(),\n            loadOp: 'load',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindgroup);\n      pass.draw(kSize * kSize);\n      pass.end();\n      commands.push(encoder.finish());\n    }\n  }\n  return { device, objects: commands };\n}\n\n/**\n * Creates a device and a large number of buffers which are immediately written to. The\n * buffers are expected to be kept alive until they or the device are destroyed.\n */\nasync function createDeviceAndBuffers(adapter: GPUAdapter) {\n  // Currently we just allocate 2G of memory using 512MB blocks. We may be able to\n  // increase this to hit OOM instead, but on integrated GPUs on Metal, this can cause\n  // kernel panics at the moment, and it can greatly increase the time needed.\n  const kTotalMemorySize = 2 * 1024 * 1024 * 1024;\n  const kMemoryBlockSize = 512 * 1024 * 1024;\n  const kMemoryBlockData = new Uint8Array(kMemoryBlockSize);\n\n  const device: GPUDevice = await adapter.requestDevice();\n  const buffers = [];\n  for (let memory = 0; memory < kTotalMemorySize; memory += kMemoryBlockSize) {\n    const buffer = device.createBuffer({\n      size: kMemoryBlockSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // Write out to the buffer to make sure that it has backing memory.\n    device.queue.writeBuffer(buffer, 0, kMemoryBlockData, 0, kMemoryBlockData.length);\n    buffers.push(buffer);\n  }\n  return { device, objects: buffers };\n}\n\ng.test('coexisting')\n  .desc(`Tests allocation of many coexisting GPUDevice objects.`)\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Based on Vulkan conformance test requirement to be able to create multiple devices.\n    const kNumDevices = 5;\n\n    const devices = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const device: GPUDevice = await adapter.requestDevice();\n      devices.push(device);\n    }\n  });\n\ng.test('continuous,with_destroy')\n  .desc(\n    `Tests allocation and destruction of many GPUDevice objects over time. Device objects\nare sequentially requested with a series of device allocated objects created on each\ndevice. The devices are then destroyed to verify that the device and the device allocated\nobjects are recycled over a very large number of iterations.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    // Since devices are being destroyed, we should be able to create many devices.\n    const kNumDevices = 100;\n    const kFunctions = [\n      createDeviceAndBuffers,\n      createDeviceAndComputeCommands,\n      createDeviceAndRenderCommands,\n    ];\n\n    const deviceList = [];\n    const objectLists = [];\n    for (let i = 0; i < kNumDevices; ++i) {\n      const { device, objects } = await kFunctions[i % kFunctions.length](adapter);\n      t.expect(objects.length > 0, 'unable to allocate any objects');\n      deviceList.push(device);\n      objectLists.push(objects);\n      device.destroy();\n    }\n  });\n\ng.test('continuous,no_destroy')\n  .desc(\n    `Tests allocation and implicit GC of many GPUDevice objects over time. Objects are\nsequentially requested and dropped for GC over a very large number of iterations. Note\nthat without destroy, we do not create device allocated objects because that will\nimplicitly keep the device in scope.`\n  )\n  .params(u => u.combine('adapterType', kAdapterTypes))\n  .fn(async t => {\n    const { adapterType } = t.params;\n    const adapter = await getGPU().requestAdapter(kAdapterTypeOptions[adapterType]);\n    assert(adapter !== null, 'Failed to get adapter.');\n\n    const kNumDevices = 10_000;\n    for (let i = 1; i <= kNumDevices; ++i) {\n      await (async () => {\n        t.expect((await adapter.requestDevice()) !== null, 'unexpected null device');\n      })();\n      if (i % 10 === 0) {\n        // We need to occasionally wait for GC to clear out stale devices.\n        await attemptGarbageCollection();\n      }\n    }\n  });\n"],"mappings":"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"}