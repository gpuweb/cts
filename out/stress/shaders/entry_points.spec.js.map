{"version":3,"sources":["../../../src/stress/shaders/entry_points.spec.ts"],"names":["description","makeTestGroup","range","GPUTest","g","makeCode","numEntryPoints","kBaseCode","makeEntryPoint","i","join","test","desc","fn","t","data","Uint32Array","buffer","makeBufferWithContents","GPUBufferUsage","STORAGE","COPY_SRC","kNumEntryPoints","shader","device","createShaderModule","code","layout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","type","pipelineLayout","createPipelineLayout","bindGroupLayouts","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","pipeline","createComputePipeline","compute","module","entryPoint","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","queue","submit","finish","expectGPUBufferValuesEqual"],"mappings":"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","sourcesContent":["export const description = `\nStress tests covering behavior around shader entry points.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { range } from '../../common/util/util.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst makeCode = (numEntryPoints: number) => {\n  const kBaseCode = `\n      struct Buffer { data: u32; };\n      @group(0) @binding(0) var<storage, read_write> buffer: Buffer;\n      fn main() { buffer.data = buffer.data + 1u;  }\n      `;\n  const makeEntryPoint = (i: number) => `\n      @stage(compute) @workgroup_size(1) fn computeMain${i}() { main(); }\n      `;\n  return kBaseCode + range(numEntryPoints, makeEntryPoint).join('');\n};\n\ng.test('many')\n  .desc(\n    `Tests compilation and usage of shaders with a huge number of entry points.\n\nTODO: There may be a normative limit to the number of entry points allowed in\na shader, in which case this would become a validation test instead.`\n  )\n  .fn(async t => {\n    const data = new Uint32Array([0]);\n    const buffer = t.makeBufferWithContents(data, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);\n\n    // NOTE: Initial shader compilation time seems to scale exponentially with\n    // this value in Chrome.\n    const kNumEntryPoints = 200;\n\n    const shader = t.device.createShaderModule({\n      code: makeCode(kNumEntryPoints),\n    });\n\n    const layout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' },\n        },\n      ],\n    });\n    const pipelineLayout = t.device.createPipelineLayout({\n      bindGroupLayouts: [layout],\n    });\n    const bindGroup = t.device.createBindGroup({\n      layout,\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    range(kNumEntryPoints, i => {\n      const pipeline = t.device.createComputePipeline({\n        layout: pipelineLayout,\n        compute: {\n          module: shader,\n          entryPoint: `computeMain${i}`,\n        },\n      });\n\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n      pass.dispatch(1);\n      pass.end();\n    });\n\n    t.device.queue.submit([encoder.finish()]);\n    t.expectGPUBufferValuesEqual(buffer, new Uint32Array([kNumEntryPoints]));\n  });\n"],"file":"entry_points.spec.js"}