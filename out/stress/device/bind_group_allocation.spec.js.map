{"version":3,"file":"bind_group_allocation.spec.js","names":["description","makeTestGroup","GPUTest","g","test","desc","fn","t","kNumGroups","buffer","device","createBuffer","size","usage","GPUBufferUsage","STORAGE","layout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","type","bindGroups","i","push","createBindGroup","resource"],"sources":["../../../src/stress/device/bind_group_allocation.spec.ts"],"sourcesContent":["export const description = `\nStress tests for allocation of GPUBindGroup objects through GPUDevice.\n`;\n\nimport { makeTestGroup } from '../../common/framework/test_group.js';\nimport { GPUTest } from '../../webgpu/gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('coexisting')\n  .desc(`Tests allocation of many coexisting GPUBindGroup objects.`)\n  .fn(t => {\n    const kNumGroups = 1_000_000;\n    const buffer = t.device.createBuffer({\n      size: 64,\n      usage: GPUBufferUsage.STORAGE,\n    });\n    const layout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' },\n        },\n      ],\n    });\n    const bindGroups = [];\n    for (let i = 0; i < kNumGroups; ++i) {\n      bindGroups.push(\n        t.device.createBindGroup({\n          layout,\n          entries: [{ binding: 0, resource: { buffer } }],\n        })\n      );\n    }\n  });\n\ng.test('continuous')\n  .desc(\n    `Tests allocation and implicit GC of many GPUBindGroup objects over time.\nObjects are sequentially created and dropped for GC over a very large number of\niterations.`\n  )\n  .fn(t => {\n    const kNumGroups = 5_000_000;\n    const buffer = t.device.createBuffer({\n      size: 64,\n      usage: GPUBufferUsage.STORAGE,\n    });\n    const layout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type: 'storage' },\n        },\n      ],\n    });\n    for (let i = 0; i < kNumGroups; ++i) {\n      t.device.createBindGroup({\n        layout,\n        entries: [{ binding: 0, resource: { buffer } }],\n      });\n    }\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,sCAAsC;AACpE,SAASC,OAAO,QAAQ,0BAA0B;;AAElD,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,OAAO,CAAC;;AAEvCC,CAAC,CAACC,IAAI,CAAC,YAAY,CAAC;AACjBC,IAAI,CAAE,2DAA0D,CAAC;AACjEC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,UAAU,GAAG,SAAS;EAC5B,MAAMC,MAAM,GAAGF,CAAC,CAACG,MAAM,CAACC,YAAY,CAAC;IACnCC,IAAI,EAAE,EAAE;IACRC,KAAK,EAAEC,cAAc,CAACC;EACxB,CAAC,CAAC;EACF,MAAMC,MAAM,GAAGT,CAAC,CAACG,MAAM,CAACO,qBAAqB,CAAC;IAC5CC,OAAO,EAAE;IACP;MACEC,OAAO,EAAE,CAAC;MACVC,UAAU,EAAEC,cAAc,CAACC,OAAO;MAClCb,MAAM,EAAE,EAAEc,IAAI,EAAE,SAAS,CAAC;IAC5B,CAAC;;EAEL,CAAC,CAAC;EACF,MAAMC,UAAU,GAAG,EAAE;EACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,UAAU,EAAE,EAAEiB,CAAC,EAAE;IACnCD,UAAU,CAACE,IAAI;MACbnB,CAAC,CAACG,MAAM,CAACiB,eAAe,CAAC;QACvBX,MAAM;QACNE,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAES,QAAQ,EAAE,EAAEnB,MAAM,CAAC,CAAC,CAAC,CAAC;MAChD,CAAC;IACH,CAAC;EACH;AACF,CAAC,CAAC;;AAEJN,CAAC,CAACC,IAAI,CAAC,YAAY,CAAC;AACjBC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,UAAU,GAAG,SAAS;EAC5B,MAAMC,MAAM,GAAGF,CAAC,CAACG,MAAM,CAACC,YAAY,CAAC;IACnCC,IAAI,EAAE,EAAE;IACRC,KAAK,EAAEC,cAAc,CAACC;EACxB,CAAC,CAAC;EACF,MAAMC,MAAM,GAAGT,CAAC,CAACG,MAAM,CAACO,qBAAqB,CAAC;IAC5CC,OAAO,EAAE;IACP;MACEC,OAAO,EAAE,CAAC;MACVC,UAAU,EAAEC,cAAc,CAACC,OAAO;MAClCb,MAAM,EAAE,EAAEc,IAAI,EAAE,SAAS,CAAC;IAC5B,CAAC;;EAEL,CAAC,CAAC;EACF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,UAAU,EAAE,EAAEiB,CAAC,EAAE;IACnClB,CAAC,CAACG,MAAM,CAACiB,eAAe,CAAC;MACvBX,MAAM;MACNE,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAES,QAAQ,EAAE,EAAEnB,MAAM,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC;EACJ;AACF,CAAC,CAAC"}