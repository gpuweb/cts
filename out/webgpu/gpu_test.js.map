{"version":3,"file":"gpu_test.js","names":["Fixture","SubcaseBatchState","registerShutdownTask","globalTestConfig","isCompatibilityDevice","getGPU","assert","makeValueTestVariant","memcpy","range","unreachable","kQueryTypeInfo","resolvePerAspectFormat","isCompressedTextureFormat","getRequiredFeatureForTextureFormat","isTextureFormatUsableAsRenderAttachment","isTextureFormatMultisampled","is32Float","isSintOrUintFormat","isTextureFormatResolvable","isDepthTextureFormat","isStencilTextureFormat","textureViewDimensionAndFormatCompatibleForDevice","textureDimensionAndFormatCompatibleForDevice","isTextureFormatUsableWithStorageAccessMode","checkElementsEqual","checkElementsBetween","CommandBufferMaker","DevicePool","align","roundDown","getTextureCopyLayout","getTextureSubCopyLayout","kTexelRepresentationInfo","reifyExtent3D","reifyOrigin3D","devicePool","mismatchedDevicePool","destroy","kResourceStateValues","kResourceStates","initUncanonicalizedDeviceDescriptor","descriptor","requiredFeatures","Array","filter","f","undefined","mergeDeviceSelectionDescriptorIntoDeviceDescriptor","src","dst","srcFixed","push","Object","assign","requiredLimits","GPUTestSubcaseBatchState","skipIfRequirements","defaultQueue","useMismatchedDevice","postInit","acquireProvider","finalize","results","Promise","allSettled","provider","then","x","release","mismatchedProvider","result","status","reason","requestDeviceWithRequiredParametersOrSkip","isCompatibility","compatibility","descriptorModifier","acquire","recorder","catch","usesMismatchedDevice","selectDeviceOrSkipTestCase","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","add","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","feature","acquireMismatchedProvider","skipIfCopyTextureToTextureNotSupportedForFormat","skip","skipIfInterpolationTypeOrSamplingNotSupported","type","sampling","skipIf","skipIfLanguageFeatureNotSupported","langFeature","hasLanguageFeature","skipIfLanguageFeatureSupported","lf","wgslLanguageFeatures","has","GPUTestBase","MakeSharedState","params","device","queue","makeLimitVariant","limit","variant","limits","canCallCopyTextureToBufferWithTextureFormat","createCopyForMapRead","srcOffset","size","createBufferTracked","label","usage","GPUBufferUsage","MAP_READ","COPY_DST","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","subarrayByteStart","alignedSize","mappable","readGPUBufferRangeTyped","srcByteOffset","method","typedLength","BYTES_PER_ELEMENT","byteLength","mapOffset","mapSize","subarrayStart","mapAsync","GPUMapMode","READ","mapped","getMappedRange","data","subarray","cleanup","unmap","skipIfDeviceDoesNotHaveFeature","skipIfDeviceDoesNotSupportQueryType","skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler","skipIfTextureFormatNotSupported","skipIfTextureFormatAndViewDimensionNotCompatible","viewDimension","skipIfTextureFormatAndDimensionNotCompatible","dimension","skipIfTextureFormatNotResolvable","skipIfTextureViewDimensionNotSupported","dimensions","skipIfTextureLoadNotSupportedForTextureType","skipIfTextureFormatNotUsableWithStorageAccessMode","access","skipIfTextureFormatNotUsableAsRenderAttachment","skipIfTextureFormatNotMultisampled","skipIfTextureFormatNotBlendable","skipIfTextureFormatNotFilterable","skipIfTextureFormatDoesNotSupportUsage","GPUTextureUsage","RENDER_ATTACHMENT","STORAGE_BINDING","skipIfTextureFormatDoesNotSupportCopyTextureToBuffer","rec","expectGPUBufferValuesPassCheck","check","mode","readbackPromise","eventualAsyncExpectation","niceStack","readback","expectOK","expectGPUBufferValuesEqual","expected","a","constructor","length","expectGPUBufferRepeatsSingleValue","buffer","expectedValue","numRows","minBytesPerRow","bytesPerRow","valueSize","kMaxBufferSizeToCheckOnCpu","bufferSize","valueBytes","Uint8Array","rowValues","fill","rowBytes","concat","expectedContents","row","set","storageBuffer","STORAGE","expectedDataSize","Math","max","expectedDataBuffer","mappedAtCreation","expectedData","Uint32Array","value","values","min","padding","expectedBytes","Uint16Array","expectedWords","resultBuffer","COPY_SRC","readsPerRow","ceil","reducer","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","commandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","expectedResults","expectSingleColor","exp","slice","aspect","rowsPerImage","mipSize","copySize","rep","expectedTexelData","pack","encode","copyTextureToBuffer","texture","mipLevel","origin","y","z","readSinglePixelFrom2DTexture","expectSinglePixelBetweenTwoValuesIn2DTexture","generateWarningOnly","checkElementsBetweenFn","act","b","i","copy2DTextureToBufferUsingComputePass","componentCount","textureView","sampleCount","extent_","origin_","extent","width","height","kWorkgroupSizeX","kWorkgroupSizeY","textureSrcCode","computePipeline","uniformBuffer","makeBufferWithContents","UNIFORM","uniformBindGroup","encoder","floor","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","message","expectationFailed","debug","expectValidationError","gpuValidationError","validationFailed","trackForCleanup","createBuffer","createTextureTracked","createTexture","createQuerySetTracked","createQuerySet","dataArray","createEncoder","encoderType","attachmentInfo","occlusionQuerySet","targets","fullAttachmentInfo","colorFormats","rbEncoder","createRenderBundleEncoder","executeBundles","makeAttachmentView","createView","depthStencilAttachment","depthStencilFormat","view","depthReadOnly","stencilReadOnly","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","passDesc","colorAttachments","clearValue","loadOp","storeOp","beginRenderPass","GPUTest","init","sharedState","adapter","mismatchedDevice","expectDeviceLost","getAdapterLimitsAsDeviceRequiredLimits","adapterLimits","key","removeNonExistentLimits","filteredLimits","applyLimitsToDescriptor","desc","getRequiredLimits","descWithMaxLimits","getAdapterFeaturesAsDeviceRequiredFeatures","applyFeaturesToDescriptor","getRequiredFeatures","existingRequiredFeatures","descWithRequiredFeatures","RequiredLimitsGPUTestSubcaseBatchState","requiredLimitsHelper","mod","keyModifier","baseKey","RequiredLimitsTestMixin","Base","RequiredLimitsImpl","AllFeaturesMaxLimitsGPUTestSubcaseBatchState","selectMismatchedDeviceOrSkipTestCase","UniqueFeaturesOrLimitsGPUTest","AllFeaturesMaxLimitsGPUTest"],"sources":["../../src/webgpu/gpu_test.ts"],"sourcesContent":["import {\n  Fixture,\n  FixtureClass,\n  FixtureClassInterface,\n  FixtureClassWithMixin,\n  SubcaseBatchState,\n  TestCaseRecorder,\n  TestParams,\n} from '../common/framework/fixture.js';\nimport { registerShutdownTask } from '../common/framework/on_shutdown.js';\nimport { globalTestConfig, isCompatibilityDevice } from '../common/framework/test_config.js';\nimport { getGPU } from '../common/util/navigator_gpu.js';\nimport {\n  assert,\n  makeValueTestVariant,\n  memcpy,\n  range,\n  ValueTestVariant,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n  unreachable,\n} from '../common/util/util.js';\n\nimport { kLimits, kQueryTypeInfo, WGSLLanguageFeature } from './capability_info.js';\nimport { InterpolationType, InterpolationSampling } from './constants.js';\nimport {\n  resolvePerAspectFormat,\n  SizedTextureFormat,\n  EncodableTextureFormat,\n  isCompressedTextureFormat,\n  getRequiredFeatureForTextureFormat,\n  isTextureFormatUsableAsRenderAttachment,\n  isTextureFormatMultisampled,\n  is32Float,\n  isSintOrUintFormat,\n  isTextureFormatResolvable,\n  isDepthTextureFormat,\n  isStencilTextureFormat,\n  textureViewDimensionAndFormatCompatibleForDevice,\n  textureDimensionAndFormatCompatibleForDevice,\n  isTextureFormatUsableWithStorageAccessMode,\n} from './format_info.js';\nimport { checkElementsEqual, checkElementsBetween } from './util/check_contents.js';\nimport { CommandBufferMaker, EncoderType } from './util/command_buffer_maker.js';\nimport { ScalarType } from './util/conversion.js';\nimport {\n  CanonicalDeviceDescriptor,\n  DescriptorModifier,\n  DevicePool,\n  DeviceProvider,\n  UncanonicalizedDeviceDescriptor,\n} from './util/device_pool.js';\nimport { align, roundDown } from './util/math.js';\nimport {\n  getTextureCopyLayout,\n  getTextureSubCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, kTexelRepresentationInfo } from './util/texture/texel_data.js';\nimport { reifyExtent3D, reifyOrigin3D } from './util/unions.js';\n\n// Declarations for WebGPU items we want tests for that are not yet officially part of the spec.\ndeclare global {\n  // MAINTENANCE_TODO: remove once added to @webgpu/types\n  interface GPUSupportedLimits {\n    readonly maxStorageBuffersInFragmentStage?: number;\n    readonly maxStorageTexturesInFragmentStage?: number;\n    readonly maxStorageBuffersInVertexStage?: number;\n    readonly maxStorageTexturesInVertexStage?: number;\n  }\n}\n\nconst devicePool = new DevicePool();\n\n// MAINTENANCE_TODO: When DevicePool becomes able to provide multiple devices at once, use the\n// usual one instead of a new one.\nconst mismatchedDevicePool = new DevicePool();\n\n// On shutdown, try to explicitly destroy() the device pools (and devices) used by GPUTest,\n// so they don't keep using system resources until they're fully garbage collected.\nregisterShutdownTask(() => {\n  devicePool.destroy();\n  mismatchedDevicePool.destroy();\n});\n\nconst kResourceStateValues = ['valid', 'invalid', 'destroyed'] as const;\nexport type ResourceState = (typeof kResourceStateValues)[number];\nexport const kResourceStates: readonly ResourceState[] = kResourceStateValues;\n\n/** Various \"convenient\" shorthands for GPUDeviceDescriptors for selectDevice functions. */\nexport type DeviceSelectionDescriptor =\n  | UncanonicalizedDeviceDescriptor\n  | GPUFeatureName\n  | undefined\n  | Array<GPUFeatureName | undefined>;\n\nexport function initUncanonicalizedDeviceDescriptor(\n  descriptor: DeviceSelectionDescriptor\n): UncanonicalizedDeviceDescriptor {\n  if (typeof descriptor === 'string') {\n    return { requiredFeatures: [descriptor] };\n  } else if (descriptor instanceof Array) {\n    return {\n      requiredFeatures: descriptor.filter(f => f !== undefined) as GPUFeatureName[],\n    };\n  } else {\n    return descriptor ?? {};\n  }\n}\n\ntype DeviceDescriptorSimplified = {\n  requiredFeatures: GPUFeatureName[];\n  requiredLimits: Record<string, number>;\n  defaultQueue: GPUQueueDescriptor;\n};\n\nfunction mergeDeviceSelectionDescriptorIntoDeviceDescriptor(\n  src: DeviceSelectionDescriptor,\n  dst: DeviceDescriptorSimplified\n) {\n  const srcFixed = initUncanonicalizedDeviceDescriptor(src);\n  if (srcFixed) {\n    dst.requiredFeatures.push(...(srcFixed.requiredFeatures ?? []));\n    Object.assign(dst.requiredLimits, srcFixed.requiredLimits ?? {});\n  }\n}\n\nexport class GPUTestSubcaseBatchState extends SubcaseBatchState {\n  /** Provider for default device. */\n  private provider: Promise<DeviceProvider> | undefined;\n  /** Provider for mismatched device. */\n  private mismatchedProvider: Promise<DeviceProvider> | undefined;\n  /** The accumulated skip-if requirements for this subcase */\n  private skipIfRequirements: DeviceDescriptorSimplified = {\n    requiredFeatures: [],\n    requiredLimits: {},\n    defaultQueue: {},\n  };\n  /** Whether or not to provide a mismatched device */\n  private useMismatchedDevice = false;\n\n  override async postInit(): Promise<void> {\n    // Skip all subcases if there's no device.\n    await this.acquireProvider();\n  }\n\n  override async finalize(): Promise<void> {\n    await super.finalize();\n\n    // Ensure devicePool.release is called for both providers even if one rejects\n    // and wait for both of them before proceeding.\n    const results = await Promise.allSettled([\n      this.provider?.then(x => devicePool.release(x)),\n      this.mismatchedProvider?.then(x => mismatchedDevicePool.release(x)),\n    ]);\n\n    // If one of them rejected throw its reason. It should be an `Error`.\n    for (const result of results) {\n      if (result.status === 'rejected') throw result.reason;\n    }\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireProvider(): Promise<DeviceProvider> {\n    if (this.provider === undefined) {\n      this.requestDeviceWithRequiredParametersOrSkip(this.skipIfRequirements);\n    }\n    assert(this.provider !== undefined);\n    assert(!this.useMismatchedDevice || this.mismatchedProvider !== undefined);\n    return this.provider;\n  }\n\n  get isCompatibility() {\n    return globalTestConfig.compatibility;\n  }\n\n  /**\n   * Some tests or cases need particular feature flags or limits to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities. If this isn't called, a default device is provided.\n   *\n   * If the request isn't supported, throws a SkipTestCase exception to skip the entire test case.\n   */\n  requestDeviceWithRequiredParametersOrSkip(\n    descriptor: DeviceSelectionDescriptor,\n    descriptorModifier?: DescriptorModifier\n  ): void {\n    assert(this.provider === undefined, \"Can't selectDeviceOrSkipTestCase() multiple times\");\n    this.provider = devicePool.acquire(\n      this.recorder,\n      initUncanonicalizedDeviceDescriptor(descriptor),\n      descriptorModifier\n    );\n    // Suppress uncaught promise rejection (we'll catch it later).\n    this.provider.catch(() => {});\n\n    if (this.useMismatchedDevice) {\n      this.mismatchedProvider = mismatchedDevicePool.acquire(\n        this.recorder,\n        initUncanonicalizedDeviceDescriptor(descriptor),\n        descriptorModifier\n      );\n      // Suppress uncaught promise rejection (we'll catch it later).\n      this.mismatchedProvider.catch(() => {});\n    }\n  }\n\n  /**\n   * Some tests need a second device which is different from the first.\n   * This requests a second device so it will be available during the test. If it is not called,\n   * no second device will be available. The second device will be created with the\n   * same features and limits as the first device.\n   */\n  usesMismatchedDevice() {\n    assert(this.provider === undefined, 'Can not call usedMismatchedDevice after device creation');\n    this.useMismatchedDevice = true;\n  }\n\n  /**\n   * Some tests or cases need particular feature flags or limits to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to add\n   * features or limits required by the subcase. If the features or limits are not\n   * available a SkipTestCase exception will be thrown to skip the entire test case.\n   */\n  selectDeviceOrSkipTestCase(descriptor: DeviceSelectionDescriptor): void {\n    mergeDeviceSelectionDescriptorIntoDeviceDescriptor(descriptor, this.skipIfRequirements);\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these texture format(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): void {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set<GPUFeatureName | undefined>();\n    for (const format of formats) {\n      if (format !== undefined) {\n        features.add(getRequiredFeatureForTextureFormat(format));\n      }\n    }\n\n    this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these query type(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForQueryTypeOrSkipTestCase(types: GPUQueryType | GPUQueryType[]): void {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map(t => kQueryTypeInfo[t].feature);\n    this.selectDeviceOrSkipTestCase(features);\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireMismatchedProvider(): Promise<DeviceProvider> | undefined {\n    return this.mismatchedProvider;\n  }\n\n  skipIfCopyTextureToTextureNotSupportedForFormat(...formats: (GPUTextureFormat | undefined)[]) {\n    if (this.isCompatibility) {\n      for (const format of formats) {\n        if (format && isCompressedTextureFormat(format)) {\n          this.skip(`copyTextureToTexture with ${format} is not supported in compatibility mode`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Skips test if the given interpolation type or sampling is not supported.\n   */\n  skipIfInterpolationTypeOrSamplingNotSupported({\n    type,\n    sampling,\n  }: {\n    type?: InterpolationType;\n    sampling?: InterpolationSampling;\n  }) {\n    if (this.isCompatibility) {\n      this.skipIf(\n        type === 'linear',\n        'interpolation type linear is not supported in compatibility mode'\n      );\n      this.skipIf(\n        sampling === 'sample',\n        'interpolation type linear is not supported in compatibility mode'\n      );\n      this.skipIf(\n        type === 'flat' && (!sampling || sampling === 'first'),\n        'interpolation type flat with sampling not set to either is not supported in compatibility mode'\n      );\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is *not* supported. */\n  skipIfLanguageFeatureNotSupported(langFeature: WGSLLanguageFeature) {\n    if (!this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is not supported`);\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is supported. */\n  skipIfLanguageFeatureSupported(langFeature: WGSLLanguageFeature) {\n    if (this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is supported`);\n    }\n  }\n\n  /** returns true iff the `langFeature` is supported  */\n  hasLanguageFeature(langFeature: WGSLLanguageFeature) {\n    const lf = getGPU(this.recorder).wgslLanguageFeatures;\n    return lf !== undefined && lf.has(langFeature);\n  }\n}\n\n/**\n * Base fixture for WebGPU tests.\n *\n * This class is a Fixture + a getter that returns a GPUDevice\n * as well as helpers that use that device.\n */\nexport class GPUTestBase extends Fixture<GPUTestSubcaseBatchState> {\n  public static override MakeSharedState(\n    recorder: TestCaseRecorder,\n    params: TestParams\n  ): GPUTestSubcaseBatchState {\n    return new GPUTestSubcaseBatchState(recorder, params);\n  }\n\n  // This must be overridden in derived classes\n  get device(): GPUDevice {\n    unreachable();\n    return null as unknown as GPUDevice;\n  }\n\n  /** GPUQueue for the test to use. (Same as `t.device.queue`.) */\n  get queue(): GPUQueue {\n    return this.device.queue;\n  }\n\n  get isCompatibility() {\n    return globalTestConfig.compatibility;\n  }\n\n  makeLimitVariant(limit: (typeof kLimits)[number], variant: ValueTestVariant) {\n    return makeValueTestVariant(this.device.limits[limit]!, variant);\n  }\n\n  canCallCopyTextureToBufferWithTextureFormat(format: GPUTextureFormat) {\n    return !this.isCompatibility || !isCompressedTextureFormat(format);\n  }\n\n  /** Snapshot a GPUBuffer's contents, returning a new GPUBuffer with the `MAP_READ` usage. */\n  private createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.createBufferTracked({\n      label: 'createCopyForMapRead',\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    const c = this.device.createCommandEncoder({ label: 'createCopyForMapRead' });\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  /**\n   * Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n   * we might need to copy more bytes from the buffer than we want to map.\n   * begin and end values represent the part of the copied buffer that stores the contents\n   * we initially wanted to map.\n   * The copy will not cause an OOB error because the buffer size must be 4-aligned.\n   */\n  private createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { mappable: GPUBuffer; subarrayByteStart: number } {\n    const alignedOffset = roundDown(offset, 4);\n    const subarrayByteStart = offset - alignedOffset;\n    const alignedSize = align(size + subarrayByteStart, 4);\n    const mappable = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { mappable, subarrayByteStart };\n  }\n\n  /**\n   * Snapshot the current contents of a range of a GPUBuffer, and return them as a TypedArray.\n   * Also provides a cleanup() function to unmap and destroy the staging buffer.\n   */\n  async readGPUBufferRangeTyped<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    {\n      srcByteOffset = 0,\n      method = 'copy',\n      type,\n      typedLength,\n    }: {\n      srcByteOffset?: number;\n      method?: 'copy' | 'map';\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n    }\n  ): Promise<{ data: T; cleanup(): void }> {\n    assert(\n      srcByteOffset % type.BYTES_PER_ELEMENT === 0,\n      'srcByteOffset must be a multiple of BYTES_PER_ELEMENT'\n    );\n\n    const byteLength = typedLength * type.BYTES_PER_ELEMENT;\n    let mappable: GPUBuffer;\n    let mapOffset: number | undefined, mapSize: number | undefined, subarrayByteStart: number;\n    if (method === 'copy') {\n      ({ mappable, subarrayByteStart } = this.createAlignedCopyForMapRead(\n        src,\n        byteLength,\n        srcByteOffset\n      ));\n    } else if (method === 'map') {\n      mappable = src;\n      mapOffset = roundDown(srcByteOffset, 8);\n      mapSize = align(byteLength, 4);\n      subarrayByteStart = srcByteOffset - mapOffset;\n    } else {\n      unreachable();\n    }\n\n    assert(subarrayByteStart % type.BYTES_PER_ELEMENT === 0);\n    const subarrayStart = subarrayByteStart / type.BYTES_PER_ELEMENT;\n\n    // 2. Map the staging buffer, and create the TypedArray from it.\n    await mappable.mapAsync(GPUMapMode.READ, mapOffset, mapSize);\n    const mapped = new type(mappable.getMappedRange(mapOffset, mapSize));\n    const data = mapped.subarray(subarrayStart, typedLength) as T;\n\n    return {\n      data,\n      cleanup() {\n        mappable.unmap();\n        mappable.destroy();\n      },\n    };\n  }\n\n  /**\n   * Skips test if device does not have feature.\n   * Note: Try to use one of the more specific skipIf tests if possible.\n   */\n  skipIfDeviceDoesNotHaveFeature(feature: GPUFeatureName) {\n    this.skipIf(!this.device.features.has(feature), `device does not have feature: '${feature}'`);\n  }\n\n  /**\n   * Skips test if device des not support query type.\n   */\n  skipIfDeviceDoesNotSupportQueryType(...types: GPUQueryType[]) {\n    for (const type of types) {\n      const feature = kQueryTypeInfo[type].feature;\n      if (feature) {\n        this.skipIfDeviceDoesNotHaveFeature(feature);\n      }\n    }\n  }\n\n  skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler() {\n    this.skipIf(\n      this.isCompatibility,\n      'depth textures are not usable with non-comparison samplers in compatibility mode'\n    );\n  }\n\n  /**\n   * Skips test if any format is not supported.\n   */\n  skipIfTextureFormatNotSupported(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (!format) {\n        continue;\n      }\n      if (format === 'bgra8unorm-srgb') {\n        if (isCompatibilityDevice(this.device)) {\n          this.skip(`texture format '${format}' is not supported`);\n        }\n      }\n      const feature = getRequiredFeatureForTextureFormat(format);\n      this.skipIf(\n        !!feature && !this.device.features.has(feature),\n        `texture format '${format}' requires feature: '${feature}'`\n      );\n    }\n  }\n\n  skipIfTextureFormatAndViewDimensionNotCompatible(\n    format: GPUTextureFormat,\n    viewDimension: GPUTextureViewDimension\n  ) {\n    this.skipIf(\n      !textureViewDimensionAndFormatCompatibleForDevice(this.device, viewDimension, format),\n      `format: ${format} does not support viewDimension: ${viewDimension}`\n    );\n  }\n\n  skipIfTextureFormatAndDimensionNotCompatible(\n    format: GPUTextureFormat,\n    dimension: GPUTextureDimension | undefined\n  ) {\n    this.skipIf(\n      !textureDimensionAndFormatCompatibleForDevice(this.device, dimension, format),\n      `format: ${format} does not support dimension: ${dimension}`\n    );\n  }\n\n  skipIfTextureFormatNotResolvable(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (format === undefined) continue;\n      if (!isTextureFormatResolvable(this.device, format)) {\n        this.skip(`texture format '${format}' is not resolvable`);\n      }\n    }\n  }\n\n  skipIfTextureViewDimensionNotSupported(...dimensions: (GPUTextureViewDimension | undefined)[]) {\n    if (isCompatibilityDevice(this.device)) {\n      for (const dimension of dimensions) {\n        if (dimension === 'cube-array') {\n          this.skip(`texture view dimension '${dimension}' is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfCopyTextureToTextureNotSupportedForFormat(...formats: (GPUTextureFormat | undefined)[]) {\n    if (isCompatibilityDevice(this.device)) {\n      for (const format of formats) {\n        if (format && isCompressedTextureFormat(format)) {\n          this.skip(`copyTextureToTexture with ${format} is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureLoadNotSupportedForTextureType(...types: (string | undefined | null)[]) {\n    if (this.isCompatibility) {\n      for (const type of types) {\n        switch (type) {\n          case 'texture_depth_2d':\n          case 'texture_depth_2d_array':\n          case 'texture_depth_multisampled_2d':\n            this.skip(`${type} is not supported by textureLoad in compatibility mode`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureFormatNotUsableWithStorageAccessMode(\n    access: GPUStorageTextureAccess | 'read' | 'write' | 'read_write',\n    ...formats: (GPUTextureFormat | undefined)[]\n  ) {\n    for (const format of formats) {\n      if (!format) continue;\n\n      if (!isTextureFormatUsableWithStorageAccessMode(this.device, format, access)) {\n        this.skip(\n          `Texture with ${format} is not usable as a storage texture with access ${access}`\n        );\n      }\n    }\n  }\n\n  skipIfTextureFormatNotUsableAsRenderAttachment(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (format && !isTextureFormatUsableAsRenderAttachment(this.device, format)) {\n        this.skip(`Texture with ${format} is not usable as a render attachment`);\n      }\n    }\n  }\n\n  skipIfTextureFormatNotMultisampled(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (format === undefined) continue;\n      if (!isTextureFormatMultisampled(this.device, format)) {\n        this.skip(`texture format '${format}' does not support multisampling`);\n      }\n    }\n  }\n\n  skipIfTextureFormatNotBlendable(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (format === undefined) continue;\n      this.skipIf(isSintOrUintFormat(format), 'sint/uint formats are not blendable');\n      if (is32Float(format)) {\n        this.skipIf(\n          !this.device.features.has('float32-blendable'),\n          `texture format '${format}' is not blendable`\n        );\n      }\n    }\n  }\n\n  skipIfTextureFormatNotFilterable(...formats: (GPUTextureFormat | undefined)[]) {\n    for (const format of formats) {\n      if (format === undefined) continue;\n      this.skipIf(isSintOrUintFormat(format), 'sint/uint formats are not filterable');\n      if (is32Float(format)) {\n        this.skipIf(\n          !this.device.features.has('float32-filterable'),\n          `texture format '${format}' is not filterable`\n        );\n      }\n    }\n  }\n\n  skipIfTextureFormatDoesNotSupportUsage(\n    usage: GPUTextureUsageFlags,\n    ...formats: (GPUTextureFormat | undefined)[]\n  ) {\n    for (const format of formats) {\n      if (!format) continue;\n      if (usage & GPUTextureUsage.RENDER_ATTACHMENT) {\n        this.skipIfTextureFormatNotUsableAsRenderAttachment(format);\n      }\n      if (usage & GPUTextureUsage.STORAGE_BINDING) {\n        this.skipIfTextureFormatNotUsableWithStorageAccessMode('write-only', format);\n      }\n    }\n  }\n\n  skipIfTextureFormatDoesNotSupportCopyTextureToBuffer(format: GPUTextureFormat) {\n    this.skipIf(\n      !this.canCallCopyTextureToBufferWithTextureFormat(format),\n      `can not use copyTextureToBuffer with ${format}`\n    );\n  }\n\n  /** Skips this test case if the `langFeature` is *not* supported. */\n  skipIfLanguageFeatureNotSupported(langFeature: WGSLLanguageFeature) {\n    if (!this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is not supported`);\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is supported. */\n  skipIfLanguageFeatureSupported(langFeature: WGSLLanguageFeature) {\n    if (this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is supported`);\n    }\n  }\n\n  /** returns true if the `langFeature` is supported  */\n  hasLanguageFeature(langFeature: WGSLLanguageFeature) {\n    const lf = getGPU(this.rec).wgslLanguageFeatures;\n    return lf !== undefined && lf.has(langFeature);\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to pass the provided check.\n   *\n   * A library of checks can be found in {@link webgpu/util/check_contents}.\n   */\n  expectGPUBufferValuesPassCheck<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    check: (actual: T) => Error | undefined,\n    {\n      srcByteOffset = 0,\n      type,\n      typedLength,\n      method = 'copy',\n      mode = 'fail',\n    }: {\n      srcByteOffset?: number;\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n      method?: 'copy' | 'map';\n      mode?: 'fail' | 'warn';\n    }\n  ) {\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      srcByteOffset,\n      type,\n      typedLength,\n      method,\n    });\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      this.expectOK(check(readback.data), { mode, niceStack });\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to equal the values in the provided TypedArray.\n   */\n  expectGPUBufferValuesEqual(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    srcByteOffset: number = 0,\n    { method = 'copy', mode = 'fail' }: { method?: 'copy' | 'map'; mode?: 'fail' | 'warn' } = {}\n  ): void {\n    this.expectGPUBufferValuesPassCheck(src, a => checkElementsEqual(a, expected), {\n      srcByteOffset,\n      type: expected.constructor as TypedArrayBufferViewConstructor,\n      typedLength: expected.length,\n      method,\n      mode,\n    });\n  }\n\n  /**\n   * Expect a buffer to consist exclusively of rows of some repeated expected value. The size of\n   * `expectedValue` must be 1, 2, or any multiple of 4 bytes. Rows in the buffer are expected to be\n   * zero-padded out to `bytesPerRow`. `minBytesPerRow` is the number of bytes per row that contain\n   * actual (non-padding) data and must be an exact multiple of the byte-length of `expectedValue`.\n   */\n  expectGPUBufferRepeatsSingleValue(\n    buffer: GPUBuffer,\n    {\n      expectedValue,\n      numRows,\n      minBytesPerRow,\n      bytesPerRow,\n    }: {\n      expectedValue: ArrayBuffer;\n      numRows: number;\n      minBytesPerRow: number;\n      bytesPerRow: number;\n    }\n  ) {\n    const valueSize = expectedValue.byteLength;\n    assert(valueSize === 1 || valueSize === 2 || valueSize % 4 === 0);\n    assert(minBytesPerRow % valueSize === 0);\n    assert(bytesPerRow % 4 === 0);\n\n    // If the buffer is small enough, just generate the full expected buffer contents and check\n    // against them on the CPU.\n    const kMaxBufferSizeToCheckOnCpu = 256 * 1024;\n    const bufferSize = bytesPerRow * (numRows - 1) + minBytesPerRow;\n    if (bufferSize <= kMaxBufferSizeToCheckOnCpu) {\n      const valueBytes = Array.from(new Uint8Array(expectedValue));\n      const rowValues = new Array(minBytesPerRow / valueSize).fill(valueBytes);\n      const rowBytes = new Uint8Array([].concat(...rowValues));\n      const expectedContents = new Uint8Array(bufferSize);\n      range(numRows, row => expectedContents.set(rowBytes, row * bytesPerRow));\n      this.expectGPUBufferValuesEqual(buffer, expectedContents);\n      return;\n    }\n\n    // Copy into a buffer suitable for STORAGE usage.\n    const storageBuffer = this.createBufferTracked({\n      label: 'expectGPUBufferRepeatsSingleValue:storageBuffer',\n      size: bufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // This buffer conveys the data we expect to see for a single value read. Since we read 32 bits at\n    // a time, for values smaller than 32 bits we pad this expectation with repeated value data, or\n    // with zeroes if the width of a row in the buffer is less than 4 bytes. For value sizes larger\n    // than 32 bits, we assume they're a multiple of 32 bits and expect to read exact matches of\n    // `expectedValue` as-is.\n    const expectedDataSize = Math.max(4, valueSize);\n    const expectedDataBuffer = this.createBufferTracked({\n      label: 'expectGPUBufferRepeatsSingleValue:expectedDataBuffer',\n      size: expectedDataSize,\n      usage: GPUBufferUsage.STORAGE,\n      mappedAtCreation: true,\n    });\n    const expectedData = new Uint32Array(expectedDataBuffer.getMappedRange());\n    if (valueSize === 1) {\n      const value = new Uint8Array(expectedValue)[0];\n      const values = new Array(Math.min(4, minBytesPerRow)).fill(value);\n      const padding = new Array(Math.max(0, 4 - values.length)).fill(0);\n      const expectedBytes = new Uint8Array(expectedData.buffer);\n      expectedBytes.set([...values, ...padding]);\n    } else if (valueSize === 2) {\n      const value = new Uint16Array(expectedValue)[0];\n      const expectedWords = new Uint16Array(expectedData.buffer);\n      expectedWords.set([value, minBytesPerRow > 2 ? value : 0]);\n    } else {\n      expectedData.set(new Uint32Array(expectedValue));\n    }\n    expectedDataBuffer.unmap();\n\n    // The output buffer has one 32-bit entry per buffer row. An entry's value will be 1 if every\n    // read from the corresponding row matches the expected data derived above, or 0 otherwise.\n    const resultBuffer = this.createBufferTracked({\n      label: 'expectGPUBufferRepeatsSingleValue:resultBuffer',\n      size: numRows * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const readsPerRow = Math.ceil(minBytesPerRow / expectedDataSize);\n    const reducer = `\n    struct Buffer { data: array<u32>, };\n    @group(0) @binding(0) var<storage, read> expected: Buffer;\n    @group(0) @binding(1) var<storage, read> in: Buffer;\n    @group(0) @binding(2) var<storage, read_write> out: Buffer;\n    @compute @workgroup_size(1) fn reduce(\n        @builtin(global_invocation_id) id: vec3<u32>) {\n      let rowBaseIndex = id.x * ${bytesPerRow / 4}u;\n      let readSize = ${expectedDataSize / 4}u;\n      out.data[id.x] = 1u;\n      for (var i: u32 = 0u; i < ${readsPerRow}u; i = i + 1u) {\n        let elementBaseIndex = rowBaseIndex + i * readSize;\n        for (var j: u32 = 0u; j < readSize; j = j + 1u) {\n          if (in.data[elementBaseIndex + j] != expected.data[j]) {\n            out.data[id.x] = 0u;\n            return;\n          }\n        }\n      }\n    }\n    `;\n\n    const pipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({ code: reducer }),\n        entryPoint: 'reduce',\n      },\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: expectedDataBuffer } },\n        { binding: 1, resource: { buffer: storageBuffer } },\n        { binding: 2, resource: { buffer: resultBuffer } },\n      ],\n    });\n\n    const commandEncoder = this.device.createCommandEncoder({\n      label: 'expectGPUBufferRepeatsSingleValue',\n    });\n    commandEncoder.copyBufferToBuffer(buffer, 0, storageBuffer, 0, bufferSize);\n    const pass = commandEncoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(numRows);\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    const expectedResults = new Array(numRows).fill(1);\n    this.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array(expectedResults));\n  }\n\n  // MAINTENANCE_TODO: add an expectContents for textures, which logs data: uris on failure\n\n  /**\n   * Expect an entire GPUTexture to have a single color at the given mip level (defaults to 0).\n   * MAINTENANCE_TODO: Remove this and/or replace it with a helper in TextureTestMixin.\n   */\n  expectSingleColor(\n    src: GPUTexture,\n    format: GPUTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    assert(\n      slice === 0 || dimension === '2d',\n      'texture slices are only implemented for 2d textures'\n    );\n\n    format = resolvePerAspectFormat(format, layout?.aspect);\n    const { byteLength, minBytesPerRow, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    // MAINTENANCE_TODO: getTextureCopyLayout does not return the proper size for array textures,\n    // i.e. it will leave the z/depth value as is instead of making it 1 when dealing with 2d\n    // texture arrays. Since we are passing in the dimension, we should update it to return the\n    // corrected size.\n    const copySize = [\n      mipSize[0],\n      dimension !== '1d' ? mipSize[1] : 1,\n      dimension === '3d' ? mipSize[2] : 1,\n    ];\n\n    const rep = kTexelRepresentationInfo[format as EncodableTextureFormat];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.createBufferTracked({\n      label: 'expectSingleColor',\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder({ label: 'expectSingleColor' });\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: src,\n        mipLevel: layout?.mipLevel,\n        origin: { x: 0, y: 0, z: slice },\n        aspect: layout?.aspect,\n      },\n      { buffer, bytesPerRow, rowsPerImage },\n      copySize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    this.expectGPUBufferRepeatsSingleValue(buffer, {\n      expectedValue: expectedTexelData,\n      numRows: rowsPerImage * copySize[2],\n      minBytesPerRow,\n      bytesPerRow,\n    });\n  }\n\n  /**\n   * Return a GPUBuffer that data are going to be written into.\n   * MAINTENANCE_TODO: Remove this once expectSinglePixelBetweenTwoValuesIn2DTexture is removed.\n   */\n  private readSinglePixelFrom2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    { slice = 0, layout }: { slice?: number; layout?: TextureLayoutOptions }\n  ): GPUBuffer {\n    const { byteLength, bytesPerRow, rowsPerImage } = getTextureSubCopyLayout(\n      format,\n      [1, 1],\n      layout\n    );\n    const buffer = this.createBufferTracked({\n      label: 'readSinglePixelFrom2DTexture',\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder({\n      label: 'readSinglePixelFrom2DTexture',\n    });\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      [1, 1]\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    return buffer;\n  }\n\n  /**\n   * Take a single pixel of a 2D texture, interpret it using a TypedArray of the `expected` type,\n   * and expect each value in that array to be between the corresponding \"expected\" values\n   * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n   * MAINTENANCE_TODO: Remove this once there is a way to deal with undefined lerp-ed values.\n   */\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n      checkElementsBetweenFn = (act, [a, b]) =>\n        checkElementsBetween(act, [i => a[i] as number, i => b[i] as number]),\n    }: {\n      exp: [TypedArrayBufferView, TypedArrayBufferView];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n      checkElementsBetweenFn?: (\n        actual: TypedArrayBufferView,\n        expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n      ) => Error | undefined;\n    }\n  ): void {\n    assert(exp[0].constructor === exp[1].constructor);\n    const constructor = exp[0].constructor as TypedArrayBufferViewConstructor;\n    assert(exp[0].length === exp[1].length);\n    const typedLength = exp[0].length;\n\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesPassCheck(buffer, a => checkElementsBetweenFn(a, exp), {\n      type: constructor,\n      typedLength,\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Emulate a texture to buffer copy by using a compute shader\n   * to load texture values of a subregion of a 2d texture and write to a storage buffer.\n   * For sample count == 1, the buffer contains extent[0] * extent[1] of the sample.\n   * For sample count > 1, the buffer contains extent[0] * extent[1] * (N = sampleCount) values sorted\n   * in the order of their sample index [0, sampleCount - 1]\n   *\n   * This can be useful when the texture to buffer copy is not available to the texture format\n   * e.g. (depth24plus), or when the texture is multisampled.\n   *\n   * MAINTENANCE_TODO: extend texture dimension to 1d and 3d.\n   *\n   * @returns storage buffer containing the copied value from the texture.\n   */\n  copy2DTextureToBufferUsingComputePass(\n    type: ScalarType,\n    componentCount: number,\n    textureView: GPUTextureView,\n    sampleCount: number = 1,\n    extent_: GPUExtent3D = [1, 1, 1],\n    origin_: GPUOrigin3D = [0, 0, 0]\n  ): GPUBuffer {\n    const origin = reifyOrigin3D(origin_);\n    const extent = reifyExtent3D(extent_);\n    const width = extent.width;\n    const height = extent.height;\n    const kWorkgroupSizeX = 8;\n    const kWorkgroupSizeY = 8;\n    const textureSrcCode =\n      sampleCount === 1\n        ? `@group(0) @binding(0) var src: texture_2d<${type}>;`\n        : `@group(0) @binding(0) var src: texture_multisampled_2d<${type}>;`;\n    const code = `\n      struct Buffer {\n        data: array<${type}>,\n      };\n\n      ${textureSrcCode}\n      @group(0) @binding(1) var<storage, read_write> dst : Buffer;\n\n      struct Params {\n        origin: vec2u,\n        extent: vec2u,\n      };\n      @group(0) @binding(2) var<uniform> params : Params;\n\n      @compute @workgroup_size(${kWorkgroupSizeX}, ${kWorkgroupSizeY}, 1) fn main(@builtin(global_invocation_id) id : vec3u) {\n        let boundary = params.origin + params.extent;\n        let coord = params.origin + id.xy;\n        if (any(coord >= boundary)) {\n          return;\n        }\n        let offset = (id.x + id.y * params.extent.x) * ${componentCount} * ${sampleCount};\n        for (var sampleIndex = 0u; sampleIndex < ${sampleCount};\n          sampleIndex = sampleIndex + 1) {\n          let o = offset + sampleIndex * ${componentCount};\n          let v = textureLoad(src, coord.xy, sampleIndex);\n          for (var component = 0u; component < ${componentCount}; component = component + 1) {\n            dst.data[o + component] = v[component];\n          }\n        }\n      }\n    `;\n    const computePipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const storageBuffer = this.createBufferTracked({\n      label: 'copy2DTextureToBufferUsingComputePass:storageBuffer',\n      size: sampleCount * type.size * componentCount * width * height,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n\n    const uniformBuffer = this.makeBufferWithContents(\n      new Uint32Array([origin.x, origin.y, width, height]),\n      GPUBufferUsage.UNIFORM\n    );\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: textureView,\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: storageBuffer,\n          },\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder({\n      label: 'copy2DTextureToBufferUsingComputePass',\n    });\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(computePipeline);\n    pass.setBindGroup(0, uniformBindGroup);\n    pass.dispatchWorkgroups(\n      Math.floor((width + kWorkgroupSizeX - 1) / kWorkgroupSizeX),\n      Math.floor((height + kWorkgroupSizeY - 1) / kWorkgroupSizeY),\n      1\n    );\n    pass.end();\n    this.device.queue.submit([encoder.finish()]);\n\n    return storageBuffer;\n  }\n\n  /**\n   * Expect the specified WebGPU error to be generated when running the provided function.\n   */\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Expect a validation error inside the callback.\n   *\n   * Tests should always do just one WebGPU call in the callback, to make sure that's what's tested.\n   */\n  expectValidationError(fn: () => void, shouldError: boolean = true): void {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (shouldError) {\n      this.device.pushErrorScope('validation');\n    }\n\n    // Note: A return value is not allowed for the callback function. This is to avoid confusion\n    // about what the actual behavior would be; either of the following could be reasonable:\n    //   - Make expectValidationError async, and have it await on fn(). This causes an async split\n    //     between pushErrorScope and popErrorScope, so if the caller doesn't `await` on\n    //     expectValidationError (either accidentally or because it doesn't care to do so), then\n    //     other test code will be (nondeterministically) caught by the error scope.\n    //   - Make expectValidationError NOT await fn(), but just execute its first block (until the\n    //     first await) and return the return value (a Promise). This would be confusing because it\n    //     would look like the error scope includes the whole async function, but doesn't.\n    // If we do decide we need to return a value, we should use the latter semantic.\n    const returnValue = fn() as unknown;\n    assert(\n      returnValue === undefined,\n      'expectValidationError callback should not return a value (or be async)'\n    );\n\n    if (shouldError) {\n      const promise = this.device.popErrorScope();\n\n      this.eventualAsyncExpectation(async niceStack => {\n        const gpuValidationError = await promise;\n        if (!gpuValidationError) {\n          niceStack.message = 'Validation succeeded unexpectedly.';\n          this.rec.validationFailed(niceStack);\n        } else if (gpuValidationError instanceof GPUValidationError) {\n          niceStack.message = `Validation failed, as expected - ${gpuValidationError.message}`;\n          this.rec.debug(niceStack);\n        }\n      });\n    }\n  }\n\n  /** Create a GPUBuffer and track it for cleanup at the end of the test. */\n  createBufferTracked(descriptor: GPUBufferDescriptor): GPUBuffer {\n    return this.trackForCleanup(this.device.createBuffer(descriptor));\n  }\n\n  /** Create a GPUTexture and track it for cleanup at the end of the test. */\n  createTextureTracked(descriptor: GPUTextureDescriptor): GPUTexture {\n    return this.trackForCleanup(this.device.createTexture(descriptor));\n  }\n\n  /** Create a GPUQuerySet and track it for cleanup at the end of the test. */\n  createQuerySetTracked(descriptor: GPUQuerySetDescriptor): GPUQuerySet {\n    return this.trackForCleanup(this.device.createQuerySet(descriptor));\n  }\n\n  /**\n   * Creates a buffer with the contents of some TypedArray.\n   * The buffer size will always be aligned to 4 as we set mappedAtCreation === true when creating the\n   * buffer.\n   *\n   * MAINTENANCE_TODO: Several call sites would be simplified if this took ArrayBuffer as well.\n   */\n  makeBufferWithContents(dataArray: TypedArrayBufferView, usage: GPUBufferUsageFlags): GPUBuffer {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: align(dataArray.byteLength, 4),\n      usage,\n    });\n    memcpy({ src: dataArray }, { dst: buffer.getMappedRange() });\n    buffer.unmap();\n    return buffer;\n  }\n\n  /**\n   * Returns a GPUCommandEncoder, GPUComputePassEncoder, GPURenderPassEncoder, or\n   * GPURenderBundleEncoder, and a `finish` method returning a GPUCommandBuffer.\n   * Allows testing methods which have the same signature across multiple encoder interfaces.\n   *\n   * @example\n   * ```\n   * g.test('popDebugGroup')\n   *   .params(u => u.combine('encoderType', kEncoderTypes))\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     encoder.popDebugGroup();\n   *   });\n   *\n   * g.test('writeTimestamp')\n   *   .params(u => u.combine('encoderType', ['non-pass', 'compute pass', 'render pass'] as const)\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     // Encoder type is inferred, so `writeTimestamp` can be used even though it doesn't exist\n   *     // on GPURenderBundleEncoder.\n   *     encoder.writeTimestamp(args);\n   *   });\n   * ```\n   */\n  createEncoder<T extends EncoderType>(\n    encoderType: T,\n    {\n      attachmentInfo,\n      occlusionQuerySet,\n      targets,\n    }: {\n      attachmentInfo?: GPURenderBundleEncoderDescriptor;\n      occlusionQuerySet?: GPUQuerySet;\n      targets?: GPUTextureView[];\n    } = {}\n  ): CommandBufferMaker<T> {\n    const fullAttachmentInfo = {\n      // Defaults if not overridden:\n      colorFormats: ['rgba8unorm'],\n      sampleCount: 1,\n      // Passed values take precedent.\n      ...attachmentInfo,\n    } as const;\n\n    switch (encoderType) {\n      case 'non-pass': {\n        const encoder = this.device.createCommandEncoder();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          return encoder.finish();\n        });\n      }\n      case 'render bundle': {\n        const device = this.device;\n        const rbEncoder = device.createRenderBundleEncoder(fullAttachmentInfo);\n        const pass = this.createEncoder('render pass', { attachmentInfo, targets });\n\n        return new CommandBufferMaker(this, rbEncoder, () => {\n          pass.encoder.executeBundles([rbEncoder.finish()]);\n          return pass.finish();\n        });\n      }\n      case 'compute pass': {\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginComputePass();\n\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n      case 'render pass': {\n        const makeAttachmentView = (format: GPUTextureFormat) =>\n          this.createTextureTracked({\n            size: [16, 16, 1],\n            format,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            sampleCount: fullAttachmentInfo.sampleCount,\n          }).createView();\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment | undefined = undefined;\n        if (fullAttachmentInfo.depthStencilFormat !== undefined) {\n          depthStencilAttachment = {\n            view: makeAttachmentView(fullAttachmentInfo.depthStencilFormat),\n            depthReadOnly: fullAttachmentInfo.depthReadOnly,\n            stencilReadOnly: fullAttachmentInfo.stencilReadOnly,\n          };\n          if (\n            isDepthTextureFormat(fullAttachmentInfo.depthStencilFormat) &&\n            !fullAttachmentInfo.depthReadOnly\n          ) {\n            depthStencilAttachment.depthClearValue = 0;\n            depthStencilAttachment.depthLoadOp = 'clear';\n            depthStencilAttachment.depthStoreOp = 'discard';\n          }\n          if (\n            isStencilTextureFormat(fullAttachmentInfo.depthStencilFormat) &&\n            !fullAttachmentInfo.stencilReadOnly\n          ) {\n            depthStencilAttachment.stencilClearValue = 1;\n            depthStencilAttachment.stencilLoadOp = 'clear';\n            depthStencilAttachment.stencilStoreOp = 'discard';\n          }\n        }\n        const passDesc: GPURenderPassDescriptor = {\n          colorAttachments: Array.from(fullAttachmentInfo.colorFormats, (format, i) =>\n            format\n              ? {\n                  view: targets ? targets[i] : makeAttachmentView(format),\n                  clearValue: [0, 0, 0, 0],\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                }\n              : null\n          ),\n          depthStencilAttachment,\n          occlusionQuerySet,\n        };\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const encoder = commandEncoder.beginRenderPass(passDesc);\n        return new CommandBufferMaker(this, encoder, () => {\n          encoder.end();\n          return commandEncoder.finish();\n        });\n      }\n    }\n    unreachable();\n  }\n}\n\n/**\n * Fixture for WebGPU tests that uses a DeviceProvider\n */\nexport class GPUTest extends GPUTestBase {\n  // Should never be undefined in a test. If it is, init() must not have run/finished.\n  private provider: DeviceProvider | undefined;\n  private mismatchedProvider: DeviceProvider | undefined;\n\n  override async init() {\n    await super.init();\n\n    this.provider = await this.sharedState.acquireProvider();\n    this.mismatchedProvider = await this.sharedState.acquireMismatchedProvider();\n  }\n\n  /** GPUAdapter that the device was created from. */\n  get adapter(): GPUAdapter {\n    assert(this.provider !== undefined, 'internal error: DeviceProvider missing');\n    return this.provider.adapter;\n  }\n\n  /**\n   * GPUDevice for the test to use.\n   */\n  override get device(): GPUDevice {\n    assert(this.provider !== undefined, 'internal error: DeviceProvider missing');\n    return this.provider.device;\n  }\n\n  /**\n   * GPUDevice for tests requiring a second device different from the default one,\n   * e.g. for creating objects for by device_mismatch validation tests.\n   */\n  get mismatchedDevice(): GPUDevice {\n    assert(\n      this.mismatchedProvider !== undefined,\n      'usesMismatchedDevice or selectMismatchedDeviceOrSkipTestCase was not called in beforeAllSubcases'\n    );\n    return this.mismatchedProvider.device;\n  }\n\n  /**\n   * Expects that the device should be lost for a particular reason at the teardown of the test.\n   */\n  expectDeviceLost(reason: GPUDeviceLostReason): void {\n    assert(this.provider !== undefined, 'internal error: GPUDevice missing?');\n    this.provider.expectDeviceLost(reason);\n  }\n}\n\n/**\n * Gets the adapter limits as a standard JavaScript object.\n */\nfunction getAdapterLimitsAsDeviceRequiredLimits(adapter: GPUAdapter) {\n  const requiredLimits: Record<string, GPUSize64> = {};\n  const adapterLimits = adapter.limits as unknown as Record<string, GPUSize64>;\n  for (const key in adapter.limits) {\n    // MAINTENANCE_TODO: Remove this once minSubgroupSize is removed from\n    // chromium.\n    if (key === 'maxSubgroupSize' || key === 'minSubgroupSize') {\n      continue;\n    }\n    requiredLimits[key] = adapterLimits[key];\n  }\n  return requiredLimits;\n}\n\n/**\n * Removes limits that don't exist on the adapter.\n * A test might request a new limit that not all implementations support. The test itself\n * should check the requested limit using code that expects undefined.\n *\n * ```ts\n *    t.skipIf(limit < 2);     // BAD! Doesn't skip if unsupported because undefined is never less than 2.\n *    t.skipIf(!(limit >= 2)); // Good. Skips if limits is not >= 2. undefined is not >= 2.\n * ```\n */\nfunction removeNonExistentLimits(adapter: GPUAdapter, limits: Record<string, GPUSize64>) {\n  const filteredLimits: Record<string, GPUSize64> = {};\n  const adapterLimits = adapter.limits as unknown as Record<string, GPUSize64>;\n  for (const [limit, value] of Object.entries(limits)) {\n    if (adapterLimits[limit] !== undefined) {\n      filteredLimits[limit] = value;\n    }\n  }\n  return filteredLimits;\n}\n\nfunction applyLimitsToDescriptor(\n  adapter: GPUAdapter,\n  desc: CanonicalDeviceDescriptor | undefined,\n  getRequiredLimits: (adapter: GPUAdapter) => Record<string, number>\n) {\n  const descWithMaxLimits: CanonicalDeviceDescriptor = {\n    requiredFeatures: [],\n    defaultQueue: {},\n    ...desc,\n    requiredLimits: removeNonExistentLimits(adapter, getRequiredLimits(adapter)),\n  };\n  return descWithMaxLimits;\n}\n\nfunction getAdapterFeaturesAsDeviceRequiredFeatures(adapter: GPUAdapter): Iterable<GPUFeatureName> {\n  return [...adapter.features].filter(\n    f => f !== 'core-features-and-limits'\n  ) as Iterable<GPUFeatureName>;\n}\n\nfunction applyFeaturesToDescriptor(\n  adapter: GPUAdapter,\n  desc: CanonicalDeviceDescriptor | undefined,\n  getRequiredFeatures: (adapter: GPUAdapter) => Iterable<GPUFeatureName>\n) {\n  const existingRequiredFeatures = (desc && desc?.requiredFeatures) ?? [];\n  const descWithRequiredFeatures: CanonicalDeviceDescriptor = {\n    requiredLimits: {},\n    defaultQueue: {},\n    ...desc,\n    requiredFeatures: [...existingRequiredFeatures, ...getRequiredFeatures(adapter)],\n  };\n  return descWithRequiredFeatures;\n}\n\n/**\n * Used by RequiredLimitsTestMixin to allow you to request specific limits\n *\n * Supply a `getRequiredLimits` function that given a GPUAdapter, turns the limits\n * you want.\n *\n * Also supply a key function that returns a device key. You should generally return\n * the name of each limit you request and any math you did on the limit. For example\n *\n * ```js\n * {\n *   getRequiredLimits(adapter) {\n *     return {\n *       maxBindGroups: adapter.limits.maxBindGroups / 2,\n *       maxTextureDimensions2D: Math.max(adapter.limits.maxTextureDimensions2D, 8192),\n *     },\n *   },\n *   key() {\n *     return `\n *       maxBindGroups / 2,\n *       max(maxTextureDimension2D, 8192),\n *     `;\n *   },\n * }\n * ```\n *\n * Its important to note, the key is used BEFORE knowing the adapter limits to get a device\n * that was already created with the same key.\n */\ninterface RequiredLimitsHelper {\n  getRequiredLimits: (adapter: GPUAdapter) => Record<string, number>;\n  key(): string;\n}\n\n/**\n * Used by RequiredLimitsTest to request a device with all requested limits of the adapter.\n */\nexport class RequiredLimitsGPUTestSubcaseBatchState extends GPUTestSubcaseBatchState {\n  private requiredLimitsHelper: RequiredLimitsHelper;\n  constructor(\n    protected override readonly recorder: TestCaseRecorder,\n    public override readonly params: TestParams,\n    requiredLimitsHelper: RequiredLimitsHelper\n  ) {\n    super(recorder, params);\n    this.requiredLimitsHelper = requiredLimitsHelper;\n  }\n  override requestDeviceWithRequiredParametersOrSkip(\n    descriptor: DeviceSelectionDescriptor,\n    descriptorModifier?: DescriptorModifier\n  ): void {\n    const requiredLimitsHelper = this.requiredLimitsHelper;\n    const mod: DescriptorModifier = {\n      descriptorModifier(adapter: GPUAdapter, desc: CanonicalDeviceDescriptor | undefined) {\n        desc = descriptorModifier?.descriptorModifier\n          ? descriptorModifier.descriptorModifier(adapter, desc)\n          : desc;\n        return applyLimitsToDescriptor(adapter, desc, requiredLimitsHelper.getRequiredLimits);\n      },\n      keyModifier(baseKey: string) {\n        return `${baseKey}:${requiredLimitsHelper.key()}`;\n      },\n    };\n    super.requestDeviceWithRequiredParametersOrSkip(\n      initUncanonicalizedDeviceDescriptor(descriptor),\n      mod\n    );\n  }\n}\n\nexport type RequiredLimitsTestMixinType = {\n  // placeholder. Change to an interface if we need MaxLimits specific methods.\n};\n\n/**\n * A text mixin to make it relatively easy to request specific limits.\n */\nexport function RequiredLimitsTestMixin<F extends FixtureClass<GPUTestBase>>(\n  Base: F,\n  requiredLimitsHelper: RequiredLimitsHelper\n): FixtureClassWithMixin<F, RequiredLimitsTestMixinType> {\n  class RequiredLimitsImpl\n    extends (Base as FixtureClassInterface<GPUTestBase>)\n    implements RequiredLimitsTestMixinType\n  {\n    //\n    public static override MakeSharedState(\n      recorder: TestCaseRecorder,\n      params: TestParams\n    ): GPUTestSubcaseBatchState {\n      return new RequiredLimitsGPUTestSubcaseBatchState(recorder, params, requiredLimitsHelper);\n    }\n  }\n\n  return RequiredLimitsImpl as unknown as FixtureClassWithMixin<F, RequiredLimitsTestMixinType>;\n}\n\n/**\n * Used by AllFeaturesMaxLimitsGPUTest to request a device with all limits and features of the adapter.\n */\nexport class AllFeaturesMaxLimitsGPUTestSubcaseBatchState extends GPUTestSubcaseBatchState {\n  constructor(\n    protected override readonly recorder: TestCaseRecorder,\n    public override readonly params: TestParams\n  ) {\n    super(recorder, params);\n  }\n  override requestDeviceWithRequiredParametersOrSkip(\n    descriptor: DeviceSelectionDescriptor,\n    descriptorModifier?: DescriptorModifier\n  ): void {\n    const mod: DescriptorModifier = {\n      descriptorModifier(adapter: GPUAdapter, desc: CanonicalDeviceDescriptor | undefined) {\n        desc = descriptorModifier?.descriptorModifier\n          ? descriptorModifier.descriptorModifier(adapter, desc)\n          : desc;\n        desc = applyLimitsToDescriptor(adapter, desc, getAdapterLimitsAsDeviceRequiredLimits);\n        desc = applyFeaturesToDescriptor(adapter, desc, getAdapterFeaturesAsDeviceRequiredFeatures);\n        return desc;\n      },\n      keyModifier(baseKey: string) {\n        return `${baseKey}:AllFeaturesMaxLimits`;\n      },\n    };\n    super.requestDeviceWithRequiredParametersOrSkip(\n      initUncanonicalizedDeviceDescriptor(descriptor),\n      mod\n    );\n  }\n\n  /**\n   * Use skipIfDeviceDoesNotHaveFeature or similar. If you really need to test\n   * lack of a feature (for example tests under webgpu/api/validation/capability_checks)\n   * then use UniqueFeaturesOrLimitsGPUTest\n   */\n  override selectDeviceOrSkipTestCase(descriptor: DeviceSelectionDescriptor): void {\n    unreachable('this function should not be called in AllFeaturesMaxLimitsGPUTest');\n  }\n\n  /**\n   * Use skipIfDeviceDoesNotHaveFeature or similar.\n   */\n  override selectDeviceForQueryTypeOrSkipTestCase(types: GPUQueryType | GPUQueryType[]): void {\n    unreachable('this function should not be called in AllFeaturesMaxLimitsGPUTest');\n  }\n\n  /**\n   * Use skipIfDeviceDoesNotHaveFeature or skipIf(device.limits.maxXXX < requiredXXX) etc...\n   */\n  override selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): void {\n    unreachable('this function should not be called in AllFeaturesMaxLimitsGPUTest');\n  }\n\n  /**\n   * Use skipIfDeviceDoesNotHaveFeature or skipIf(device.limits.maxXXX < requiredXXX) etc...\n   */\n  selectMismatchedDeviceOrSkipTestCase(descriptor: DeviceSelectionDescriptor): void {\n    unreachable('this function should not be called in AllFeaturesMaxLimitsGPUTest');\n  }\n}\n\n/**\n * Most tests should be using `AllFeaturesMaxLimitsGPUTest`. The exceptions\n * are tests specifically validating limits like those under api/validation/capability_checks/limits\n * and those tests the specifically validate certain features fail validation if not enabled\n * like those under api/validation/capability_checks/feature.\n *\n * NOTE: The goal is to go through all existing tests and remove any direct use of GPUTest.\n * For each test, choose either AllFeaturesMaxLimitsGPUTest or UniqueFeaturesOrLimitsGPUTest.\n * This way we can track progress as we go through every test using GPUTest and check it is\n * testing everything it should test.\n */\nexport class UniqueFeaturesOrLimitsGPUTest extends GPUTest {}\n\n/**\n * A test that requests all features and maximum limits. This should be the default\n * test for the majority of tests, otherwise optional features will not be tested.\n * The exceptions are only tests that explicitly test the absence of a feature or\n * specific limits such as the tests under validation/capability_checks.\n *\n * As a concrete example to demonstrate the issue, texture format `rg11b10ufloat` is\n * optionally renderable and can optionally be used multisampled. Any test that tests\n * texture formats should test this format, skipping only if the feature is missing.\n * So, the default should be that the test tests `kAllTextureFormats` with the appropriate\n * filters from format_info.ts or the various helpers. This way, `rg11b10ufloat` will\n * included in the test and fail if not appropriately filtered. If instead you were\n * to use GPUTest then `rg11b10ufloat` would just be skipped as its never enabled.\n * You could enable it manually but that spreads enabling to every test instead of being\n * centralized in one place, here.\n */\nexport class AllFeaturesMaxLimitsGPUTest extends GPUTest {\n  public static override MakeSharedState(\n    recorder: TestCaseRecorder,\n    params: TestParams\n  ): GPUTestSubcaseBatchState {\n    return new AllFeaturesMaxLimitsGPUTestSubcaseBatchState(recorder, params);\n  }\n}\n"],"mappings":"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"}