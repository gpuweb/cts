{"version":3,"file":"inter_stage.js","names":["assert","s_deviceToEitherSamplingIndex","WeakMap","getProvokingVertexForFlatInterpolationEitherSampling","t","device","sampling","get","module","createShaderModule","code","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","texture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","label","pass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","draw","end","buffer","createBufferTracked","GPUBufferUsage","COPY_DST","MAP_READ","copyTextureToBuffer","commandBuffer","finish","queue","submit","mapAsync","GPUMapMode","READ","result","Uint8Array","getMappedRange","unmap","destroy","set"],"sources":["../../src/webgpu/inter_stage.ts"],"sourcesContent":["import { assert } from '../common/util/util.js';\n\nimport { GPUTest } from './gpu_test.js';\n\nexport type FlatSampling = 'first' | 'last';\n\nconst s_deviceToEitherSamplingIndex = new WeakMap<GPUDevice, FlatSampling>();\n\n/**\n * Returns whether the device uses the first or last vertex for the\n * provoking vertex when using @interpolate(flat, either)\n */\nexport async function getProvokingVertexForFlatInterpolationEitherSampling(\n  t: GPUTest\n): Promise<FlatSampling> {\n  const { device } = t;\n  let sampling = s_deviceToEitherSamplingIndex.get(device);\n  if (!sampling) {\n    const module = device.createShaderModule({\n      code: `\n        struct VSOut {\n          @builtin(position) position: vec4f,\n          @location(0) @interpolate(flat, either) vertexIndex: u32,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32,\n        ) -> VSOut {\n          let pos = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n          var vsOutput: VSOut;\n          vsOutput.position = vec4f(pos[vertexIndex], 0, 1);\n          vsOutput.vertexIndex = vertexIndex;\n          return vsOutput;\n        }\n\n        @fragment fn fs(@location(0) @interpolate(flat, either) vertexIndex: u32) -> @location(0) vec4u {\n          return vec4u(vertexIndex);\n        }\n      `,\n    });\n\n    const pipeline = device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n      },\n      fragment: {\n        module,\n        targets: [{ format: 'rgba8uint' }],\n      },\n    });\n\n    const texture = t.createTextureTracked({\n      format: 'rgba8uint',\n      size: [1, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const encoder = device.createCommandEncoder({\n      label: 'getProvokingVertexForFlatInterpolationEitherSampling',\n    });\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView(),\n          clearValue: [255, 255, 255, 255],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n\n    const buffer = t.createBufferTracked({\n      size: 4,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n    encoder.copyTextureToBuffer({ texture }, { buffer }, [1, 1]);\n\n    const commandBuffer = encoder.finish();\n    device.queue.submit([commandBuffer]);\n\n    await buffer.mapAsync(GPUMapMode.READ);\n    const result = new Uint8Array(buffer.getMappedRange())[0];\n    buffer.unmap();\n    buffer.destroy();\n    texture.destroy();\n\n    assert(result === 0 || result === 2, `expected result to be 0 or 2, was ${result}`);\n    sampling = result === 2 ? 'last' : 'first';\n    s_deviceToEitherSamplingIndex.set(device, sampling);\n  }\n  return sampling;\n}\n"],"mappings":"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"}