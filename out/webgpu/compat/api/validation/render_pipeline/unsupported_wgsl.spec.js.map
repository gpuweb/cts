{"version":3,"file":"unsupported_wgsl.spec.js","names":["description","makeTestGroup","keysOf","vtu","kCompatModeUnsupportedStorageTextureFormats","CompatibilityTest","g","test","desc","params","u","combine","fn","t","entryPoint","async","module","device","createShaderModule","code","isValid","isCompatibility","doCreateRenderPipelineTest","layout","vertex","fragment","targets","format","combineWithParams","success","interpolate","doCreateComputePipelineTest","compute","depthStencil","depthWriteEnabled","depthCompare","kDepthTextureTypeToParams","texture_depth_2d","texture_depth_2d_array","texture_depth_multisampled_2d","kDepthTextureTypes","type"],"sources":["../../../../../../src/webgpu/compat/api/validation/render_pipeline/unsupported_wgsl.spec.ts"],"sourcesContent":["export const description = `\nTests limitations of createShaderModule in compat mode.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport * as vtu from '../../../../api/validation/validation_test_utils.js';\nimport { kCompatModeUnsupportedStorageTextureFormats } from '../../../../format_info.js';\nimport { CompatibilityTest } from '../../../compatibility_test.js';\n\nexport const g = makeTestGroup(CompatibilityTest);\n\ng.test('sample_mask')\n  .desc(\n    `\nTests that you can not create a render pipeline that uses sample_mask in compat mode.\n\n- Test that a pipeline with a shader that uses sample_mask fails.\n- Test that a pipeline that references a module that has a shader that uses sample_mask\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u\n      .combine('entryPoint', ['fsWithoutSampleMaskUsage', 'fsWithSampleMaskUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { entryPoint, async } = t.params;\n    const module = t.device.createShaderModule({\n      code: `\n        @vertex fn vs() -> @builtin(position) vec4f {\n            return vec4f(1);\n        }\n        struct Output {\n            @builtin(sample_mask) mask_out: u32,\n            @location(0) color : vec4f,\n        }\n        @fragment fn fsWithoutSampleMaskUsage() -> @location(0) vec4f {\n            return vec4f(1.0, 1.0, 1.0, 1.0);\n        }\n        @fragment fn fsWithSampleMaskUsage() -> Output {\n            var o: Output;\n            // We need to make sure this sample_mask isn't optimized out even if its value equals \"no op\".\n            o.mask_out = 0xFFFFFFFFu;\n            o.color = vec4f(1.0, 1.0, 1.0, 1.0);\n            return o;\n        }\n      `,\n    });\n    const isValid = !t.isCompatibility || entryPoint === 'fsWithoutSampleMaskUsage';\n    vtu.doCreateRenderPipelineTest(t, async, isValid, {\n      layout: 'auto',\n      vertex: { module },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    });\n  });\n\ng.test('sample_index')\n  .desc(\n    `\nTests that you can not create a render pipeline that uses sample_index in compat mode.\n\n- Test that a pipeline with a shader that uses sample_index fails.\n- Test that a pipeline that references a module that has a shader that uses sample_index\n  but the pipeline does not reference that shader succeeds.\n    `\n  )\n  .params(u =>\n    u\n      .combine('entryPoint', ['fsWithoutSampleIndexUsage', 'fsWithSampleIndexUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { entryPoint, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @vertex fn vs() -> @builtin(position) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithoutSampleIndexUsage() -> @location(0) vec4f {\n            return vec4f(0);\n        }\n        @fragment fn fsWithSampleIndexUsage(@builtin(sample_index) sampleIndex: u32) -> @location(0) vec4f {\n            _ = sampleIndex;\n            return vec4f(0);\n        }\n          `,\n    });\n\n    const isValid = !t.isCompatibility || entryPoint === 'fsWithoutSampleIndexUsage';\n    vtu.doCreateRenderPipelineTest(t, async, isValid, {\n      layout: 'auto',\n      vertex: { module },\n      fragment: {\n        module,\n        entryPoint,\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    });\n  });\n\ng.test('interpolate')\n  .desc(\n    `Tests that you can not create a render pipeline that uses interpolate(linear), interpolate(...,sample),\n     interpolate(flat), nor interpolate(flat, first) in compat mode.`\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { success: false, interpolate: '@interpolate(linear)' },\n        { success: false, interpolate: '@interpolate(linear, sample)' },\n        { success: false, interpolate: '@interpolate(perspective, sample)' },\n        { success: false, interpolate: '@interpolate(flat)' },\n        { success: false, interpolate: '@interpolate(flat, first)' },\n        { success: true, interpolate: '@interpolate(flat, either)' },\n      ] as const)\n      .combine('entryPoint', [\n        'fsWithoutInterpolationUsage',\n        'fsWithInterpolationUsage1',\n        'fsWithInterpolationUsage2',\n        'fsWithInterpolationUsage3',\n      ] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { interpolate, success, entryPoint, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        struct Vertex {\n            @builtin(position) pos: vec4f,\n            @location(0) ${interpolate} color : vec4f,\n        };\n        @vertex fn vs() -> Vertex {\n            var v: Vertex;\n            v.pos = vec4f(1);\n            v.color = vec4f(1);\n            return v;\n        }\n        @fragment fn fsWithoutInterpolationUsage() -> @location(0) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithInterpolationUsage1(v: Vertex) -> @location(0) vec4f {\n            return vec4f(1);\n        }\n        @fragment fn fsWithInterpolationUsage2(v: Vertex) -> @location(0) vec4f {\n            return v.pos;\n        }\n        @fragment fn fsWithInterpolationUsage3(v: Vertex) -> @location(0) vec4f {\n            return v.color;\n        }\n        `,\n    });\n\n    const isValid = success || !t.isCompatibility || entryPoint === 'fsWithoutInterpolationUsage';\n    vtu.doCreateRenderPipelineTest(t, async, isValid, {\n      layout: 'auto',\n      vertex: { module },\n      fragment: {\n        entryPoint,\n        module,\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    });\n  });\n\ng.test('unsupportedStorageTextureFormats,computePipeline')\n  .desc(\n    `Tests that you can not create a compute pipeline that uses an\n     unsupported storage texture format in compat mode.`\n  )\n  .params(u =>\n    u\n      .combine('format', kCompatModeUnsupportedStorageTextureFormats)\n      .combine('entryPoint', ['csWithoutStorageUsage', 'csWithStorageUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { format, entryPoint, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var s: texture_storage_2d<${format}, read>;\n        @compute @workgroup_size(1) fn csWithoutStorageUsage() {\n        }\n        @compute @workgroup_size(1) fn csWithStorageUsage() {\n            _ = textureLoad(s, vec2u(0));\n        }\n      `,\n    });\n\n    const isValid = !t.isCompatibility || entryPoint === 'csWithoutStorageUsage';\n    vtu.doCreateComputePipelineTest(t, async, isValid, {\n      layout: 'auto',\n      compute: { module, entryPoint },\n    });\n  });\n\ng.test('unsupportedStorageTextureFormats,renderPipeline')\n  .desc(\n    `Tests that you can not create a render pipeline that uses an\n     unsupported storage texture format in compat mode.`\n  )\n  .params(u =>\n    u\n      .combine('format', kCompatModeUnsupportedStorageTextureFormats)\n      .combine('entryPoint', ['vsWithoutStorageUsage', 'vsWithStorageUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { format, entryPoint, async } = t.params;\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var s: texture_storage_2d<${format}, read>;\n        @vertex fn vsWithoutStorageUsage() -> @builtin(position) vec4f {\n            return vec4f(0);\n        }\n        @vertex fn vsWithStorageUsage() -> @builtin(position) vec4f {\n            _ = textureLoad(s, vec2u(0));\n            return vec4f(0);\n        }\n      `,\n    });\n\n    const isValid = !t.isCompatibility || entryPoint === 'vsWithoutStorageUsage';\n    vtu.doCreateRenderPipelineTest(t, async, isValid, {\n      layout: 'auto',\n      vertex: { module, entryPoint },\n      depthStencil: { format: 'depth32float', depthWriteEnabled: true, depthCompare: 'always' },\n    });\n  });\n\nconst kDepthTextureTypeToParams = {\n  texture_depth_2d: 'vec2u(0), 0',\n  texture_depth_2d_array: 'vec2u(0), 0, 0',\n  texture_depth_multisampled_2d: 'vec2u(0), 0',\n} as const;\nconst kDepthTextureTypes = keysOf(kDepthTextureTypeToParams);\n\ng.test('textureLoad_with_depth_textures,computePipeline')\n  .desc(\n    `Tests that you can not create a compute pipeline that uses textureLoad with a depth texture in compat mode.`\n  )\n  .params(u =>\n    u\n      .combine('type', kDepthTextureTypes)\n      .combine('entryPoint', ['csWithoutDepthUsage', 'csWithDepthUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { type, entryPoint, async } = t.params;\n    const params = kDepthTextureTypeToParams[type];\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var t: ${type};\n        @compute @workgroup_size(1) fn csWithoutDepthUsage() {\n        }\n        @compute @workgroup_size(1) fn csWithDepthUsage() {\n            _ = textureLoad(t, ${params});\n        }\n      `,\n    });\n\n    const isValid = !t.isCompatibility || entryPoint === 'csWithoutDepthUsage';\n    vtu.doCreateComputePipelineTest(t, async, isValid, {\n      layout: 'auto',\n      compute: { module, entryPoint },\n    });\n  });\n\ng.test('textureLoad_with_depth_textures,renderPipeline')\n  .desc(\n    `Tests that you can not create a render pipeline that uses textureLoad with a depth texture in compat mode.`\n  )\n  .params(u =>\n    u\n      .combine('type', kDepthTextureTypes)\n      .combine('entryPoint', ['vsWithoutDepthUsage', 'vsWithDepthUsage'] as const)\n      .combine('async', [false, true] as const)\n  )\n  .fn(t => {\n    const { type, entryPoint, async } = t.params;\n    const params = kDepthTextureTypeToParams[type];\n\n    const module = t.device.createShaderModule({\n      code: `\n        @group(0) @binding(0) var t: ${type};\n        @vertex fn vsWithoutDepthUsage() -> @builtin(position) vec4f {\n            return vec4f(0);\n        }\n        @vertex fn vsWithDepthUsage() -> @builtin(position) vec4f {\n            _ = textureLoad(t, ${params});\n            return vec4f(0);\n        }\n      `,\n    });\n\n    const isValid = !t.isCompatibility || entryPoint === 'vsWithoutDepthUsage';\n    vtu.doCreateRenderPipelineTest(t, async, isValid, {\n      layout: 'auto',\n      vertex: { module, entryPoint },\n      depthStencil: { format: 'depth32float', depthWriteEnabled: true, depthCompare: 'always' },\n    });\n  });\n"],"mappings":"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"}