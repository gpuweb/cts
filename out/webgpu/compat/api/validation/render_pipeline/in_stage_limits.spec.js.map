{"version":3,"file":"in_stage_limits.spec.js","names":["description","makeTestGroup","range","RequiredLimitsTestMixin","CompatibilityTest","g","getRequiredLimits","adapter","maxStorageBuffersInFragmentStage","limits","maxStorageBuffersInVertexStage","maxStorageBuffersPerShaderStage","maxStorageTexturesInFragmentStage","maxStorageTexturesInVertexStage","maxStorageTexturesPerShaderStage","key","test","desc","params","u","combine","beginSubcases","fn","t","limit","extra","async","device","isBuffer","includes","inStageLimit","perStageLimitName","perStageLimit","debug","skipIf","typeWGSLFn","i","count","code","join","module","createShaderModule","isFragment","pipelineDescriptor","layout","vertex","entryPoint","fragment","targets","format","success","doCreateRenderPipelineTest"],"sources":["../../../../../../src/webgpu/compat/api/validation/render_pipeline/in_stage_limits.spec.ts"],"sourcesContent":["export const description = `\nTests that, in compat mode, you can not create a pipeline layout with with\nmore than the max in stage limit even if the per stage limit is higher.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { range } from '../../../../../common/util/util.js';\nimport { RequiredLimitsTestMixin } from '../../../../gpu_test.js';\nimport { CompatibilityTest } from '../../../compatibility_test.js';\n\nexport const g = makeTestGroup(\n  RequiredLimitsTestMixin(CompatibilityTest, {\n    getRequiredLimits(adapter: GPUAdapter) {\n      return {\n        maxStorageBuffersInFragmentStage: adapter.limits.maxStorageBuffersInFragmentStage! / 2,\n        maxStorageBuffersInVertexStage: adapter.limits.maxStorageBuffersInVertexStage! / 2,\n        maxStorageBuffersPerShaderStage: adapter.limits.maxStorageBuffersPerShaderStage,\n        maxStorageTexturesInFragmentStage: adapter.limits.maxStorageTexturesInFragmentStage! / 2,\n        maxStorageTexturesInVertexStage: adapter.limits.maxStorageTexturesInVertexStage! / 2,\n        maxStorageTexturesPerShaderStage: adapter.limits.maxStorageTexturesPerShaderStage,\n      };\n    },\n    key() {\n      return `\n      maxStorageBuffersInFragmentStage/2,\n      maxStorageBuffersInVertexStage/2,\n      maxStorageTexturesInFragmentStage/2,\n      maxStorageTexturesInVertexStage/2,\n      maxStorageBuffersPerShaderStage\n      maxStorageTexturesPerShaderStage\n    `;\n    },\n  })\n);\n\ng.test('maxStorageBuffersTexturesInVertexFragmentStage')\n  .desc(\n    `\n      Tests that you can't use more than maxStorage(Buffers/Textures)In(Fragment/Vertex)Stage when\n      the limit is less than maxStorage(Buffers/Textures)PerShaderStage\n    `\n  )\n  .params(u =>\n    u\n      .combine('limit', [\n        'maxStorageBuffersInFragmentStage',\n        'maxStorageBuffersInVertexStage',\n        'maxStorageTexturesInFragmentStage',\n        'maxStorageTexturesInVertexStage',\n      ] as const)\n      .beginSubcases()\n      .combine('async', [false, true] as const)\n      .combine('extra', [0, 1] as const)\n  )\n  .fn(t => {\n    const { limit, extra, async } = t.params;\n    const { device } = t;\n\n    const isBuffer = limit.includes('Buffers');\n    const inStageLimit = device.limits[limit]!;\n    const perStageLimitName = isBuffer\n      ? 'maxStorageBuffersPerShaderStage'\n      : 'maxStorageTexturesPerShaderStage';\n    const perStageLimit = device.limits[perStageLimitName];\n\n    t.debug(`${limit}(${inStageLimit}), ${perStageLimitName}(${perStageLimit})`);\n\n    t.skipIf(inStageLimit === 0, `${limit} is 0`);\n    t.skipIf(\n      !(inStageLimit < perStageLimit),\n      `${limit}(${inStageLimit}) is not less than ${perStageLimitName}(${perStageLimit})`\n    );\n\n    const typeWGSLFn = isBuffer\n      ? (i: number) => `var<storage, read> v${i}: f32;`\n      : (i: number) => `var v${i}: texture_storage_2d<r32float, read>;`;\n\n    const count = inStageLimit + extra;\n    const code = `\n    ${range(count, i => `@group(0) @binding(${i}) ${typeWGSLFn(i)}`).join('\\n')}\n\n    fn useResources() {\n      ${range(count, i => `_ = v${i};`).join('\\n')}\n    }\n\n    @vertex fn vsNoUse() -> @builtin(position) vec4f {\n      return vec4f(0);\n    }\n\n    @vertex fn vsUse() -> @builtin(position) vec4f {\n      useResources();\n      return vec4f(0);\n    }\n\n    @fragment fn fsNoUse() -> @location(0) vec4f {\n      return vec4f(0);\n    }\n\n    @fragment fn fsUse() -> @location(0) vec4f {\n      useResources();\n      return vec4f(0);\n    }\n    `;\n\n    const module = device.createShaderModule({ code });\n\n    const isFragment = limit.includes('Fragment');\n    const pipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: isFragment ? 'vsNoUse' : 'vsUse',\n      },\n      fragment: {\n        module,\n        entryPoint: isFragment ? 'fsUse' : 'fsNoUse',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    };\n\n    const success = extra === 0;\n    t.doCreateRenderPipelineTest(async, success, pipelineDescriptor);\n  });\n"],"mappings":"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"}