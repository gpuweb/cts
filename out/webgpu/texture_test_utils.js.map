{"version":3,"file":"texture_test_utils.js","names":["assert","memcpy","getBlockInfoForColorTextureFormat","getBlockInfoForTextureFormat","kEncodableTextureFormats","resolvePerAspectFormat","checkElementsEqual","align","physicalMipSizeFromTexture","virtualMipSize","bytesInACompleteRow","getTextureCopyLayout","TexelView","textureContentIsOKByT2B","createTextureFromTexelViews","reifyOrigin3D","s_deviceToResourcesMap","WeakMap","getPipelineToRenderTextureToRGB8UnormTexture","device","texture","has","set","pipelineByPipelineType","Map","get","pipelineType","dimension","depthOrArrayLayers","textureType","coordCode","code","module","createShaderModule","pipeline","createRenderPipeline","label","layout","vertex","entryPoint","fragment","targets","format","createTextureFromTexelView","t","texelView","desc","createTextureFromTexelViewsMultipleMipmaps","texelViews","expectTexelViewComparisonIsOkInTexture","src","exp","size","comparisonOptions","maxIntDiff","maxDiffULPsForNormFormat","maxDiffULPsForFloatFormat","eventualExpectOK","expTexelView","expectSinglePixelComparisonsAreOkInTexture","length","includes","lowerCorner","width","height","upperCorner","expMap","coords","e","coord","coordKey","JSON","stringify","push","Math","min","x","y","z","max","Symbol","iterator","fromTexelsAsBytes","res","undefined","fromTexelsAsColors","coordsF","origin","expectTexturesToMatchByRendering","actualTexture","expectedTexture","mipLevel","readbackPromisesPerTexturePerLayer","map","ndx","attachmentSize","attachment","createTextureTracked","usage","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","sampler","createSampler","numLayers","readbackPromisesPerLayer","uniformBuffer","createBufferTracked","GPUBufferUsage","UNIFORM","COPY_DST","layer","viewDescriptor","baseMipLevel","mipLevelCount","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","queue","writeBuffer","Uint32Array","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","setBindGroup","draw","end","submit","finish","copyWholeTextureToNewBufferSimple","readGPUBufferRangeTyped","type","Uint8Array","typedLength","eventualAsyncExpectation","niceStack","readbacksPerTexturePerLayer","readbackPromises","Promise","all","arrayNotAllTheSameValue","arr","msg","first","findIndex","v","Error","actualReadbacksPerLayer","expectedReadbacksPerLayer","actualReadback","expectedReadback","sameOk","expectOK","data","mode","cleanup","expectSingleColorWithTolerance","slice","maxFractionalDiff","aspect","mipSize","copySize","source","blockWidth","blockHeight","bytesPerBlock","blocksPerRow","blocksPerColumn","bytesPerRow","byteLength","copyWholeTextureToNewBuffer","rowsPerImage","resultDataLayout","copyTextureToBuffer","updateLinearTextureDataSubBox","copyParams","dest","rowLength","texel","iterateBlockRows","srcOffsetElements","getTexelOffsetInBytes","dataLayout","dstOffsetElements","start","dst","textureDataLayout","offset","info","bytesPerImage"],"sources":["../../src/webgpu/texture_test_utils.ts"],"sourcesContent":["import { assert, memcpy, TypedArrayBufferView } from '../common/util/util.js';\n\nimport {\n  ColorTextureFormat,\n  EncodableTextureFormat,\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForTextureFormat,\n  kEncodableTextureFormats,\n  resolvePerAspectFormat,\n} from './format_info.js';\nimport { GPUTest } from './gpu_test.js';\nimport { checkElementsEqual } from './util/check_contents.js';\nimport { align } from './util/math.js';\nimport { physicalMipSizeFromTexture, virtualMipSize } from './util/texture/base.js';\nimport {\n  bytesInACompleteRow,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent } from './util/texture/texel_data.js';\nimport { TexelView } from './util/texture/texel_view.js';\nimport {\n  PerPixelComparison,\n  PixelExpectation,\n  TexelCompareOptions,\n  textureContentIsOKByT2B,\n} from './util/texture/texture_ok.js';\nimport { createTextureFromTexelViews } from './util/texture.js';\nimport { reifyOrigin3D } from './util/unions.js';\n\ntype PipelineType = '2d' | '2d-array' | '3d';\n\ntype ImageCopyTestResources = {\n  pipelineByPipelineType: Map<PipelineType, GPURenderPipeline>;\n};\n\nconst s_deviceToResourcesMap = new WeakMap<GPUDevice, ImageCopyTestResources>();\n/**\n * Gets a (cached) pipeline to render a texture to an rgba8unorm texture\n */\nfunction getPipelineToRenderTextureToRGB8UnormTexture(device: GPUDevice, texture: GPUTexture) {\n  if (!s_deviceToResourcesMap.has(device)) {\n    s_deviceToResourcesMap.set(device, {\n      pipelineByPipelineType: new Map<PipelineType, GPURenderPipeline>(),\n    });\n  }\n\n  const { pipelineByPipelineType } = s_deviceToResourcesMap.get(device)!;\n  const pipelineType: PipelineType =\n    texture.dimension === '3d' ? '3d' : texture.depthOrArrayLayers > 1 ? '2d-array' : '2d';\n  if (!pipelineByPipelineType.get(pipelineType)) {\n    const [textureType, coordCode] =\n      pipelineType === '3d'\n        ? [\n            'texture_3d',\n            'vec3f(fsInput.texcoord, (f32(uni.baseArrayLayer) + 0.5) / f32(textureDimensions(ourTexture, 0).z))',\n          ]\n        : pipelineType === '2d'\n        ? ['texture_2d', 'fsInput.texcoord']\n        : ['texture_2d_array', 'fsInput.texcoord, uni.baseArrayLayer'];\n    const code = `\n      struct VSOutput {\n        @builtin(position) position: vec4f,\n        @location(0) texcoord: vec2f,\n      };\n\n      struct Uniforms {\n        baseArrayLayer: u32,\n      };\n\n      @vertex fn vs(\n        @builtin(vertex_index) vertexIndex : u32\n      ) -> VSOutput {\n          let pos = array(\n             vec2f(-1, -1),\n             vec2f(-1,  3),\n             vec2f( 3, -1),\n          );\n\n          var vsOutput: VSOutput;\n\n          let xy = pos[vertexIndex];\n\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n\n          return vsOutput;\n       }\n\n       @group(0) @binding(0) var ourSampler: sampler;\n       @group(0) @binding(1) var ourTexture: ${textureType}<f32>;\n       @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n       @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni;\n          return textureSample(ourTexture, ourSampler, ${coordCode});\n       }\n    `;\n    const module = device.createShaderModule({ code });\n    const pipeline = device.createRenderPipeline({\n      label: `layer rendered for ${pipelineType}`,\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    });\n    pipelineByPipelineType.set(pipelineType, pipeline);\n  }\n  const pipeline = pipelineByPipelineType.get(pipelineType)!;\n  return { pipelineType, pipeline };\n}\n\ntype LinearCopyParameters = {\n  dataLayout: Required<GPUTexelCopyBufferLayout>;\n  origin: Required<GPUOrigin3DDict>;\n  data: Uint8Array;\n};\n\n/**\n * Creates a 1 mip level texture with the contents of a TexelView.\n */\nexport function createTextureFromTexelView(\n  t: GPUTest,\n  texelView: TexelView,\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  return createTextureFromTexelViews(t, [texelView], desc);\n}\n\nexport function createTextureFromTexelViewsMultipleMipmaps(\n  t: GPUTest,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  return createTextureFromTexelViews(t, texelViews, desc);\n}\n\nexport function expectTexelViewComparisonIsOkInTexture(\n  t: GPUTest,\n  src: GPUTexelCopyTextureInfo,\n  exp: TexelView,\n  size: GPUExtent3D,\n  comparisonOptions = {\n    maxIntDiff: 0,\n    maxDiffULPsForNormFormat: 1,\n    maxDiffULPsForFloatFormat: 1,\n  } as TexelCompareOptions\n): void {\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(t, src, size, { expTexelView: exp }, comparisonOptions)\n  );\n}\n\nexport function expectSinglePixelComparisonsAreOkInTexture<E extends PixelExpectation>(\n  t: GPUTest,\n  src: GPUTexelCopyTextureInfo,\n  exp: PerPixelComparison<E>[],\n  comparisonOptions = {\n    maxIntDiff: 0,\n    maxDiffULPsForNormFormat: 1,\n    maxDiffULPsForFloatFormat: 1,\n  } as TexelCompareOptions\n): void {\n  assert(exp.length > 0, 'must specify at least one pixel comparison');\n  assert(\n    (kEncodableTextureFormats as GPUTextureFormat[]).includes(src.texture.format),\n    () => `${src.texture.format} is not an encodable format`\n  );\n  const lowerCorner = [src.texture.width, src.texture.height, src.texture.depthOrArrayLayers];\n  const upperCorner = [0, 0, 0];\n  const expMap = new Map<string, E>();\n  const coords: Required<GPUOrigin3DDict>[] = [];\n  for (const e of exp) {\n    const coord = reifyOrigin3D(e.coord);\n    const coordKey = JSON.stringify(coord);\n    coords.push(coord);\n\n    // Compute the minimum sub-rect that encompasses all the pixel comparisons. The\n    // `lowerCorner` will become the origin, and the `upperCorner` will be used to compute the\n    // size.\n    lowerCorner[0] = Math.min(lowerCorner[0], coord.x);\n    lowerCorner[1] = Math.min(lowerCorner[1], coord.y);\n    lowerCorner[2] = Math.min(lowerCorner[2], coord.z);\n    upperCorner[0] = Math.max(upperCorner[0], coord.x);\n    upperCorner[1] = Math.max(upperCorner[1], coord.y);\n    upperCorner[2] = Math.max(upperCorner[2], coord.z);\n\n    // Build a sparse map of the coordinates to the expected colors for the texel view.\n    assert(\n      !expMap.has(coordKey),\n      () => `duplicate pixel expectation at coordinate (${coord.x},${coord.y},${coord.z})`\n    );\n    expMap.set(coordKey, e.exp);\n  }\n  const size: GPUExtent3D = [\n    upperCorner[0] - lowerCorner[0] + 1,\n    upperCorner[1] - lowerCorner[1] + 1,\n    upperCorner[2] - lowerCorner[2] + 1,\n  ];\n  let expTexelView: TexelView;\n  if (Symbol.iterator in exp[0].exp) {\n    expTexelView = TexelView.fromTexelsAsBytes(\n      src.texture.format as EncodableTextureFormat,\n      coord => {\n        const res = expMap.get(JSON.stringify(coord));\n        assert(\n          res !== undefined,\n          () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n        );\n        return res as Uint8Array;\n      }\n    );\n  } else {\n    expTexelView = TexelView.fromTexelsAsColors(\n      src.texture.format as EncodableTextureFormat,\n      coord => {\n        const res = expMap.get(JSON.stringify(coord));\n        assert(\n          res !== undefined,\n          () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n        );\n        return res as PerTexelComponent<number>;\n      }\n    );\n  }\n  const coordsF = (function* () {\n    for (const coord of coords) {\n      yield coord;\n    }\n  })();\n\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(\n      t,\n      { ...src, origin: reifyOrigin3D(lowerCorner) },\n      size,\n      { expTexelView },\n      comparisonOptions,\n      coordsF\n    )\n  );\n}\n\nexport function expectTexturesToMatchByRendering(\n  t: GPUTest,\n  actualTexture: GPUTexture,\n  expectedTexture: GPUTexture,\n  mipLevel: number,\n  origin: Required<GPUOrigin3DDict>,\n  size: Required<GPUExtent3DDict>\n): void {\n  // Render every layer of both textures at mipLevel to an rgba8unorm texture\n  // that matches the size of the mipLevel. After each render, copy the\n  // result to a buffer and expect the results from both textures to match.\n  const { pipelineType, pipeline } = getPipelineToRenderTextureToRGB8UnormTexture(\n    t.device,\n    actualTexture\n  );\n  const readbackPromisesPerTexturePerLayer = [actualTexture, expectedTexture].map(\n    (texture, ndx) => {\n      const attachmentSize = virtualMipSize(\n        actualTexture.dimension,\n        [texture.width, texture.height, 1],\n        mipLevel\n      );\n      const attachment = t.createTextureTracked({\n        label: `readback${ndx}`,\n        size: attachmentSize,\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      });\n\n      const sampler = t.device.createSampler();\n\n      const numLayers = texture.depthOrArrayLayers;\n      const readbackPromisesPerLayer = [];\n\n      const uniformBuffer = t.createBufferTracked({\n        label: 'expectTexturesToMatchByRendering:uniformBuffer',\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n\n      for (let layer = 0; layer < numLayers; ++layer) {\n        const viewDescriptor: GPUTextureViewDescriptor = {\n          baseMipLevel: mipLevel,\n          mipLevelCount: 1,\n          dimension: pipelineType,\n        };\n\n        const bindGroup = t.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n            { binding: 0, resource: sampler },\n            {\n              binding: 1,\n              resource: texture.createView(viewDescriptor),\n            },\n            {\n              binding: 2,\n              resource: { buffer: uniformBuffer },\n            },\n          ],\n        });\n\n        t.device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([layer]));\n\n        const encoder = t.device.createCommandEncoder({\n          label: 'expectTexturesToMatchByRendering',\n        });\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: attachment.createView(),\n              clearValue: [0.5, 0.5, 0.5, 0.5],\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindGroup);\n        pass.draw(3);\n        pass.end();\n        t.queue.submit([encoder.finish()]);\n\n        const buffer = copyWholeTextureToNewBufferSimple(t, attachment, 0);\n\n        readbackPromisesPerLayer.push(\n          t.readGPUBufferRangeTyped(buffer, {\n            type: Uint8Array,\n            typedLength: buffer.size,\n          })\n        );\n      }\n      return readbackPromisesPerLayer;\n    }\n  );\n\n  t.eventualAsyncExpectation(async niceStack => {\n    const readbacksPerTexturePerLayer = [];\n\n    // Wait for all buffers to be ready\n    for (const readbackPromises of readbackPromisesPerTexturePerLayer) {\n      readbacksPerTexturePerLayer.push(await Promise.all(readbackPromises));\n    }\n\n    function arrayNotAllTheSameValue(arr: TypedArrayBufferView | number[], msg?: string) {\n      const first = arr[0];\n      return arr.length <= 1 || arr.findIndex(v => v !== first) >= 0\n        ? undefined\n        : Error(`array is entirely ${first} so likely nothing was tested: ${msg || ''}`);\n    }\n\n    // Compare each layer of each texture as read from buffer.\n    const [actualReadbacksPerLayer, expectedReadbacksPerLayer] = readbacksPerTexturePerLayer;\n    for (let layer = 0; layer < actualReadbacksPerLayer.length; ++layer) {\n      const actualReadback = actualReadbacksPerLayer[layer];\n      const expectedReadback = expectedReadbacksPerLayer[layer];\n      const sameOk =\n        size.width === 0 ||\n        size.height === 0 ||\n        layer < origin.z ||\n        layer >= origin.z + size.depthOrArrayLayers;\n      t.expectOK(\n        sameOk ? undefined : arrayNotAllTheSameValue(actualReadback.data, 'actualTexture')\n      );\n      t.expectOK(\n        sameOk ? undefined : arrayNotAllTheSameValue(expectedReadback.data, 'expectedTexture')\n      );\n      t.expectOK(checkElementsEqual(actualReadback.data, expectedReadback.data), {\n        mode: 'fail',\n        niceStack,\n      });\n      actualReadback.cleanup();\n      expectedReadback.cleanup();\n    }\n  });\n}\n\n/**\n * Expect an entire GPUTexture to have a single color at the given mip level (defaults to 0).\n * MAINTENANCE_TODO: Remove this and/or replace it with a helper in TextureTestMixin.\n */\nexport function expectSingleColorWithTolerance(\n  t: GPUTest,\n  src: GPUTexture,\n  format: GPUTextureFormat,\n  {\n    size,\n    exp,\n    dimension = '2d',\n    slice = 0,\n    layout,\n    maxFractionalDiff,\n  }: {\n    size: [number, number, number];\n    exp: PerTexelComponent<number>;\n    dimension?: GPUTextureDimension;\n    slice?: number;\n    layout?: TextureLayoutOptions;\n    maxFractionalDiff?: number;\n  }\n): void {\n  assert(slice === 0 || dimension === '2d', 'texture slices are only implemented for 2d textures');\n\n  format = resolvePerAspectFormat(format, layout?.aspect);\n  const { mipSize } = getTextureCopyLayout(format, dimension, size, layout);\n  // MAINTENANCE_TODO: getTextureCopyLayout does not return the proper size for array textures,\n  // i.e. it will leave the z/depth value as is instead of making it 1 when dealing with 2d\n  // texture arrays. Since we are passing in the dimension, we should update it to return the\n  // corrected size.\n  const copySize = [\n    mipSize[0],\n    dimension !== '1d' ? mipSize[1] : 1,\n    dimension === '3d' ? mipSize[2] : 1,\n  ];\n\n  // Create a TexelView that returns exp for all texels.\n  const expTexelView = TexelView.fromTexelsAsColors(format as EncodableTextureFormat, () => exp);\n  const source: GPUTexelCopyTextureInfo = {\n    texture: src,\n    mipLevel: layout?.mipLevel ?? 0,\n    aspect: layout?.aspect ?? 'all',\n    origin: [0, 0, slice],\n  };\n  const comparisonOptions = {\n    maxFractionalDiff: maxFractionalDiff ?? 0,\n  };\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(t, source, copySize, { expTexelView }, comparisonOptions)\n  );\n}\n\nexport function copyWholeTextureToNewBufferSimple(\n  t: GPUTest,\n  texture: GPUTexture,\n  mipLevel: number\n) {\n  const { blockWidth, blockHeight, bytesPerBlock } = getBlockInfoForTextureFormat(texture.format);\n  const mipSize = physicalMipSizeFromTexture(texture, mipLevel);\n  assert(bytesPerBlock !== undefined);\n\n  const blocksPerRow = mipSize[0] / blockWidth;\n  const blocksPerColumn = mipSize[1] / blockHeight;\n\n  assert(blocksPerRow % 1 === 0);\n  assert(blocksPerColumn % 1 === 0);\n\n  const bytesPerRow = align(blocksPerRow * bytesPerBlock, 256);\n  const byteLength = bytesPerRow * blocksPerColumn * mipSize[2];\n\n  return copyWholeTextureToNewBuffer(\n    t,\n    { texture, mipLevel },\n    {\n      bytesPerBlock,\n      bytesPerRow,\n      rowsPerImage: blocksPerColumn,\n      byteLength,\n    }\n  );\n}\n\nexport function copyWholeTextureToNewBuffer(\n  t: GPUTest,\n  { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n  resultDataLayout: {\n    bytesPerBlock: number;\n    byteLength: number;\n    bytesPerRow: number;\n    rowsPerImage: number;\n  }\n): GPUBuffer {\n  const { byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n  const buffer = t.createBufferTracked({\n    label: 'copyWholeTextureToNewBuffer:buffer',\n    size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  });\n\n  const mipSize = physicalMipSizeFromTexture(texture, mipLevel || 0);\n  const encoder = t.device.createCommandEncoder({ label: 'copyWholeTextureToNewBuffer' });\n  encoder.copyTextureToBuffer(\n    { texture, mipLevel },\n    { buffer, bytesPerRow, rowsPerImage },\n    mipSize\n  );\n  t.device.queue.submit([encoder.finish()]);\n\n  return buffer;\n}\n\nexport function updateLinearTextureDataSubBox(\n  t: GPUTest,\n  format: ColorTextureFormat,\n  copySize: Required<GPUExtent3DDict>,\n  copyParams: {\n    dest: LinearCopyParameters;\n    src: LinearCopyParameters;\n  }\n): void {\n  const { src, dest } = copyParams;\n  const rowLength = bytesInACompleteRow(copySize.width, format);\n  for (const texel of iterateBlockRows(copySize, format)) {\n    const srcOffsetElements = getTexelOffsetInBytes(src.dataLayout, format, texel, src.origin);\n    const dstOffsetElements = getTexelOffsetInBytes(dest.dataLayout, format, texel, dest.origin);\n    memcpy(\n      { src: src.data, start: srcOffsetElements, length: rowLength },\n      { dst: dest.data, start: dstOffsetElements }\n    );\n  }\n}\n\n/** Offset for a particular texel in the linear texture data */\nexport function getTexelOffsetInBytes(\n  textureDataLayout: Required<GPUTexelCopyBufferLayout>,\n  format: ColorTextureFormat,\n  texel: Required<GPUOrigin3DDict>,\n  origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n): number {\n  const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n  const info = getBlockInfoForColorTextureFormat(format);\n\n  assert(texel.x % info.blockWidth === 0);\n  assert(texel.y % info.blockHeight === 0);\n  assert(origin.x % info.blockWidth === 0);\n  assert(origin.y % info.blockHeight === 0);\n\n  const bytesPerImage = rowsPerImage * bytesPerRow;\n\n  return (\n    offset +\n    (texel.z + origin.z) * bytesPerImage +\n    ((texel.y + origin.y) / info.blockHeight) * bytesPerRow +\n    ((texel.x + origin.x) / info.blockWidth) * info.bytesPerBlock\n  );\n}\n\nexport function* iterateBlockRows(\n  size: Required<GPUExtent3DDict>,\n  format: ColorTextureFormat\n): Generator<Required<GPUOrigin3DDict>> {\n  if (size.width === 0 || size.height === 0 || size.depthOrArrayLayers === 0) {\n    // do not iterate anything for an empty region\n    return;\n  }\n  const info = getBlockInfoForTextureFormat(format);\n  assert(size.height % info.blockHeight === 0);\n  // Note: it's important that the order is in increasing memory address order.\n  for (let z = 0; z < size.depthOrArrayLayers; ++z) {\n    for (let y = 0; y < size.height; y += info.blockHeight) {\n      yield {\n        x: 0,\n        y,\n        z,\n      };\n    }\n  }\n}\n"],"mappings":"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"}