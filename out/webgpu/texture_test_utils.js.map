{"version":3,"file":"texture_test_utils.js","names":["assert","memcpy","getBlockInfoForColorTextureFormat","getBlockInfoForTextureFormat","kEncodableTextureFormats","resolvePerAspectFormat","checkElementsEqual","align","physicalMipSizeFromTexture","virtualMipSize","bytesInACompleteRow","getTextureCopyLayout","TexelView","textureContentIsOKByT2B","createTextureFromTexelViews","reifyOrigin3D","s_deviceToResourcesMap","WeakMap","getPipelineToRenderTextureToRGB8UnormTexture","device","texture","isCompatibility","has","set","pipelineByPipelineType","Map","get","pipelineType","depthOrArrayLayers","textureType","layerCode","module","createShaderModule","code","pipeline","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","format","createTextureFromTexelView","t","texelView","desc","createTextureFromTexelViewsMultipleMipmaps","texelViews","expectTexelViewComparisonIsOkInTexture","src","exp","size","comparisonOptions","maxIntDiff","maxDiffULPsForNormFormat","maxDiffULPsForFloatFormat","eventualExpectOK","expTexelView","expectSinglePixelComparisonsAreOkInTexture","length","includes","lowerCorner","width","height","upperCorner","expMap","coords","e","coord","coordKey","JSON","stringify","push","Math","min","x","y","z","max","Symbol","iterator","fromTexelsAsBytes","res","undefined","fromTexelsAsColors","coordsF","origin","expectTexturesToMatchByRendering","actualTexture","expectedTexture","mipLevel","readbackPromisesPerTexturePerLayer","map","ndx","attachmentSize","attachment","createTextureTracked","label","usage","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","sampler","createSampler","numLayers","readbackPromisesPerLayer","uniformBuffer","createBufferTracked","GPUBufferUsage","UNIFORM","COPY_DST","layer","viewDescriptor","baseMipLevel","mipLevelCount","baseArrayLayer","arrayLayerCount","dimension","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","queue","writeBuffer","Uint32Array","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","setBindGroup","draw","end","submit","finish","copyWholeTextureToNewBufferSimple","readGPUBufferRangeTyped","type","Uint8Array","typedLength","eventualAsyncExpectation","niceStack","readbacksPerTexturePerLayer","readbackPromises","Promise","all","arrayNotAllTheSameValue","arr","msg","first","findIndex","v","Error","actualReadbacksPerLayer","expectedReadbacksPerLayer","actualReadback","expectedReadback","sameOk","expectOK","data","mode","cleanup","expectSingleColorWithTolerance","slice","maxFractionalDiff","aspect","mipSize","copySize","source","blockWidth","blockHeight","bytesPerBlock","blocksPerRow","blocksPerColumn","bytesPerRow","byteLength","copyWholeTextureToNewBuffer","rowsPerImage","resultDataLayout","copyTextureToBuffer","updateLinearTextureDataSubBox","copyParams","dest","rowLength","texel","iterateBlockRows","srcOffsetElements","getTexelOffsetInBytes","dataLayout","dstOffsetElements","start","dst","textureDataLayout","offset","info","bytesPerImage"],"sources":["../../src/webgpu/texture_test_utils.ts"],"sourcesContent":["import { assert, memcpy, TypedArrayBufferView } from '../common/util/util.js';\n\nimport {\n  ColorTextureFormat,\n  EncodableTextureFormat,\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForTextureFormat,\n  kEncodableTextureFormats,\n  resolvePerAspectFormat,\n} from './format_info.js';\nimport { GPUTest } from './gpu_test.js';\nimport { checkElementsEqual } from './util/check_contents.js';\nimport { align } from './util/math.js';\nimport { physicalMipSizeFromTexture, virtualMipSize } from './util/texture/base.js';\nimport {\n  bytesInACompleteRow,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent } from './util/texture/texel_data.js';\nimport { TexelView } from './util/texture/texel_view.js';\nimport {\n  PerPixelComparison,\n  PixelExpectation,\n  TexelCompareOptions,\n  textureContentIsOKByT2B,\n} from './util/texture/texture_ok.js';\nimport { createTextureFromTexelViews } from './util/texture.js';\nimport { reifyOrigin3D } from './util/unions.js';\n\ntype PipelineType = '2d' | '2d-array';\n\ntype ImageCopyTestResources = {\n  pipelineByPipelineType: Map<PipelineType, GPURenderPipeline>;\n};\n\nconst s_deviceToResourcesMap = new WeakMap<GPUDevice, ImageCopyTestResources>();\n/**\n * Gets a (cached) pipeline to render a texture to an rgba8unorm texture\n */\nfunction getPipelineToRenderTextureToRGB8UnormTexture(\n  device: GPUDevice,\n  texture: GPUTexture,\n  isCompatibility: boolean\n) {\n  if (!s_deviceToResourcesMap.has(device)) {\n    s_deviceToResourcesMap.set(device, {\n      pipelineByPipelineType: new Map<PipelineType, GPURenderPipeline>(),\n    });\n  }\n\n  const { pipelineByPipelineType } = s_deviceToResourcesMap.get(device)!;\n  const pipelineType: PipelineType =\n    isCompatibility && texture.depthOrArrayLayers > 1 ? '2d-array' : '2d';\n  if (!pipelineByPipelineType.get(pipelineType)) {\n    const [textureType, layerCode] =\n      pipelineType === '2d' ? ['texture_2d', ''] : ['texture_2d_array', ', uni.baseArrayLayer'];\n    const module = device.createShaderModule({\n      code: `\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        struct Uniforms {\n          baseArrayLayer: u32,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n            let pos = array(\n               vec2f(-1, -1),\n               vec2f(-1,  3),\n               vec2f( 3, -1),\n            );\n\n            var vsOutput: VSOutput;\n\n            let xy = pos[vertexIndex];\n\n            vsOutput.position = vec4f(xy, 0.0, 1.0);\n            vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n\n            return vsOutput;\n         }\n\n         @group(0) @binding(0) var ourSampler: sampler;\n         @group(0) @binding(1) var ourTexture: ${textureType}<f32>;\n         @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n         @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n            return textureSample(ourTexture, ourSampler, fsInput.texcoord${layerCode});\n         }\n      `,\n    });\n    const pipeline = device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    });\n    pipelineByPipelineType.set(pipelineType, pipeline);\n  }\n  const pipeline = pipelineByPipelineType.get(pipelineType)!;\n  return { pipelineType, pipeline };\n}\n\ntype LinearCopyParameters = {\n  dataLayout: Required<GPUTexelCopyBufferLayout>;\n  origin: Required<GPUOrigin3DDict>;\n  data: Uint8Array;\n};\n\n/**\n * Creates a 1 mip level texture with the contents of a TexelView.\n */\nexport function createTextureFromTexelView(\n  t: GPUTest,\n  texelView: TexelView,\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  return createTextureFromTexelViews(t, [texelView], desc);\n}\n\nexport function createTextureFromTexelViewsMultipleMipmaps(\n  t: GPUTest,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'>\n): GPUTexture {\n  return createTextureFromTexelViews(t, texelViews, desc);\n}\n\nexport function expectTexelViewComparisonIsOkInTexture(\n  t: GPUTest,\n  src: GPUTexelCopyTextureInfo,\n  exp: TexelView,\n  size: GPUExtent3D,\n  comparisonOptions = {\n    maxIntDiff: 0,\n    maxDiffULPsForNormFormat: 1,\n    maxDiffULPsForFloatFormat: 1,\n  } as TexelCompareOptions\n): void {\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(t, src, size, { expTexelView: exp }, comparisonOptions)\n  );\n}\n\nexport function expectSinglePixelComparisonsAreOkInTexture<E extends PixelExpectation>(\n  t: GPUTest,\n  src: GPUTexelCopyTextureInfo,\n  exp: PerPixelComparison<E>[],\n  comparisonOptions = {\n    maxIntDiff: 0,\n    maxDiffULPsForNormFormat: 1,\n    maxDiffULPsForFloatFormat: 1,\n  } as TexelCompareOptions\n): void {\n  assert(exp.length > 0, 'must specify at least one pixel comparison');\n  assert(\n    (kEncodableTextureFormats as GPUTextureFormat[]).includes(src.texture.format),\n    () => `${src.texture.format} is not an encodable format`\n  );\n  const lowerCorner = [src.texture.width, src.texture.height, src.texture.depthOrArrayLayers];\n  const upperCorner = [0, 0, 0];\n  const expMap = new Map<string, E>();\n  const coords: Required<GPUOrigin3DDict>[] = [];\n  for (const e of exp) {\n    const coord = reifyOrigin3D(e.coord);\n    const coordKey = JSON.stringify(coord);\n    coords.push(coord);\n\n    // Compute the minimum sub-rect that encompasses all the pixel comparisons. The\n    // `lowerCorner` will become the origin, and the `upperCorner` will be used to compute the\n    // size.\n    lowerCorner[0] = Math.min(lowerCorner[0], coord.x);\n    lowerCorner[1] = Math.min(lowerCorner[1], coord.y);\n    lowerCorner[2] = Math.min(lowerCorner[2], coord.z);\n    upperCorner[0] = Math.max(upperCorner[0], coord.x);\n    upperCorner[1] = Math.max(upperCorner[1], coord.y);\n    upperCorner[2] = Math.max(upperCorner[2], coord.z);\n\n    // Build a sparse map of the coordinates to the expected colors for the texel view.\n    assert(\n      !expMap.has(coordKey),\n      () => `duplicate pixel expectation at coordinate (${coord.x},${coord.y},${coord.z})`\n    );\n    expMap.set(coordKey, e.exp);\n  }\n  const size: GPUExtent3D = [\n    upperCorner[0] - lowerCorner[0] + 1,\n    upperCorner[1] - lowerCorner[1] + 1,\n    upperCorner[2] - lowerCorner[2] + 1,\n  ];\n  let expTexelView: TexelView;\n  if (Symbol.iterator in exp[0].exp) {\n    expTexelView = TexelView.fromTexelsAsBytes(\n      src.texture.format as EncodableTextureFormat,\n      coord => {\n        const res = expMap.get(JSON.stringify(coord));\n        assert(\n          res !== undefined,\n          () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n        );\n        return res as Uint8Array;\n      }\n    );\n  } else {\n    expTexelView = TexelView.fromTexelsAsColors(\n      src.texture.format as EncodableTextureFormat,\n      coord => {\n        const res = expMap.get(JSON.stringify(coord));\n        assert(\n          res !== undefined,\n          () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n        );\n        return res as PerTexelComponent<number>;\n      }\n    );\n  }\n  const coordsF = (function* () {\n    for (const coord of coords) {\n      yield coord;\n    }\n  })();\n\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(\n      t,\n      { ...src, origin: reifyOrigin3D(lowerCorner) },\n      size,\n      { expTexelView },\n      comparisonOptions,\n      coordsF\n    )\n  );\n}\n\nexport function expectTexturesToMatchByRendering(\n  t: GPUTest,\n  actualTexture: GPUTexture,\n  expectedTexture: GPUTexture,\n  mipLevel: number,\n  origin: Required<GPUOrigin3DDict>,\n  size: Required<GPUExtent3DDict>\n): void {\n  // Render every layer of both textures at mipLevel to an rgba8unorm texture\n  // that matches the size of the mipLevel. After each render, copy the\n  // result to a buffer and expect the results from both textures to match.\n  const { pipelineType, pipeline } = getPipelineToRenderTextureToRGB8UnormTexture(\n    t.device,\n    actualTexture,\n    t.isCompatibility\n  );\n  const readbackPromisesPerTexturePerLayer = [actualTexture, expectedTexture].map(\n    (texture, ndx) => {\n      const attachmentSize = virtualMipSize('2d', [texture.width, texture.height, 1], mipLevel);\n      const attachment = t.createTextureTracked({\n        label: `readback${ndx}`,\n        size: attachmentSize,\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      });\n\n      const sampler = t.device.createSampler();\n\n      const numLayers = texture.depthOrArrayLayers;\n      const readbackPromisesPerLayer = [];\n\n      const uniformBuffer = t.createBufferTracked({\n        label: 'expectTexturesToMatchByRendering:uniforBuffer',\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      });\n\n      for (let layer = 0; layer < numLayers; ++layer) {\n        const viewDescriptor: GPUTextureViewDescriptor = {\n          baseMipLevel: mipLevel,\n          mipLevelCount: 1,\n          ...(!t.isCompatibility && {\n            baseArrayLayer: layer,\n            arrayLayerCount: 1,\n          }),\n          dimension: pipelineType,\n        };\n\n        const bindGroup = t.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n            { binding: 0, resource: sampler },\n            {\n              binding: 1,\n              resource: texture.createView(viewDescriptor),\n            },\n            ...(pipelineType === '2d-array'\n              ? [\n                  {\n                    binding: 2,\n                    resource: { buffer: uniformBuffer },\n                  },\n                ]\n              : []),\n          ],\n        });\n\n        t.device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([layer]));\n\n        const encoder = t.device.createCommandEncoder({\n          label: 'expectTexturesToMatchByRendering',\n        });\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: attachment.createView(),\n              clearValue: [0.5, 0.5, 0.5, 0.5],\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, bindGroup);\n        pass.draw(3);\n        pass.end();\n        t.queue.submit([encoder.finish()]);\n\n        const buffer = copyWholeTextureToNewBufferSimple(t, attachment, 0);\n\n        readbackPromisesPerLayer.push(\n          t.readGPUBufferRangeTyped(buffer, {\n            type: Uint8Array,\n            typedLength: buffer.size,\n          })\n        );\n      }\n      return readbackPromisesPerLayer;\n    }\n  );\n\n  t.eventualAsyncExpectation(async niceStack => {\n    const readbacksPerTexturePerLayer = [];\n\n    // Wait for all buffers to be ready\n    for (const readbackPromises of readbackPromisesPerTexturePerLayer) {\n      readbacksPerTexturePerLayer.push(await Promise.all(readbackPromises));\n    }\n\n    function arrayNotAllTheSameValue(arr: TypedArrayBufferView | number[], msg?: string) {\n      const first = arr[0];\n      return arr.length <= 1 || arr.findIndex(v => v !== first) >= 0\n        ? undefined\n        : Error(`array is entirely ${first} so likely nothing was tested: ${msg || ''}`);\n    }\n\n    // Compare each layer of each texture as read from buffer.\n    const [actualReadbacksPerLayer, expectedReadbacksPerLayer] = readbacksPerTexturePerLayer;\n    for (let layer = 0; layer < actualReadbacksPerLayer.length; ++layer) {\n      const actualReadback = actualReadbacksPerLayer[layer];\n      const expectedReadback = expectedReadbacksPerLayer[layer];\n      const sameOk =\n        size.width === 0 ||\n        size.height === 0 ||\n        layer < origin.z ||\n        layer >= origin.z + size.depthOrArrayLayers;\n      t.expectOK(\n        sameOk ? undefined : arrayNotAllTheSameValue(actualReadback.data, 'actualTexture')\n      );\n      t.expectOK(\n        sameOk ? undefined : arrayNotAllTheSameValue(expectedReadback.data, 'expectedTexture')\n      );\n      t.expectOK(checkElementsEqual(actualReadback.data, expectedReadback.data), {\n        mode: 'fail',\n        niceStack,\n      });\n      actualReadback.cleanup();\n      expectedReadback.cleanup();\n    }\n  });\n}\n\n/**\n * Expect an entire GPUTexture to have a single color at the given mip level (defaults to 0).\n * MAINTENANCE_TODO: Remove this and/or replace it with a helper in TextureTestMixin.\n */\nexport function expectSingleColorWithTolerance(\n  t: GPUTest,\n  src: GPUTexture,\n  format: GPUTextureFormat,\n  {\n    size,\n    exp,\n    dimension = '2d',\n    slice = 0,\n    layout,\n    maxFractionalDiff,\n  }: {\n    size: [number, number, number];\n    exp: PerTexelComponent<number>;\n    dimension?: GPUTextureDimension;\n    slice?: number;\n    layout?: TextureLayoutOptions;\n    maxFractionalDiff?: number;\n  }\n): void {\n  assert(slice === 0 || dimension === '2d', 'texture slices are only implemented for 2d textures');\n\n  format = resolvePerAspectFormat(format, layout?.aspect);\n  const { mipSize } = getTextureCopyLayout(format, dimension, size, layout);\n  // MAINTENANCE_TODO: getTextureCopyLayout does not return the proper size for array textures,\n  // i.e. it will leave the z/depth value as is instead of making it 1 when dealing with 2d\n  // texture arrays. Since we are passing in the dimension, we should update it to return the\n  // corrected size.\n  const copySize = [\n    mipSize[0],\n    dimension !== '1d' ? mipSize[1] : 1,\n    dimension === '3d' ? mipSize[2] : 1,\n  ];\n\n  // Create a TexelView that returns exp for all texels.\n  const expTexelView = TexelView.fromTexelsAsColors(format as EncodableTextureFormat, () => exp);\n  const source: GPUTexelCopyTextureInfo = {\n    texture: src,\n    mipLevel: layout?.mipLevel ?? 0,\n    aspect: layout?.aspect ?? 'all',\n    origin: [0, 0, slice],\n  };\n  const comparisonOptions = {\n    maxFractionalDiff: maxFractionalDiff ?? 0,\n  };\n  t.eventualExpectOK(\n    textureContentIsOKByT2B(t, source, copySize, { expTexelView }, comparisonOptions)\n  );\n}\n\nexport function copyWholeTextureToNewBufferSimple(\n  t: GPUTest,\n  texture: GPUTexture,\n  mipLevel: number\n) {\n  const { blockWidth, blockHeight, bytesPerBlock } = getBlockInfoForTextureFormat(texture.format);\n  const mipSize = physicalMipSizeFromTexture(texture, mipLevel);\n  assert(bytesPerBlock !== undefined);\n\n  const blocksPerRow = mipSize[0] / blockWidth;\n  const blocksPerColumn = mipSize[1] / blockHeight;\n\n  assert(blocksPerRow % 1 === 0);\n  assert(blocksPerColumn % 1 === 0);\n\n  const bytesPerRow = align(blocksPerRow * bytesPerBlock, 256);\n  const byteLength = bytesPerRow * blocksPerColumn * mipSize[2];\n\n  return copyWholeTextureToNewBuffer(\n    t,\n    { texture, mipLevel },\n    {\n      bytesPerBlock,\n      bytesPerRow,\n      rowsPerImage: blocksPerColumn,\n      byteLength,\n    }\n  );\n}\n\nexport function copyWholeTextureToNewBuffer(\n  t: GPUTest,\n  { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n  resultDataLayout: {\n    bytesPerBlock: number;\n    byteLength: number;\n    bytesPerRow: number;\n    rowsPerImage: number;\n  }\n): GPUBuffer {\n  const { byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n  const buffer = t.createBufferTracked({\n    label: 'copyWholeTextureToNewBuffer:buffer',\n    size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n  });\n\n  const mipSize = physicalMipSizeFromTexture(texture, mipLevel || 0);\n  const encoder = t.device.createCommandEncoder({ label: 'copyWholeTextureToNewBuffer' });\n  encoder.copyTextureToBuffer(\n    { texture, mipLevel },\n    { buffer, bytesPerRow, rowsPerImage },\n    mipSize\n  );\n  t.device.queue.submit([encoder.finish()]);\n\n  return buffer;\n}\n\nexport function updateLinearTextureDataSubBox(\n  t: GPUTest,\n  format: ColorTextureFormat,\n  copySize: Required<GPUExtent3DDict>,\n  copyParams: {\n    dest: LinearCopyParameters;\n    src: LinearCopyParameters;\n  }\n): void {\n  const { src, dest } = copyParams;\n  const rowLength = bytesInACompleteRow(copySize.width, format);\n  for (const texel of iterateBlockRows(copySize, format)) {\n    const srcOffsetElements = getTexelOffsetInBytes(src.dataLayout, format, texel, src.origin);\n    const dstOffsetElements = getTexelOffsetInBytes(dest.dataLayout, format, texel, dest.origin);\n    memcpy(\n      { src: src.data, start: srcOffsetElements, length: rowLength },\n      { dst: dest.data, start: dstOffsetElements }\n    );\n  }\n}\n\n/** Offset for a particular texel in the linear texture data */\nexport function getTexelOffsetInBytes(\n  textureDataLayout: Required<GPUTexelCopyBufferLayout>,\n  format: ColorTextureFormat,\n  texel: Required<GPUOrigin3DDict>,\n  origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n): number {\n  const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n  const info = getBlockInfoForColorTextureFormat(format);\n\n  assert(texel.x % info.blockWidth === 0);\n  assert(texel.y % info.blockHeight === 0);\n  assert(origin.x % info.blockWidth === 0);\n  assert(origin.y % info.blockHeight === 0);\n\n  const bytesPerImage = rowsPerImage * bytesPerRow;\n\n  return (\n    offset +\n    (texel.z + origin.z) * bytesPerImage +\n    ((texel.y + origin.y) / info.blockHeight) * bytesPerRow +\n    ((texel.x + origin.x) / info.blockWidth) * info.bytesPerBlock\n  );\n}\n\nexport function* iterateBlockRows(\n  size: Required<GPUExtent3DDict>,\n  format: ColorTextureFormat\n): Generator<Required<GPUOrigin3DDict>> {\n  if (size.width === 0 || size.height === 0 || size.depthOrArrayLayers === 0) {\n    // do not iterate anything for an empty region\n    return;\n  }\n  const info = getBlockInfoForTextureFormat(format);\n  assert(size.height % info.blockHeight === 0);\n  // Note: it's important that the order is in increasing memory address order.\n  for (let z = 0; z < size.depthOrArrayLayers; ++z) {\n    for (let y = 0; y < size.height; y += info.blockHeight) {\n      yield {\n        x: 0,\n        y,\n        z,\n      };\n    }\n  }\n}\n"],"mappings":"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"}