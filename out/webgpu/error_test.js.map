{"version":3,"file":"error_test.js","names":["Fixture","getGPU","assert","raceWithRejectOnTimeout","ErrorTest","_device","undefined","device","init","gpu","rec","adapter","requestAdapter","requestDeviceTracked","requiredLimits","maxTextureDimension2D","limits","maxTextureArrayLayers","generateError","filter","trackForCleanup","createTexture","format","usage","GPUTextureUsage","COPY_DST","size","createBuffer","queue","submit","isInstanceOfError","error","GPUOutOfMemoryError","GPUValidationError","GPUInternalError","chunkedPopManyErrorScopes","count","promises","i","push","popErrorScope","length","expect","Promise","all","every","e","expectUncapturedError","fn","immediateAsyncExpectation","TIMEOUT_IN_MS","promise","resolve","eventListener","event","debug","addEventListener","once"],"sources":["../../src/webgpu/error_test.ts"],"sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { getGPU } from '../common/util/navigator_gpu.js';\nimport { assert, raceWithRejectOnTimeout } from '../common/util/util.js';\n\n/**\n * A test class to help test error scopes and uncapturederror events.\n */\nexport class ErrorTest extends Fixture {\n  _device: GPUDevice | undefined = undefined;\n\n  get device(): GPUDevice {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  override async init(): Promise<void> {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null);\n\n    // We need to max out the adapter limits related to texture dimensions to more reliably cause an\n    // OOM error when asked for it, so set that on the device now.\n    const device = await this.requestDeviceTracked(adapter, {\n      requiredLimits: {\n        maxTextureDimension2D: adapter.limits.maxTextureDimension2D,\n        maxTextureArrayLayers: adapter.limits.maxTextureArrayLayers,\n      },\n    });\n    assert(device !== null);\n    this._device = device;\n  }\n\n  /**\n   * Generates an error of the given filter type. For now, the errors are generated by calling a\n   * known code-path to cause the error. This can be updated in the future should there be a more\n   * direct way to inject errors.\n   */\n  generateError(filter: GPUErrorFilter): void {\n    switch (filter) {\n      case 'out-of-memory':\n        this.trackForCleanup(\n          this.device.createTexture({\n            // One of the largest formats. With the base limits, the texture will be 256 GiB.\n            format: 'rgba32float',\n            usage: GPUTextureUsage.COPY_DST,\n            size: [\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureArrayLayers,\n            ],\n          })\n        );\n        break;\n      case 'validation':\n        // Generating a validation error by passing in an invalid usage when creating a buffer.\n        this.trackForCleanup(\n          this.device.createBuffer({\n            size: 1024,\n            usage: 0xffff, // Invalid GPUBufferUsage\n          })\n        );\n        break;\n    }\n    // MAINTENANCE_TODO: This is a workaround for Chromium not flushing. Remove when not needed.\n    this.device.queue.submit([]);\n  }\n\n  /**\n   * Checks whether the error is of the type expected given the filter.\n   */\n  isInstanceOfError(filter: GPUErrorFilter, error: GPUError | null): boolean {\n    switch (filter) {\n      case 'out-of-memory':\n        return error instanceof GPUOutOfMemoryError;\n      case 'validation':\n        return error instanceof GPUValidationError;\n      case 'internal':\n        return error instanceof GPUInternalError;\n    }\n  }\n\n  /**\n   * Pop `count` error scopes, and assert they all return `null`. Chunks the\n   * awaits so we only `Promise.all` 200 scopes at a time, instead of stalling\n   * on a huge `Promise.all` all at once. This helps Chromium's \"heartbeat\"\n   * mechanism know that the test is still running (and not hung).\n   */\n  async chunkedPopManyErrorScopes(count: number) {\n    const promises = [];\n    for (let i = 0; i < count; i++) {\n      promises.push(this.device.popErrorScope());\n      if (promises.length >= 200) {\n        this.expect((await Promise.all(promises)).every(e => e === null));\n        promises.length = 0;\n      }\n    }\n    this.expect((await Promise.all(promises)).every(e => e === null));\n  }\n\n  /**\n   * Expect an uncapturederror event to occur. Note: this MUST be awaited, because\n   * otherwise it could erroneously pass by capturing an error from later in the test.\n   */\n  async expectUncapturedError(fn: Function): Promise<GPUUncapturedErrorEvent> {\n    return this.immediateAsyncExpectation(() => {\n      // MAINTENANCE_TODO: Make arbitrary timeout value a test runner variable\n      const TIMEOUT_IN_MS = 1000;\n\n      const promise: Promise<GPUUncapturedErrorEvent> = new Promise(resolve => {\n        const eventListener = ((event: GPUUncapturedErrorEvent) => {\n          this.debug(`Got uncaptured error event with ${event.error}`);\n          resolve(event);\n        }) as EventListener;\n\n        this.device.addEventListener('uncapturederror', eventListener, { once: true });\n      });\n\n      fn();\n\n      return raceWithRejectOnTimeout(\n        promise,\n        TIMEOUT_IN_MS,\n        'Timeout occurred waiting for uncaptured error'\n      );\n    });\n  }\n}\n"],"mappings":";;GAAA,SAASA,OAAO,QAAQ,gCAAgC,CACxD,SAASC,MAAM,QAAQ,iCAAiC,CACxD,SAASC,MAAM,EAAEC,uBAAuB,QAAQ,wBAAwB;;AAExE;AACA;AACA;AACA,OAAO,MAAMC,SAAS,SAASJ,OAAO,CAAC;EACrCK,OAAO,GAA0BC,SAAS;;EAE1C,IAAIC,MAAMA,CAAA,EAAc;IACtBL,MAAM,CAAC,IAAI,CAACG,OAAO,KAAKC,SAAS,CAAC;IAClC,OAAO,IAAI,CAACD,OAAO;EACrB;;EAEA,MAAeG,IAAIA,CAAA,EAAkB;IACnC,MAAM,KAAK,CAACA,IAAI,CAAC,CAAC;IAClB,MAAMC,GAAG,GAAGR,MAAM,CAAC,IAAI,CAACS,GAAG,CAAC;IAC5B,MAAMC,OAAO,GAAG,MAAMF,GAAG,CAACG,cAAc,CAAC,CAAC;IAC1CV,MAAM,CAACS,OAAO,KAAK,IAAI,CAAC;;IAExB;IACA;IACA,MAAMJ,MAAM,GAAG,MAAM,IAAI,CAACM,oBAAoB,CAACF,OAAO,EAAE;MACtDG,cAAc,EAAE;QACdC,qBAAqB,EAAEJ,OAAO,CAACK,MAAM,CAACD,qBAAqB;QAC3DE,qBAAqB,EAAEN,OAAO,CAACK,MAAM,CAACC;MACxC;IACF,CAAC,CAAC;IACFf,MAAM,CAACK,MAAM,KAAK,IAAI,CAAC;IACvB,IAAI,CAACF,OAAO,GAAGE,MAAM;EACvB;;EAEA;AACF;AACA;AACA;AACA;EACEW,aAAaA,CAACC,MAAsB,EAAQ;IAC1C,QAAQA,MAAM;MACZ,KAAK,eAAe;QAClB,IAAI,CAACC,eAAe;UAClB,IAAI,CAACb,MAAM,CAACc,aAAa,CAAC;YACxB;YACAC,MAAM,EAAE,aAAa;YACrBC,KAAK,EAAEC,eAAe,CAACC,QAAQ;YAC/BC,IAAI,EAAE;YACJ,IAAI,CAACnB,MAAM,CAACS,MAAM,CAACD,qBAAqB;YACxC,IAAI,CAACR,MAAM,CAACS,MAAM,CAACD,qBAAqB;YACxC,IAAI,CAACR,MAAM,CAACS,MAAM,CAACC,qBAAqB;;UAE5C,CAAC;QACH,CAAC;QACD;MACF,KAAK,YAAY;QACf;QACA,IAAI,CAACG,eAAe;UAClB,IAAI,CAACb,MAAM,CAACoB,YAAY,CAAC;YACvBD,IAAI,EAAE,IAAI;YACVH,KAAK,EAAE,MAAM,CAAE;UACjB,CAAC;QACH,CAAC;QACD;IACJ;IACA;IACA,IAAI,CAAChB,MAAM,CAACqB,KAAK,CAACC,MAAM,CAAC,EAAE,CAAC;EAC9B;;EAEA;AACF;AACA;EACEC,iBAAiBA,CAACX,MAAsB,EAAEY,KAAsB,EAAW;IACzE,QAAQZ,MAAM;MACZ,KAAK,eAAe;QAClB,OAAOY,KAAK,YAAYC,mBAAmB;MAC7C,KAAK,YAAY;QACf,OAAOD,KAAK,YAAYE,kBAAkB;MAC5C,KAAK,UAAU;QACb,OAAOF,KAAK,YAAYG,gBAAgB;IAC5C;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMC,yBAAyBA,CAACC,KAAa,EAAE;IAC7C,MAAMC,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;MAC9BD,QAAQ,CAACE,IAAI,CAAC,IAAI,CAAChC,MAAM,CAACiC,aAAa,CAAC,CAAC,CAAC;MAC1C,IAAIH,QAAQ,CAACI,MAAM,IAAI,GAAG,EAAE;QAC1B,IAAI,CAACC,MAAM,CAAC,CAAC,MAAMC,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC,EAAEQ,KAAK,CAAC,CAAAC,CAAC,KAAIA,CAAC,KAAK,IAAI,CAAC,CAAC;QACjET,QAAQ,CAACI,MAAM,GAAG,CAAC;MACrB;IACF;IACA,IAAI,CAACC,MAAM,CAAC,CAAC,MAAMC,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC,EAAEQ,KAAK,CAAC,CAAAC,CAAC,KAAIA,CAAC,KAAK,IAAI,CAAC,CAAC;EACnE;;EAEA;AACF;AACA;AACA;EACE,MAAMC,qBAAqBA,CAACC,EAAY,EAAoC;IAC1E,OAAO,IAAI,CAACC,yBAAyB,CAAC,MAAM;MAC1C;MACA,MAAMC,aAAa,GAAG,IAAI;;MAE1B,MAAMC,OAAyC,GAAG,IAAIR,OAAO,CAAC,CAAAS,OAAO,KAAI;QACvE,MAAMC,aAAa,GAAIA,CAACC,KAA8B,KAAK;UACzD,IAAI,CAACC,KAAK,CAAE,mCAAkCD,KAAK,CAACvB,KAAM,EAAC,CAAC;UAC5DqB,OAAO,CAACE,KAAK,CAAC;QAChB,CAAmB;;QAEnB,IAAI,CAAC/C,MAAM,CAACiD,gBAAgB,CAAC,iBAAiB,EAAEH,aAAa,EAAE,EAAEI,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;MAChF,CAAC,CAAC;;MAEFT,EAAE,CAAC,CAAC;;MAEJ,OAAO7C,uBAAuB;QAC5BgD,OAAO;QACPD,aAAa;QACb;MACF,CAAC;IACH,CAAC,CAAC;EACJ;AACF"}