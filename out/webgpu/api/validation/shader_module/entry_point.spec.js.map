{"version":3,"file":"entry_point.spec.js","names":["description","makeTestGroup","kDefaultVertexShaderCode","getShaderWithEntryPoint","ValidationTest","g","kEntryPointTestCases","shaderModuleEntryPoint","stageEntryPoint","test","desc","params","u","combine","beginSubcases","combineWithParams","fn","t","isAsync","provideEntryPoint","extraEntryPoint","shaderModuleStage","entryPoint","undefined","code","descriptor","layout","compute","module","device","createShaderModule","_success","doCreateComputePipelineTest","vertex","doCreateRenderPipelineTest","fragment","targets","format","extraShaderModuleStage","success"],"sources":["../../../../../src/webgpu/api/validation/shader_module/entry_point.spec.ts"],"sourcesContent":["export const description = `\nThis tests entry point validation of compute/render pipelines and their shader modules.\n\nThe entryPoint in shader module include standard \"main\" and others.\nThe entryPoint assigned in descriptor include:\n- Undefined with matching entry point for stage\n- Matching case (control case)\n- Empty string\n- Mistyping\n- Containing invalid char, including space and control codes (Null character)\n- Unicode entrypoints and their ASCIIfied version\n\nTODO:\n- Fine-tune test cases to reduce number by removing trivially similar cases\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kDefaultVertexShaderCode, getShaderWithEntryPoint } from '../../../util/shader.js';\nimport { ValidationTest } from '../validation_test.js';\n\nexport const g = makeTestGroup(ValidationTest);\n\nconst kEntryPointTestCases = [\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: '' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\0' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\0a' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'mian' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main ' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'ma in' },\n  { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\n' },\n  { shaderModuleEntryPoint: 'mian', stageEntryPoint: 'mian' },\n  { shaderModuleEntryPoint: 'mian', stageEntryPoint: 'main' },\n  { shaderModuleEntryPoint: 'mainmain', stageEntryPoint: 'mainmain' },\n  { shaderModuleEntryPoint: 'mainmain', stageEntryPoint: 'foo' },\n  { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: 'main_t12V3' },\n  { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: 'main_t12V5' },\n  { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: '_main_t12V3' },\n  { shaderModuleEntryPoint: 'séquençage', stageEntryPoint: 'séquençage' },\n  { shaderModuleEntryPoint: 'séquençage', stageEntryPoint: 'séquençage' },\n];\n\ng.test('compute')\n  .desc(\n    `\nTests calling createComputePipeline(Async) with valid compute stage shader and different entryPoints,\nand check that the APIs only accept matching entryPoint.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('shaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n      .beginSubcases()\n      .combine('provideEntryPoint', [true, false])\n      .combine('extraEntryPoint', [true, false])\n      .combineWithParams(kEntryPointTestCases)\n  )\n  .fn(t => {\n    const {\n      isAsync,\n      provideEntryPoint,\n      extraEntryPoint,\n      shaderModuleStage,\n      shaderModuleEntryPoint,\n      stageEntryPoint,\n    } = t.params;\n    const entryPoint = provideEntryPoint ? stageEntryPoint : undefined;\n    let code = getShaderWithEntryPoint(shaderModuleStage, shaderModuleEntryPoint);\n    if (extraEntryPoint) {\n      code += ` ${getShaderWithEntryPoint(shaderModuleStage, 'extra')}`;\n    }\n    const descriptor: GPUComputePipelineDescriptor = {\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code,\n        }),\n        entryPoint,\n      },\n    };\n    let _success = true;\n    if (shaderModuleStage !== 'compute') {\n      _success = false;\n    }\n    if (!provideEntryPoint && extraEntryPoint) {\n      _success = false;\n    }\n    if (shaderModuleEntryPoint !== stageEntryPoint && provideEntryPoint) {\n      _success = false;\n    }\n    t.doCreateComputePipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('vertex')\n  .desc(\n    `\nTests calling createRenderPipeline(Async) with valid vertex stage shader and different entryPoints,\nand check that the APIs only accept matching entryPoint.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('shaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n      .beginSubcases()\n      .combine('provideEntryPoint', [true, false])\n      .combine('extraEntryPoint', [true, false])\n      .combineWithParams(kEntryPointTestCases)\n  )\n  .fn(t => {\n    const {\n      isAsync,\n      provideEntryPoint,\n      extraEntryPoint,\n      shaderModuleStage,\n      shaderModuleEntryPoint,\n      stageEntryPoint,\n    } = t.params;\n    const entryPoint = provideEntryPoint ? stageEntryPoint : undefined;\n    let code = getShaderWithEntryPoint(shaderModuleStage, shaderModuleEntryPoint);\n    if (extraEntryPoint) {\n      code += ` ${getShaderWithEntryPoint(shaderModuleStage, 'extra')}`;\n    }\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({ code }),\n        entryPoint,\n      },\n    };\n    let _success = true;\n    if (shaderModuleStage !== 'vertex') {\n      _success = false;\n    }\n    if (!provideEntryPoint && extraEntryPoint) {\n      _success = false;\n    }\n    if (shaderModuleEntryPoint !== stageEntryPoint && provideEntryPoint) {\n      _success = false;\n    }\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('fragment')\n  .desc(\n    `\nTests calling createRenderPipeline(Async) with valid fragment stage shader and different entryPoints,\nand check that the APIs only accept matching entryPoint.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('shaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n      .beginSubcases()\n      .combine('provideEntryPoint', [true, false])\n      .combine('extraEntryPoint', [true, false])\n      .combineWithParams(kEntryPointTestCases)\n  )\n  .fn(t => {\n    const {\n      isAsync,\n      provideEntryPoint,\n      extraEntryPoint,\n      shaderModuleStage,\n      shaderModuleEntryPoint,\n      stageEntryPoint,\n    } = t.params;\n    const entryPoint = provideEntryPoint ? stageEntryPoint : undefined;\n    let code = getShaderWithEntryPoint(shaderModuleStage, shaderModuleEntryPoint);\n    if (extraEntryPoint) {\n      code += ` ${getShaderWithEntryPoint(shaderModuleStage, 'extra')}`;\n    }\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: kDefaultVertexShaderCode,\n        }),\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code,\n        }),\n        entryPoint,\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    };\n    let _success = true;\n    if (shaderModuleStage !== 'fragment') {\n      _success = false;\n    }\n    if (!provideEntryPoint && extraEntryPoint) {\n      _success = false;\n    }\n    if (shaderModuleEntryPoint !== stageEntryPoint && provideEntryPoint) {\n      _success = false;\n    }\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('compute_undefined_entry_point_and_extra_stage')\n  .desc(\n    `\nTests calling createComputePipeline(Async) with compute stage shader and\nan undefined entryPoint is valid if there's an extra shader stage.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('extraShaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n  )\n  .fn(t => {\n    const { isAsync, extraShaderModuleStage } = t.params;\n    const code = `\n        ${getShaderWithEntryPoint('compute', 'main')}\n        ${getShaderWithEntryPoint(extraShaderModuleStage, 'extra')}\n    `;\n    const descriptor: GPUComputePipelineDescriptor = {\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code,\n        }),\n        entryPoint: undefined,\n      },\n    };\n\n    const success = extraShaderModuleStage !== 'compute';\n    t.doCreateComputePipelineTest(isAsync, success, descriptor);\n  });\n\ng.test('vertex_undefined_entry_point_and_extra_stage')\n  .desc(\n    `\nTests calling createRenderPipeline(Async) with vertex stage shader and\nan undefined entryPoint is valid if there's an extra shader stage.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('extraShaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n  )\n  .fn(t => {\n    const { isAsync, extraShaderModuleStage } = t.params;\n    const code = `\n        ${getShaderWithEntryPoint('vertex', 'main')}\n        ${getShaderWithEntryPoint(extraShaderModuleStage, 'extra')}\n    `;\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code,\n        }),\n        entryPoint: undefined,\n      },\n    };\n\n    const success = extraShaderModuleStage !== 'vertex';\n    t.doCreateRenderPipelineTest(isAsync, success, descriptor);\n  });\n\ng.test('fragment_undefined_entry_point_and_extra_stage')\n  .desc(\n    `\nTests calling createRenderPipeline(Async) with fragment stage shader and\nan undefined entryPoint is valid if there's an extra shader stage.\n`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [true, false])\n      .combine('extraShaderModuleStage', ['compute', 'vertex', 'fragment'] as const)\n  )\n  .fn(t => {\n    const { isAsync, extraShaderModuleStage } = t.params;\n    const code = `\n        ${getShaderWithEntryPoint('fragment', 'main')}\n        ${getShaderWithEntryPoint(extraShaderModuleStage, 'extra')}\n    `;\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: kDefaultVertexShaderCode,\n        }),\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code,\n        }),\n        entryPoint: undefined,\n        targets: [{ format: 'rgba8unorm' }],\n      },\n    };\n\n    const success = extraShaderModuleStage !== 'fragment';\n    t.doCreateRenderPipelineTest(isAsync, success, descriptor);\n  });\n"],"mappings":"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"}