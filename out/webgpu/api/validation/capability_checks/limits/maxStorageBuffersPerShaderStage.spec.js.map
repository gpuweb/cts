{"version":3,"file":"maxStorageBuffersPerShaderStage.spec.js","names":["range","reorder","kReorderOrderKeys","assert","kShaderStageCombinationsWithStage","GPUConst","kMaximumLimitBaseParams","makeLimitTestGroup","kBindGroupTests","kBindingCombinations","getPipelineTypeForBindingCombination","getPerStageWGSLForBindingCombination","getStageVisibilityForBinidngCombination","addMaximumLimitUpToDependentLimit","kExtraLimits","maxBindingsPerBindGroup","maxBindGroups","limit","g","description","createBindGroupLayout","device","visibility","type","order","numBindings","bindGroupLayoutDescription","entries","i","binding","buffer","addExtraRequiredLimits","adapter","limits","limitTest","newLimits","test","desc","params","combine","filter","ShaderStage","VERTEX","fn","t","testValueName","testDeviceWithRequestedMaximumLimits","testValue","shouldError","skipIf","skipIfNotEnoughStorageBuffersInStage","expectValidationError","actualLimit","Math","min","kNumGroups","ceil","bindGroupLayouts","numInGroup","createPipelineLayout","beginSubcases","async","bindingCombination","bindGroupTest","pipelineType","code","j","module","createShaderModule","testCreatePipeline"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxStorageBuffersPerShaderStage.spec.ts"],"sourcesContent":["import {\n  range,\n  reorder,\n  kReorderOrderKeys,\n  ReorderOrder,\n  assert,\n} from '../../../../../common/util/util.js';\nimport { kShaderStageCombinationsWithStage } from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  kBindGroupTests,\n  kBindingCombinations,\n  getPipelineTypeForBindingCombination,\n  getPerStageWGSLForBindingCombination,\n  LimitsRequest,\n  getStageVisibilityForBinidngCombination,\n  addMaximumLimitUpToDependentLimit,\n  MaximumLimitValueTest,\n} from './limit_utils.js';\n\nconst kExtraLimits: LimitsRequest = {\n  maxBindingsPerBindGroup: 'adapterLimit',\n  maxBindGroups: 'adapterLimit',\n};\n\nconst limit = 'maxStorageBuffersPerShaderStage';\nexport const { g, description } = makeLimitTestGroup(limit);\n\nfunction createBindGroupLayout(\n  device: GPUDevice,\n  visibility: number,\n  type: GPUBufferBindingType,\n  order: ReorderOrder,\n  numBindings: number\n) {\n  const bindGroupLayoutDescription = {\n    entries: reorder(\n      order,\n      range(numBindings, i => ({\n        binding: i,\n        visibility,\n        buffer: { type },\n      }))\n    ),\n  };\n  return device.createBindGroupLayout(bindGroupLayoutDescription);\n}\n\nfunction addExtraRequiredLimits(\n  adapter: GPUAdapter,\n  limits: LimitsRequest,\n  limitTest: MaximumLimitValueTest\n) {\n  const newLimits: LimitsRequest = { ...limits };\n\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageBuffersInFragmentStage',\n    limit,\n    limitTest\n  );\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageBuffersInVertexStage',\n    limit,\n    limitTest\n  );\n\n  return newLimits;\n}\n\ng.test('createBindGroupLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createBindGroupLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('type', ['storage', 'read-only-storage'] as GPUBufferBindingType[])\n      .combine('order', kReorderOrderKeys)\n      .filter(\n        ({ visibility, type }) =>\n          (visibility & GPUConst.ShaderStage.VERTEX) === 0 || type !== 'storage'\n      )\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, order, type } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        t.skipIf(\n          t.adapter.limits.maxBindingsPerBindGroup < testValue,\n          `maxBindingsPerBindGroup = ${t.adapter.limits.maxBindingsPerBindGroup} which is less than ${testValue}`\n        );\n\n        t.skipIfNotEnoughStorageBuffersInStage(visibility, testValue);\n\n        await t.expectValidationError(() => {\n          createBindGroupLayout(device, visibility, type, order, testValue);\n        }, shouldError);\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipelineLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createPipelineLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('type', ['storage', 'read-only-storage'] as GPUBufferBindingType[])\n      .combine('order', kReorderOrderKeys)\n      .filter(\n        ({ visibility, type }) =>\n          (visibility & GPUConst.ShaderStage.VERTEX) === 0 || type !== 'storage'\n      )\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, order, type } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        t.skipIfNotEnoughStorageBuffersInStage(visibility, testValue);\n\n        const maxBindingsPerBindGroup = Math.min(\n          t.device.limits.maxBindingsPerBindGroup,\n          actualLimit\n        );\n\n        const kNumGroups = Math.ceil(testValue / maxBindingsPerBindGroup);\n\n        // Not sure what to do in this case but best we get notified if it happens.\n        assert(kNumGroups <= t.device.limits.maxBindGroups);\n\n        const bindGroupLayouts = range(kNumGroups, i => {\n          const numInGroup = Math.min(\n            testValue - i * maxBindingsPerBindGroup,\n            maxBindingsPerBindGroup\n          );\n          return createBindGroupLayout(device, visibility, type, order, numInGroup);\n        });\n\n        await t.expectValidationError(\n          () => device.createPipelineLayout({ bindGroupLayouts }),\n          shouldError\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(\n    `\n  Test using createRenderPipeline(Async) and createComputePipeline(Async) at and over ${limit} limit\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('bindingCombination', kBindingCombinations)\n      .beginSubcases()\n      .combine('order', kReorderOrderKeys)\n      .combine('bindGroupTest', kBindGroupTests)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, bindingCombination, order, bindGroupTest } = t.params;\n    const pipelineType = getPipelineTypeForBindingCombination(bindingCombination);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        t.skipIf(\n          bindGroupTest === 'sameGroup' && testValue > device.limits.maxBindingsPerBindGroup,\n          `can not test ${testValue} bindings in same group because maxBindingsPerBindGroup = ${device.limits.maxBindingsPerBindGroup}`\n        );\n\n        const visibility = getStageVisibilityForBinidngCombination(bindingCombination);\n        t.skipIfNotEnoughStorageBuffersInStage(visibility, testValue);\n\n        const code = getPerStageWGSLForBindingCombination(\n          bindingCombination,\n          order,\n          bindGroupTest,\n          (i, j) => `var<storage> u${j}_${i}: f32`,\n          (i, j) => `_ = u${j}_${i};`,\n          device.limits.maxBindGroups,\n          testValue\n        );\n        const module = device.createShaderModule({ code });\n\n        await t.testCreatePipeline(\n          pipelineType,\n          async,\n          module,\n          shouldError,\n          `actualLimit: ${actualLimit}, testValue: ${testValue}\\n:${code}`\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n"],"mappings":"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"}