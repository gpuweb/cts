{"version":3,"file":"maxStorageTexturesPerShaderStage.spec.js","names":["getGPU","range","reorder","kReorderOrderKeys","assert","kShaderStageCombinationsWithStage","kStorageTextureAccessValues","storageTextureBindingTypeInfo","GPUConst","kMaximumLimitBaseParams","makeLimitTestGroup","kBindGroupTests","getPerStageWGSLForBindingCombinationStorageTextures","getPipelineTypeForBindingCombination","kBindingCombinations","getStageVisibilityForBindingCombination","addMaximumLimitUpToDependentLimit","kExtraLimits","maxBindingsPerBindGroup","maxBindGroups","limit","g","description","createBindGroupLayout","device","visibility","access","order","numBindings","entries","i","binding","storageTexture","format","skipIfNotEnoughStorageTexturesInStage","t","testValue","skipIf","isCompatibility","ShaderStage","FRAGMENT","limits","maxStorageTexturesPerShaderStage","maxStorageTexturesInFragmentStage","VERTEX","maxStorageTexturesInVertexStage","skipIfAccessNotSupported","rec","wgslLanguageFeatures","has","filterWriteAccessInVertexStage","addExtraRequiredLimits","adapter","limitTest","newLimits","test","desc","params","combine","filter","fn","testValueName","testDeviceWithRequestedMaximumLimits","shouldError","expectValidationError","actualLimit","Math","min","kNumGroups","ceil","bindGroupLayouts","numInGroup","createPipelineLayout","bindingCombination","beginSubcases","async","bindGroupTest","pipelineType","wgslAccess","code","j","module","createShaderModule","testCreatePipeline"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxStorageTexturesPerShaderStage.spec.ts"],"sourcesContent":["import { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport {\n  range,\n  reorder,\n  ReorderOrder,\n  kReorderOrderKeys,\n  assert,\n} from '../../../../../common/util/util.js';\nimport {\n  kShaderStageCombinationsWithStage,\n  kStorageTextureAccessValues,\n  storageTextureBindingTypeInfo,\n} from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  kBindGroupTests,\n  getPerStageWGSLForBindingCombinationStorageTextures,\n  getPipelineTypeForBindingCombination,\n  LimitsRequest,\n  LimitTestsImpl,\n  kBindingCombinations,\n  getStageVisibilityForBindingCombination,\n  MaximumLimitValueTest,\n  addMaximumLimitUpToDependentLimit,\n} from './limit_utils.js';\n\nconst kExtraLimits: LimitsRequest = {\n  maxBindingsPerBindGroup: 'adapterLimit',\n  maxBindGroups: 'adapterLimit',\n};\n\nconst limit = 'maxStorageTexturesPerShaderStage';\nexport const { g, description } = makeLimitTestGroup(limit);\n\nfunction createBindGroupLayout(\n  device: GPUDevice,\n  visibility: number,\n  access: GPUStorageTextureAccess,\n  order: ReorderOrder,\n  numBindings: number\n) {\n  return device.createBindGroupLayout({\n    entries: reorder(\n      order,\n      range(numBindings, i => ({\n        binding: i,\n        visibility,\n        storageTexture: { format: 'r32float', access },\n      }))\n    ),\n  });\n}\n\nfunction skipIfNotEnoughStorageTexturesInStage(\n  t: LimitTestsImpl,\n  visibility: GPUShaderStageFlags,\n  testValue: number\n) {\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the fragment stage\n      (visibility & GPUConst.ShaderStage.FRAGMENT) !== 0 &&\n      // If perShaderStage and inFragment stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInFragmentStage! &&\n      // They aren't equal so if there aren't enough supported in the fragment then skip\n      !(t.device.limits.maxStorageTexturesInFragmentStage! >= testValue),\n    `maxStorageTexturesInFragmentShader = ${t.device.limits.maxStorageTexturesInFragmentStage} which is less than ${testValue}`\n  );\n\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the vertex stage\n      (visibility & GPUConst.ShaderStage.VERTEX) !== 0 &&\n      // If perShaderStage and inVertex stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInVertexStage! &&\n      // They aren't equal so if there aren't enough supported in the vertex then skip\n      !(t.device.limits.maxStorageTexturesInVertexStage! >= testValue),\n    `maxStorageTexturesInVertexShader = ${t.device.limits.maxStorageTexturesInVertexStage} which is less than ${testValue}`\n  );\n}\n\nfunction skipIfAccessNotSupported(t: LimitTestsImpl, access: GPUStorageTextureAccess) {\n  t.skipIf(\n    (access === 'read-only' || access === 'read-write') &&\n      !getGPU(t.rec).wgslLanguageFeatures.has('readonly_and_readwrite_storage_textures'),\n    `access = ${access} but navigator.gpu.wsglLanguageFeatures does not contain 'readonly_and_readwrite_storage_textures'`\n  );\n}\n\nfunction filterWriteAccessInVertexStage(\n  visibility: GPUShaderStageFlags,\n  access: GPUStorageTextureAccess\n) {\n  return access === 'read-only' || (visibility & GPUConst.ShaderStage.VERTEX) === 0;\n}\n\nfunction addExtraRequiredLimits(\n  adapter: GPUAdapter,\n  limits: LimitsRequest,\n  limitTest: MaximumLimitValueTest\n) {\n  const newLimits: LimitsRequest = { ...limits };\n\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageTexturesInFragmentStage',\n    limit,\n    limitTest\n  );\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageTexturesInVertexStage',\n    limit,\n    limitTest\n  );\n\n  return newLimits;\n}\ng.test('createBindGroupLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createBindGroupLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t => filterWriteAccessInVertexStage(t.visibility, t.access))\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        t.skipIf(\n          t.adapter.limits.maxBindingsPerBindGroup < testValue,\n          `maxBindingsPerBindGroup = ${t.adapter.limits.maxBindingsPerBindGroup} which is less than ${testValue}`\n        );\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n        await t.expectValidationError(\n          () => createBindGroupLayout(device, visibility, access, order, testValue),\n          shouldError\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipelineLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createPipelineLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t => filterWriteAccessInVertexStage(t.visibility, t.access))\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const maxBindingsPerBindGroup = Math.min(\n          t.device.limits.maxBindingsPerBindGroup,\n          actualLimit\n        );\n        const kNumGroups = Math.ceil(testValue / maxBindingsPerBindGroup);\n\n        // Not sure what to do in this case but best we get notified if it happens.\n        assert(kNumGroups <= t.device.limits.maxBindGroups);\n\n        const bindGroupLayouts = range(kNumGroups, i => {\n          const numInGroup = Math.min(\n            testValue - i * maxBindingsPerBindGroup,\n            maxBindingsPerBindGroup\n          );\n          return createBindGroupLayout(device, visibility, access, order, numInGroup);\n        });\n\n        await t.expectValidationError(\n          () => device.createPipelineLayout({ bindGroupLayouts }),\n          shouldError\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(\n    `\n  Test using createRenderPipeline(Async) and createComputePipeline(Async) at and over ${limit} limit\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('bindingCombination', kBindingCombinations)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t =>\n        filterWriteAccessInVertexStage(\n          getStageVisibilityForBindingCombination(t.bindingCombination),\n          t.access\n        )\n      )\n      .beginSubcases()\n      .combine('order', kReorderOrderKeys)\n      .combine('bindGroupTest', kBindGroupTests)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, bindingCombination, access, order, bindGroupTest } =\n      t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    const pipelineType = getPipelineTypeForBindingCombination(bindingCombination);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        t.skipIf(\n          bindGroupTest === 'sameGroup' && testValue > device.limits.maxBindingsPerBindGroup,\n          `can not test ${testValue} bindings in same group because maxBindingsPerBindGroup = ${device.limits.maxBindingsPerBindGroup}`\n        );\n\n        const visibility = getStageVisibilityForBindingCombination(bindingCombination);\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const { wgslAccess } = storageTextureBindingTypeInfo({ access });\n\n        const code = getPerStageWGSLForBindingCombinationStorageTextures(\n          bindingCombination,\n          order,\n          bindGroupTest,\n          (i, j) => `var u${j}_${i}: texture_storage_2d<r32float, ${wgslAccess}>`,\n          (i, j) =>\n            access === 'write-only'\n              ? `textureStore(u${j}_${i}, vec2u(0), vec4f(0));`\n              : `_ = textureLoad(u${j}_${i}, vec2u(0));`,\n          device.limits.maxBindGroups,\n          testValue\n        );\n        const module = device.createShaderModule({ code });\n\n        await t.testCreatePipeline(\n          pipelineType,\n          async,\n          module,\n          shouldError,\n          `actualLimit: ${actualLimit}, testValue: ${testValue}\\n:${code}`\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n"],"mappings":"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"}