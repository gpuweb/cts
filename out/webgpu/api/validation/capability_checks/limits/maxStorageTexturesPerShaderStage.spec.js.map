{"version":3,"file":"maxStorageTexturesPerShaderStage.spec.js","names":["range","reorder","kReorderOrderKeys","assert","kShaderStageCombinationsWithStage","kStorageTextureAccessValues","storageTextureBindingTypeInfo","GPUConst","kMaximumLimitBaseParams","makeLimitTestGroup","kBindGroupTests","getPerStageWGSLForBindingCombinationStorageTextures","getPipelineTypeForBindingCombination","kBindingCombinations","getStageVisibilityForBinidngCombination","kExtraLimits","maxBindingsPerBindGroup","maxBindGroups","maxStorageTexturesInFragmentStage","limit","g","description","createBindGroupLayout","device","visibility","access","order","numBindings","entries","i","binding","storageTexture","format","skipIfNotEnoughStorageTexturesInStage","t","testValue","skipIf","isCompatibility","ShaderStage","FRAGMENT","limits","maxStorageTexturesPerShaderStage","VERTEX","maxStorageTexturesInVertexStage","skipIfAccessNotSupported","navigator","gpu","wgslLanguageFeatures","has","test","desc","params","combine","fn","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","shouldError","adapter","expectValidationError","actualLimit","Math","min","kNumGroups","ceil","bindGroupLayouts","numInGroup","createPipelineLayout","beginSubcases","async","bindingCombination","bindGroupTest","pipelineType","wgslAccess","code","j","module","createShaderModule","testCreatePipeline"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxStorageTexturesPerShaderStage.spec.ts"],"sourcesContent":["import {\n  range,\n  reorder,\n  ReorderOrder,\n  kReorderOrderKeys,\n  assert,\n} from '../../../../../common/util/util.js';\nimport {\n  kShaderStageCombinationsWithStage,\n  kStorageTextureAccessValues,\n  storageTextureBindingTypeInfo,\n} from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  kBindGroupTests,\n  getPerStageWGSLForBindingCombinationStorageTextures,\n  getPipelineTypeForBindingCombination,\n  LimitsRequest,\n  LimitTestsImpl,\n  kBindingCombinations,\n  getStageVisibilityForBinidngCombination,\n} from './limit_utils.js';\n\nconst kExtraLimits: LimitsRequest = {\n  maxBindingsPerBindGroup: 'adapterLimit',\n  maxBindGroups: 'adapterLimit',\n  maxStorageTexturesInFragmentStage: 'adapterLimit',\n};\n\nconst limit = 'maxStorageTexturesPerShaderStage';\nexport const { g, description } = makeLimitTestGroup(limit);\n\nfunction createBindGroupLayout(\n  device: GPUDevice,\n  visibility: number,\n  access: GPUStorageTextureAccess,\n  order: ReorderOrder,\n  numBindings: number\n) {\n  return device.createBindGroupLayout({\n    entries: reorder(\n      order,\n      range(numBindings, i => ({\n        binding: i,\n        visibility,\n        storageTexture: { format: 'r32float', access },\n      }))\n    ),\n  });\n}\n\nfunction skipIfNotEnoughStorageTexturesInStage(\n  t: LimitTestsImpl,\n  visibility: GPUShaderStageFlags,\n  testValue: number\n) {\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the fragment stage\n      (visibility & GPUConst.ShaderStage.FRAGMENT) !== 0 &&\n      // If perShaderStage and inFragment stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInFragmentStage! &&\n      // They aren't equal so if there aren't enough supported in the fragment then skip\n      !(t.device.limits.maxStorageTexturesInFragmentStage! >= testValue),\n    `maxStorageTexturesInFragmentShader = ${t.device.limits.maxStorageTexturesInFragmentStage} which is less than ${testValue}`\n  );\n\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the vertex stage\n      (visibility & GPUConst.ShaderStage.VERTEX) !== 0 &&\n      // If perShaderStage and inVertex stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInVertexStage! &&\n      // They aren't equal so if there aren't enough supported in the vertex then skip\n      !(t.device.limits.maxStorageTexturesInVertexStage! >= testValue),\n    `maxStorageTexturesInVertexShader = ${t.device.limits.maxStorageTexturesInVertexStage} which is less than ${testValue}`\n  );\n}\n\nfunction skipIfAccessNotSupported(t: LimitTestsImpl, access: GPUStorageTextureAccess) {\n  t.skipIf(\n    (access === 'read-only' || access === 'read-write') &&\n      !navigator.gpu.wgslLanguageFeatures.has('readonly_and_readwrite_storage_textures'),\n    `access = ${access} but navigator.gpu.wsglLanguageFeatures does not contain 'readonly_and_readwrite_storage_textures'`\n  );\n}\n\ng.test('createBindGroupLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createBindGroupLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        t.skipIf(\n          t.adapter.limits.maxBindingsPerBindGroup < testValue,\n          `maxBindingsPerBindGroup = ${t.adapter.limits.maxBindingsPerBindGroup} which is less than ${testValue}`\n        );\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n        await t.expectValidationError(\n          () => createBindGroupLayout(device, visibility, access, order, testValue),\n          shouldError\n        );\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('createPipelineLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createPipelineLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const maxBindingsPerBindGroup = Math.min(\n          t.device.limits.maxBindingsPerBindGroup,\n          actualLimit\n        );\n        const kNumGroups = Math.ceil(testValue / maxBindingsPerBindGroup);\n\n        // Not sure what to do in this case but best we get notified if it happens.\n        assert(kNumGroups <= t.device.limits.maxBindGroups);\n\n        const bindGroupLayouts = range(kNumGroups, i => {\n          const numInGroup = Math.min(\n            testValue - i * maxBindingsPerBindGroup,\n            maxBindingsPerBindGroup\n          );\n          return createBindGroupLayout(device, visibility, access, order, numInGroup);\n        });\n\n        await t.expectValidationError(\n          () => device.createPipelineLayout({ bindGroupLayouts }),\n          shouldError\n        );\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(\n    `\n  Test using createRenderPipeline(Async) and createComputePipeline(Async) at and over ${limit} limit\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('bindingCombination', kBindingCombinations)\n      .combine('access', kStorageTextureAccessValues)\n      .beginSubcases()\n      .combine('order', kReorderOrderKeys)\n      .combine('bindGroupTest', kBindGroupTests)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, bindingCombination, access, order, bindGroupTest } =\n      t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    const pipelineType = getPipelineTypeForBindingCombination(bindingCombination);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        t.skipIf(\n          bindGroupTest === 'sameGroup' && testValue > device.limits.maxBindingsPerBindGroup,\n          `can not test ${testValue} bindings in same group because maxBindingsPerBindGroup = ${device.limits.maxBindingsPerBindGroup}`\n        );\n\n        const visibility = getStageVisibilityForBinidngCombination(bindingCombination);\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const { wgslAccess } = storageTextureBindingTypeInfo({ access });\n\n        const code = getPerStageWGSLForBindingCombinationStorageTextures(\n          bindingCombination,\n          order,\n          bindGroupTest,\n          (i, j) => `var u${j}_${i}: texture_storage_2d<r32float, ${wgslAccess}>`,\n          (i, j) =>\n            access === 'write-only'\n              ? `textureStore(u${j}_${i}, vec2u(0), vec4f(0));`\n              : `_ = textureLoad(u${j}_${i}, vec2u(0));`,\n          device.limits.maxBindGroups,\n          testValue\n        );\n        const module = device.createShaderModule({ code });\n\n        await t.testCreatePipeline(\n          pipelineType,\n          async,\n          module,\n          shouldError,\n          `actualLimit: ${actualLimit}, testValue: ${testValue}\\n:${code}`\n        );\n      },\n      kExtraLimits\n    );\n  });\n"],"mappings":"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"}