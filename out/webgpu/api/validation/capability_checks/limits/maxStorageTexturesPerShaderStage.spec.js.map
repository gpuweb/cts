{"version":3,"file":"maxStorageTexturesPerShaderStage.spec.js","names":["range","reorder","kReorderOrderKeys","assert","kShaderStageCombinationsWithStage","kStorageTextureAccessValues","storageTextureBindingTypeInfo","GPUConst","kMaximumLimitBaseParams","makeLimitTestGroup","kBindGroupTests","getPerStageWGSLForBindingCombinationStorageTextures","getPipelineTypeForBindingCombination","kBindingCombinations","getStageVisibilityForBinidngCombination","addMaximumLimitUpToDependentLimit","kExtraLimits","maxBindingsPerBindGroup","maxBindGroups","limit","g","description","createBindGroupLayout","device","visibility","access","order","numBindings","entries","i","binding","storageTexture","format","skipIfNotEnoughStorageTexturesInStage","t","testValue","skipIf","isCompatibility","ShaderStage","FRAGMENT","limits","maxStorageTexturesPerShaderStage","maxStorageTexturesInFragmentStage","VERTEX","maxStorageTexturesInVertexStage","skipIfAccessNotSupported","navigator","gpu","wgslLanguageFeatures","has","filterWriteAccessInVertexStage","addExtraRequiredLimits","adapter","limitTest","newLimits","test","desc","params","combine","filter","fn","testValueName","testDeviceWithRequestedMaximumLimits","shouldError","expectValidationError","actualLimit","Math","min","kNumGroups","ceil","bindGroupLayouts","numInGroup","createPipelineLayout","bindingCombination","beginSubcases","async","bindGroupTest","pipelineType","wgslAccess","code","j","module","createShaderModule","testCreatePipeline"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxStorageTexturesPerShaderStage.spec.ts"],"sourcesContent":["import {\n  range,\n  reorder,\n  ReorderOrder,\n  kReorderOrderKeys,\n  assert,\n} from '../../../../../common/util/util.js';\nimport {\n  kShaderStageCombinationsWithStage,\n  kStorageTextureAccessValues,\n  storageTextureBindingTypeInfo,\n} from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  makeLimitTestGroup,\n  kBindGroupTests,\n  getPerStageWGSLForBindingCombinationStorageTextures,\n  getPipelineTypeForBindingCombination,\n  LimitsRequest,\n  LimitTestsImpl,\n  kBindingCombinations,\n  getStageVisibilityForBinidngCombination,\n  MaximumLimitValueTest,\n  addMaximumLimitUpToDependentLimit,\n} from './limit_utils.js';\n\nconst kExtraLimits: LimitsRequest = {\n  maxBindingsPerBindGroup: 'adapterLimit',\n  maxBindGroups: 'adapterLimit',\n};\n\nconst limit = 'maxStorageTexturesPerShaderStage';\nexport const { g, description } = makeLimitTestGroup(limit);\n\nfunction createBindGroupLayout(\n  device: GPUDevice,\n  visibility: number,\n  access: GPUStorageTextureAccess,\n  order: ReorderOrder,\n  numBindings: number\n) {\n  return device.createBindGroupLayout({\n    entries: reorder(\n      order,\n      range(numBindings, i => ({\n        binding: i,\n        visibility,\n        storageTexture: { format: 'r32float', access },\n      }))\n    ),\n  });\n}\n\nfunction skipIfNotEnoughStorageTexturesInStage(\n  t: LimitTestsImpl,\n  visibility: GPUShaderStageFlags,\n  testValue: number\n) {\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the fragment stage\n      (visibility & GPUConst.ShaderStage.FRAGMENT) !== 0 &&\n      // If perShaderStage and inFragment stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInFragmentStage! &&\n      // They aren't equal so if there aren't enough supported in the fragment then skip\n      !(t.device.limits.maxStorageTexturesInFragmentStage! >= testValue),\n    `maxStorageTexturesInFragmentShader = ${t.device.limits.maxStorageTexturesInFragmentStage} which is less than ${testValue}`\n  );\n\n  t.skipIf(\n    t.isCompatibility &&\n      // If we're using the vertex stage\n      (visibility & GPUConst.ShaderStage.VERTEX) !== 0 &&\n      // If perShaderStage and inVertex stage are equal we want to\n      // allow the test to run as otherwise we can't test overMaximum and overLimit\n      t.device.limits.maxStorageTexturesPerShaderStage >\n        t.device.limits.maxStorageTexturesInVertexStage! &&\n      // They aren't equal so if there aren't enough supported in the vertex then skip\n      !(t.device.limits.maxStorageTexturesInVertexStage! >= testValue),\n    `maxStorageTexturesInVertexShader = ${t.device.limits.maxStorageTexturesInVertexStage} which is less than ${testValue}`\n  );\n}\n\nfunction skipIfAccessNotSupported(t: LimitTestsImpl, access: GPUStorageTextureAccess) {\n  t.skipIf(\n    (access === 'read-only' || access === 'read-write') &&\n      !navigator.gpu.wgslLanguageFeatures.has('readonly_and_readwrite_storage_textures'),\n    `access = ${access} but navigator.gpu.wsglLanguageFeatures does not contain 'readonly_and_readwrite_storage_textures'`\n  );\n}\n\nfunction filterWriteAccessInVertexStage(\n  visibility: GPUShaderStageFlags,\n  access: GPUStorageTextureAccess\n) {\n  return access === 'read-only' || (visibility & GPUConst.ShaderStage.VERTEX) === 0;\n}\n\nfunction addExtraRequiredLimits(\n  adapter: GPUAdapter,\n  limits: LimitsRequest,\n  limitTest: MaximumLimitValueTest\n) {\n  const newLimits: LimitsRequest = { ...limits };\n\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageTexturesInFragmentStage',\n    limit,\n    limitTest\n  );\n  addMaximumLimitUpToDependentLimit(\n    adapter,\n    newLimits,\n    'maxStorageTexturesInVertexStage',\n    limit,\n    limitTest\n  );\n\n  return newLimits;\n}\ng.test('createBindGroupLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createBindGroupLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t => filterWriteAccessInVertexStage(t.visibility, t.access))\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        t.skipIf(\n          t.adapter.limits.maxBindingsPerBindGroup < testValue,\n          `maxBindingsPerBindGroup = ${t.adapter.limits.maxBindingsPerBindGroup} which is less than ${testValue}`\n        );\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n        await t.expectValidationError(\n          () => createBindGroupLayout(device, visibility, access, order, testValue),\n          shouldError\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipelineLayout,at_over')\n  .desc(\n    `\n  Test using at and over ${limit} limit in createPipelineLayout\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t => filterWriteAccessInVertexStage(t.visibility, t.access))\n      .combine('order', kReorderOrderKeys)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, access, order } = t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const maxBindingsPerBindGroup = Math.min(\n          t.device.limits.maxBindingsPerBindGroup,\n          actualLimit\n        );\n        const kNumGroups = Math.ceil(testValue / maxBindingsPerBindGroup);\n\n        // Not sure what to do in this case but best we get notified if it happens.\n        assert(kNumGroups <= t.device.limits.maxBindGroups);\n\n        const bindGroupLayouts = range(kNumGroups, i => {\n          const numInGroup = Math.min(\n            testValue - i * maxBindingsPerBindGroup,\n            maxBindingsPerBindGroup\n          );\n          return createBindGroupLayout(device, visibility, access, order, numInGroup);\n        });\n\n        await t.expectValidationError(\n          () => device.createPipelineLayout({ bindGroupLayouts }),\n          shouldError\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n\ng.test('createPipeline,at_over')\n  .desc(\n    `\n  Test using createRenderPipeline(Async) and createComputePipeline(Async) at and over ${limit} limit\n\n  Note: We also test order to make sure the implementation isn't just looking\n  at just the last entry.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('bindingCombination', kBindingCombinations)\n      .combine('access', kStorageTextureAccessValues)\n      .filter(t =>\n        filterWriteAccessInVertexStage(\n          getStageVisibilityForBinidngCombination(t.bindingCombination),\n          t.access\n        )\n      )\n      .beginSubcases()\n      .combine('order', kReorderOrderKeys)\n      .combine('bindGroupTest', kBindGroupTests)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, bindingCombination, access, order, bindGroupTest } =\n      t.params;\n\n    skipIfAccessNotSupported(t, access);\n\n    const pipelineType = getPipelineTypeForBindingCombination(bindingCombination);\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        t.skipIf(\n          bindGroupTest === 'sameGroup' && testValue > device.limits.maxBindingsPerBindGroup,\n          `can not test ${testValue} bindings in same group because maxBindingsPerBindGroup = ${device.limits.maxBindingsPerBindGroup}`\n        );\n\n        const visibility = getStageVisibilityForBinidngCombination(bindingCombination);\n        skipIfNotEnoughStorageTexturesInStage(t, visibility, testValue);\n\n        const { wgslAccess } = storageTextureBindingTypeInfo({ access });\n\n        const code = getPerStageWGSLForBindingCombinationStorageTextures(\n          bindingCombination,\n          order,\n          bindGroupTest,\n          (i, j) => `var u${j}_${i}: texture_storage_2d<r32float, ${wgslAccess}>`,\n          (i, j) =>\n            access === 'write-only'\n              ? `textureStore(u${j}_${i}, vec2u(0), vec4f(0));`\n              : `_ = textureLoad(u${j}_${i}, vec2u(0));`,\n          device.limits.maxBindGroups,\n          testValue\n        );\n        const module = device.createShaderModule({ code });\n\n        await t.testCreatePipeline(\n          pipelineType,\n          async,\n          module,\n          shouldError,\n          `actualLimit: ${actualLimit}, testValue: ${testValue}\\n:${code}`\n        );\n      },\n      addExtraRequiredLimits(t.adapter, kExtraLimits, limitTest)\n    );\n  });\n"],"mappings":"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"}