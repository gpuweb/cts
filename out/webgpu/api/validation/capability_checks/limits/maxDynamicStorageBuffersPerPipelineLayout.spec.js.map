{"version":3,"file":"maxDynamicStorageBuffersPerPipelineLayout.spec.js","names":["assert","range","kShaderStageCombinationsWithStage","GPUConst","kMaximumLimitBaseParams","makeLimitTestGroup","kExtraLimits","maxBindingsPerBindGroup","maxBindGroups","maxStorageBuffersPerShaderStage","maxStorageBuffersInFragmentStage","maxStorageBuffersInVertexStage","limit","g","description","test","desc","params","combine","filter","visibility","type","ShaderStage","VERTEX","fn","t","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","device","testValue","shouldError","skipIfNotEnoughStorageBuffersInStage","limits","expectValidationError","createBindGroupLayout","entries","i","binding","buffer","hasDynamicOffset","actualLimit","Math","min","kNumGroups","ceil","bindGroupLayouts","numInGroup","createPipelineLayout"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxDynamicStorageBuffersPerPipelineLayout.spec.ts"],"sourcesContent":["import { assert, range } from '../../../../../common/util/util.js';\nimport { kShaderStageCombinationsWithStage } from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\n\nimport { kMaximumLimitBaseParams, LimitsRequest, makeLimitTestGroup } from './limit_utils.js';\n\nconst kExtraLimits: LimitsRequest = {\n  maxBindingsPerBindGroup: 'adapterLimit',\n  maxBindGroups: 'adapterLimit',\n  maxStorageBuffersPerShaderStage: 'adapterLimit',\n  maxStorageBuffersInFragmentStage: 'adapterLimit',\n  maxStorageBuffersInVertexStage: 'adapterLimit',\n};\n\nconst limit = 'maxDynamicStorageBuffersPerPipelineLayout';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createBindGroupLayout,at_over')\n  .desc(`Test using createBindGroupLayout at and over ${limit} limit`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('type', ['storage', 'read-only-storage'] as GPUBufferBindingType[])\n      .filter(\n        ({ visibility, type }) =>\n          (visibility & GPUConst.ShaderStage.VERTEX) === 0 || type !== 'storage'\n      )\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, type } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        t.skipIfNotEnoughStorageBuffersInStage(visibility, testValue);\n        shouldError ||= testValue > t.device.limits.maxStorageBuffersPerShaderStage;\n        await t.expectValidationError(() => {\n          device.createBindGroupLayout({\n            entries: range(testValue, i => ({\n              binding: i,\n              visibility,\n              buffer: {\n                type,\n                hasDynamicOffset: true,\n              },\n            })),\n          });\n        }, shouldError);\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('createPipelineLayout,at_over')\n  .desc(`Test using at and over ${limit} limit in createPipelineLayout`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('visibility', kShaderStageCombinationsWithStage)\n      .combine('type', ['storage', 'read-only-storage'] as GPUBufferBindingType[])\n      .filter(\n        ({ visibility, type }) =>\n          (visibility & GPUConst.ShaderStage.VERTEX) === 0 || type !== 'storage'\n      )\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, visibility, type } = t.params;\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError, actualLimit }) => {\n        t.skipIfNotEnoughStorageBuffersInStage(visibility, testValue);\n\n        const maxBindingsPerBindGroup = Math.min(\n          t.device.limits.maxBindingsPerBindGroup,\n          actualLimit\n        );\n\n        const kNumGroups = Math.ceil(testValue / maxBindingsPerBindGroup);\n\n        // Not sure what to do in this case but best we get notified if it happens.\n        assert(kNumGroups <= t.device.limits.maxBindGroups);\n\n        const bindGroupLayouts = range(kNumGroups, i => {\n          const numInGroup = Math.min(\n            testValue - i * maxBindingsPerBindGroup,\n            maxBindingsPerBindGroup\n          );\n          return device.createBindGroupLayout({\n            entries: range(numInGroup, i => ({\n              binding: i,\n              visibility,\n              buffer: {\n                type,\n                hasDynamicOffset: true,\n              },\n            })),\n          });\n        });\n\n        await t.expectValidationError(\n          () => device.createPipelineLayout({ bindGroupLayouts }),\n          shouldError\n        );\n      },\n      kExtraLimits\n    );\n  });\n"],"mappings":"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"}