{"version":3,"file":"maxInterStageShaderComponents.spec.js","names":["assert","range","kMaximumLimitBaseParams","makeLimitTestGroup","getTypeForNumComponents","numComponents","getPipelineDescriptor","device","testValue","pointList","frontFacing","sampleIndex","sampleMaskIn","sampleMaskOut","maxVertexShaderOutputComponents","maxFragmentShaderInputComponents","maxInterStageVariables","limits","maxInterStageShaderVariables","Math","min","ceil","num4ComponentVaryings","floor","lastVaryingNumComponents","varyings","i","join","code","maxInterStageShaderComponents","module","createShaderModule","pipelineDescriptor","layout","primitive","topology","vertex","entryPoint","limit","g","description","test","desc","params","combine","fn","t","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","shouldError","expectValidationError","createRenderPipeline","shouldRejectConditionally","createRenderPipelineAsync"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxInterStageShaderComponents.spec.ts"],"sourcesContent":["import { assert, range } from '../../../../../common/util/util.js';\n\nimport { kMaximumLimitBaseParams, makeLimitTestGroup } from './limit_utils.js';\n\nfunction getTypeForNumComponents(numComponents: number) {\n  return numComponents > 1 ? `vec${numComponents}f` : 'f32';\n}\n\nfunction getPipelineDescriptor(\n  device: GPUDevice,\n  testValue: number,\n  pointList: boolean,\n  frontFacing: boolean,\n  sampleIndex: boolean,\n  sampleMaskIn: boolean,\n  sampleMaskOut: boolean\n): { pipelineDescriptor: GPURenderPipelineDescriptor; code: string } {\n  const maxVertexShaderOutputComponents = testValue - (pointList ? 1 : 0);\n  const maxFragmentShaderInputComponents =\n    testValue - (frontFacing ? 1 : 0) - (sampleIndex ? 1 : 0) - (sampleMaskIn ? 1 : 0);\n\n  const maxInterStageVariables = device.limits.maxInterStageShaderVariables;\n  const numComponents = Math.min(maxVertexShaderOutputComponents, maxFragmentShaderInputComponents);\n  assert(Math.ceil(numComponents / 4) <= maxInterStageVariables);\n\n  const num4ComponentVaryings = Math.floor(numComponents / 4);\n  const lastVaryingNumComponents = numComponents % 4;\n\n  const varyings = `\n      ${range(num4ComponentVaryings, i => `@location(${i}) v4_${i}: vec4f,`).join('\\n')}\n      ${\n        lastVaryingNumComponents > 0\n          ? `@location(${num4ComponentVaryings}) vx: ${getTypeForNumComponents(\n              lastVaryingNumComponents\n            )},`\n          : ``\n      }\n  `;\n\n  const code = `\n    // test value                        : ${testValue}\n    // maxInterStageShaderComponents     : ${device.limits.maxInterStageShaderComponents}\n    // num components in vertex shader   : ${numComponents}${pointList ? ' + point-list' : ''}\n    // num components in fragment shader : ${numComponents}${frontFacing ? ' + front-facing' : ''}${\n    sampleIndex ? ' + sample_index' : ''\n  }${sampleMaskIn ? ' + sample_mask' : ''}\n    // maxVertexShaderOutputComponents   : ${maxVertexShaderOutputComponents}\n    // maxFragmentShaderInputComponents  : ${maxFragmentShaderInputComponents}\n    // maxInterStageVariables:           : ${maxInterStageVariables}\n    // num used inter stage variables    : ${Math.ceil(numComponents / 4)}\n\n    struct VSOut {\n      @builtin(position) p: vec4f,\n      ${varyings}\n    }\n    struct FSIn {\n      ${pointList ? '@builtin(front_facing) frontFacing: bool,' : ''}\n      ${sampleIndex ? '@builtin(sample_index) sampleIndex: u32,' : ''}\n      ${sampleMaskIn ? '@builtin(sample_mask) sampleMask: u32,' : ''}\n      ${varyings}\n    }\n    struct FSOut {\n      @location(0) color: vec4f,\n      ${sampleMaskOut ? '@builtin(sample_mask) sampleMask: u32,' : ''}\n    }\n    @vertex fn vs() -> VSOut {\n      var o: VSOut;\n      o.p = vec4f(0);\n      return o;\n    }\n    @fragment fn fs(i: FSIn) -> FSOut {\n      var o: FSOut;\n      o.color = vec4f(0);\n      return o;\n    }\n  `;\n  const module = device.createShaderModule({ code });\n  const pipelineDescriptor: GPURenderPipelineDescriptor = {\n    layout: 'auto',\n    primitive: {\n      topology: pointList ? 'point-list' : 'triangle-list',\n    },\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n  };\n  return { pipelineDescriptor, code };\n}\n\nconst limit = 'maxInterStageShaderComponents';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipeline`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('pointList', [false, true])\n      .combine('frontFacing', [false, true])\n      .combine('sampleIndex', [false, true])\n      .combine('sampleMaskIn', [false, true])\n      .combine('sampleMaskOut', [false, true])\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      pointList,\n      frontFacing,\n      sampleIndex,\n      sampleMaskIn,\n      sampleMaskOut,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const { pipelineDescriptor, code } = getPipelineDescriptor(\n          device,\n          testValue,\n          pointList,\n          frontFacing,\n          sampleIndex,\n          sampleMaskIn,\n          sampleMaskOut\n        );\n\n        await t.expectValidationError(\n          () => {\n            device.createRenderPipeline(pipelineDescriptor);\n          },\n          shouldError,\n          code\n        );\n      }\n    );\n  });\n\ng.test('createRenderPipelineAsync,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipelineAsync`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('pointList', [false, true])\n      .combine('frontFacing', [false, true])\n      .combine('sampleIndex', [false, true])\n      .combine('sampleMaskIn', [false, true])\n      .combine('sampleMaskOut', [false, true])\n  )\n  .fn(async t => {\n    const {\n      limitTest,\n      testValueName,\n      pointList,\n      frontFacing,\n      sampleIndex,\n      sampleMaskIn,\n      sampleMaskOut,\n    } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const { pipelineDescriptor, code } = getPipelineDescriptor(\n          device,\n          testValue,\n          pointList,\n          frontFacing,\n          sampleIndex,\n          sampleMaskIn,\n          sampleMaskOut\n        );\n        await t.shouldRejectConditionally(\n          'GPUPipelineError',\n          device.createRenderPipelineAsync(pipelineDescriptor),\n          shouldError,\n          code\n        );\n      }\n    );\n  });\n"],"mappings":"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"}