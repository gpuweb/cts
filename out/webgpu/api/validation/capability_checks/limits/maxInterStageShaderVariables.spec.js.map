{"version":3,"file":"maxInterStageShaderVariables.spec.js","names":["keysOf","hasFeature","range","kMaximumLimitBaseParams","makeLimitTestGroup","kFragmentInputTypes","front_facing","sample_index","sample_mask","primitive_index","subgroup_invocation_id","subgroup_size","kFragmentInputs","kItemsThatCountAgainstLimit","kExtraItems","combinations","arr","size","start","path","length","i","push","pop","kTestItems","kTestItemCombinations","requiresSubgroupsFeature","items","has","getPipelineDescriptor","t","device","testValue","vertexOutputDeductions","usedFragInputs","values","filter","p","fragmentInputDeductions","map","reduce","acc","debug","features","join","numVertexOutputVariables","numFragmentInputVariables","numInterStageVariables","Math","min","maxVertexOutputVariables","limits","maxInterStageShaderVariables","maxFragmentInputVariables","maxInterStageVariables","fragInputs","input","varyings","code","module","createShaderModule","pipelineDescriptor","layout","primitive","topology","vertex","entryPoint","fragment","targets","format","limit","g","description","test","desc","params","combine","fn","limitTest","testValueName","async","itemsAsArray","Set","isCompatibility","skipIf","adapter","skip","testDeviceWithRequestedMaximumLimits","shouldError","testCreateRenderPipeline","undefined"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxInterStageShaderVariables.spec.ts"],"sourcesContent":["import { Fixture } from '../../../../../common/framework/fixture.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { hasFeature, range } from '../../../../../common/util/util.js';\n\nimport { kMaximumLimitBaseParams, makeLimitTestGroup } from './limit_utils.js';\n\nconst kFragmentInputTypes = {\n  front_facing: 'bool',\n  sample_index: 'u32',\n  sample_mask: 'u32',\n  primitive_index: 'u32',\n  subgroup_invocation_id: 'u32',\n  subgroup_size: 'u32',\n} as const;\n\nconst kFragmentInputs = keysOf(kFragmentInputTypes);\n\nconst kItemsThatCountAgainstLimit = ['point-list', ...kFragmentInputs] as const;\n\nconst kExtraItems = [\n  'sample_mask_out', // special - see below\n] as const;\n\n/**\n * Generates every combination of size elements from array\n * combinations([a, b, c], 2) generates [a, b], [a, c], [b, c]\n */\nfunction* combinations<T>(\n  arr: readonly T[],\n  size: number,\n  start = 0,\n  path: T[] = []\n): Generator<T[]> {\n  if (path.length === size) {\n    yield [...path];\n    return;\n  }\n\n  for (let i = start; i < arr.length; i++) {\n    path.push(arr[i]);\n    yield* combinations(arr, size, i + 1, path);\n    path.pop();\n  }\n}\n\nconst kTestItems = [...kItemsThatCountAgainstLimit, ...kExtraItems] as const;\nconst kTestItemCombinations = [\n  [], // no builtins case\n  ...combinations(kTestItems, 1), // one builtin\n  ...combinations(kTestItems, 2), // 2 builtins\n  ...combinations(kTestItems, 3), // 3 builtins\n  kTestItems, // all builtins case\n] as const;\n\nconst requiresSubgroupsFeature = (items: Set<(typeof kTestItems)[number]>) =>\n  items.has('subgroup_invocation_id') || items.has('subgroup_size');\n\nfunction getPipelineDescriptor(\n  t: Fixture,\n  device: GPUDevice,\n  testValue: number,\n  items: Set<(typeof kTestItems)[number]>\n): GPURenderPipelineDescriptor {\n  const vertexOutputDeductions = items.has('point-list') ? 1 : 0;\n  const usedFragInputs = [...items.values()].filter(p => p in kFragmentInputTypes);\n  const fragmentInputDeductions = usedFragInputs\n    .map(p => (p ? 1 : 0) as number)\n    .reduce((acc, p) => acc + p, 0);\n\n  t.debug(() => `device features: ${[...device.features].join(', ')}`);\n\n  const numVertexOutputVariables = testValue - vertexOutputDeductions;\n  const numFragmentInputVariables = testValue - fragmentInputDeductions;\n  const numInterStageVariables = Math.min(numVertexOutputVariables, numFragmentInputVariables);\n\n  const maxVertexOutputVariables =\n    device.limits.maxInterStageShaderVariables - vertexOutputDeductions;\n  const maxFragmentInputVariables =\n    device.limits.maxInterStageShaderVariables - fragmentInputDeductions;\n  const maxInterStageVariables = Math.min(maxVertexOutputVariables, maxFragmentInputVariables);\n\n  const fragInputs = usedFragInputs\n    .map(\n      (input, i) =>\n        `      @builtin(${input}) i_${i}: ${\n          kFragmentInputTypes[input as keyof typeof kFragmentInputTypes]\n        },`\n    )\n    .join('\\n');\n\n  const varyings = `${range(\n    numInterStageVariables,\n    i => `      @location(${i}) v4_${i}: vec4f,`\n  ).join('\\n')}`;\n\n  const code = `\n    // test value                        : ${testValue}\n    // maxInterStageShaderVariables      : ${device.limits.maxInterStageShaderVariables}\n    // num variables in vertex shader    : ${numVertexOutputVariables}${\n      items.has('point-list') ? ' + point-list' : ''\n    }\n    // num variables in fragment shader  : ${numFragmentInputVariables} + ${usedFragInputs.join(\n      ' + '\n    )}\n    // maxInterStageVariables:           : ${maxInterStageVariables}\n    // num used inter stage variables    : ${numInterStageVariables}\n\n    ${items.has('primitive_index') ? 'enable primitive_index;' : ''}\n    ${requiresSubgroupsFeature(items) ? 'enable subgroups;' : ''}\n\n    struct VSOut {\n      @builtin(position) p: vec4f,\n${varyings}\n    }\n    struct FSIn {\n${fragInputs}\n${varyings}\n    }\n\n    struct FSOut {\n      @location(0) color: vec4f,\n      ${items.has('sample_mask_out') ? '@builtin(sample_mask) sampleMask: u32,' : ''}\n    }\n\n    @vertex fn vs() -> VSOut {\n      var o: VSOut;\n      o.p = vec4f(0);\n      return o;\n    }\n\n    @fragment fn fs(i: FSIn) -> FSOut {\n      var o: FSOut;\n\n      o.color = vec4f(0);\n      return o;\n    }\n  `;\n  t.debug(code);\n  const module = device.createShaderModule({ code });\n  const pipelineDescriptor: GPURenderPipelineDescriptor = {\n    layout: 'auto',\n    primitive: {\n      topology: items.has('point-list') ? 'point-list' : 'triangle-list',\n    },\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets: [\n        {\n          format: 'rgba8unorm',\n        },\n      ],\n    },\n  };\n  return pipelineDescriptor;\n}\n\nconst limit = 'maxInterStageShaderVariables';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(\n    `\nTest using at and over ${limit} limit in createRenderPipeline(Async)\n\nNote: We test combinations to make sure each entry is counted separately.\nand that implementations don't accidentally add only 1 to the count when\n2 or more builtins are used. We also include sample_mask as an output\nto make sure it does not count against the limit since it has the same\nname as sample_mask as an input.\n  `\n  )\n  .params(\n    kMaximumLimitBaseParams.combine('async', [false, true]).combine('items', kTestItemCombinations)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, items: itemsAsArray } = t.params;\n    const items = new Set(itemsAsArray);\n\n    if (t.isCompatibility) {\n      t.skipIf(\n        items.has('sample_mask') || items.has('sample_mask_out'),\n        'sample_mask not supported in compatibility mode'\n      );\n      t.skipIf(items.has('sample_index'), 'sample_index not supported in compatibility mode');\n    }\n\n    const features: GPUFeatureName[] = [];\n\n    if (items.has('primitive_index')) {\n      if (hasFeature(t.adapter.features, 'primitive-index')) {\n        features.push('primitive-index');\n      } else {\n        t.skip('primitive_index requires primitive-index feature');\n      }\n    }\n\n    if (requiresSubgroupsFeature(items)) {\n      if (hasFeature(t.adapter.features, 'subgroups')) {\n        features.push('subgroups');\n      } else {\n        t.skip('subgroup_invocation_id or subgroup_size requires subgroups feature');\n      }\n    }\n\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, shouldError }) => {\n        const pipelineDescriptor = getPipelineDescriptor(t, device, testValue, items);\n\n        await t.testCreateRenderPipeline(pipelineDescriptor, async, shouldError);\n      },\n      undefined,\n      features\n    );\n  });\n"],"mappings":"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"}