{"version":3,"file":"maxColorAttachmentBytesPerSample.spec.js","names":["assert","kTextureSampleCounts","getColorRenderAlignment","getColorRenderByteCost","align","kMaximumLimitBaseParams","makeLimitTestGroup","kFormatsToUseBySize","kInterleaveFormats","kFormatsUsedInTest","getAttachments","interleaveFormat","testValue","bytesPerSample","targets","addTexture","format","newBytesPerSample","push","writeMask","getDescription","actualLimit","sampleCount","offset","map","alignment","byteCost","s","padEnd","toString","padStart","join","getPipelineDescriptor","device","typedVec","includes","code","module","createShaderModule","pipelineDescriptor","layout","vertex","entryPoint","fragment","depthStencil","depthWriteEnabled","depthCompare","multisample","count","createTextures","t","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","kExtraLimits","maxColorAttachments","limit","g","description","test","desc","params","combine","fn","limitTest","testValueName","async","testDeviceWithRequestedMaximumLimits","shouldError","result","numTargets","length","limits","testCreateRenderPipeline","encoder","createCommandEncoder","textures","pass","beginRenderPass","colorAttachments","texture","view","createView","loadOp","storeOp","end","expectValidationError","finish","createRenderBundleEncoder","colorFormats"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxColorAttachmentBytesPerSample.spec.ts"],"sourcesContent":["import { assert } from '../../../../../common/util/util.js';\nimport { kTextureSampleCounts } from '../../../../capability_info.js';\nimport { getColorRenderAlignment, getColorRenderByteCost } from '../../../../format_info.js';\nimport { align } from '../../../../util/math.js';\n\nimport {\n  kMaximumLimitBaseParams,\n  LimitsRequest,\n  LimitTestsImpl,\n  makeLimitTestGroup,\n} from './limit_utils.js';\n\nconst kFormatsToUseBySize = [\n  'rgba32uint',\n  'rgba16uint',\n  'rgba8unorm',\n  'rg8unorm',\n  'r8unorm',\n] as const;\n\nconst kInterleaveFormats = ['rgba16uint', 'rg16uint', 'rgba8unorm', 'rg8unorm', 'r8unorm'] as const;\n\nconst kFormatsUsedInTest = [...kFormatsToUseBySize, ...kInterleaveFormats] as const;\ntype FormatUsedInTest = (typeof kFormatsUsedInTest)[number];\n\nfunction getAttachments(interleaveFormat: FormatUsedInTest, testValue: number) {\n  let bytesPerSample = 0;\n  const targets: GPUColorTargetState[] = [];\n\n  const addTexture = (format: FormatUsedInTest) => {\n    const newBytesPerSample =\n      align(bytesPerSample, getColorRenderAlignment(format)) + getColorRenderByteCost(format);\n    if (newBytesPerSample > testValue) {\n      return false;\n    }\n    targets.push({ format, writeMask: 0 });\n    bytesPerSample = newBytesPerSample;\n    return true;\n  };\n\n  while (bytesPerSample < testValue) {\n    addTexture(interleaveFormat);\n    for (const format of kFormatsToUseBySize) {\n      if (addTexture(format)) {\n        break;\n      }\n    }\n  }\n\n  assert(bytesPerSample === testValue);\n  return targets;\n}\n\nfunction getDescription(\n  testValue: number,\n  actualLimit: number,\n  sampleCount: number,\n  targets: GPUColorTargetState[]\n) {\n  return `\n    // testValue  : ${testValue}\n    // actualLimit: ${actualLimit}\n    // sampleCount: ${sampleCount}\n    // targets:\n    ${(() => {\n      let offset = 0;\n      return targets\n        .map(({ format }) => {\n          const alignment = getColorRenderAlignment(format as FormatUsedInTest);\n          const byteCost = getColorRenderByteCost(format as FormatUsedInTest);\n          offset = align(offset, alignment);\n          const s = `//   ${format.padEnd(11)} (offset: ${offset\n            .toString()\n            .padStart(2)}, align: ${alignment}, size: ${byteCost})`;\n          offset += byteCost;\n          return s;\n        })\n        .join('\\n    ');\n    })()}\n  `;\n}\n\nfunction getPipelineDescriptor(\n  device: GPUDevice,\n  actualLimit: number,\n  interleaveFormat: FormatUsedInTest,\n  sampleCount: number,\n  testValue: number\n): { pipelineDescriptor: GPURenderPipelineDescriptor; code: string } | undefined {\n  const targets = getAttachments(interleaveFormat, testValue);\n  if (!targets) {\n    return;\n  }\n\n  const typedVec = interleaveFormat.includes('uint') ? 'vec4u' : 'vec4f';\n\n  const code = `\n    ${getDescription(testValue, actualLimit, sampleCount, targets)}\n    @vertex fn vs() -> @builtin(position) vec4f {\n      return vec4f(0);\n    }\n\n    @fragment fn fs() -> @location(0) ${typedVec} {\n      return ${typedVec}(0);\n    }\n  `;\n  const module = device.createShaderModule({ code });\n  const pipelineDescriptor: GPURenderPipelineDescriptor = {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets,\n    },\n    // depth should not affect the test so added to make sure the implementation does not consider it\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: 'depth24plus',\n    },\n    multisample: {\n      count: sampleCount,\n    },\n  };\n  return { pipelineDescriptor, code };\n}\n\nfunction createTextures(t: LimitTestsImpl, targets: GPUColorTargetState[]) {\n  return targets.map(({ format }) =>\n    t.createTextureTracked({\n      size: [1, 1],\n      format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    })\n  );\n}\n\nconst kExtraLimits: LimitsRequest = {\n  maxColorAttachments: 'adapterLimit',\n};\n\nconst limit = 'maxColorAttachmentBytesPerSample';\nexport const { g, description } = makeLimitTestGroup(limit);\n\ng.test('createRenderPipeline,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderPipeline(Async)`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('async', [false, true] as const)\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, async, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const result = getPipelineDescriptor(\n          device,\n          actualLimit,\n          interleaveFormat,\n          sampleCount,\n          testValue\n        );\n        if (!result) {\n          return;\n        }\n        const { pipelineDescriptor, code } = result;\n        const numTargets = (pipelineDescriptor.fragment!.targets as GPUColorTargetState[]).length;\n        if (numTargets > device.limits.maxColorAttachments) {\n          return;\n        }\n\n        await t.testCreateRenderPipeline(pipelineDescriptor, async, shouldError, code);\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('beginRenderPass,at_over')\n  .desc(`Test using at and over ${limit} limit in beginRenderPass`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        if (targets.length > device.limits.maxColorAttachments) {\n          return;\n        }\n\n        const encoder = device.createCommandEncoder();\n        const textures = createTextures(t, targets);\n\n        const pass = encoder.beginRenderPass({\n          colorAttachments: textures.map(texture => ({\n            view: texture.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          })),\n        });\n        pass.end();\n\n        await t.expectValidationError(\n          () => {\n            encoder.finish();\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      kExtraLimits\n    );\n  });\n\ng.test('createRenderBundle,at_over')\n  .desc(`Test using at and over ${limit} limit in createRenderBundle`)\n  .params(\n    kMaximumLimitBaseParams\n      .combine('sampleCount', kTextureSampleCounts)\n      .combine('interleaveFormat', kInterleaveFormats)\n  )\n  .fn(async t => {\n    const { limitTest, testValueName, sampleCount, interleaveFormat } = t.params;\n    await t.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        const targets = getAttachments(interleaveFormat, testValue);\n        if (targets.length > device.limits.maxColorAttachments) {\n          return;\n        }\n\n        await t.expectValidationError(\n          () => {\n            device.createRenderBundleEncoder({\n              colorFormats: targets.map(({ format }) => format),\n            });\n          },\n          shouldError,\n          getDescription(testValue, actualLimit, sampleCount, targets)\n        );\n      },\n      kExtraLimits\n    );\n  });\n"],"mappings":";;GAAA,SAASA,MAAM,QAAQ,oCAAoC,CAC3D,SAASC,oBAAoB,QAAQ,gCAAgC,CACrE,SAASC,uBAAuB,EAAEC,sBAAsB,QAAQ,4BAA4B;AAC5F,SAASC,KAAK,QAAQ,0BAA0B;;AAEhD;EACEC,uBAAuB;;;EAGvBC,kBAAkB;AACb,kBAAkB;;AAEzB,MAAMC,mBAAmB,GAAG;AAC1B,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,UAAU;AACV,SAAS,CACD;;;AAEV,MAAMC,kBAAkB,GAAG,CAAC,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,SAAS,CAAU;;AAEnG,MAAMC,kBAAkB,GAAG,CAAC,GAAGF,mBAAmB,EAAE,GAAGC,kBAAkB,CAAU;;;AAGnF,SAASE,cAAcA,CAACC,gBAAkC,EAAEC,SAAiB,EAAE;EAC7E,IAAIC,cAAc,GAAG,CAAC;EACtB,MAAMC,OAA8B,GAAG,EAAE;;EAEzC,MAAMC,UAAU,GAAGA,CAACC,MAAwB,KAAK;IAC/C,MAAMC,iBAAiB;IACrBb,KAAK,CAACS,cAAc,EAAEX,uBAAuB,CAACc,MAAM,CAAC,CAAC,GAAGb,sBAAsB,CAACa,MAAM,CAAC;IACzF,IAAIC,iBAAiB,GAAGL,SAAS,EAAE;MACjC,OAAO,KAAK;IACd;IACAE,OAAO,CAACI,IAAI,CAAC,EAAEF,MAAM,EAAEG,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IACtCN,cAAc,GAAGI,iBAAiB;IAClC,OAAO,IAAI;EACb,CAAC;;EAED,OAAOJ,cAAc,GAAGD,SAAS,EAAE;IACjCG,UAAU,CAACJ,gBAAgB,CAAC;IAC5B,KAAK,MAAMK,MAAM,IAAIT,mBAAmB,EAAE;MACxC,IAAIQ,UAAU,CAACC,MAAM,CAAC,EAAE;QACtB;MACF;IACF;EACF;;EAEAhB,MAAM,CAACa,cAAc,KAAKD,SAAS,CAAC;EACpC,OAAOE,OAAO;AAChB;;AAEA,SAASM,cAAcA;AACrBR,SAAiB;AACjBS,WAAmB;AACnBC,WAAmB;AACnBR,OAA8B;AAC9B;EACA,OAAQ;AACV,sBAAsBF,SAAU;AAChC,sBAAsBS,WAAY;AAClC,sBAAsBC,WAAY;AAClC;AACA,MAAM,CAAC,MAAM;IACP,IAAIC,MAAM,GAAG,CAAC;IACd,OAAOT,OAAO;IACXU,GAAG,CAAC,CAAC,EAAER,MAAM,CAAC,CAAC,KAAK;MACnB,MAAMS,SAAS,GAAGvB,uBAAuB,CAACc,MAA0B,CAAC;MACrE,MAAMU,QAAQ,GAAGvB,sBAAsB,CAACa,MAA0B,CAAC;MACnEO,MAAM,GAAGnB,KAAK,CAACmB,MAAM,EAAEE,SAAS,CAAC;MACjC,MAAME,CAAC,GAAI,QAAOX,MAAM,CAACY,MAAM,CAAC,EAAE,CAAE,aAAYL,MAAM;MACnDM,QAAQ,CAAC,CAAC;MACVC,QAAQ,CAAC,CAAC,CAAE,YAAWL,SAAU,WAAUC,QAAS,GAAE;MACzDH,MAAM,IAAIG,QAAQ;MAClB,OAAOC,CAAC;IACV,CAAC,CAAC;IACDI,IAAI,CAAC,QAAQ,CAAC;EACnB,CAAC,EAAE,CAAE;AACT,GAAG;AACH;;AAEA,SAASC,qBAAqBA;AAC5BC,MAAiB;AACjBZ,WAAmB;AACnBV,gBAAkC;AAClCW,WAAmB;AACnBV,SAAiB;AAC8D;EAC/E,MAAME,OAAO,GAAGJ,cAAc,CAACC,gBAAgB,EAAEC,SAAS,CAAC;EAC3D,IAAI,CAACE,OAAO,EAAE;IACZ;EACF;;EAEA,MAAMoB,QAAQ,GAAGvB,gBAAgB,CAACwB,QAAQ,CAAC,MAAM,CAAC,GAAG,OAAO,GAAG,OAAO;;EAEtE,MAAMC,IAAI,GAAI;AAChB,MAAMhB,cAAc,CAACR,SAAS,EAAES,WAAW,EAAEC,WAAW,EAAER,OAAO,CAAE;AACnE;AACA;AACA;AACA;AACA,wCAAwCoB,QAAS;AACjD,eAAeA,QAAS;AACxB;AACA,GAAG;EACD,MAAMG,MAAM,GAAGJ,MAAM,CAACK,kBAAkB,CAAC,EAAEF,IAAI,CAAC,CAAC,CAAC;EAClD,MAAMG,kBAA+C,GAAG;IACtDC,MAAM,EAAE,MAAM;IACdC,MAAM,EAAE;MACNJ,MAAM;MACNK,UAAU,EAAE;IACd,CAAC;IACDC,QAAQ,EAAE;MACRN,MAAM;MACNK,UAAU,EAAE,IAAI;MAChB5B;IACF,CAAC;IACD;IACA8B,YAAY,EAAE;MACZC,iBAAiB,EAAE,IAAI;MACvBC,YAAY,EAAE,MAAM;MACpB9B,MAAM,EAAE;IACV,CAAC;IACD+B,WAAW,EAAE;MACXC,KAAK,EAAE1B;IACT;EACF,CAAC;EACD,OAAO,EAAEiB,kBAAkB,EAAEH,IAAI,CAAC,CAAC;AACrC;;AAEA,SAASa,cAAcA,CAACC,CAAiB,EAAEpC,OAA8B,EAAE;EACzE,OAAOA,OAAO,CAACU,GAAG,CAAC,CAAC,EAAER,MAAM,CAAC,CAAC;EAC5BkC,CAAC,CAACC,oBAAoB,CAAC;IACrBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACZpC,MAAM;IACNqC,KAAK,EAAEC,eAAe,CAACC;EACzB,CAAC;EACH,CAAC;AACH;;AAEA,MAAMC,YAA2B,GAAG;EAClCC,mBAAmB,EAAE;AACvB,CAAC;;AAED,MAAMC,KAAK,GAAG,kCAAkC;AAChD,OAAO,MAAM,EAAEC,CAAC,EAAEC,WAAW,CAAC,CAAC,GAAGtD,kBAAkB,CAACoD,KAAK,CAAC;;AAE3DC,CAAC,CAACE,IAAI,CAAC,8BAA8B,CAAC;AACnCC,IAAI,CAAE,0BAAyBJ,KAAM,uCAAsC,CAAC;AAC5EK,MAAM;EACL1D,uBAAuB;EACpB2D,OAAO,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU,CAAC;EACxCA,OAAO,CAAC,aAAa,EAAE/D,oBAAoB,CAAC;EAC5C+D,OAAO,CAAC,kBAAkB,EAAExD,kBAAkB;AACnD,CAAC;AACAyD,EAAE,CAAC,OAAMf,CAAC,KAAI;EACb,MAAM,EAAEgB,SAAS,EAAEC,aAAa,EAAEC,KAAK,EAAE9C,WAAW,EAAEX,gBAAgB,CAAC,CAAC,GAAGuC,CAAC,CAACa,MAAM;EACnF,MAAMb,CAAC,CAACmB,oCAAoC;IAC1CH,SAAS;IACTC,aAAa;IACb,OAAO,EAAElC,MAAM,EAAErB,SAAS,EAAES,WAAW,EAAEiD,WAAW,CAAC,CAAC,KAAK;MACzD,MAAMC,MAAM,GAAGvC,qBAAqB;QAClCC,MAAM;QACNZ,WAAW;QACXV,gBAAgB;QAChBW,WAAW;QACXV;MACF,CAAC;MACD,IAAI,CAAC2D,MAAM,EAAE;QACX;MACF;MACA,MAAM,EAAEhC,kBAAkB,EAAEH,IAAI,CAAC,CAAC,GAAGmC,MAAM;MAC3C,MAAMC,UAAU,GAAIjC,kBAAkB,CAACI,QAAQ,CAAE7B,OAAO,CAA2B2D,MAAM;MACzF,IAAID,UAAU,GAAGvC,MAAM,CAACyC,MAAM,CAACjB,mBAAmB,EAAE;QAClD;MACF;;MAEA,MAAMP,CAAC,CAACyB,wBAAwB,CAACpC,kBAAkB,EAAE6B,KAAK,EAAEE,WAAW,EAAElC,IAAI,CAAC;IAChF,CAAC;IACDoB;EACF,CAAC;AACH,CAAC,CAAC;;AAEJG,CAAC,CAACE,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,IAAI,CAAE,0BAAyBJ,KAAM,2BAA0B,CAAC;AAChEK,MAAM;EACL1D,uBAAuB;EACpB2D,OAAO,CAAC,aAAa,EAAE/D,oBAAoB,CAAC;EAC5C+D,OAAO,CAAC,kBAAkB,EAAExD,kBAAkB;AACnD,CAAC;AACAyD,EAAE,CAAC,OAAMf,CAAC,KAAI;EACb,MAAM,EAAEgB,SAAS,EAAEC,aAAa,EAAE7C,WAAW,EAAEX,gBAAgB,CAAC,CAAC,GAAGuC,CAAC,CAACa,MAAM;EAC5E,MAAMb,CAAC,CAACmB,oCAAoC;IAC1CH,SAAS;IACTC,aAAa;IACb,OAAO,EAAElC,MAAM,EAAErB,SAAS,EAAES,WAAW,EAAEiD,WAAW,CAAC,CAAC,KAAK;MACzD,MAAMxD,OAAO,GAAGJ,cAAc,CAACC,gBAAgB,EAAEC,SAAS,CAAC;MAC3D,IAAIE,OAAO,CAAC2D,MAAM,GAAGxC,MAAM,CAACyC,MAAM,CAACjB,mBAAmB,EAAE;QACtD;MACF;;MAEA,MAAMmB,OAAO,GAAG3C,MAAM,CAAC4C,oBAAoB,CAAC,CAAC;MAC7C,MAAMC,QAAQ,GAAG7B,cAAc,CAACC,CAAC,EAAEpC,OAAO,CAAC;;MAE3C,MAAMiE,IAAI,GAAGH,OAAO,CAACI,eAAe,CAAC;QACnCC,gBAAgB,EAAEH,QAAQ,CAACtD,GAAG,CAAC,CAAA0D,OAAO,MAAK;UACzCC,IAAI,EAAED,OAAO,CAACE,UAAU,CAAC,CAAC;UAC1BC,MAAM,EAAE,OAAO;UACfC,OAAO,EAAE;QACX,CAAC,CAAC;MACJ,CAAC,CAAC;MACFP,IAAI,CAACQ,GAAG,CAAC,CAAC;;MAEV,MAAMrC,CAAC,CAACsC,qBAAqB;QAC3B,MAAM;UACJZ,OAAO,CAACa,MAAM,CAAC,CAAC;QAClB,CAAC;QACDnB,WAAW;QACXlD,cAAc,CAACR,SAAS,EAAES,WAAW,EAAEC,WAAW,EAAER,OAAO;MAC7D,CAAC;IACH,CAAC;IACD0C;EACF,CAAC;AACH,CAAC,CAAC;;AAEJG,CAAC,CAACE,IAAI,CAAC,4BAA4B,CAAC;AACjCC,IAAI,CAAE,0BAAyBJ,KAAM,8BAA6B,CAAC;AACnEK,MAAM;EACL1D,uBAAuB;EACpB2D,OAAO,CAAC,aAAa,EAAE/D,oBAAoB,CAAC;EAC5C+D,OAAO,CAAC,kBAAkB,EAAExD,kBAAkB;AACnD,CAAC;AACAyD,EAAE,CAAC,OAAMf,CAAC,KAAI;EACb,MAAM,EAAEgB,SAAS,EAAEC,aAAa,EAAE7C,WAAW,EAAEX,gBAAgB,CAAC,CAAC,GAAGuC,CAAC,CAACa,MAAM;EAC5E,MAAMb,CAAC,CAACmB,oCAAoC;IAC1CH,SAAS;IACTC,aAAa;IACb,OAAO,EAAElC,MAAM,EAAErB,SAAS,EAAES,WAAW,EAAEiD,WAAW,CAAC,CAAC,KAAK;MACzD,MAAMxD,OAAO,GAAGJ,cAAc,CAACC,gBAAgB,EAAEC,SAAS,CAAC;MAC3D,IAAIE,OAAO,CAAC2D,MAAM,GAAGxC,MAAM,CAACyC,MAAM,CAACjB,mBAAmB,EAAE;QACtD;MACF;;MAEA,MAAMP,CAAC,CAACsC,qBAAqB;QAC3B,MAAM;UACJvD,MAAM,CAACyD,yBAAyB,CAAC;YAC/BC,YAAY,EAAE7E,OAAO,CAACU,GAAG,CAAC,CAAC,EAAER,MAAM,CAAC,CAAC,KAAKA,MAAM;UAClD,CAAC,CAAC;QACJ,CAAC;QACDsD,WAAW;QACXlD,cAAc,CAACR,SAAS,EAAES,WAAW,EAAEC,WAAW,EAAER,OAAO;MAC7D,CAAC;IACH,CAAC;IACD0C;EACF,CAAC;AACH,CAAC,CAAC"}