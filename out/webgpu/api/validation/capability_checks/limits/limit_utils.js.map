{"version":3,"file":"limit_utils.js","names":["kUnitCaseParamsBuilder","makeTestGroup","getGPU","assert","range","reorder","getDefaultLimits","getDefaultLimitsForAdapter","GPUConst","GPUTestBase","kCreatePipelineTypes","kRenderEncoderTypes","kEncoderTypes","kBindGroupTests","kBindingCombinations","getPipelineTypeForBindingCombination","bindingCombination","getStageVisibilityForBinidngCombination","ShaderStage","VERTEX","FRAGMENT","COMPUTE","getBindGroupIndex","bindGroupTest","numBindGroups","i","getBindingIndex","getWGSLBindings","order","storageDefinitionWGSLSnippetFn","numBindings","id","groupNdx","bindingNdx","storageWGSL","join","getPerStageWGSLForBindingCombinationImpl","bodyFn","extraWGSL","bindingParams","getPerStageWGSLForBindingCombination","usageWGSLSnippetFn","maxBindGroups","set","getPerStageWGSLForBindingCombinationStorageTextures","kLimitModes","kMaximumTestValues","getMaximumTestValue","limit","testValue","kMinimumTestValues","kMaximumLimitValueTests","getLimitValue","defaultLimit","maximumLimit","limitValueTest","Math","floor","kMinimumLimitValueTests","getDefaultLimitForAdapter","adapter","limitInfo","default","kMinimumLimits","Set","kMaximumLimitBaseParams","combine","kMinimumLimitBaseParams","addMaximumLimitUpToDependentLimit","limits","dependentLimitName","dependentLimitTest","limitMaximum","dependentLimitMaximum","value","min","LimitTestsImpl","_adapter","_device","undefined","limitTestParams","adapterLimit","init","gpu","rec","requestAdapter","skipIf","limitOptional","Number","isNaN","device","isCompatibility","getDefaultLimit","requestDeviceWithLimits","requiredLimits","shouldReject","requiredFeatures","requestDeviceTracked","allowMissingStack","getDefaultOrAdapterLimit","limitMode","_getDeviceWithSpecificLimit","requestedLimit","extraLimits","features","extraLimitStr","limitModeOrNumber","Object","entries","extraLimit","has","actualLimit","expect","checked","limitCheckFn","_getDeviceWithRequestedMaximumLimit","_testThenDestroyDevice","deviceAndLimits","fn","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","testDeviceWithSpecificLimits","deviceLimitValue","testDeviceWithRequestedMaximumLimits","limitTest","testValueName","extraFeatures","inputs","expectGPUErrorAsync","filter","msg","returnValue","Promise","error","shouldRejectConditionally","expectedName","p","shouldResolve","e","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","getGroupIndexWGSLForPipelineType","pipelineType","groupIndex","getBindingIndexWGSLForPipelineType","bindingIndex","_createRenderPipelineDescriptor","module","layout","vertex","entryPoint","fragment","targets","format","createShaderModule","code","_createRenderPipelineDescriptorWithFragmentShader","depthStencil","depthWriteEnabled","depthCompare","_createComputePipelineDescriptor","compute","createPipeline","createPipelineType","createRenderPipeline","createComputePipeline","createPipelineAsync","createRenderPipelineAsync","createComputePipelineAsync","testCreatePipeline","async","testCreateRenderPipeline","pipelineDescriptor","testMaxComputeWorkgroupSize","axis","kExtraLimits","maxComputeInvocationsPerWorkgroup","size","codePointAt","getModuleForWorkgroupSize","getGPURenderCommandsMixin","#getGPURenderCommandsMixin","encoderType","buffer","createBufferTracked","usage","GPUBufferUsage","UNIFORM","texture","createTextureTracked","GPUTextureUsage","RENDER_ATTACHMENT","createBindGroupLayout","binding","visibility","GPUShaderStage","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","passEncoder","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","prep","end","test","finish","createRenderBundleEncoder","colorFormats","testGPURenderAndBindingCommandsMixin","getGPUBindingCommandsMixin","#getGPUBindingCommandsMixin","beginComputePass","testGPUBindingCommandsMixin","skipIfNotEnoughStorageBuffersInStage","numRequired","maxStorageBuffersPerShaderStage","maxStorageBuffersInFragmentStage","maxStorageBuffersInVertexStage","makeLimitTestFixture","params","LimitTests","makeLimitTestGroup","description","g","testMaxStorageXXXInYYYStageDeviceCreationWithDependentLimit","desc","u","t","useMax","dependentLimit","dependentEffectiveLimits","debug","dependentAdapterLimit","expectedLimit"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["import { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert, range, reorder, ReorderOrder } from '../../../../../common/util/util.js';\nimport {\n  getDefaultLimits,\n  getDefaultLimitsForAdapter,\n  kLimits,\n} from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\nimport { GPUTestBase } from '../../../../gpu_test.js';\n\ntype GPUSupportedLimit = keyof Omit<GPUSupportedLimits, '__brand'>;\n\nexport const kCreatePipelineTypes = [\n  'createRenderPipeline',\n  'createRenderPipelineWithFragmentStage',\n  'createComputePipeline',\n] as const;\nexport type CreatePipelineType = (typeof kCreatePipelineTypes)[number];\n\nexport const kRenderEncoderTypes = ['render', 'renderBundle'] as const;\nexport type RenderEncoderType = (typeof kRenderEncoderTypes)[number];\n\nexport const kEncoderTypes = ['compute', 'render', 'renderBundle'] as const;\nexport type EncoderType = (typeof kEncoderTypes)[number];\n\nexport const kBindGroupTests = ['sameGroup', 'differentGroups'] as const;\nexport type BindGroupTest = (typeof kBindGroupTests)[number];\n\nexport const kBindingCombinations = [\n  'vertex',\n  'fragment',\n  'vertexAndFragmentWithPossibleVertexStageOverflow',\n  'vertexAndFragmentWithPossibleFragmentStageOverflow',\n  'compute',\n] as const;\nexport type BindingCombination = (typeof kBindingCombinations)[number];\n\nexport function getPipelineTypeForBindingCombination(bindingCombination: BindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return 'createRenderPipeline';\n    case 'fragment':\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return 'createRenderPipelineWithFragmentStage';\n    case 'compute':\n      return 'createComputePipeline';\n  }\n}\n\nexport function getStageVisibilityForBinidngCombination(bindingCombination: BindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return GPUConst.ShaderStage.VERTEX;\n    case 'fragment':\n      return GPUConst.ShaderStage.FRAGMENT;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return GPUConst.ShaderStage.FRAGMENT | GPUConst.ShaderStage.VERTEX;\n    case 'compute':\n      return GPUConst.ShaderStage.COMPUTE;\n  }\n}\n\nfunction getBindGroupIndex(bindGroupTest: BindGroupTest, numBindGroups: number, i: number) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return 0;\n    case 'differentGroups':\n      return i % numBindGroups;\n  }\n}\n\nfunction getBindingIndex(bindGroupTest: BindGroupTest, numBindGroups: number, i: number) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return i;\n    case 'differentGroups':\n      return (i / numBindGroups) | 0;\n  }\n}\n\nfunction getWGSLBindings(\n  {\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    numBindGroups,\n  }: {\n    order: ReorderOrder;\n    bindGroupTest: BindGroupTest;\n    storageDefinitionWGSLSnippetFn: (i: number, j: number) => string;\n    numBindGroups: number;\n  },\n  numBindings: number,\n  id: number\n) {\n  return reorder(\n    order,\n    range(numBindings, i => {\n      const groupNdx = getBindGroupIndex(bindGroupTest, numBindGroups, i);\n      const bindingNdx = getBindingIndex(bindGroupTest, numBindGroups, i);\n      const storageWGSL = storageDefinitionWGSLSnippetFn(i, id);\n      return `@group(${groupNdx}) @binding(${bindingNdx}) ${storageWGSL};`;\n    })\n  ).join('\\n        ');\n}\n\nexport function getPerStageWGSLForBindingCombinationImpl(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  bodyFn: (numBindings: number, set: number) => string,\n  numBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  const bindingParams = {\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    numBindGroups,\n  };\n  switch (bindingCombination) {\n    case 'vertex':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n      `;\n    case 'fragment':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings - 1, 1)}\n        }\n      `;\n    }\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings - 1, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 1)}\n        }\n      `;\n    }\n    case 'compute':\n      return `\n        ${extraWGSL}\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n        @compute @workgroup_size(1) fn main() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n      break;\n  }\n}\n\nexport function getPerStageWGSLForBindingCombination(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  maxBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    maxBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport function getPerStageWGSLForBindingCombinationStorageTextures(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  numBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    numBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport const kLimitModes = ['defaultLimit', 'adapterLimit'] as const;\nexport type LimitMode = (typeof kLimitModes)[number];\nexport type LimitsRequest = Record<string, LimitMode | number>;\n\nexport const kMaximumTestValues = ['atLimit', 'overLimit'] as const;\nexport type MaximumTestValue = (typeof kMaximumTestValues)[number];\n\nexport function getMaximumTestValue(limit: number, testValue: MaximumTestValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const kMinimumTestValues = ['atLimit', 'underLimit'] as const;\nexport type MinimumTestValue = (typeof kMinimumTestValues)[number];\n\nexport const kMaximumLimitValueTests = [\n  'atDefault',\n  'underDefault',\n  'betweenDefaultAndMaximum',\n  'atMaximum',\n  'overMaximum',\n] as const;\nexport type MaximumLimitValueTest = (typeof kMaximumLimitValueTests)[number];\n\nexport function getLimitValue(\n  defaultLimit: number,\n  maximumLimit: number,\n  limitValueTest: MaximumLimitValueTest\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'betweenDefaultAndMaximum':\n      // The result can be larger than maximum i32.\n      return Math.floor((defaultLimit + maximumLimit) / 2);\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport const kMinimumLimitValueTests = [\n  'atDefault',\n  'overDefault',\n  'betweenDefaultAndMinimum',\n  'atMinimum',\n  'underMinimum',\n] as const;\nexport type MinimumLimitValueTest = (typeof kMinimumLimitValueTests)[number];\n\nexport function getDefaultLimitForAdapter(adapter: GPUAdapter, limit: GPUSupportedLimit): number {\n  const limitInfo = getDefaultLimitsForAdapter(adapter);\n  return limitInfo[limit as keyof typeof limitInfo].default;\n}\n\nexport type DeviceAndLimits = {\n  device: GPUDevice;\n  defaultLimit: number;\n  adapterLimit: number;\n  requestedLimit: number;\n  actualLimit: number;\n};\n\nexport type SpecificLimitTestInputs = DeviceAndLimits & {\n  testValue: number;\n  shouldError: boolean;\n};\n\nexport type MaximumLimitTestInputs = SpecificLimitTestInputs & {\n  testValueName: MaximumTestValue;\n};\n\nconst kMinimumLimits = new Set<GPUSupportedLimit>([\n  'minUniformBufferOffsetAlignment',\n  'minStorageBufferOffsetAlignment',\n]);\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kMaximumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMaximumLimitValueTests)\n  .combine('testValueName', kMaximumTestValues);\n\nexport const kMinimumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMinimumLimitValueTests)\n  .combine('testValueName', kMinimumTestValues);\n\n/**\n * Adds a maximum limit upto a dependent limit.\n *\n * Example:\n *   You want to test `maxStorageBuffersPerShaderStage` in fragment stage\n *   so you need `maxStorageBuffersInFragmentStage` set as well. But, you\n *   don't know exactly what value will be used for `maxStorageBuffersPerShaderStage`\n *   since that is defined by an enum like `underDefault`.\n *\n *   So, you want `maxStorageBuffersInFragmentStage` to be set as high as possible.\n *   You can't just set it to it's maximum value (adapter.limits.maxStorageBuffersInFragmentStage)\n *   because if it's greater than `maxStorageBuffersPerShaderStage` you'll get an error.\n *\n *   So, use this function\n *\n *   const limits: LimitsRequest = {};\n *   addMaximumLimitUpToDependentLimit(\n *     adapter,\n *     limits,\n *     limit: 'maxStorageBuffersInFragmentStage', // the limit we want to add\n *     dependentLimitName: 'maxStorageBuffersPerShaderStage', // what the previous limit is dependent on\n *     dependentLimitTest: 'underDefault', // the enum used to decide the dependent limit\n *   )\n */\nexport function addMaximumLimitUpToDependentLimit(\n  adapter: GPUAdapter,\n  limits: LimitsRequest,\n  limit: GPUSupportedLimit,\n  dependentLimitName: GPUSupportedLimit,\n  dependentLimitTest: MaximumLimitValueTest\n) {\n  if (!(limit in adapter.limits)) {\n    return;\n  }\n\n  const limitMaximum: number = adapter.limits[limit]!;\n  const dependentLimitMaximum: number = adapter.limits[dependentLimitName]!;\n  const testValue = getLimitValue(\n    getDefaultLimitForAdapter(adapter, dependentLimitName),\n    dependentLimitMaximum,\n    dependentLimitTest\n  );\n\n  const value = Math.min(testValue, dependentLimitMaximum, limitMaximum);\n  limits[limit] = value;\n}\n\ntype LimitCheckParams = {\n  limit: GPUSupportedLimit;\n  actualLimit: number;\n  defaultLimit: number;\n};\n\ntype LimitCheckFn = (t: LimitTestsImpl, device: GPUDevice, params: LimitCheckParams) => boolean;\n\nexport class LimitTestsImpl extends GPUTestBase {\n  _adapter: GPUAdapter | null = null;\n  _device: GPUDevice | undefined = undefined;\n  limit: GPUSupportedLimit = '' as GPUSupportedLimit;\n  limitTestParams: LimitTestParams = {};\n  defaultLimit = 0;\n  adapterLimit = 0;\n\n  override async init() {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    this._adapter = await gpu.requestAdapter();\n    const limit = this.limit;\n    // MAINTENANCE_TODO: consider removing this skip if the spec has no optional limits.\n    this.skipIf(\n      this._adapter?.limits[limit] === undefined && !!this.limitTestParams.limitOptional,\n      `${limit} is missing but optional for now`\n    );\n    this.defaultLimit = getDefaultLimitForAdapter(this.adapter, limit);\n    this.adapterLimit = this.adapter.limits[limit] as number;\n    assert(!Number.isNaN(this.defaultLimit));\n    assert(!Number.isNaN(this.adapterLimit));\n  }\n\n  get adapter(): GPUAdapter {\n    assert(this._adapter !== undefined);\n    return this._adapter!;\n  }\n\n  override get device(): GPUDevice {\n    assert(this._device !== undefined, 'device is only valid in _testThenDestroyDevice callback');\n    return this._device;\n  }\n\n  getDefaultLimits() {\n    return getDefaultLimits(this.isCompatibility ? 'compatibility' : 'core');\n  }\n\n  getDefaultLimit(limit: (typeof kLimits)[number]) {\n    return this.getDefaultLimits()[limit].default;\n  }\n\n  async requestDeviceWithLimits(\n    adapter: GPUAdapter,\n    requiredLimits: Record<string, number>,\n    shouldReject: boolean,\n    requiredFeatures?: GPUFeatureName[]\n  ) {\n    if (shouldReject) {\n      this.shouldReject('OperationError', this.requestDeviceTracked(adapter, { requiredLimits }), {\n        allowMissingStack: true,\n      });\n      return undefined;\n    } else {\n      return this.requestDeviceTracked(adapter, { requiredLimits, requiredFeatures });\n    }\n  }\n\n  getDefaultOrAdapterLimit(limit: GPUSupportedLimit, limitMode: LimitMode) {\n    switch (limitMode) {\n      case 'defaultLimit':\n        return getDefaultLimitForAdapter(this.adapter, limit);\n      case 'adapterLimit':\n        return this.adapter.limits[limit];\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithSpecificLimit(\n    requestedLimit: number,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { adapter, limit, adapterLimit, defaultLimit } = this;\n\n    const requiredLimits: Record<string, number> = {};\n    requiredLimits[limit] = requestedLimit;\n\n    if (extraLimits) {\n      for (const [extraLimitStr, limitModeOrNumber] of Object.entries(extraLimits)) {\n        const extraLimit = extraLimitStr as GPUSupportedLimit;\n        if (adapter.limits[extraLimit] !== undefined) {\n          requiredLimits[extraLimit] =\n            typeof limitModeOrNumber === 'number'\n              ? limitModeOrNumber\n              : limitModeOrNumber === 'defaultLimit'\n              ? getDefaultLimitForAdapter(adapter, extraLimit)\n              : (adapter.limits[extraLimit] as number);\n        }\n      }\n    }\n\n    const shouldReject = kMinimumLimits.has(limit)\n      ? requestedLimit < adapterLimit\n      : requestedLimit > adapterLimit;\n\n    const device = await this.requestDeviceWithLimits(\n      adapter,\n      requiredLimits,\n      shouldReject,\n      features\n    );\n    const actualLimit = (device ? device.limits[limit] : 0) as number;\n\n    if (shouldReject) {\n      this.expect(!device, 'expected no device');\n    } else {\n      if (kMinimumLimits.has(limit)) {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${requestedLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        }\n      } else {\n        const checked = this.limitTestParams.limitCheckFn\n          ? this.limitTestParams.limitCheckFn(this, device!, { limit, actualLimit, defaultLimit })\n          : false;\n        if (!checked) {\n          if (requestedLimit <= defaultLimit) {\n            this.expect(\n              actualLimit === defaultLimit,\n              `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n            );\n          } else {\n            this.expect(\n              actualLimit === requestedLimit,\n              `expected actual actualLimit: ${actualLimit} to equal requestedLimit: ${requestedLimit}`\n            );\n          }\n        }\n      }\n    }\n\n    return device ? { device, defaultLimit, adapterLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedMaximumLimit(\n    limitValueTest: MaximumLimitValueTest,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { defaultLimit, adapterLimit: maximumLimit } = this;\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n    this.skipIf(\n      requestedLimit < 0 && limitValueTest === 'underDefault',\n      `requestedLimit(${requestedLimit}) for ${this.limit} is < 0`\n    );\n    return this._getDeviceWithSpecificLimit(requestedLimit, extraLimits, features);\n  }\n\n  /**\n   * Call the given function and check no WebGPU errors are leaked.\n   */\n  async _testThenDestroyDevice(\n    deviceAndLimits: DeviceAndLimits,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>\n  ) {\n    assert(!this._device);\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n\n    const shouldError = kMinimumLimits.has(this.limit)\n      ? testValue < actualLimit\n      : testValue > actualLimit;\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, `unexpected validation error: ${validationError?.message || ''}`);\n    this.expect(\n      !outOfMemoryError,\n      `unexpected out-of-memory error: ${outOfMemoryError?.message || ''}`\n    );\n    this.expect(!internalError, `unexpected internal error: ${internalError?.message || ''}`);\n\n    device.destroy();\n    this._device = undefined;\n  }\n\n  /**\n   * Creates a device with a specific limit.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithSpecificLimits(\n    deviceLimitValue: number,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithSpecificLimit(\n      deviceLimitValue,\n      extraLimits,\n      features\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    await this._testThenDestroyDevice(deviceAndLimits, testValue, fn);\n  }\n\n  /**\n   * Creates a device with the limit defined by LimitValueTest.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedMaximumLimits(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    fn: (inputs: MaximumLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest,\n    extraFeatures: GPUFeatureName[] = []\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedMaximumLimit(\n      limitTest,\n      extraLimits,\n      extraFeatures\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { actualLimit } = deviceAndLimits;\n    const testValue = getMaximumTestValue(actualLimit, testValueName);\n\n    await this._testThenDestroyDevice(\n      deviceAndLimits,\n      testValue,\n      async (inputs: SpecificLimitTestInputs) => {\n        await fn({ ...inputs, testValueName });\n      }\n    );\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUErrorAsync<R>(\n    filter: GPUErrorFilter,\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  async shouldRejectConditionally(\n    expectedName: string,\n    p: Promise<unknown>,\n    shouldReject: boolean,\n    message?: string\n  ): Promise<void> {\n    if (shouldReject) {\n      this.shouldReject(expectedName, p, { message });\n    } else {\n      this.shouldResolve(p, message);\n    }\n\n    // We need to explicitly wait for the promise because the device may be\n    // destroyed immediately after returning from this function.\n    try {\n      await p;\n    } catch (e) {\n      //\n    }\n  }\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  override async expectValidationError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError<R>(fn: () => R, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  getGroupIndexWGSLForPipelineType(pipelineType: CreatePipelineType, groupIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  getBindingIndexWGSLForPipelineType(pipelineType: CreatePipelineType, bindingIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  _createRenderPipelineDescriptor(module: GPUShaderModule): GPURenderPipelineDescriptor {\n    const { device } = this;\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n      // Specify a color attachment so we have at least one render target.\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module: device.createShaderModule({\n          code: `@fragment fn main() -> @location(0) vec4f { return vec4f(0); }`,\n        }),\n      },\n    };\n  }\n\n  _createRenderPipelineDescriptorWithFragmentShader(\n    module: GPUShaderModule\n  ): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n      fragment: {\n        module,\n        entryPoint: 'mainFS',\n        targets: [],\n      },\n      depthStencil: {\n        format: 'depth24plus-stencil8',\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n      },\n    };\n  }\n\n  _createComputePipelineDescriptor(module: GPUShaderModule): GPUComputePipelineDescriptor {\n    return {\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  createPipeline(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipeline(this._createRenderPipelineDescriptor(module));\n        break;\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipeline(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n        break;\n      case 'createComputePipeline':\n        return device.createComputePipeline(this._createComputePipelineDescriptor(module));\n        break;\n    }\n  }\n\n  createPipelineAsync(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipelineAsync(this._createRenderPipelineDescriptor(module));\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipelineAsync(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n      case 'createComputePipeline':\n        return device.createComputePipelineAsync(this._createComputePipelineDescriptor(module));\n    }\n  }\n\n  async testCreatePipeline(\n    createPipelineType: CreatePipelineType,\n    async: boolean,\n    module: GPUShaderModule,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        this.createPipelineAsync(createPipelineType, module),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          this.createPipeline(createPipelineType, module);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testCreateRenderPipeline(\n    pipelineDescriptor: GPURenderPipelineDescriptor,\n    async: boolean,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { device } = this;\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        device.createRenderPipelineAsync(pipelineDescriptor),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          device.createRenderPipeline(pipelineDescriptor);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testMaxComputeWorkgroupSize(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    async: boolean,\n    axis: 'X' | 'Y' | 'Z'\n  ) {\n    const kExtraLimits: LimitsRequest = {\n      maxComputeInvocationsPerWorkgroup: 'adapterLimit',\n    };\n\n    await this.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        if (testValue > device.limits.maxComputeInvocationsPerWorkgroup) {\n          return;\n        }\n\n        const size = [1, 1, 1];\n        size[axis.codePointAt(0)! - 'X'.codePointAt(0)!] = testValue;\n        const { module, code } = this.getModuleForWorkgroupSize(size);\n\n        await this.testCreatePipeline(\n          'createComputePipeline',\n          async,\n          module,\n          shouldError,\n          `size: ${testValue}, limit: ${actualLimit}\\n${code}`\n        );\n      },\n      kExtraLimits\n    );\n  }\n\n  /**\n   * Creates an GPURenderCommandsMixin setup with some initial state.\n   */\n  #getGPURenderCommandsMixin(encoderType: RenderEncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'render': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const texture = this.createTextureTracked({\n          size: [1, 1],\n          format: 'rgba8unorm',\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const passEncoder = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: texture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {\n            passEncoder.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n\n      case 'renderBundle': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const passEncoder = device.createRenderBundleEncoder({\n          colorFormats: ['rgba8unorm'],\n        });\n\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {},\n          test() {\n            passEncoder.finish();\n          },\n        };\n        break;\n      }\n    }\n  }\n\n  /**\n   * Test a method on GPURenderCommandsMixin or GPUBindingCommandsMixin\n   * The function will be called with the passEncoder.\n   */\n  async testGPURenderAndBindingCommandsMixin(\n    encoderType: RenderEncoderType,\n    fn: ({\n      passEncoder,\n      bindGroup,\n    }: {\n      passEncoder: GPURenderCommandsMixin & GPUBindingCommandsMixin;\n      bindGroup: GPUBindGroup;\n    }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { passEncoder, prep, test, bindGroup } = this.#getGPURenderCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  /**\n   * Creates GPUBindingCommandsMixin setup with some initial state.\n   */\n  #getGPUBindingCommandsMixin(encoderType: EncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'compute': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const passEncoder = encoder.beginComputePass();\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {\n            passEncoder.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n      case 'render':\n        return this.#getGPURenderCommandsMixin('render');\n      case 'renderBundle':\n        return this.#getGPURenderCommandsMixin('renderBundle');\n    }\n  }\n\n  /**\n   * Tests a method on GPUBindingCommandsMixin\n   * The function pass will be called with the passEncoder and a bindGroup\n   */\n  async testGPUBindingCommandsMixin(\n    encoderType: EncoderType,\n    fn: ({ bindGroup }: { passEncoder: GPUBindingCommandsMixin; bindGroup: GPUBindGroup }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { passEncoder, bindGroup, prep, test } = this.#getGPUBindingCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  getModuleForWorkgroupSize(size: number[]) {\n    const { device } = this;\n    const code = `\n      @group(0) @binding(0) var<storage, read_write> d: f32;\n      @compute @workgroup_size(${size.join(',')}) fn main() {\n        d = 0;\n      }\n    `;\n    const module = device.createShaderModule({ code });\n    return { module, code };\n  }\n\n  skipIfNotEnoughStorageBuffersInStage(visibility: GPUShaderStageFlags, numRequired: number) {\n    const { device } = this;\n    this.skipIf(\n      this.isCompatibility &&\n        // If we're using the fragment stage\n        (visibility & GPUShaderStage.FRAGMENT) !== 0 &&\n        // If perShaderStage and inFragment stage are equal we want to\n        // allow the test to run as otherwise we can't test overMaximum and overLimit\n        device.limits.maxStorageBuffersPerShaderStage >\n          device.limits.maxStorageBuffersInFragmentStage! &&\n        // They aren't equal so if there aren't enough supported in the fragment then skip\n        !(device.limits.maxStorageBuffersInFragmentStage! >= numRequired),\n      `maxStorageBuffersInFragmentShader = ${device.limits.maxStorageBuffersInFragmentStage} which is less than ${numRequired}`\n    );\n\n    this.skipIf(\n      this.isCompatibility &&\n        // If we're using the vertex stage\n        (visibility & GPUShaderStage.VERTEX) !== 0 &&\n        // If perShaderStage and inVertex stage are equal we want to\n        // allow the test to run as otherwise we can't test overMaximum and overLimit\n        device.limits.maxStorageBuffersPerShaderStage >\n          device.limits.maxStorageBuffersInVertexStage! &&\n        // They aren't equal so if there aren't enough supported in the vertex then skip\n        !(device.limits.maxStorageBuffersInVertexStage! >= numRequired),\n      `maxStorageBuffersInVertexShader = ${device.limits.maxStorageBuffersInVertexStage} which is less than ${numRequired}`\n    );\n  }\n}\n\ntype LimitTestParams = {\n  limitCheckFn?: LimitCheckFn;\n  limitOptional?: boolean;\n};\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(\n  limit: GPUSupportedLimit,\n  params?: LimitTestParams\n): typeof LimitTestsImpl {\n  class LimitTests extends LimitTestsImpl {\n    override limit = limit;\n    override limitTestParams = params ?? {};\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit: GPUSupportedLimit, params?: LimitTestParams) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit, params));\n  return { g, description, limit };\n}\n\n/**\n * Test that limit must be less than dependentLimitName when requesting a device.\n */\nexport function testMaxStorageXXXInYYYStageDeviceCreationWithDependentLimit(\n  g: ReturnType<typeof makeLimitTestGroup>['g'],\n  limit:\n    | 'maxStorageBuffersInFragmentStage'\n    | 'maxStorageBuffersInVertexStage'\n    | 'maxStorageTexturesInFragmentStage'\n    | 'maxStorageTexturesInVertexStage',\n  dependentLimitName: 'maxStorageBuffersPerShaderStage' | 'maxStorageTexturesPerShaderStage'\n) {\n  g.test(`validate,${dependentLimitName}`)\n    .desc(\n      `Test that adapter.limit.${limit} and requiredLimits.${limit} must be <= ${dependentLimitName}`\n    )\n    .params(u => u.combine('useMax', [true, false] as const)) // true case should not reject.\n    .fn(async t => {\n      const { useMax } = t.params;\n      const { adapterLimit: maximumLimit, adapter } = t;\n\n      const dependentLimit = adapter.limits[dependentLimitName]!;\n      t.expect(\n        maximumLimit <= dependentLimit,\n        `maximumLimit(${maximumLimit}) is <= adapter.limits.${dependentLimitName}(${dependentLimit})`\n      );\n\n      const dependentEffectiveLimits = useMax\n        ? dependentLimit\n        : t.getDefaultLimit(dependentLimitName);\n      const shouldReject = maximumLimit > dependentEffectiveLimits;\n      t.debug(\n        `${limit}(${maximumLimit}) > ${dependentLimitName}(${dependentEffectiveLimits}) shouldReject: ${shouldReject}`\n      );\n      const device = await t.requestDeviceWithLimits(\n        adapter,\n        {\n          [limit]: maximumLimit,\n          ...(useMax && {\n            [dependentLimitName]: dependentLimit,\n          }),\n        },\n        shouldReject\n      );\n      device?.destroy();\n    });\n\n  g.test(`auto_upgrade,${dependentLimitName}`)\n    .desc(\n      `Test that adapter.limit.${limit} is automatically upgraded to ${dependentLimitName} except in compat.`\n    )\n    .fn(async t => {\n      const { adapter, defaultLimit } = t;\n      const dependentAdapterLimit = adapter.limits[dependentLimitName];\n      const shouldReject = false;\n      const device = await t.requestDeviceWithLimits(\n        adapter,\n        {\n          [dependentLimitName]: dependentAdapterLimit,\n        },\n        shouldReject\n      );\n\n      const expectedLimit = t.isCompatibility ? defaultLimit : dependentAdapterLimit;\n      t.expect(\n        device!.limits[limit] === expectedLimit,\n        `${limit}(${device!.limits[limit]}) === ${expectedLimit}`\n      );\n    });\n}\n"],"mappings":"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"}