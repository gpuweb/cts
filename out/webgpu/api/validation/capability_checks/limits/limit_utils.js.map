{"version":3,"file":"limit_utils.js","names":["kUnitCaseParamsBuilder","makeTestGroup","getGPU","assert","range","reorder","getDefaultLimitsForAdapter","GPUTestBase","kCreatePipelineTypes","kRenderEncoderTypes","kEncoderTypes","kBindGroupTests","kBindingCombinations","getPipelineTypeForBindingCombination","bindingCombination","getStageVisibilityForBinidngCombination","GPUShaderStage","VERTEX","FRAGMENT","COMPUTE","getBindGroupIndex","bindGroupTest","numBindGroups","i","getBindingIndex","getWGSLBindings","order","storageDefinitionWGSLSnippetFn","numBindings","id","groupNdx","bindingNdx","storageWGSL","join","getPerStageWGSLForBindingCombinationImpl","bodyFn","extraWGSL","bindingParams","getPerStageWGSLForBindingCombination","usageWGSLSnippetFn","maxBindGroups","set","getPerStageWGSLForBindingCombinationStorageTextures","kLimitModes","kMaximumTestValues","getMaximumTestValue","limit","testValue","kMinimumTestValues","kMaximumLimitValueTests","getLimitValue","defaultLimit","maximumLimit","limitValueTest","Math","floor","kMinimumLimitValueTests","getDefaultLimitForAdapter","adapter","limitInfo","default","kMinimumLimits","Set","kMaximumLimitBaseParams","combine","kMinimumLimitBaseParams","LimitTestsImpl","_adapter","_device","undefined","adapterLimit","init","gpu","rec","requestAdapter","limits","Number","isNaN","device","requestDeviceWithLimits","requiredLimits","shouldReject","requiredFeatures","requestDeviceTracked","allowMissingStack","getDefaultOrAdapterLimit","limitMode","_getDeviceWithSpecificLimit","requestedLimit","extraLimits","features","extraLimitStr","Object","entries","extraLimit","has","actualLimit","expect","_getDeviceWithRequestedMaximumLimit","_testThenDestroyDevice","deviceAndLimits","fn","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","testDeviceWithSpecificLimits","deviceLimitValue","testDeviceWithRequestedMaximumLimits","limitTest","testValueName","extraFeatures","inputs","expectGPUErrorAsync","filter","msg","returnValue","Promise","error","shouldRejectConditionally","expectedName","p","shouldResolve","e","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","getGroupIndexWGSLForPipelineType","pipelineType","groupIndex","getBindingIndexWGSLForPipelineType","bindingIndex","_createRenderPipelineDescriptor","module","layout","vertex","entryPoint","fragment","targets","format","createShaderModule","code","_createRenderPipelineDescriptorWithFragmentShader","depthStencil","depthWriteEnabled","depthCompare","_createComputePipelineDescriptor","compute","createPipeline","createPipelineType","createRenderPipeline","createComputePipeline","createPipelineAsync","createRenderPipelineAsync","createComputePipelineAsync","testCreatePipeline","async","testCreateRenderPipeline","pipelineDescriptor","testMaxComputeWorkgroupSize","axis","kExtraLimits","maxComputeInvocationsPerWorkgroup","size","codePointAt","getModuleForWorkgroupSize","getGPURenderCommandsMixin","#getGPURenderCommandsMixin","encoderType","buffer","createBufferTracked","usage","GPUBufferUsage","UNIFORM","texture","createTextureTracked","GPUTextureUsage","RENDER_ATTACHMENT","createBindGroupLayout","binding","visibility","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","passEncoder","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","prep","end","test","finish","createRenderBundleEncoder","colorFormats","testGPURenderAndBindingCommandsMixin","getGPUBindingCommandsMixin","#getGPUBindingCommandsMixin","beginComputePass","testGPUBindingCommandsMixin","skipIfNotEnoughStorageBuffersInStage","numRequired","skipIf","isCompatibility","maxStorageBuffersPerShaderStage","maxStorageBuffersInFragmentStage","maxStorageBuffersInVertexStage","makeLimitTestFixture","LimitTests","makeLimitTestGroup","description","g"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["import { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert, range, reorder, ReorderOrder } from '../../../../../common/util/util.js';\nimport { getDefaultLimitsForAdapter } from '../../../../capability_info.js';\nimport { GPUTestBase } from '../../../../gpu_test.js';\n\ntype GPUSupportedLimit = keyof GPUSupportedLimits;\n\nexport const kCreatePipelineTypes = [\n  'createRenderPipeline',\n  'createRenderPipelineWithFragmentStage',\n  'createComputePipeline',\n] as const;\nexport type CreatePipelineType = (typeof kCreatePipelineTypes)[number];\n\nexport const kRenderEncoderTypes = ['render', 'renderBundle'] as const;\nexport type RenderEncoderType = (typeof kRenderEncoderTypes)[number];\n\nexport const kEncoderTypes = ['compute', 'render', 'renderBundle'] as const;\nexport type EncoderType = (typeof kEncoderTypes)[number];\n\nexport const kBindGroupTests = ['sameGroup', 'differentGroups'] as const;\nexport type BindGroupTest = (typeof kBindGroupTests)[number];\n\nexport const kBindingCombinations = [\n  'vertex',\n  'fragment',\n  'vertexAndFragmentWithPossibleVertexStageOverflow',\n  'vertexAndFragmentWithPossibleFragmentStageOverflow',\n  'compute',\n] as const;\nexport type BindingCombination = (typeof kBindingCombinations)[number];\n\nexport function getPipelineTypeForBindingCombination(bindingCombination: BindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return 'createRenderPipeline';\n    case 'fragment':\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return 'createRenderPipelineWithFragmentStage';\n    case 'compute':\n      return 'createComputePipeline';\n  }\n}\n\nexport function getStageVisibilityForBinidngCombination(bindingCombination: BindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return GPUShaderStage.VERTEX;\n    case 'fragment':\n      return GPUShaderStage.FRAGMENT;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX;\n    case 'compute':\n      return GPUShaderStage.COMPUTE;\n  }\n}\n\nfunction getBindGroupIndex(bindGroupTest: BindGroupTest, numBindGroups: number, i: number) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return 0;\n    case 'differentGroups':\n      return i % numBindGroups;\n  }\n}\n\nfunction getBindingIndex(bindGroupTest: BindGroupTest, numBindGroups: number, i: number) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return i;\n    case 'differentGroups':\n      return (i / numBindGroups) | 0;\n  }\n}\n\nfunction getWGSLBindings(\n  {\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    numBindGroups,\n  }: {\n    order: ReorderOrder;\n    bindGroupTest: BindGroupTest;\n    storageDefinitionWGSLSnippetFn: (i: number, j: number) => string;\n    numBindGroups: number;\n  },\n  numBindings: number,\n  id: number\n) {\n  return reorder(\n    order,\n    range(numBindings, i => {\n      const groupNdx = getBindGroupIndex(bindGroupTest, numBindGroups, i);\n      const bindingNdx = getBindingIndex(bindGroupTest, numBindGroups, i);\n      const storageWGSL = storageDefinitionWGSLSnippetFn(i, id);\n      return `@group(${groupNdx}) @binding(${bindingNdx}) ${storageWGSL};`;\n    })\n  ).join('\\n        ');\n}\n\nexport function getPerStageWGSLForBindingCombinationImpl(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  bodyFn: (numBindings: number, set: number) => string,\n  numBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  const bindingParams = {\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    numBindGroups,\n  };\n  switch (bindingCombination) {\n    case 'vertex':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n      `;\n    case 'fragment':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings - 1, 1)}\n        }\n      `;\n    }\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow': {\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings - 1, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 1)}\n        }\n      `;\n    }\n    case 'compute':\n      return `\n        ${extraWGSL}\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n        @compute @workgroup_size(1) fn main() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n      break;\n  }\n}\n\nexport function getPerStageWGSLForBindingCombination(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  maxBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    maxBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport function getPerStageWGSLForBindingCombinationStorageTextures(\n  bindingCombination: BindingCombination,\n  order: ReorderOrder,\n  bindGroupTest: BindGroupTest,\n  storageDefinitionWGSLSnippetFn: (i: number, j: number) => string,\n  usageWGSLSnippetFn: (i: number, j: number) => string,\n  numBindGroups: number,\n  numBindings: number,\n  extraWGSL = ''\n) {\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings: number, set: number) =>\n      `${range(numBindings, i => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    numBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport const kLimitModes = ['defaultLimit', 'adapterLimit'] as const;\nexport type LimitMode = (typeof kLimitModes)[number];\nexport type LimitsRequest = Record<string, LimitMode>;\n\nexport const kMaximumTestValues = ['atLimit', 'overLimit'] as const;\nexport type MaximumTestValue = (typeof kMaximumTestValues)[number];\n\nexport function getMaximumTestValue(limit: number, testValue: MaximumTestValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const kMinimumTestValues = ['atLimit', 'underLimit'] as const;\nexport type MinimumTestValue = (typeof kMinimumTestValues)[number];\n\nexport const kMaximumLimitValueTests = [\n  'atDefault',\n  'underDefault',\n  'betweenDefaultAndMaximum',\n  'atMaximum',\n  'overMaximum',\n] as const;\nexport type MaximumLimitValueTest = (typeof kMaximumLimitValueTests)[number];\n\nexport function getLimitValue(\n  defaultLimit: number,\n  maximumLimit: number,\n  limitValueTest: MaximumLimitValueTest\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'betweenDefaultAndMaximum':\n      // The result can be larger than maximum i32.\n      return Math.floor((defaultLimit + maximumLimit) / 2);\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport const kMinimumLimitValueTests = [\n  'atDefault',\n  'overDefault',\n  'betweenDefaultAndMinimum',\n  'atMinimum',\n  'underMinimum',\n] as const;\nexport type MinimumLimitValueTest = (typeof kMinimumLimitValueTests)[number];\n\nexport function getDefaultLimitForAdapter(adapter: GPUAdapter, limit: GPUSupportedLimit): number {\n  const limitInfo = getDefaultLimitsForAdapter(adapter);\n  return limitInfo[limit as keyof typeof limitInfo].default;\n}\n\nexport type DeviceAndLimits = {\n  device: GPUDevice;\n  defaultLimit: number;\n  adapterLimit: number;\n  requestedLimit: number;\n  actualLimit: number;\n};\n\nexport type SpecificLimitTestInputs = DeviceAndLimits & {\n  testValue: number;\n  shouldError: boolean;\n};\n\nexport type MaximumLimitTestInputs = SpecificLimitTestInputs & {\n  testValueName: MaximumTestValue;\n};\n\nconst kMinimumLimits = new Set<GPUSupportedLimit>([\n  'minUniformBufferOffsetAlignment',\n  'minStorageBufferOffsetAlignment',\n]);\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kMaximumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMaximumLimitValueTests)\n  .combine('testValueName', kMaximumTestValues);\n\nexport const kMinimumLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kMinimumLimitValueTests)\n  .combine('testValueName', kMinimumTestValues);\n\nexport class LimitTestsImpl extends GPUTestBase {\n  _adapter: GPUAdapter | null = null;\n  _device: GPUDevice | undefined = undefined;\n  limit: GPUSupportedLimit = '' as GPUSupportedLimit;\n  defaultLimit = 0;\n  adapterLimit = 0;\n\n  override async init() {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    this._adapter = await gpu.requestAdapter();\n    const limit = this.limit;\n    this.defaultLimit = getDefaultLimitForAdapter(this.adapter, limit);\n    this.adapterLimit = this.adapter.limits[limit] as number;\n    assert(!Number.isNaN(this.defaultLimit));\n    assert(!Number.isNaN(this.adapterLimit));\n  }\n\n  get adapter(): GPUAdapter {\n    assert(this._adapter !== undefined);\n    return this._adapter!;\n  }\n\n  override get device(): GPUDevice {\n    assert(this._device !== undefined, 'device is only valid in _testThenDestroyDevice callback');\n    return this._device;\n  }\n\n  async requestDeviceWithLimits(\n    adapter: GPUAdapter,\n    requiredLimits: Record<string, number>,\n    shouldReject: boolean,\n    requiredFeatures?: GPUFeatureName[]\n  ) {\n    if (shouldReject) {\n      this.shouldReject('OperationError', this.requestDeviceTracked(adapter, { requiredLimits }), {\n        allowMissingStack: true,\n      });\n      return undefined;\n    } else {\n      return this.requestDeviceTracked(adapter, { requiredLimits, requiredFeatures });\n    }\n  }\n\n  getDefaultOrAdapterLimit(limit: GPUSupportedLimit, limitMode: LimitMode) {\n    switch (limitMode) {\n      case 'defaultLimit':\n        return getDefaultLimitForAdapter(this.adapter, limit);\n      case 'adapterLimit':\n        return this.adapter.limits[limit];\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithSpecificLimit(\n    requestedLimit: number,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { adapter, limit, adapterLimit, defaultLimit } = this;\n\n    const requiredLimits: Record<string, number> = {};\n    requiredLimits[limit] = requestedLimit;\n\n    if (extraLimits) {\n      for (const [extraLimitStr, limitMode] of Object.entries(extraLimits)) {\n        const extraLimit = extraLimitStr as GPUSupportedLimit;\n        requiredLimits[extraLimit] =\n          limitMode === 'defaultLimit'\n            ? getDefaultLimitForAdapter(adapter, extraLimit)\n            : (adapter.limits[extraLimit] as number);\n      }\n    }\n\n    const shouldReject = kMinimumLimits.has(limit)\n      ? requestedLimit < adapterLimit\n      : requestedLimit > adapterLimit;\n\n    const device = await this.requestDeviceWithLimits(\n      adapter,\n      requiredLimits,\n      shouldReject,\n      features\n    );\n    const actualLimit = (device ? device.limits[limit] : 0) as number;\n\n    if (shouldReject) {\n      this.expect(!device, 'expected no device');\n    } else {\n      if (kMinimumLimits.has(limit)) {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${requestedLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        }\n      } else {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal requestedLimit: ${requestedLimit}`\n          );\n        }\n      }\n    }\n\n    return device ? { device, defaultLimit, adapterLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedMaximumLimit(\n    limitValueTest: MaximumLimitValueTest,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ): Promise<DeviceAndLimits | undefined> {\n    const { defaultLimit, adapterLimit: maximumLimit } = this;\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n    return this._getDeviceWithSpecificLimit(requestedLimit, extraLimits, features);\n  }\n\n  /**\n   * Call the given function and check no WebGPU errors are leaked.\n   */\n  async _testThenDestroyDevice(\n    deviceAndLimits: DeviceAndLimits,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>\n  ) {\n    assert(!this._device);\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n\n    const shouldError = kMinimumLimits.has(this.limit)\n      ? testValue < actualLimit\n      : testValue > actualLimit;\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, `unexpected validation error: ${validationError?.message || ''}`);\n    this.expect(\n      !outOfMemoryError,\n      `unexpected out-of-memory error: ${outOfMemoryError?.message || ''}`\n    );\n    this.expect(!internalError, `unexpected internal error: ${internalError?.message || ''}`);\n\n    device.destroy();\n    this._device = undefined;\n  }\n\n  /**\n   * Creates a device with a specific limit.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithSpecificLimits(\n    deviceLimitValue: number,\n    testValue: number,\n    fn: (inputs: SpecificLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest,\n    features?: GPUFeatureName[]\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithSpecificLimit(\n      deviceLimitValue,\n      extraLimits,\n      features\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    await this._testThenDestroyDevice(deviceAndLimits, testValue, fn);\n  }\n\n  /**\n   * Creates a device with the limit defined by LimitValueTest.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedMaximumLimits(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    fn: (inputs: MaximumLimitTestInputs) => void | Promise<void>,\n    extraLimits?: LimitsRequest,\n    extraFeatures: GPUFeatureName[] = []\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedMaximumLimit(\n      limitTest,\n      extraLimits,\n      extraFeatures\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { actualLimit } = deviceAndLimits;\n    const testValue = getMaximumTestValue(actualLimit, testValueName);\n\n    await this._testThenDestroyDevice(\n      deviceAndLimits,\n      testValue,\n      async (inputs: SpecificLimitTestInputs) => {\n        await fn({ ...inputs, testValueName });\n      }\n    );\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUErrorAsync<R>(\n    filter: GPUErrorFilter,\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  async shouldRejectConditionally(\n    expectedName: string,\n    p: Promise<unknown>,\n    shouldReject: boolean,\n    message?: string\n  ): Promise<void> {\n    if (shouldReject) {\n      this.shouldReject(expectedName, p, { message });\n    } else {\n      this.shouldResolve(p, message);\n    }\n\n    // We need to explicitly wait for the promise because the device may be\n    // destroyed immediately after returning from this function.\n    try {\n      await p;\n    } catch (e) {\n      //\n    }\n  }\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  override async expectValidationError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError<R>(fn: () => R, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  getGroupIndexWGSLForPipelineType(pipelineType: CreatePipelineType, groupIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  getBindingIndexWGSLForPipelineType(pipelineType: CreatePipelineType, bindingIndex: number) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  _createRenderPipelineDescriptor(module: GPUShaderModule): GPURenderPipelineDescriptor {\n    const { device } = this;\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n      // Specify a color attachment so we have at least one render target.\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module: device.createShaderModule({\n          code: `@fragment fn main() -> @location(0) vec4f { return vec4f(0); }`,\n        }),\n      },\n    };\n  }\n\n  _createRenderPipelineDescriptorWithFragmentShader(\n    module: GPUShaderModule\n  ): GPURenderPipelineDescriptor {\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS',\n      },\n      fragment: {\n        module,\n        entryPoint: 'mainFS',\n        targets: [],\n      },\n      depthStencil: {\n        format: 'depth24plus-stencil8',\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n      },\n    };\n  }\n\n  _createComputePipelineDescriptor(module: GPUShaderModule): GPUComputePipelineDescriptor {\n    return {\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  createPipeline(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipeline(this._createRenderPipelineDescriptor(module));\n        break;\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipeline(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n        break;\n      case 'createComputePipeline':\n        return device.createComputePipeline(this._createComputePipelineDescriptor(module));\n        break;\n    }\n  }\n\n  createPipelineAsync(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipelineAsync(this._createRenderPipelineDescriptor(module));\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipelineAsync(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n      case 'createComputePipeline':\n        return device.createComputePipelineAsync(this._createComputePipelineDescriptor(module));\n    }\n  }\n\n  async testCreatePipeline(\n    createPipelineType: CreatePipelineType,\n    async: boolean,\n    module: GPUShaderModule,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        this.createPipelineAsync(createPipelineType, module),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          this.createPipeline(createPipelineType, module);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testCreateRenderPipeline(\n    pipelineDescriptor: GPURenderPipelineDescriptor,\n    async: boolean,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { device } = this;\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        device.createRenderPipelineAsync(pipelineDescriptor),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          device.createRenderPipeline(pipelineDescriptor);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testMaxComputeWorkgroupSize(\n    limitTest: MaximumLimitValueTest,\n    testValueName: MaximumTestValue,\n    async: boolean,\n    axis: 'X' | 'Y' | 'Z'\n  ) {\n    const kExtraLimits: LimitsRequest = {\n      maxComputeInvocationsPerWorkgroup: 'adapterLimit',\n    };\n\n    await this.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        if (testValue > device.limits.maxComputeInvocationsPerWorkgroup) {\n          return;\n        }\n\n        const size = [1, 1, 1];\n        size[axis.codePointAt(0)! - 'X'.codePointAt(0)!] = testValue;\n        const { module, code } = this.getModuleForWorkgroupSize(size);\n\n        await this.testCreatePipeline(\n          'createComputePipeline',\n          async,\n          module,\n          shouldError,\n          `size: ${testValue}, limit: ${actualLimit}\\n${code}`\n        );\n      },\n      kExtraLimits\n    );\n  }\n\n  /**\n   * Creates an GPURenderCommandsMixin setup with some initial state.\n   */\n  #getGPURenderCommandsMixin(encoderType: RenderEncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'render': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const texture = this.createTextureTracked({\n          size: [1, 1],\n          format: 'rgba8unorm',\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const passEncoder = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: texture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {\n            passEncoder.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n\n      case 'renderBundle': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const passEncoder = device.createRenderBundleEncoder({\n          colorFormats: ['rgba8unorm'],\n        });\n\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {},\n          test() {\n            passEncoder.finish();\n          },\n        };\n        break;\n      }\n    }\n  }\n\n  /**\n   * Test a method on GPURenderCommandsMixin or GPUBindingCommandsMixin\n   * The function will be called with the passEncoder.\n   */\n  async testGPURenderAndBindingCommandsMixin(\n    encoderType: RenderEncoderType,\n    fn: ({\n      passEncoder,\n      bindGroup,\n    }: {\n      passEncoder: GPURenderCommandsMixin & GPUBindingCommandsMixin;\n      bindGroup: GPUBindGroup;\n    }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { passEncoder, prep, test, bindGroup } = this.#getGPURenderCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  /**\n   * Creates GPUBindingCommandsMixin setup with some initial state.\n   */\n  #getGPUBindingCommandsMixin(encoderType: EncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'compute': {\n        const buffer = this.createBufferTracked({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const passEncoder = encoder.beginComputePass();\n        return {\n          passEncoder,\n          bindGroup,\n          prep() {\n            passEncoder.end();\n          },\n          test() {\n            encoder.finish();\n          },\n        };\n        break;\n      }\n      case 'render':\n        return this.#getGPURenderCommandsMixin('render');\n      case 'renderBundle':\n        return this.#getGPURenderCommandsMixin('renderBundle');\n    }\n  }\n\n  /**\n   * Tests a method on GPUBindingCommandsMixin\n   * The function pass will be called with the passEncoder and a bindGroup\n   */\n  async testGPUBindingCommandsMixin(\n    encoderType: EncoderType,\n    fn: ({ bindGroup }: { passEncoder: GPUBindingCommandsMixin; bindGroup: GPUBindGroup }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { passEncoder, bindGroup, prep, test } = this.#getGPUBindingCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  getModuleForWorkgroupSize(size: number[]) {\n    const { device } = this;\n    const code = `\n      @group(0) @binding(0) var<storage, read_write> d: f32;\n      @compute @workgroup_size(${size.join(',')}) fn main() {\n        d = 0;\n      }\n    `;\n    const module = device.createShaderModule({ code });\n    return { module, code };\n  }\n\n  skipIfNotEnoughStorageBuffersInStage(visibility: GPUShaderStageFlags, numRequired: number) {\n    const { device } = this;\n    this.skipIf(\n      this.isCompatibility &&\n        // If we're using the fragment stage\n        (visibility & GPUShaderStage.FRAGMENT) !== 0 &&\n        // If perShaderStage and inFragment stage are equal we want to\n        // allow the test to run as otherwise we can't test overMaximum and overLimit\n        device.limits.maxStorageBuffersPerShaderStage >\n          device.limits.maxStorageBuffersInFragmentStage! &&\n        // They aren't equal so if there aren't enough supported in the fragment then skip\n        !(device.limits.maxStorageBuffersInFragmentStage! >= numRequired),\n      `maxStorageBuffersInFragmentShader = ${device.limits.maxStorageBuffersInFragmentStage} which is less than ${numRequired}`\n    );\n\n    this.skipIf(\n      this.isCompatibility &&\n        // If we're using the vertex stage\n        (visibility & GPUShaderStage.VERTEX) !== 0 &&\n        // If perShaderStage and inVertex stage are equal we want to\n        // allow the test to run as otherwise we can't test overMaximum and overLimit\n        device.limits.maxStorageBuffersPerShaderStage >\n          device.limits.maxStorageBuffersInVertexStage! &&\n        // They aren't equal so if there aren't enough supported in the vertex then skip\n        !(device.limits.maxStorageBuffersInVertexStage! >= numRequired),\n      `maxStorageBuffersInVertexShader = ${device.limits.maxStorageBuffersInVertexStage} which is less than ${numRequired}`\n    );\n  }\n}\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(limit: GPUSupportedLimit): typeof LimitTestsImpl {\n  class LimitTests extends LimitTestsImpl {\n    override limit = limit;\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit: GPUSupportedLimit) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit));\n  return { g, description, limit };\n}\n"],"mappings":"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"}