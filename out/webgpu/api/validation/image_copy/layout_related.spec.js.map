{"version":3,"file":"layout_related.spec.js","names":["description","makeTestGroup","assert","kTextureFormatInfo","kSizedTextureFormats","textureDimensionAndFormatCompatible","kTextureDimensions","align","bytesInACompleteRow","dataBytesForCopyOrOverestimate","dataBytesForCopyOrFail","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","desc","params","u","combine","combineWithParams","dimension","size","beginSubcases","undefined","unless","p","copyHeightInBlocks","copyDepth","fn","t","rowsPerImage","method","format","copyHeight","blockHeight","texture","device","createTexture","usage","GPUTextureUsage","COPY_SRC","COPY_DST","layout","bytesPerRow","copySize","width","height","depthOrArrayLayers","minDataSizeOrOverestimate","copyValid","testRun","dataSize","success","_success","filter","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","_offsetMultiplier","info","depth","stencil","expand","bytesPerBlock","beforeAllSubcases","selectDeviceOrSkipTestCase","feature","offset","bytesPerRowAlignment","copyWidth","blockWidth","minDataSize","createAlignedTexture","expandWithParams","widthInBlocks","offsetInBlocks","dataSizeInBlocks"],"sources":["../../../../../src/webgpu/api/validation/image_copy/layout_related.spec.ts"],"sourcesContent":["export const description = `Validation tests for the linear data layout of linear data <-> texture copies\n\nTODO check if the tests need to be updated to support aspects of depth-stencil textures`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport {\n  kTextureFormatInfo,\n  kSizedTextureFormats,\n  textureDimensionAndFormatCompatible,\n  kTextureDimensions,\n} from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrOverestimate,\n  dataBytesForCopyOrFail,\n  kImageCopyTypes,\n} from '../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod,\n} from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('bound_on_rows_per_image')\n  .desc(\n    `\nTest that rowsPerImage must be at least the copy height (if defined).\n- for various copy methods\n- for all texture dimensions\n- for various values of rowsPerImage including undefined\n- for various copy heights\n- for various copy depths\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n      .beginSubcases()\n      .combine('rowsPerImage', [undefined, 0, 1, 2, 1024])\n      .combine('copyHeightInBlocks', [0, 1, 2])\n      .combine('copyDepth', [1, 3])\n      .unless(p => p.dimension === '1d' && p.copyHeightInBlocks !== 1)\n      .unless(p => p.copyDepth > p.size[2])\n  )\n  .fn(t => {\n    const { rowsPerImage, copyHeightInBlocks, copyDepth, dimension, size, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const copyHeight = copyHeightInBlocks * kTextureFormatInfo[format].blockHeight;\n\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const layout = { bytesPerRow: 1024, rowsPerImage };\n    const copySize = { width: 0, height: copyHeight, depthOrArrayLayers: copyDepth };\n    const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: copyValid,\n    });\n  });\n\ng.test('copy_end_overflows_u64')\n  .desc(\n    `\nTest an error is produced when offset+requiredBytesInCopy overflows GPUSize64.\n- for various copy methods\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 1, _success: true }, // success case\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 16, _success: false }, // bytesPerRow * rowsPerImage * (depthOrArrayLayers - 1) overflows.\n      ])\n  )\n  .fn(t => {\n    const { method, bytesPerRow, rowsPerImage, depthOrArrayLayers, _success } = t.params;\n\n    const texture = t.device.createTexture({\n      size: [1, 1, depthOrArrayLayers],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow, rowsPerImage },\n      { width: 1, height: 1, depthOrArrayLayers },\n      {\n        dataSize: 10000,\n        method,\n        success: _success,\n      }\n    );\n  });\n\ng.test('required_bytes_in_copy')\n  .desc(\n    `\nTest the computation of requiredBytesInCopy by computing the minimum data size for the copy and checking success/error at the boundary.\n- for various copy methods\n- for all formats\n- for all dimensions\n- for various extra bytesPerRow/rowsPerImage\n- for various copy sizes\n- for various offsets in the linear data\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combineWithParams([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combineWithParams([\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, _offsetMultiplier: 11 }, // standard copy, offset > 0\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, _offsetMultiplier: 0 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, _offsetMultiplier: 13 }, // empty copy because of depth, offset > 0\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // copyWidth = 1\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, _offsetMultiplier: 15 }, // copyHeight = 1, offset > 0\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, _offsetMultiplier: 0 }, // copyDepth = 1\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, _offsetMultiplier: 0 }, // copyHeight = 1 and copyDepth = 1\n      ])\n      // The test texture size will be rounded up from the copy size to the next valid texture size.\n      // If the format is a depth/stencil format, its copy size must equal to subresource's size.\n      // So filter out depth/stencil cases where the rounded-up texture size would be different from the copy size.\n      .filter(({ format, copyWidthInBlocks, copyHeightInBlocks, copyDepth }) => {\n        const info = kTextureFormatInfo[format];\n        return (\n          (!info.depth && !info.stencil) ||\n          (copyWidthInBlocks > 0 && copyHeightInBlocks > 0 && copyDepth > 0)\n        );\n      })\n      .unless(p => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1))\n      .expand('offset', p => {\n        const info = kTextureFormatInfo[p.format];\n        if (info.depth || info.stencil) {\n          return [p._offsetMultiplier * 4];\n        }\n        return [p._offsetMultiplier * info.bytesPerBlock];\n      })\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const {\n      offset,\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      dimension,\n      method,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n    const layout = { offset, bytesPerRow, rowsPerImage };\n    const minDataSize = dataBytesForCopyOrFail({ layout, format, copySize, method });\n\n    const texture = t.createAlignedTexture(format, copySize, undefined, dimension);\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSize,\n      method,\n      success: true,\n    });\n\n    if (minDataSize > 0) {\n      t.testRun({ texture }, layout, copySize, {\n        dataSize: minDataSize - 1,\n        method,\n        success: false,\n      });\n    }\n  });\n\ng.test('rows_per_image_alignment')\n  .desc(\n    `\nTest that rowsPerImage has no alignment constraints.\n- for various copy methods\n- for all sized format\n- for all dimensions\n- for various rowsPerImage\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .expand('rowsPerImage', texelBlockAlignmentTestExpanderForRowsPerImage)\n      // Copy height is info.blockHeight, so rowsPerImage must be equal or greater than it.\n      .filter(({ rowsPerImage, format }) => rowsPerImage >= kTextureFormatInfo[format].blockHeight)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const { rowsPerImage, format, method } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun({ texture }, { bytesPerRow: 256, rowsPerImage }, size, {\n      dataSize: info.bytesPerBlock,\n      method,\n      success: true,\n    });\n  });\n\ng.test('offset_alignment')\n  .desc(\n    `\nTest the alignment requirement on the linear data offset (block size, or 4 for depth-stencil).\n- for various copy methods\n- for all sized formats\n- for all dimensions\n- for various linear data offsets\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .expand('offset', texelBlockAlignmentTestExpanderForOffset)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const { format, offset, method } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    let success = false;\n    if (method === 'WriteTexture') success = true;\n    if (info.depth || info.stencil) {\n      if (offset % 4 === 0) success = true;\n    } else {\n      if (offset % info.bytesPerBlock === 0) success = true;\n    }\n\n    t.testRun({ texture }, { offset, bytesPerRow: 256 }, size, {\n      dataSize: offset + info.bytesPerBlock,\n      method,\n      success,\n    });\n  });\n\ng.test('bound_on_bytes_per_row')\n  .desc(\n    `\nTest that bytesPerRow, if specified must be big enough for a full copy row.\n- for various copy methods\n- for all sized formats\n- for all dimension\n- for various copy heights\n- for various copy depths\n- for various combinations of bytesPerRow and copy width.\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('format', kSizedTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('copyHeightInBlocks', [1, 2])\n      .combine('copyDepth', [1, 2])\n      .unless(p => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1))\n      .expandWithParams(p => {\n        const info = kTextureFormatInfo[p.format];\n        // We currently have a built-in assumption that for all formats, 128 % bytesPerBlock === 0.\n        // This assumption ensures that all division below results in integers.\n        assert(128 % info.bytesPerBlock === 0);\n        return [\n          // Copying exact fit with aligned bytesPerRow should work.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: true,\n          },\n          // Copying into smaller texture when padding in bytesPerRow is enough should work unless\n          // it is a depth/stencil typed format.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock - 1,\n            _success: !(info.stencil || info.depth),\n          },\n          // Unaligned bytesPerRow should not work unless the method is 'WriteTexture'.\n          {\n            bytesPerRow: 128,\n            widthInBlocks: 128 / info.bytesPerBlock,\n            copyWidthInBlocks: 128 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          {\n            bytesPerRow: 384,\n            widthInBlocks: 384 / info.bytesPerBlock,\n            copyWidthInBlocks: 384 / info.bytesPerBlock,\n            _success: p.method === 'WriteTexture',\n          },\n          // When bytesPerRow is smaller than bytesInLastRow copying should fail.\n          {\n            bytesPerRow: 256,\n            widthInBlocks: (2 * 256) / info.bytesPerBlock,\n            copyWidthInBlocks: (2 * 256) / info.bytesPerBlock,\n            _success: false,\n          },\n          // When copyHeightInBlocks > 1, bytesPerRow must be specified.\n          {\n            bytesPerRow: undefined,\n            widthInBlocks: 256 / info.bytesPerBlock,\n            copyWidthInBlocks: 256 / info.bytesPerBlock,\n            _success: !(p.copyHeightInBlocks > 1 || p.copyDepth > 1),\n          },\n        ];\n      })\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const {\n      method,\n      format,\n      bytesPerRow,\n      widthInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      _success,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n\n    // We create an aligned texture using the widthInBlocks which may be different from the\n    // copyWidthInBlocks. This allows us to test scenarios where the two may be different.\n    const texture = t.createAlignedTexture(format, {\n      width: widthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    });\n\n    const layout = { bytesPerRow, rowsPerImage: copyHeightInBlocks };\n    const copySize = {\n      width: copyWidthInBlocks * info.blockWidth,\n      height: copyHeightInBlocks * info.blockHeight,\n      depthOrArrayLayers: copyDepth,\n    };\n    const { minDataSizeOrOverestimate } = dataBytesForCopyOrOverestimate({\n      layout,\n      format,\n      copySize,\n      method,\n    });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSizeOrOverestimate,\n      method,\n      success: _success,\n    });\n  });\n\ng.test('bound_on_offset')\n  .desc(\n    `\nTest that the offset cannot be larger than the linear data size (even for an empty copy).\n- for various offsets and data sizes\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('offsetInBlocks', [0, 1, 2])\n      .combine('dataSizeInBlocks', [0, 1, 2])\n  )\n  .fn(t => {\n    const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const info = kTextureFormatInfo[format];\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const dataSize = dataSizeInBlocks * info.bytesPerBlock;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = offset <= dataSize;\n\n    t.testRun(\n      { texture },\n      { offset, bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize, method, success }\n    );\n  });\n"],"mappings":"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"}