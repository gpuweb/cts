{"version":3,"file":"texture_related.spec.js","names":["description","makeTestGroup","assert","kColorTextureFormats","kSizedTextureFormats","kTextureDimensions","kTextureFormatInfo","kTextureUsages","textureDimensionAndFormatCompatible","GPUConst","kResourceStates","align","virtualMipSize","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForValueToCoordinate","formatCopyableWithMethod","getACopyableAspectWithMethod","g","test","desc","params","u","combine","combineWithParams","dimension","size","fn","t","method","textureState","texture","createTextureWithState","format","usage","GPUTextureUsage","COPY_SRC","COPY_DST","success","submit","testRun","bytesPerRow","width","height","depthOrArrayLayers","dataSize","paramsSubcasesOnly","beforeAllSubcases","selectMismatchedDeviceOrSkipTestCase","undefined","mismatched","sourceDevice","mismatchedDevice","device","createTexture","beginSubcases","unless","usage0","usage1","TextureUsage","RENDER_ATTACHMENT","sampleCount","TEXTURE_BINDING","p","mipLevelCount","mipLevel","filter","expand","d","info","selectDeviceOrSkipTestCase","feature","copyWidthModifier","copyHeightModifier","copyDepthModifier","blockWidth","blockHeight","depth","stencil","levelSize","copySize","aspect","rowsPerImage","coordinateToTest","valueToCoordinate","origin","x","y","z","createAlignedTexture","Math","max","ceil","bytesPerBlock","originValue","copySizeValue","textureSizeValue","textureSize"],"sources":["../../../../../src/webgpu/api/validation/image_copy/texture_related.spec.ts"],"sourcesContent":["export const description = `Texture related validation tests for B2T copy and T2B copy and writeTexture.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport {\n  kColorTextureFormats,\n  kSizedTextureFormats,\n  kTextureDimensions,\n  kTextureFormatInfo,\n  kTextureUsages,\n  textureDimensionAndFormatCompatible,\n} from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { kResourceStates } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\nimport { virtualMipSize } from '../../../util/texture/base.js';\nimport { kImageCopyTypes } from '../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForValueToCoordinate,\n  formatCopyableWithMethod,\n  getACopyableAspectWithMethod,\n} from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('valid')\n  .desc(\n    `\nTest that the texture must be valid and not destroyed.\n- for all copy methods\n- for all texture states\n- for various dimensions\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combine('textureState', kResourceStates)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n  )\n  .fn(t => {\n    const { method, textureState, size, dimension } = t.params;\n\n    const texture = t.createTextureWithState(textureState, {\n      size,\n      dimension,\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = textureState === 'valid';\n    const submit = textureState !== 'invalid';\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success, submit }\n    );\n  });\n\ng.test('texture,device_mismatch')\n  .desc('Tests the image copies cannot be called with a texture created from another device')\n  .paramsSubcasesOnly(u =>\n    u.combine('method', kImageCopyTypes).combine('mismatched', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    t.selectMismatchedDeviceOrSkipTestCase(undefined);\n  })\n  .fn(t => {\n    const { method, mismatched } = t.params;\n    const sourceDevice = mismatched ? t.mismatchedDevice : t.device;\n\n    const texture = sourceDevice.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success: !mismatched }\n    );\n  });\n\ng.test('usage')\n  .desc(\n    `\nThe texture must have the appropriate COPY_SRC/COPY_DST usage.\n- for various copy methods\n- for various dimensions\n- for various usages\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n      .beginSubcases()\n      // If usage0 and usage1 are the same, the usage being test is a single usage. Otherwise, it's\n      // a combined usage.\n      .combine('usage0', kTextureUsages)\n      .combine('usage1', kTextureUsages)\n      // RENDER_ATTACHMENT is not valid with 1d and 3d textures.\n      .unless(\n        ({ usage0, usage1, dimension }) =>\n          ((usage0 | usage1) & GPUConst.TextureUsage.RENDER_ATTACHMENT) !== 0 &&\n          (dimension === '1d' || dimension === '3d')\n      )\n  )\n  .fn(t => {\n    const { usage0, usage1, method, size, dimension } = t.params;\n\n    const usage = usage0 | usage1;\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format: 'rgba8unorm',\n      usage,\n    });\n\n    const success =\n      method === 'CopyT2B'\n        ? (usage & GPUTextureUsage.COPY_SRC) !== 0\n        : (usage & GPUTextureUsage.COPY_DST) !== 0;\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('sample_count')\n  .desc(\n    `\nTest that multisampled textures cannot be copied.\n- for various copy methods\n- multisampled or not\n\nNote: we don't test 1D, 2D array and 3D textures because multisample is not supported them.\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('sampleCount', [1, 4])\n  )\n  .fn(t => {\n    const { sampleCount, method } = t.params;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      sampleCount,\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const success = sampleCount === 1;\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('mip_level')\n  .desc(\n    `\nTest that the mipLevel of the copy must be in range of the texture.\n- for various copy methods\n- for various dimensions\n- for several mipLevelCounts\n- for several target/source mipLevels`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [32, 1, 1] },\n        { dimension: '2d', size: [32, 32, 1] },\n        { dimension: '2d', size: [32, 32, 3] },\n        { dimension: '3d', size: [32, 32, 3] },\n      ] as const)\n      .beginSubcases()\n      .combine('mipLevelCount', [1, 3, 5])\n      .unless(p => p.dimension === '1d' && p.mipLevelCount !== 1)\n      .combine('mipLevel', [0, 1, 3, 4])\n  )\n  .fn(t => {\n    const { mipLevelCount, mipLevel, method, size, dimension } = t.params;\n\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      mipLevelCount,\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = mipLevel < mipLevelCount;\n\n    t.testRun(\n      { texture, mipLevel },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('format')\n  .desc(\n    `\nTest the copy must be a full subresource if the texture's format is depth/stencil format.\n- for various copy methods\n- for various dimensions\n- for all sized formats\n- for a couple target/source mipLevels\n- for some modifier (or not) for the full copy size\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { depthOrArrayLayers: 1, dimension: '1d' },\n        { depthOrArrayLayers: 1, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '2d' },\n        { depthOrArrayLayers: 32, dimension: '3d' },\n      ] as const)\n      .combine('format', kSizedTextureFormats)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .combine('mipLevel', [0, 2])\n      .unless(p => p.dimension === '1d' && p.mipLevel !== 0)\n      .combine('copyWidthModifier', [0, -1])\n      .combine('copyHeightModifier', [0, -1])\n      // If the texture has multiple depth/array slices and it is not a 3D texture, which means it is an array texture,\n      // depthModifier is not needed upon the third dimension. Because different layers are different subresources in\n      // an array texture. Whether it is a full copy or non-full copy doesn't make sense across different subresources.\n      // However, different depth slices on the same mip level are within the same subresource for a 3d texture. So we\n      // need to examine depth dimension via copyDepthModifier to determine whether it is a full copy for a 3D texture.\n      .expand('copyDepthModifier', ({ dimension: d }) => (d === '3d' ? [0, -1] : [0]))\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const {\n      method,\n      depthOrArrayLayers,\n      dimension,\n      format,\n      mipLevel,\n      copyWidthModifier,\n      copyHeightModifier,\n      copyDepthModifier,\n    } = t.params;\n\n    const info = kTextureFormatInfo[format];\n    const size = { width: 32 * info.blockWidth, height: 32 * info.blockHeight, depthOrArrayLayers };\n    if (dimension === '1d') {\n      size.height = 1;\n    }\n\n    const texture = t.device.createTexture({\n      size,\n      dimension,\n      format,\n      mipLevelCount: dimension === '1d' ? 1 : 5,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    let success = true;\n    if (\n      (info.depth || info.stencil) &&\n      (copyWidthModifier !== 0 || copyHeightModifier !== 0 || copyDepthModifier !== 0)\n    ) {\n      success = false;\n    }\n\n    const levelSize = virtualMipSize(\n      dimension,\n      [size.width, size.height, size.depthOrArrayLayers],\n      mipLevel\n    );\n    const copySize = [\n      levelSize[0] + copyWidthModifier * info.blockWidth,\n      levelSize[1] + copyHeightModifier * info.blockHeight,\n      // Note that compressed format is not supported for 3D textures yet, so there is no info.blockDepth.\n      levelSize[2] + copyDepthModifier,\n    ];\n\n    t.testRun(\n      { texture, mipLevel, aspect: getACopyableAspectWithMethod({ format, method }) },\n      { bytesPerRow: 512, rowsPerImage: 32 },\n      copySize,\n      {\n        dataSize: 512 * 32 * 32,\n        method,\n        success,\n      }\n    );\n  });\n\ng.test('origin_alignment')\n  .desc(\n    `\nTest that the texture copy origin must be aligned to the format's block size.\n- for various copy methods\n- for all color formats (depth stencil formats require a full copy)\n- for X, Y and Z coordinates\n- for various values for that coordinate depending on the block size\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      // No need to test depth/stencil formats because its copy origin must be [0, 0, 0], which is already aligned with block size.\n      .combine('format', kColorTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combineWithParams([\n        { depthOrArrayLayers: 1, dimension: '1d' },\n        { depthOrArrayLayers: 1, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '3d' },\n      ] as const)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('coordinateToTest', ['x', 'y', 'z'] as const)\n      .unless(p => p.dimension === '1d' && p.coordinateToTest !== 'x')\n      .expand('valueToCoordinate', texelBlockAlignmentTestExpanderForValueToCoordinate)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const {\n      valueToCoordinate,\n      coordinateToTest,\n      format,\n      method,\n      depthOrArrayLayers,\n      dimension,\n    } = t.params;\n    const info = kTextureFormatInfo[format];\n    const size = { width: 0, height: 0, depthOrArrayLayers };\n    const origin = { x: 0, y: 0, z: 0 };\n    let success = true;\n\n    origin[coordinateToTest] = valueToCoordinate;\n    switch (coordinateToTest) {\n      case 'x': {\n        success = origin.x % info.blockWidth === 0;\n        break;\n      }\n      case 'y': {\n        success = origin.y % info.blockHeight === 0;\n        break;\n      }\n    }\n\n    const texture = t.createAlignedTexture(format, size, origin, dimension);\n\n    t.testRun({ texture, origin }, { bytesPerRow: 0, rowsPerImage: 0 }, size, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n\ng.test('size_alignment')\n  .desc(\n    `\nTest that the copy size must be aligned to the texture's format's block size.\n- for various copy methods\n- for all formats (depth-stencil formats require a full copy)\n- for all texture dimensions\n- for the size's parameters to test (width / height / depth)\n- for various values for that copy size parameters, depending on the block size\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      // No need to test depth/stencil formats because its copy size must be subresource's size, which is already aligned with block size.\n      .combine('format', kColorTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('coordinateToTest', ['width', 'height', 'depthOrArrayLayers'] as const)\n      .unless(p => p.dimension === '1d' && p.coordinateToTest !== 'width')\n      .expand('valueToCoordinate', texelBlockAlignmentTestExpanderForValueToCoordinate)\n  )\n  .beforeAllSubcases(t => {\n    const info = kTextureFormatInfo[t.params.format];\n    t.selectDeviceOrSkipTestCase(info.feature);\n  })\n  .fn(t => {\n    const { valueToCoordinate, coordinateToTest, dimension, format, method } = t.params;\n    const info = kTextureFormatInfo[format];\n    const size = { width: 0, height: 0, depthOrArrayLayers: 0 };\n    const origin = { x: 0, y: 0, z: 0 };\n    let success = true;\n\n    size[coordinateToTest] = valueToCoordinate;\n    switch (coordinateToTest) {\n      case 'width': {\n        success = size.width % info.blockWidth === 0;\n        break;\n      }\n      case 'height': {\n        success = size.height % info.blockHeight === 0;\n        break;\n      }\n    }\n\n    const texture = t.createAlignedTexture(format, size, origin, dimension);\n\n    const bytesPerRow = align(\n      Math.max(1, Math.ceil(size.width / info.blockWidth)) * info.bytesPerBlock,\n      256\n    );\n    const rowsPerImage = Math.ceil(size.height / info.blockHeight);\n    t.testRun({ texture, origin }, { bytesPerRow, rowsPerImage }, size, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n\ng.test('copy_rectangle')\n  .desc(\n    `\nTest that the max corner of the copy rectangle (origin+copySize) must be inside the texture.\n- for various copy methods\n- for all dimensions\n- for the X, Y and Z dimensions\n- for various origin and copy size values (and texture sizes)\n- for various mip levels\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('dimension', kTextureDimensions)\n      .beginSubcases()\n      .combine('originValue', [7, 8])\n      .combine('copySizeValue', [7, 8])\n      .combine('textureSizeValue', [14, 15])\n      .combine('mipLevel', [0, 2])\n      .combine('coordinateToTest', [0, 1, 2] as const)\n      .unless(p => p.dimension === '1d' && (p.coordinateToTest !== 0 || p.mipLevel !== 0))\n  )\n  .fn(t => {\n    const {\n      originValue,\n      copySizeValue,\n      textureSizeValue,\n      mipLevel,\n      coordinateToTest,\n      method,\n      dimension,\n    } = t.params;\n    const format = 'rgba8unorm';\n    const info = kTextureFormatInfo[format];\n\n    const origin = [0, 0, 0];\n    const copySize = [0, 0, 0];\n    const textureSize = { width: 16 << mipLevel, height: 16 << mipLevel, depthOrArrayLayers: 16 };\n    if (dimension === '1d') {\n      textureSize.height = 1;\n      textureSize.depthOrArrayLayers = 1;\n    }\n    const success = originValue + copySizeValue <= textureSizeValue;\n\n    origin[coordinateToTest] = originValue;\n    copySize[coordinateToTest] = copySizeValue;\n    switch (coordinateToTest) {\n      case 0: {\n        textureSize.width = textureSizeValue << mipLevel;\n        break;\n      }\n      case 1: {\n        textureSize.height = textureSizeValue << mipLevel;\n        break;\n      }\n      case 2: {\n        textureSize.depthOrArrayLayers =\n          dimension === '3d' ? textureSizeValue << mipLevel : textureSizeValue;\n        break;\n      }\n    }\n\n    const texture = t.device.createTexture({\n      size: textureSize,\n      dimension,\n      mipLevelCount: dimension === '1d' ? 1 : 3,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    assert(copySize[0] % info.blockWidth === 0);\n    const bytesPerRow = align(copySize[0] / info.blockWidth, 256);\n    assert(copySize[1] % info.blockHeight === 0);\n    const rowsPerImage = copySize[1] / info.blockHeight;\n    t.testRun({ texture, origin, mipLevel }, { bytesPerRow, rowsPerImage }, copySize, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n"],"mappings":"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"}