{"version":3,"file":"texture_related.spec.js","names":["description","makeTestGroup","assert","kTextureDimensions","kTextureUsages","GPUConst","getBlockInfoForColorTextureFormat","getBlockInfoForSizedTextureFormat","getBlockInfoForTextureFormat","isDepthOrStencilTextureFormat","kColorTextureFormats","kSizedTextureFormats","textureDimensionAndFormatCompatible","kResourceStates","align","virtualMipSize","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForValueToCoordinate","formatCopyableWithMethod","getACopyableAspectWithMethod","g","test","desc","params","u","combine","combineWithParams","dimension","size","fn","t","method","textureState","texture","createTextureWithState","format","usage","GPUTextureUsage","COPY_SRC","COPY_DST","success","submit","testRun","bytesPerRow","width","height","depthOrArrayLayers","dataSize","paramsSubcasesOnly","beforeAllSubcases","usesMismatchedDevice","mismatched","sourceDevice","mismatchedDevice","device","trackForCleanup","createTexture","beginSubcases","unless","usage0","usage1","TextureUsage","RENDER_ATTACHMENT","createTextureTracked","sampleCount","TEXTURE_BINDING","p","mipLevelCount","mipLevel","filter","expand","d","copyWidthModifier","copyHeightModifier","copyDepthModifier","skipIfTextureFormatNotSupported","info","blockWidth","blockHeight","levelSize","copySize","aspect","rowsPerImage","coordinateToTest","valueToCoordinate","origin","x","y","z","createAlignedTexture","Math","max","ceil","bytesPerBlock","originValue","copySizeValue","textureSizeValue","textureSize"],"sources":["../../../../../src/webgpu/api/validation/image_copy/texture_related.spec.ts"],"sourcesContent":["export const description = `Texture related validation tests for B2T copy and T2B copy and writeTexture.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { kTextureDimensions, kTextureUsages } from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport {\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForSizedTextureFormat,\n  getBlockInfoForTextureFormat,\n  isDepthOrStencilTextureFormat,\n  kColorTextureFormats,\n  kSizedTextureFormats,\n  textureDimensionAndFormatCompatible,\n} from '../../../format_info.js';\nimport { kResourceStates } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\nimport { virtualMipSize } from '../../../util/texture/base.js';\nimport { kImageCopyTypes } from '../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForValueToCoordinate,\n  formatCopyableWithMethod,\n  getACopyableAspectWithMethod,\n} from './image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('valid')\n  .desc(\n    `\nTest that the texture must be valid and not destroyed.\n- for all copy methods\n- for all texture states\n- for various dimensions\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combine('textureState', kResourceStates)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n  )\n  .fn(t => {\n    const { method, textureState, size, dimension } = t.params;\n\n    const texture = t.createTextureWithState(textureState, {\n      size,\n      dimension,\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = textureState === 'valid';\n    const submit = textureState !== 'invalid';\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success, submit }\n    );\n  });\n\ng.test('texture,device_mismatch')\n  .desc('Tests the image copies cannot be called with a texture created from another device')\n  .paramsSubcasesOnly(u =>\n    u.combine('method', kImageCopyTypes).combine('mismatched', [true, false])\n  )\n  .beforeAllSubcases(t => t.usesMismatchedDevice())\n  .fn(t => {\n    const { method, mismatched } = t.params;\n    const sourceDevice = mismatched ? t.mismatchedDevice : t.device;\n\n    const texture = t.trackForCleanup(\n      sourceDevice.createTexture({\n        size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success: !mismatched }\n    );\n  });\n\ng.test('usage')\n  .desc(\n    `\nThe texture must have the appropriate COPY_SRC/COPY_DST usage.\n- for various copy methods\n- for various dimensions\n- for various usages\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [4, 1, 1] },\n        { dimension: '2d', size: [4, 4, 1] },\n        { dimension: '2d', size: [4, 4, 3] },\n        { dimension: '3d', size: [4, 4, 3] },\n      ] as const)\n      .beginSubcases()\n      // If usage0 and usage1 are the same, the usage being test is a single usage. Otherwise, it's\n      // a combined usage.\n      .combine('usage0', kTextureUsages)\n      .combine('usage1', kTextureUsages)\n      // RENDER_ATTACHMENT is not valid with 1d and 3d textures.\n      .unless(\n        ({ usage0, usage1, dimension }) =>\n          ((usage0 | usage1) & GPUConst.TextureUsage.RENDER_ATTACHMENT) !== 0 &&\n          (dimension === '1d' || dimension === '3d')\n      )\n  )\n  .fn(t => {\n    const { usage0, usage1, method, size, dimension } = t.params;\n\n    const usage = usage0 | usage1;\n    const texture = t.createTextureTracked({\n      size,\n      dimension,\n      format: 'rgba8unorm',\n      usage,\n    });\n\n    const success =\n      method === 'CopyT2B'\n        ? (usage & GPUTextureUsage.COPY_SRC) !== 0\n        : (usage & GPUTextureUsage.COPY_DST) !== 0;\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('sample_count')\n  .desc(\n    `\nTest that multisampled textures cannot be copied.\n- for various copy methods\n- multisampled or not\n\nNote: we don't test 1D, 2D array and 3D textures because multisample is not supported them.\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .beginSubcases()\n      .combine('sampleCount', [1, 4])\n  )\n  .fn(t => {\n    const { sampleCount, method } = t.params;\n\n    const texture = t.createTextureTracked({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      sampleCount,\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const success = sampleCount === 1;\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('mip_level')\n  .desc(\n    `\nTest that the mipLevel of the copy must be in range of the texture.\n- for various copy methods\n- for various dimensions\n- for several mipLevelCounts\n- for several target/source mipLevels`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { dimension: '1d', size: [32, 1, 1] },\n        { dimension: '2d', size: [32, 32, 1] },\n        { dimension: '2d', size: [32, 32, 3] },\n        { dimension: '3d', size: [32, 32, 3] },\n      ] as const)\n      .beginSubcases()\n      .combine('mipLevelCount', [1, 3, 5])\n      .unless(p => p.dimension === '1d' && p.mipLevelCount !== 1)\n      .combine('mipLevel', [0, 1, 3, 4])\n  )\n  .fn(t => {\n    const { mipLevelCount, mipLevel, method, size, dimension } = t.params;\n\n    const texture = t.createTextureTracked({\n      size,\n      dimension,\n      mipLevelCount,\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = mipLevel < mipLevelCount;\n\n    t.testRun(\n      { texture, mipLevel },\n      { bytesPerRow: 0 },\n      { width: 0, height: 0, depthOrArrayLayers: 0 },\n      { dataSize: 1, method, success }\n    );\n  });\n\ng.test('format')\n  .desc(\n    `\nTest the copy must be a full subresource if the texture's format is depth/stencil format.\n- for various copy methods\n- for various dimensions\n- for all sized formats\n- for a couple target/source mipLevels\n- for some modifier (or not) for the full copy size\n`\n  )\n  .params(u =>\n    u //\n      .combine('method', kImageCopyTypes)\n      .combineWithParams([\n        { depthOrArrayLayers: 1, dimension: '1d' },\n        { depthOrArrayLayers: 1, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '2d' },\n        { depthOrArrayLayers: 32, dimension: '3d' },\n      ] as const)\n      .combine('format', kSizedTextureFormats)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .filter(formatCopyableWithMethod)\n      .beginSubcases()\n      .combine('mipLevel', [0, 2])\n      .unless(p => p.dimension === '1d' && p.mipLevel !== 0)\n      .combine('copyWidthModifier', [0, -1])\n      .combine('copyHeightModifier', [0, -1])\n      // If the texture has multiple depth/array slices and it is not a 3D texture, which means it is an array texture,\n      // depthModifier is not needed upon the third dimension. Because different layers are different subresources in\n      // an array texture. Whether it is a full copy or non-full copy doesn't make sense across different subresources.\n      // However, different depth slices on the same mip level are within the same subresource for a 3d texture. So we\n      // need to examine depth dimension via copyDepthModifier to determine whether it is a full copy for a 3D texture.\n      .expand('copyDepthModifier', ({ dimension: d }) => (d === '3d' ? [0, -1] : [0]))\n  )\n  .fn(t => {\n    const {\n      method,\n      depthOrArrayLayers,\n      dimension,\n      format,\n      mipLevel,\n      copyWidthModifier,\n      copyHeightModifier,\n      copyDepthModifier,\n    } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = getBlockInfoForSizedTextureFormat(format);\n\n    const size = { width: 32 * info.blockWidth, height: 32 * info.blockHeight, depthOrArrayLayers };\n    if (dimension === '1d') {\n      size.height = 1;\n    }\n\n    const texture = t.createTextureTracked({\n      size,\n      dimension,\n      format,\n      mipLevelCount: dimension === '1d' ? 1 : 5,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    let success = true;\n    if (\n      isDepthOrStencilTextureFormat(format) &&\n      (copyWidthModifier !== 0 || copyHeightModifier !== 0 || copyDepthModifier !== 0)\n    ) {\n      success = false;\n    }\n\n    const levelSize = virtualMipSize(dimension, size, mipLevel);\n    const copySize = [\n      levelSize[0] + copyWidthModifier * info.blockWidth,\n      levelSize[1] + copyHeightModifier * info.blockHeight,\n      // Note that compressed format is not supported for 3D textures yet, so there is no info.blockDepth.\n      levelSize[2] + copyDepthModifier,\n    ];\n\n    t.testRun(\n      { texture, mipLevel, aspect: getACopyableAspectWithMethod({ format, method }) },\n      { bytesPerRow: 512, rowsPerImage: 32 },\n      copySize,\n      {\n        dataSize: 512 * 32 * 32,\n        method,\n        success,\n      }\n    );\n  });\n\ng.test('origin_alignment')\n  .desc(\n    `\nTest that the texture copy origin must be aligned to the format's block size.\n- for various copy methods\n- for all color formats (depth stencil formats require a full copy)\n- for X, Y and Z coordinates\n- for various values for that coordinate depending on the block size\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      // No need to test depth/stencil formats because its copy origin must be [0, 0, 0], which is already aligned with block size.\n      .combine('format', kColorTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combineWithParams([\n        { depthOrArrayLayers: 1, dimension: '1d' },\n        { depthOrArrayLayers: 1, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '2d' },\n        { depthOrArrayLayers: 3, dimension: '3d' },\n      ] as const)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('coordinateToTest', ['x', 'y', 'z'] as const)\n      .unless(p => p.dimension === '1d' && p.coordinateToTest !== 'x')\n      .expand('valueToCoordinate', texelBlockAlignmentTestExpanderForValueToCoordinate)\n  )\n  .fn(t => {\n    const { valueToCoordinate, coordinateToTest, format, method, depthOrArrayLayers, dimension } =\n      t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = getBlockInfoForTextureFormat(format);\n    const size = { width: 0, height: 0, depthOrArrayLayers };\n    const origin = { x: 0, y: 0, z: 0 };\n    let success = true;\n\n    origin[coordinateToTest] = valueToCoordinate;\n    switch (coordinateToTest) {\n      case 'x': {\n        success = origin.x % info.blockWidth === 0;\n        break;\n      }\n      case 'y': {\n        success = origin.y % info.blockHeight === 0;\n        break;\n      }\n    }\n\n    const texture = t.createAlignedTexture(format, size, origin, dimension);\n\n    t.testRun({ texture, origin }, { bytesPerRow: 0, rowsPerImage: 0 }, size, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n\ng.test('size_alignment')\n  .desc(\n    `\nTest that the copy size must be aligned to the texture's format's block size.\n- for various copy methods\n- for all formats (depth-stencil formats require a full copy)\n- for all texture dimensions\n- for the size's parameters to test (width / height / depth)\n- for various values for that copy size parameters, depending on the block size\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      // No need to test depth/stencil formats because its copy size must be subresource's size, which is already aligned with block size.\n      .combine('format', kColorTextureFormats)\n      .filter(formatCopyableWithMethod)\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format))\n      .beginSubcases()\n      .combine('coordinateToTest', ['width', 'height', 'depthOrArrayLayers'] as const)\n      .unless(p => p.dimension === '1d' && p.coordinateToTest !== 'width')\n      .expand('valueToCoordinate', texelBlockAlignmentTestExpanderForValueToCoordinate)\n  )\n  .fn(t => {\n    const { valueToCoordinate, coordinateToTest, dimension, format, method } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    const info = getBlockInfoForColorTextureFormat(format);\n    const size = { width: 0, height: 0, depthOrArrayLayers: 0 };\n    const origin = { x: 0, y: 0, z: 0 };\n    let success = true;\n\n    size[coordinateToTest] = valueToCoordinate;\n    switch (coordinateToTest) {\n      case 'width': {\n        success = size.width % info.blockWidth === 0;\n        break;\n      }\n      case 'height': {\n        success = size.height % info.blockHeight === 0;\n        break;\n      }\n    }\n\n    const texture = t.createAlignedTexture(format, size, origin, dimension);\n\n    const bytesPerRow = align(\n      Math.max(1, Math.ceil(size.width / info.blockWidth)) * info.bytesPerBlock,\n      256\n    );\n    const rowsPerImage = Math.ceil(size.height / info.blockHeight);\n    t.testRun({ texture, origin }, { bytesPerRow, rowsPerImage }, size, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n\ng.test('copy_rectangle')\n  .desc(\n    `\nTest that the max corner of the copy rectangle (origin+copySize) must be inside the texture.\n- for various copy methods\n- for all dimensions\n- for the X, Y and Z dimensions\n- for various origin and copy size values (and texture sizes)\n- for various mip levels\n`\n  )\n  .params(u =>\n    u\n      .combine('method', kImageCopyTypes)\n      .combine('dimension', kTextureDimensions)\n      .beginSubcases()\n      .combine('originValue', [7, 8])\n      .combine('copySizeValue', [7, 8])\n      .combine('textureSizeValue', [14, 15])\n      .combine('mipLevel', [0, 2])\n      .combine('coordinateToTest', [0, 1, 2] as const)\n      .unless(p => p.dimension === '1d' && (p.coordinateToTest !== 0 || p.mipLevel !== 0))\n  )\n  .fn(t => {\n    const {\n      originValue,\n      copySizeValue,\n      textureSizeValue,\n      mipLevel,\n      coordinateToTest,\n      method,\n      dimension,\n    } = t.params;\n    const format = 'rgba8unorm';\n    const info = getBlockInfoForColorTextureFormat(format);\n\n    const origin = [0, 0, 0];\n    const copySize = [0, 0, 0];\n    const textureSize = { width: 16 << mipLevel, height: 16 << mipLevel, depthOrArrayLayers: 16 };\n    if (dimension === '1d') {\n      textureSize.height = 1;\n      textureSize.depthOrArrayLayers = 1;\n    }\n    const success = originValue + copySizeValue <= textureSizeValue;\n\n    origin[coordinateToTest] = originValue;\n    copySize[coordinateToTest] = copySizeValue;\n    switch (coordinateToTest) {\n      case 0: {\n        textureSize.width = textureSizeValue << mipLevel;\n        break;\n      }\n      case 1: {\n        textureSize.height = textureSizeValue << mipLevel;\n        break;\n      }\n      case 2: {\n        textureSize.depthOrArrayLayers =\n          dimension === '3d' ? textureSizeValue << mipLevel : textureSizeValue;\n        break;\n      }\n    }\n\n    const texture = t.createTextureTracked({\n      size: textureSize,\n      dimension,\n      mipLevelCount: dimension === '1d' ? 1 : 3,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    assert(copySize[0] % info.blockWidth === 0);\n    const bytesPerRow = align(copySize[0] / info.blockWidth, 256);\n    assert(copySize[1] % info.blockHeight === 0);\n    const rowsPerImage = copySize[1] / info.blockHeight;\n    t.testRun({ texture, origin, mipLevel }, { bytesPerRow, rowsPerImage }, copySize, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n"],"mappings":"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"}