{"version":3,"file":"image_copy.js","names":["depthStencilFormatCopyableAspects","kTextureFormatInfo","isCompressedTextureFormat","align","ValidationTest","ImageCopyTest","testRun","textureCopyView","textureDataLayout","size","method","dataSize","success","submit","data","Uint8Array","expectValidationError","device","queue","writeTexture","buffer","createBuffer","usage","GPUBufferUsage","COPY_SRC","trackForCleanup","encoder","createCommandEncoder","copyBufferToTexture","cmd","finish","isCompatibility","texture","format","skip","COPY_DST","copyTextureToBuffer","createAlignedTexture","width","height","depthOrArrayLayers","origin","x","y","z","dimension","info","alignedSize","Math","max","blockWidth","blockHeight","createTexture","GPUTextureUsage","testBuffer","validateFinish","validateFinishAndSubmit","createEncoder","valuesToTestDivisibilityBy","number","values","i","push","texelBlockAlignmentTestExpanderForOffset","depth","stencil","bytesPerBlock","texelBlockAlignmentTestExpanderForRowsPerImage","texelBlockAlignmentTestExpanderForValueToCoordinate","coordinateToTest","formatCopyableWithMethod","supportedAspects","length","color","copySrc","copyDst","getACopyableAspectWithMethod"],"sources":["../../../../../src/webgpu/api/validation/image_copy/image_copy.ts"],"sourcesContent":["import {\n  depthStencilFormatCopyableAspects,\n  DepthStencilFormat,\n  SizedTextureFormat,\n  kTextureFormatInfo,\n  isCompressedTextureFormat,\n} from '../../../format_info.js';\nimport { align } from '../../../util/math.js';\nimport { ImageCopyType } from '../../../util/texture/layout.js';\nimport { ValidationTest } from '../validation_test.js';\n\nexport class ImageCopyTest extends ValidationTest {\n  testRun(\n    textureCopyView: GPUImageCopyTexture,\n    textureDataLayout: GPUImageDataLayout,\n    size: GPUExtent3D,\n    {\n      method,\n      dataSize,\n      success,\n      submit = false,\n    }: {\n      method: ImageCopyType;\n      dataSize: number;\n      success: boolean;\n      /** If submit is true, the validation error is expected to come from the submit and encoding\n       * should succeed. */\n      submit?: boolean;\n    }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.queue.writeTexture(textureCopyView, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n        this.trackForCleanup(buffer);\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, textureCopyView, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n      case 'CopyT2B': {\n        if (this.isCompatibility && isCompressedTextureFormat(textureCopyView.texture.format)) {\n          this.skip(\n            'copyTextureToBuffer is not supported for compressed texture formats in compatibility mode.'\n          );\n        }\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_DST,\n        });\n        this.trackForCleanup(buffer);\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyTextureToBuffer(textureCopyView, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n    }\n  }\n\n  /**\n   * Creates a texture when all that is needed is an aligned texture given the format and desired\n   * dimensions/origin. The resultant texture guarantees that a copy with the same size and origin\n   * should be possible.\n   */\n  createAlignedTexture(\n    format: SizedTextureFormat,\n    size: Required<GPUExtent3DDict> = {\n      width: 1,\n      height: 1,\n      depthOrArrayLayers: 1,\n    },\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 },\n    dimension: Required<GPUTextureDimension> = '2d'\n  ): GPUTexture {\n    const info = kTextureFormatInfo[format];\n    const alignedSize = {\n      width: align(Math.max(1, size.width + origin.x), info.blockWidth),\n      height: align(Math.max(1, size.height + origin.y), info.blockHeight),\n      depthOrArrayLayers: Math.max(1, size.depthOrArrayLayers + origin.z),\n    };\n    return this.device.createTexture({\n      size: alignedSize,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n  }\n\n  testBuffer(\n    buffer: GPUBuffer,\n    texture: GPUTexture,\n    textureDataLayout: GPUImageDataLayout,\n    size: GPUExtent3D,\n    {\n      method,\n      dataSize,\n      success,\n      submit = true,\n    }: {\n      method: ImageCopyType;\n      dataSize: number;\n      success: boolean;\n      /** If submit is true, the validation error is expected to come from the submit and encoding\n       * should succeed. */\n      submit?: boolean;\n    }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.queue.writeTexture({ texture }, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyB2T': {\n        const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, { texture }, size);\n\n        if (submit) {\n          // validation error is expected to come from the submit and encoding should succeed\n          validateFinishAndSubmit(true, success);\n        } else {\n          // validation error is expected to come from the encoding\n          validateFinish(success);\n        }\n\n        break;\n      }\n      case 'CopyT2B': {\n        if (this.isCompatibility && isCompressedTextureFormat(texture.format)) {\n          this.skip(\n            'copyTextureToBuffer is not supported for compressed texture formats in compatibility mode.'\n          );\n        }\n        const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n        encoder.copyTextureToBuffer({ texture }, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          // validation error is expected to come from the submit and encoding should succeed\n          validateFinishAndSubmit(true, success);\n        } else {\n          // validation error is expected to come from the encoding\n          validateFinish(success);\n        }\n\n        break;\n      }\n    }\n  }\n}\n\n// For testing divisibility by a number we test all the values returned by this function:\nfunction valuesToTestDivisibilityBy(number: number): Iterable<number> {\n  const values = [];\n  for (let i = 0; i <= 2 * number; ++i) {\n    values.push(i);\n  }\n  values.push(3 * number);\n  return values;\n}\n\ninterface WithFormat {\n  format: SizedTextureFormat;\n}\n\ninterface WithFormatAndCoordinate extends WithFormat {\n  coordinateToTest: keyof GPUOrigin3DDict | keyof GPUExtent3DDict;\n}\n\ninterface WithFormatAndMethod extends WithFormat {\n  method: ImageCopyType;\n}\n\n// This is a helper function used for expanding test parameters for offset alignment, by spec\nexport function texelBlockAlignmentTestExpanderForOffset({ format }: WithFormat) {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    return valuesToTestDivisibilityBy(4);\n  }\n\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].bytesPerBlock);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on rowsPerImage\nexport function texelBlockAlignmentTestExpanderForRowsPerImage({ format }: WithFormat) {\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on origin and size\nexport function texelBlockAlignmentTestExpanderForValueToCoordinate({\n  format,\n  coordinateToTest,\n}: WithFormatAndCoordinate) {\n  switch (coordinateToTest) {\n    case 'x':\n    case 'width':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockWidth);\n\n    case 'y':\n    case 'height':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight);\n\n    case 'z':\n    case 'depthOrArrayLayers':\n      return valuesToTestDivisibilityBy(1);\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function formatCopyableWithMethod({ format, method }: WithFormatAndMethod): boolean {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects: readonly GPUTextureAspect[] = depthStencilFormatCopyableAspects(\n      method,\n      format as DepthStencilFormat\n    );\n    return supportedAspects.length > 0;\n  }\n  if (method === 'CopyT2B') {\n    return info.color.copySrc;\n  } else {\n    return info.color.copyDst;\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function getACopyableAspectWithMethod({\n  format,\n  method,\n}: WithFormatAndMethod): GPUTextureAspect {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects: readonly GPUTextureAspect[] = depthStencilFormatCopyableAspects(\n      method,\n      format as DepthStencilFormat\n    );\n    return supportedAspects[0];\n  }\n  return 'all' as GPUTextureAspect;\n}\n"],"mappings":"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"}