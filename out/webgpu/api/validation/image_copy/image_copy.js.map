{"version":3,"sources":["../../../../../src/webgpu/api/validation/image_copy/image_copy.ts"],"names":["kTextureFormatInfo","depthStencilFormatCopyableAspects","align","ValidationTest","ImageCopyTest","testRun","textureCopyView","textureDataLayout","size","method","dataSize","success","submit","data","Uint8Array","expectValidationError","device","queue","writeTexture","buffer","createBuffer","usage","GPUBufferUsage","COPY_SRC","trackForCleanup","encoder","createCommandEncoder","copyBufferToTexture","cmd","finish","COPY_DST","copyTextureToBuffer","createAlignedTexture","format","width","height","depthOrArrayLayers","origin","x","y","z","dimension","info","alignedSize","Math","max","blockWidth","blockHeight","createTexture","GPUTextureUsage","testBuffer","texture","validateFinish","validateFinishAndSubmit","createEncoder","valuesToTestDivisibilityBy","number","values","i","push","texelBlockAlignmentTestExpanderForOffset","depth","stencil","bytesPerBlock","texelBlockAlignmentTestExpanderForRowsPerImage","texelBlockAlignmentTestExpanderForValueToCoordinate","coordinateToTest","formatCopyableWithMethod","supportedAspects","length","copySrc","copyDst","getACopyableAspectWithMethod"],"mappings":"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","sourcesContent":["import {\n  kTextureFormatInfo,\n  SizedTextureFormat,\n  DepthStencilFormat,\n  depthStencilFormatCopyableAspects,\n} from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport { ImageCopyType } from '../../../util/texture/layout.js';\nimport { ValidationTest } from '../validation_test.js';\n\nexport class ImageCopyTest extends ValidationTest {\n  testRun(\n    textureCopyView: GPUImageCopyTexture,\n    textureDataLayout: GPUImageDataLayout,\n    size: GPUExtent3D,\n    {\n      method,\n      dataSize,\n      success,\n      submit = false,\n    }: {\n      method: ImageCopyType;\n      dataSize: number;\n      success: boolean;\n      /** If submit is true, the validation error is expected to come from the submit and encoding\n       * should succeed. */\n      submit?: boolean;\n    }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.queue.writeTexture(textureCopyView, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n        this.trackForCleanup(buffer);\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, textureCopyView, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n      case 'CopyT2B': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_DST,\n        });\n        this.trackForCleanup(buffer);\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyTextureToBuffer(textureCopyView, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n    }\n  }\n\n  /**\n   * Creates a texture when all that is needed is an aligned texture given the format and desired\n   * dimensions/origin. The resultant texture guarantees that a copy with the same size and origin\n   * should be possible.\n   */\n  createAlignedTexture(\n    format: SizedTextureFormat,\n    size: Required<GPUExtent3DDict> = {\n      width: 1,\n      height: 1,\n      depthOrArrayLayers: 1,\n    },\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 },\n    dimension: Required<GPUTextureDimension> = '2d'\n  ): GPUTexture {\n    const info = kTextureFormatInfo[format];\n    const alignedSize = {\n      width: align(Math.max(1, size.width + origin.x), info.blockWidth),\n      height: align(Math.max(1, size.height + origin.y), info.blockHeight),\n      depthOrArrayLayers: Math.max(1, size.depthOrArrayLayers + origin.z),\n    };\n    return this.device.createTexture({\n      size: alignedSize,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n  }\n\n  testBuffer(\n    buffer: GPUBuffer,\n    texture: GPUTexture,\n    textureDataLayout: GPUImageDataLayout,\n    size: GPUExtent3D,\n    {\n      method,\n      dataSize,\n      success,\n      submit = true,\n    }: {\n      method: ImageCopyType;\n      dataSize: number;\n      success: boolean;\n      /** If submit is true, the validation error is expected to come from the submit and encoding\n       * should succeed. */\n      submit?: boolean;\n    }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.queue.writeTexture({ texture }, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyB2T': {\n        const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, { texture }, size);\n\n        if (submit) {\n          // validation error is expected to come from the submit and encoding should succeed\n          validateFinishAndSubmit(true, success);\n        } else {\n          // validation error is expected to come from the encoding\n          validateFinish(success);\n        }\n\n        break;\n      }\n      case 'CopyT2B': {\n        const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n        encoder.copyTextureToBuffer({ texture }, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          // validation error is expected to come from the submit and encoding should succeed\n          validateFinishAndSubmit(true, success);\n        } else {\n          // validation error is expected to come from the encoding\n          validateFinish(success);\n        }\n\n        break;\n      }\n    }\n  }\n}\n\n// For testing divisibility by a number we test all the values returned by this function:\nfunction valuesToTestDivisibilityBy(number: number): Iterable<number> {\n  const values = [];\n  for (let i = 0; i <= 2 * number; ++i) {\n    values.push(i);\n  }\n  values.push(3 * number);\n  return values;\n}\n\ninterface WithFormat {\n  format: SizedTextureFormat;\n}\n\ninterface WithFormatAndCoordinate extends WithFormat {\n  coordinateToTest: keyof GPUOrigin3DDict | keyof GPUExtent3DDict;\n}\n\ninterface WithFormatAndMethod extends WithFormat {\n  method: ImageCopyType;\n}\n\n// This is a helper function used for expanding test parameters for offset alignment, by spec\nexport function texelBlockAlignmentTestExpanderForOffset({ format }: WithFormat) {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    return valuesToTestDivisibilityBy(4);\n  }\n\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].bytesPerBlock);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on rowsPerImage\nexport function texelBlockAlignmentTestExpanderForRowsPerImage({ format }: WithFormat) {\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on origin and size\nexport function texelBlockAlignmentTestExpanderForValueToCoordinate({\n  format,\n  coordinateToTest,\n}: WithFormatAndCoordinate) {\n  switch (coordinateToTest) {\n    case 'x':\n    case 'width':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockWidth!);\n\n    case 'y':\n    case 'height':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight!);\n\n    case 'z':\n    case 'depthOrArrayLayers':\n      return valuesToTestDivisibilityBy(1);\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function formatCopyableWithMethod({ format, method }: WithFormatAndMethod): boolean {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects: readonly GPUTextureAspect[] = depthStencilFormatCopyableAspects(\n      method,\n      format as DepthStencilFormat\n    );\n    return supportedAspects.length > 0;\n  }\n  if (method === 'CopyT2B') {\n    return info.copySrc;\n  } else {\n    return info.copyDst;\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function getACopyableAspectWithMethod({\n  format,\n  method,\n}: WithFormatAndMethod): GPUTextureAspect {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects: readonly GPUTextureAspect[] = depthStencilFormatCopyableAspects(\n      method,\n      format as DepthStencilFormat\n    );\n    return supportedAspects[0];\n  }\n  return 'all' as GPUTextureAspect;\n}\n"],"file":"image_copy.js"}