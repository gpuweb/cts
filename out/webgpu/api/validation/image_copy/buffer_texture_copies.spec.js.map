{"version":3,"file":"buffer_texture_copies.spec.js","names":["description","makeTestGroup","assert","unreachable","kBufferUsages","kTextureDimensions","kTextureUsages","GPUConst","kDepthStencilFormats","depthStencilBufferTextureCopySupported","depthStencilFormatAspectSize","kColorTextureFormats","canCopyFromAllAspectsOfTextureFormat","canCopyToAllAspectsOfTextureFormat","textureFormatAndDimensionPossiblyCompatible","getBlockInfoForColorTextureFormat","AllFeaturesMaxLimitsGPUTest","align","kBufferCopyAlignment","kBytesPerRowAlignment","ImageCopyTest","testCopyBufferToTexture","source","destination","copySize","isSuccess","encoder","validateFinishAndSubmit","createEncoder","copyBufferToTexture","testCopyTextureToBuffer","copyTextureToBuffer","testWriteTexture","uploadData","dataLayout","expectGPUError","queue","writeTexture","g","test","desc","params","u","combine","beginSubcases","fn","t","format","aspect","skipIfTextureFormatNotSupported","textureSize","width","height","depthOrArrayLayers","texture","createTextureTracked","size","usage","GPUTextureUsage","COPY_SRC","COPY_DST","uploadBufferSize","buffer","createBufferTracked","GPUBufferUsage","success","Uint8Array","filter","param","copyType","texelAspectSize","bytesPerRowAlignment","bytesPerRow","rowsPerImage","minimumBufferSize","bigEnoughBuffer","smallerBuffer","enoughUploadData","smallerUploadData","offset","sampleCount","RENDER_ATTACHMENT","kRequiredTextureUsage","CopyT2B","TextureUsage","CopyB2T","kRequiredBufferUsage","BufferUsage","unless","textureUsage","TRANSIENT_ATTACHMENT","expand","p","bufferUsage","_textureUsageValid","_bufferUsageValid","combineWithParams","bufMismatched","texMismatched","beforeAllSubcases","usesMismatchedDevice","trackForCleanup","mismatchedDevice","device","createBuffer","createTexture","isValid","dimension","xInBlocks","yInBlocks","copyWidthInBlocks","copyHeightInBlocks","offsetInBlocks","bytesPerRowAlign","bytesPerBlock","skipIfTextureFormatAndDimensionNotCompatible","skipIfTextureFormatDoesNotSupportCopyTextureToBuffer","info","widthBlocks","Math","ceil","heightBlocks","copySizeBlocks","texSizeBlocks","origin","blockWidth","blockHeight","textureBytePerRow","totalRows","bufferSize","label","shouldSucceed","debug"],"sources":["../../../../../src/webgpu/api/validation/image_copy/buffer_texture_copies.spec.ts"],"sourcesContent":["export const description = `\ncopyTextureToBuffer and copyBufferToTexture validation tests not covered by\nthe general image_copy tests, or by destroyed,*.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kBufferUsages, kTextureDimensions, kTextureUsages } from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport {\n  kDepthStencilFormats,\n  depthStencilBufferTextureCopySupported,\n  depthStencilFormatAspectSize,\n  kColorTextureFormats,\n  canCopyFromAllAspectsOfTextureFormat,\n  canCopyToAllAspectsOfTextureFormat,\n  textureFormatAndDimensionPossiblyCompatible,\n  getBlockInfoForColorTextureFormat,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\nimport { kBufferCopyAlignment, kBytesPerRowAlignment } from '../../../util/texture/layout.js';\n\nclass ImageCopyTest extends AllFeaturesMaxLimitsGPUTest {\n  testCopyBufferToTexture(\n    source: GPUTexelCopyBufferInfo,\n    destination: GPUTexelCopyTextureInfo,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const { encoder, validateFinishAndSubmit } = this.createEncoder('non-pass');\n    encoder.copyBufferToTexture(source, destination, copySize);\n    validateFinishAndSubmit(isSuccess, true);\n  }\n\n  testCopyTextureToBuffer(\n    source: GPUTexelCopyTextureInfo,\n    destination: GPUTexelCopyBufferInfo,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const { encoder, validateFinishAndSubmit } = this.createEncoder('non-pass');\n    encoder.copyTextureToBuffer(source, destination, copySize);\n    validateFinishAndSubmit(isSuccess, true);\n  }\n\n  testWriteTexture(\n    destination: GPUTexelCopyTextureInfo,\n    uploadData: Uint8Array,\n    dataLayout: GPUTexelCopyBufferLayout,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    this.expectGPUError(\n      'validation',\n      () => this.queue.writeTexture(destination, uploadData, dataLayout, copySize),\n      !isSuccess\n    );\n  }\n}\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('depth_stencil_format,copy_usage_and_aspect')\n  .desc(\n    `\n  Validate the combination of usage and aspect of each depth stencil format in copyBufferToTexture,\n  copyTextureToBuffer and writeTexture. See https://gpuweb.github.io/gpuweb/#depth-formats for more\n  details.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthStencilFormats)\n      .beginSubcases()\n      .combine('aspect', ['all', 'depth-only', 'stencil-only'] as const)\n  )\n  .fn(t => {\n    const { format, aspect } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.createTextureTracked({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const uploadBufferSize = 32;\n    const buffer = t.createBufferTracked({\n      size: uploadBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyB2T', format, aspect);\n      t.testCopyBufferToTexture({ buffer }, { texture, aspect }, textureSize, success);\n    }\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyT2B', format, aspect);\n      t.testCopyTextureToBuffer({ texture, aspect }, { buffer }, textureSize, success);\n    }\n\n    {\n      const success = depthStencilBufferTextureCopySupported('WriteTexture', format, aspect);\n      const uploadData = new Uint8Array(uploadBufferSize);\n      t.testWriteTexture({ texture, aspect }, uploadData, {}, textureSize, success);\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_size')\n  .desc(\n    `\n  Validate the minimum buffer size for each depth stencil format in copyBufferToTexture,\n  copyTextureToBuffer and writeTexture.\n\n  Given a depth stencil format, a copy aspect ('depth-only' or 'stencil-only'), the copy method\n  (buffer-to-texture or texture-to-buffer) and the copy size, validate\n  - if the copy can be successfully executed with the minimum required buffer size.\n  - if the copy fails with a validation error when the buffer size is less than the minimum\n  required buffer size.\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .combine('copyType', ['CopyB2T', 'CopyT2B', 'WriteTexture'] as const)\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n      .beginSubcases()\n      .combine('copySize', [\n        { width: 8, height: 1, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 3 },\n      ])\n  )\n  .fn(t => {\n    const { format, aspect, copyType, copySize } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n\n    const texture = t.createTextureTracked({\n      size: copySize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRowAlignment = copyType === 'WriteTexture' ? 1 : kBytesPerRowAlignment;\n    const bytesPerRow = align(texelAspectSize * copySize.width, bytesPerRowAlignment);\n    const rowsPerImage = copySize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * copySize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * copySize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const bigEnoughBuffer = t.createBufferTracked({\n      size: minimumBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const smallerBuffer = t.createBufferTracked({\n      size: minimumBufferSize - kBufferCopyAlignment,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        true\n      );\n      t.testCopyBufferToTexture(\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        false\n      );\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        true\n      );\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        false\n      );\n    } else if (copyType === 'WriteTexture') {\n      const enoughUploadData = new Uint8Array(minimumBufferSize);\n      const smallerUploadData = new Uint8Array(minimumBufferSize - kBufferCopyAlignment);\n      t.testWriteTexture(\n        { texture, aspect },\n        enoughUploadData,\n        {\n          bytesPerRow,\n          rowsPerImage,\n        },\n        copySize,\n        true\n      );\n\n      t.testWriteTexture(\n        { texture, aspect },\n        smallerUploadData,\n        {\n          bytesPerRow,\n          rowsPerImage,\n        },\n        copySize,\n        false\n      );\n    } else {\n      unreachable();\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_offset')\n  .desc(\n    `\n    Validate for every depth stencil formats the buffer offset must be a multiple of 4 in\n    copyBufferToTexture() and copyTextureToBuffer(), but the offset in writeTexture() doesn't always\n    need to be a multiple of 4.\n    `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .combine('aspect', ['depth-only', 'stencil-only'] as const)\n      .combine('copyType', ['CopyB2T', 'CopyT2B', 'WriteTexture'] as const)\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n      .beginSubcases()\n      .combine('offset', [1, 2, 4, 6, 8])\n  )\n  .fn(t => {\n    const { format, aspect, copyType, offset } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n\n    const textureSize = { width: 4, height: 4, depthOrArrayLayers: 1 };\n\n    const texture = t.createTextureTracked({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRowAlignment = copyType === 'WriteTexture' ? 1 : kBytesPerRowAlignment;\n    const bytesPerRow = align(texelAspectSize * textureSize.width, bytesPerRowAlignment);\n    const rowsPerImage = textureSize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * textureSize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * textureSize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const buffer = t.createBufferTracked({\n      size: align(minimumBufferSize + offset, kBufferCopyAlignment),\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const isSuccess = copyType === 'WriteTexture' ? true : offset % 4 === 0;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        textureSize,\n        isSuccess\n      );\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        textureSize,\n        isSuccess\n      );\n    } else if (copyType === 'WriteTexture') {\n      const uploadData = new Uint8Array(minimumBufferSize + offset);\n      t.testWriteTexture(\n        { texture, aspect },\n        uploadData,\n        {\n          offset,\n          bytesPerRow,\n          rowsPerImage,\n        },\n        textureSize,\n        isSuccess\n      );\n    } else {\n      unreachable();\n    }\n  });\n\ng.test('sample_count')\n  .desc(\n    `\n  Test that the texture sample count. Check that a validation error is generated if sample count is\n  not 1.\n  `\n  )\n  .params(u =>\n    u //\n      // writeTexture is handled by writeTexture.spec.ts.\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('sampleCount', [1, 4])\n  )\n  .fn(t => {\n    const { sampleCount, copyType } = t.params;\n\n    let usage = GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;\n    // WebGPU SPEC requires multisampled textures must have RENDER_ATTACHMENT usage.\n    if (sampleCount > 1) {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    }\n\n    const textureSize = { width: 16, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.createTextureTracked({\n      size: textureSize,\n      sampleCount,\n      format: 'bgra8unorm',\n      usage,\n    });\n\n    const uploadBufferSize = 64;\n    const buffer = t.createBufferTracked({\n      size: uploadBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const isSuccess = sampleCount === 1;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isSuccess);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isSuccess);\n    }\n  });\n\nconst kRequiredTextureUsage = {\n  CopyT2B: GPUConst.TextureUsage.COPY_SRC,\n  CopyB2T: GPUConst.TextureUsage.COPY_DST,\n};\nconst kRequiredBufferUsage = {\n  CopyB2T: GPUConst.BufferUsage.COPY_SRC,\n  CopyT2B: GPUConst.BufferUsage.COPY_DST,\n};\n\ng.test('texture_buffer_usages')\n  .desc(\n    `\n  Tests calling copyTextureToBuffer or copyBufferToTexture with the texture and the buffer missed\n  COPY_SRC, COPY_DST usage respectively.\n    - texture and buffer {with, without} COPY_SRC and COPY_DST usage.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combine('textureUsage', kTextureUsages)\n      .unless(({ textureUsage }) => {\n        // TRANSIENT_ATTACHMENT is only valid when combined with RENDER_ATTACHMENT.\n        return textureUsage === GPUConst.TextureUsage.TRANSIENT_ATTACHMENT;\n      })\n      .expand('_textureUsageValid', p => [p.textureUsage === kRequiredTextureUsage[p.copyType]])\n      .combine('bufferUsage', kBufferUsages)\n      .expand('_bufferUsageValid', p => [p.bufferUsage === kRequiredBufferUsage[p.copyType]])\n      .filter(p => p._textureUsageValid || p._bufferUsageValid)\n  )\n  .fn(t => {\n    const { copyType, textureUsage, _textureUsageValid, bufferUsage, _bufferUsageValid } = t.params;\n\n    const texture = t.createTextureTracked({\n      size: { width: 16, height: 16 },\n      format: 'rgba8unorm',\n      usage: textureUsage,\n    });\n\n    const uploadBufferSize = 32;\n    const buffer = t.createBufferTracked({\n      size: uploadBufferSize,\n      usage: bufferUsage,\n    });\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n\n    const isSuccess = _textureUsageValid && _bufferUsageValid;\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isSuccess);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isSuccess);\n    }\n  });\n\ng.test('device_mismatch')\n  .desc(\n    `\n    Tests copyBufferToTexture and copyTextureToBuffer cannot be called with a buffer or a texture\n    created from another device.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .beginSubcases()\n      .combineWithParams([\n        { bufMismatched: false, texMismatched: false }, // control case\n        { bufMismatched: true, texMismatched: false },\n        { bufMismatched: false, texMismatched: true },\n      ] as const)\n  )\n  .beforeAllSubcases(t => t.usesMismatchedDevice())\n  .fn(t => {\n    const { copyType, bufMismatched, texMismatched } = t.params;\n\n    const uploadBufferSize = 32;\n    const buffer = t.trackForCleanup(\n      (bufMismatched ? t.mismatchedDevice : t.device).createBuffer({\n        size: uploadBufferSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n      })\n    );\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.trackForCleanup(\n      (texMismatched ? t.mismatchedDevice : t.device).createTexture({\n        size: textureSize,\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      })\n    );\n\n    const isValid = !bufMismatched && !texMismatched;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture({ buffer }, { texture }, textureSize, isValid);\n    } else if (copyType === 'CopyT2B') {\n      t.testCopyTextureToBuffer({ texture }, { buffer }, textureSize, isValid);\n    }\n  });\n\ng.test('offset_and_bytesPerRow')\n  .desc(\n    `Test that for copyBufferToTexture, and copyTextureToBuffer\n     * bytesPerRow must be a multiple of 256\n     * offset must be a multiple of bytesPerBlock\n     * the last row does not need to be a multiple of 256\n       In other words, If the copy size is 4x2 of a r8unorm texture that's 4 bytes per row.\n       To get from row 0 to row 1 in the buffer, bytesPerRow must be a multiple of 256.\n       But, the size requirement for the buffer is only 256 + 4, not 256 * 2\n     * origin.x must be a multiple of blockWidth\n     * origin.y must be a multiple of blockHeight\n     * copySize.width must be a multiple of blockWidth\n     * copySize.height must be a multiple of blockHeight\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kColorTextureFormats)\n      .combine('copyType', ['CopyB2T', 'CopyT2B'] as const)\n      .filter(\n        ({ format }) =>\n          canCopyToAllAspectsOfTextureFormat(format) && canCopyFromAllAspectsOfTextureFormat(format)\n      )\n      .combine('dimension', kTextureDimensions)\n      .filter(({ dimension, format }) =>\n        textureFormatAndDimensionPossiblyCompatible(dimension, format)\n      )\n      .beginSubcases()\n      .combineWithParams(\n        /* prettier-ignore */ [\n          { xInBlocks: 1  , yInBlocks: 1  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 1  , bytesPerRowAlign: 256 }, // good\n          { xInBlocks: 0  , yInBlocks: 0  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 1.5, bytesPerRowAlign: 256 }, // bad as offset is not blockSize\n          { xInBlocks: 0  , yInBlocks: 0  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 0  , bytesPerRowAlign: 128 }, // bad as bytesPerBlock is not multiple of 256\n          { xInBlocks: 0  , yInBlocks: 0  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 0  , bytesPerRowAlign: 384 }, // bad as bytesPerBlock is not multiple of 256\n          { xInBlocks: 1.5, yInBlocks: 0  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 0  , bytesPerRowAlign: 256 }, // bad as origin.x is not multiple of blockSize\n          { xInBlocks: 0  , yInBlocks: 1.5, copyWidthInBlocks: 64  , copyHeightInBlocks: 2  , offsetInBlocks: 0  , bytesPerRowAlign: 256 }, // bad as origin.y is not multiple of blockSize\n          { xInBlocks: 0  , yInBlocks: 0  , copyWidthInBlocks: 64.5, copyHeightInBlocks: 2  , offsetInBlocks: 0  , bytesPerRowAlign: 256 }, // bad as copySize.width is not multiple of blockSize\n          { xInBlocks: 0  , yInBlocks: 0  , copyWidthInBlocks: 64  , copyHeightInBlocks: 2.5, offsetInBlocks: 0  , bytesPerRowAlign: 256 }, // bad as copySize.height is not multiple of blockSize\n        ] as const\n      )\n      // Remove non-integer offsetInBlocks, copyWidthInBlocks, copyHeightInBlocks if bytesPerBlock === 1\n      .unless(\n        t =>\n          (t.offsetInBlocks % 1 !== 0 ||\n            t.copyWidthInBlocks % 1 !== 0 ||\n            t.copyHeightInBlocks % 1 !== 0) &&\n          getBlockInfoForColorTextureFormat(t.format).bytesPerBlock > 1\n      )\n      // Remove yInBlocks > 0 if dimension is 1d\n      .unless(t => t.dimension === '1d' && t.yInBlocks > 0)\n  )\n  .fn(t => {\n    const {\n      copyType,\n      format,\n      dimension,\n      xInBlocks,\n      yInBlocks,\n      offsetInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      bytesPerRowAlign,\n    } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatAndDimensionNotCompatible(format, dimension);\n    if (copyType === 'CopyT2B') {\n      t.skipIfTextureFormatDoesNotSupportCopyTextureToBuffer(format);\n    }\n\n    const info = getBlockInfoForColorTextureFormat(format);\n\n    // make a texture big enough that we have room for our copySize and our origin.\n    // Note that xxxInBlocks may be factional so that we test origins and sizes not aligned to blocks.\n    const widthBlocks = Math.ceil(xInBlocks) + Math.ceil(copyWidthInBlocks);\n    const heightBlocks = Math.ceil(yInBlocks) + Math.ceil(copyHeightInBlocks);\n    let copySizeBlocks = [copyWidthInBlocks, copyHeightInBlocks, 1];\n    let texSizeBlocks = [widthBlocks, heightBlocks, 1];\n    if (dimension === '1d') {\n      copySizeBlocks = [copyWidthInBlocks, 1, 1];\n      texSizeBlocks = [widthBlocks, 1, 1];\n    }\n\n    const origin = [\n      Math.ceil(xInBlocks * info.blockWidth),\n      Math.ceil(yInBlocks * info.blockHeight),\n      0,\n    ];\n    const copySize = [\n      Math.ceil(copySizeBlocks[0] * info.blockWidth),\n      Math.ceil(copySizeBlocks[1] * info.blockHeight),\n      copySizeBlocks[2],\n    ];\n    const textureSize = [\n      texSizeBlocks[0] * info.blockWidth,\n      texSizeBlocks[1] * info.blockHeight,\n      texSizeBlocks[2],\n    ] as const;\n    const textureBytePerRow = info.bytesPerBlock * texSizeBlocks[0];\n    const rowsPerImage = Math.ceil(copySizeBlocks[1]);\n    const offset = Math.ceil(offsetInBlocks * info.bytesPerBlock);\n    const bytesPerRow = align(textureBytePerRow, bytesPerRowAlign);\n\n    // Make sure our buffer is big enough for the required alignment\n    // and offset but no bigger.\n    const totalRows = rowsPerImage * copySizeBlocks[2];\n    const bufferSize = offset + (totalRows - 1) * bytesPerRow + textureBytePerRow;\n\n    const buffer = t.createBufferTracked({\n      label: `buffer(${bufferSize})`,\n      size: bufferSize,\n      usage: copyType === 'CopyB2T' ? GPUBufferUsage.COPY_SRC : GPUBufferUsage.COPY_DST,\n    });\n\n    const texture = t.createTextureTracked({\n      size: textureSize,\n      format,\n      dimension,\n      usage: copyType === 'CopyB2T' ? GPUTextureUsage.COPY_DST : GPUTextureUsage.COPY_SRC,\n    });\n\n    const shouldSucceed =\n      offset % info.bytesPerBlock === 0 &&\n      bytesPerRow % 256 === 0 &&\n      origin[0] % info.blockWidth === 0 &&\n      origin[1] % info.blockHeight === 0 &&\n      copySize[0] % info.blockWidth === 0 &&\n      copySize[1] % info.blockHeight === 0;\n\n    t.debug(\n      () =>\n        `offset: ${offset}, bytesPerRow: ${bytesPerRow}, copySize: ${copySize}, origin: ${origin}`\n    );\n\n    switch (copyType) {\n      case 'CopyB2T': {\n        t.testCopyBufferToTexture(\n          { buffer, offset, bytesPerRow },\n          { texture, origin },\n          copySize,\n          shouldSucceed\n        );\n        break;\n      }\n      case 'CopyT2B': {\n        t.testCopyTextureToBuffer(\n          { texture, origin },\n          { buffer, offset, bytesPerRow },\n          copySize,\n          shouldSucceed\n        );\n        break;\n      }\n    }\n  });\n"],"mappings":"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"}