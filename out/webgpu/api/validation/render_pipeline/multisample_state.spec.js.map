{"version":3,"file":"multisample_state.spec.js","names":["description","makeTestGroup","kDefaultFragmentShaderCode","CreateRenderPipelineValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","isAsync","count","descriptor","getDescriptor","multisample","alphaToCoverageEnabled","_success","doCreateRenderPipelineTest","hasSampleMaskOutput","isCompatibility","skip","fragmentShaderCode"],"sources":["../../../../../src/webgpu/api/validation/render_pipeline/multisample_state.spec.ts"],"sourcesContent":["export const description = `\nThis test dedicatedly tests validation of GPUMultisampleState of createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kDefaultFragmentShaderCode } from '../../../util/shader.js';\n\nimport { CreateRenderPipelineValidationTest } from './common.js';\n\nexport const g = makeTestGroup(CreateRenderPipelineValidationTest);\n\ng.test('count')\n  .desc(`If multisample.count must either be 1 or 4.`)\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .beginSubcases()\n      .combine('count', [0, 1, 2, 3, 4, 8, 16, 1024])\n  )\n  .fn(t => {\n    const { isAsync, count } = t.params;\n\n    const descriptor = t.getDescriptor({ multisample: { count, alphaToCoverageEnabled: false } });\n\n    const _success = count === 1 || count === 4;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('alpha_to_coverage,count')\n  .desc(\n    `If multisample.alphaToCoverageEnabled is true, multisample.count must be greater than 1, e.g. it can only be 4.`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .combine('alphaToCoverageEnabled', [false, true])\n      .beginSubcases()\n      .combine('count', [1, 4])\n  )\n  .fn(t => {\n    const { isAsync, alphaToCoverageEnabled, count } = t.params;\n\n    const descriptor = t.getDescriptor({ multisample: { count, alphaToCoverageEnabled } });\n\n    const _success = alphaToCoverageEnabled ? count === 4 : count === 1 || count === 4;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n\ng.test('alpha_to_coverage,sample_mask')\n  .desc(\n    `If sample_mask builtin is a pipeline output of fragment, multisample.alphaToCoverageEnabled should be false.`\n  )\n  .params(u =>\n    u\n      .combine('isAsync', [false, true])\n      .combine('alphaToCoverageEnabled', [false, true])\n      .beginSubcases()\n      .combine('hasSampleMaskOutput', [false, true])\n  )\n  .fn(t => {\n    const { isAsync, alphaToCoverageEnabled, hasSampleMaskOutput } = t.params;\n\n    if (t.isCompatibility && hasSampleMaskOutput) {\n      t.skip('WGSL sample_mask is not supported in compatibility mode');\n    }\n\n    const descriptor = t.getDescriptor({\n      multisample: { alphaToCoverageEnabled, count: 4 },\n      fragmentShaderCode: hasSampleMaskOutput\n        ? `\n      struct Output {\n        @builtin(sample_mask) mask_out: u32,\n        @location(0) color : vec4<f32>,\n      }\n      @fragment fn main() -> Output {\n        var o: Output;\n        // We need to make sure this sample_mask isn't optimized out even its value equals \"no op\".\n        o.mask_out = 0xFFFFFFFFu;\n        o.color = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n        return o;\n      }`\n        : kDefaultFragmentShaderCode,\n    });\n\n    const _success = !hasSampleMaskOutput || !alphaToCoverageEnabled;\n    t.doCreateRenderPipelineTest(isAsync, _success, descriptor);\n  });\n"],"mappings":"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"}