{"version":3,"file":"vertex_state.spec.js","names":["description","makeTestGroup","filterUniqueValueTestVariants","makeValueTestVariant","kVertexFormats","kVertexFormatInfo","ValidationTest","VERTEX_SHADER_CODE_WITH_NO_INPUT","addTestAttributes","attributes","testAttribute","testAttributeAtStart","extraAttributeCount","extraAttributeSkippedLocations","currentLocation","extraAttribsAdded","includes","push","format","shaderLocation","offset","unshift","F","getDescriptor","buffers","vertexShaderCode","descriptor","layout","vertex","module","device","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","paramsSubcasesOnly","u","combine","mult","add","fn","t","countVariant","lastEmpty","params","makeLimitVariant","vertexBuffers","i","arrayStride","limits","maxVertexBuffers","attribCountVariant","attribsPerBuffer","attribCount","attribsAdded","targetCount","Math","min","length","maxVertexAttributes","vertexBufferIndexVariant","arrayStrideVariant","vertexBufferIndex","maxVertexBufferArrayStride","extraAttributeCountVariant","testShaderLocationVariant","testShaderLocation","vertexBufferIndexAVariant","vertexBufferIndexBVariant","testAttributeAtStartA","testAttributeAtStartB","shaderLocationAVariant","shaderLocationBVariant","vertexBufferIndexA","vertexBufferIndexB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocationVariant","testLocation","shader","beginSubcases","expand","p","shaderBaseType","shaderType","requiredBaseType","sint","uint","snorm","unorm","float","formatSize","byteSize","floor","offsetVariant","formatInfo","stride","limit","formats"],"sources":["../../../../../src/webgpu/api/validation/render_pipeline/vertex_state.spec.ts"],"sourcesContent":["export const description = `\nThis test dedicatedly tests validation of GPUVertexState of createRenderPipeline.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  filterUniqueValueTestVariants,\n  makeValueTestVariant,\n} from '../../../../common/util/util.js';\nimport { kVertexFormats, kVertexFormatInfo } from '../../../capability_info.js';\nimport { ValidationTest } from '../validation_test.js';\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  @vertex fn main() -> @builtin(position) vec4<f32> {\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction addTestAttributes(\n  attributes: GPUVertexAttribute[],\n  {\n    testAttribute,\n    testAttributeAtStart = true,\n    extraAttributeCount = 0,\n    extraAttributeSkippedLocations = [],\n  }: {\n    testAttribute?: GPUVertexAttribute;\n    testAttributeAtStart?: boolean;\n    extraAttributeCount?: Number;\n    extraAttributeSkippedLocations?: Number[];\n  }\n) {\n  // Add a bunch of dummy attributes each with a different location such that none of the locations\n  // are in extraAttributeSkippedLocations\n  let currentLocation = 0;\n  let extraAttribsAdded = 0;\n  while (extraAttribsAdded !== extraAttributeCount) {\n    if (extraAttributeSkippedLocations.includes(currentLocation)) {\n      currentLocation++;\n      continue;\n    }\n\n    attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n    currentLocation++;\n    extraAttribsAdded++;\n  }\n\n  // Add the test attribute at the start or the end of the attributes.\n  if (testAttribute) {\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n  }\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        @fragment fn main() -> @location(0) vec4<f32> {\n          return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n          module: vsModule,\n          entryPoint: 'main',\n          buffers,\n        },\n        fragment: {\n          module: fsModule,\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `@location(${input.location}) input${count} : ${input.type},\\n`;\n      body += `var i${count} : ${input.type} = input.input${count};\\n`;\n      count++;\n    }\n\n    return `\n      struct Inputs {\n        ${interfaces}\n      };\n      @vertex fn main(input : Inputs) -> @builtin(position) vec4<f32> {\n        ${body}\n        return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('countVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: 0 },\n        { mult: 1, add: 1 },\n      ])\n      .combine('lastEmpty', [false, true])\n  )\n  .fn(t => {\n    const { countVariant, lastEmpty } = t.params;\n    const count = t.makeLimitVariant('maxVertexBuffers', countVariant);\n    const vertexBuffers = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        } as const);\n      }\n    }\n\n    const success = count <= t.device.limits.maxVertexBuffers;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('attribCountVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: 0 },\n        { mult: 1, add: 1 },\n      ])\n      .combine('attribsPerBuffer', [0, 1, 4])\n  )\n  .fn(t => {\n    const { attribCountVariant, attribsPerBuffer } = t.params;\n    const attribCount = t.makeLimitVariant('maxVertexAttributes', attribCountVariant);\n\n    const vertexBuffers = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === t.device.limits.maxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded } as const);\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= t.device.limits.maxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('arrayStrideVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 4 },\n        { mult: 0, add: 256 },\n        { mult: 1, add: -4 },\n        { mult: 1, add: 0 },\n        { mult: 1, add: +4 },\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndexVariant, arrayStrideVariant } = t.params;\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= t.device.limits.maxVertexBufferArrayStride;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('arrayStrideVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 0, add: 2 },\n        { mult: 0, add: 4 },\n        { mult: 1, add: -4 },\n        { mult: 1, add: -2 },\n        { mult: 1, add: 0 },\n      ])\n  )\n  .fn(t => {\n    const { vertexBufferIndexVariant, arrayStrideVariant } = t.params;\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('extraAttributeCountVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocationVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n        { mult: 1, add: 0 },\n      ])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexVariant,\n      extraAttributeCountVariant,\n      testShaderLocationVariant,\n      testAttributeAtStart,\n    } = t.params;\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const extraAttributeCount = t.makeLimitVariant(\n      'maxVertexAttributes',\n      extraAttributeCountVariant\n    );\n    const testShaderLocation = t.makeLimitVariant('maxVertexAttributes', testShaderLocationVariant);\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: testShaderLocation },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < t.device.limits.maxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexAVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('vertexBufferIndexBVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('testAttributeAtStartA', [false, true])\n      .combine('testAttributeAtStartB', [false, true])\n      .combine('shaderLocationAVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 0, add: 7 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('shaderLocationBVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 0, add: 7 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('extraAttributeCount', [0, 4])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexAVariant,\n      vertexBufferIndexBVariant,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationAVariant,\n      shaderLocationBVariant,\n      extraAttributeCount,\n    } = t.params;\n    const vertexBufferIndexA = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexAVariant);\n    const vertexBufferIndexB = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexBVariant);\n    const shaderLocationA = t.makeLimitVariant('maxVertexAttributes', shaderLocationAVariant);\n    const shaderLocationB = t.makeLimitVariant('maxVertexAttributes', shaderLocationBVariant);\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    addTestAttributes(attributesA, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationA },\n      testAttributeAtStart: testAttributeAtStartA,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [shaderLocationA, shaderLocationB],\n    });\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA so they end\n    // up in the same vertex buffer.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    addTestAttributes(attributesB, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationB },\n      testAttributeAtStart: testAttributeAtStartB,\n    });\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit, MAX_I32 (the WGSL spec requires a non-negative i32)`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('testLocationVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n        { mult: 1, add: 0 },\n        { mult: 0, add: 2 ** 31 - 1 },\n      ])\n  )\n  .fn(t => {\n    const { testLocationVariant } = t.params;\n    const testLocation = t.makeLimitVariant('maxVertexAttributes', testLocationVariant);\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          } as const,\n        ],\n      },\n    ];\n\n    const success = testLocation < t.device.limits.maxVertexAttributes;\n    t.testVertexState(success, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('extraAttributeCountVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('testAttributeAtStart', [false, true])\n      .combine('testShaderLocationVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 0, add: 4 },\n        { mult: 0, add: 5 },\n        { mult: 1, add: -1 },\n      ])\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexVariant,\n      extraAttributeCountVariant,\n      testAttributeAtStart,\n      testShaderLocationVariant,\n    } = t.params;\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const extraAttributeCount = t.makeLimitVariant(\n      'maxVertexAttributes',\n      extraAttributeCountVariant\n    );\n    const testShaderLocation = t.makeLimitVariant('maxVertexAttributes', testShaderLocationVariant);\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    const attributes: GPUVertexAttribute[] = [];\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    // Fill attributes with a bunch of attributes for other locations.\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    addTestAttributes(attributes, {\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n    t.testVertexState(false, vertexBuffers, shader);\n\n    // Add an attribute for the test location and try again.\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', shaderLocation: testShaderLocation, offset: 0 },\n      testAttributeAtStart,\n    });\n    t.testVertexState(true, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_type_matches_attribute_format')\n  .desc(\n    `\n    Test that the vertex shader declaration must have a type compatible with the vertex format.\n     - Test for all formats.\n     - Test for all combinations of u/i/f32 with and without vectors.`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('shaderBaseType', ['u32', 'i32', 'f32'])\n      .expand('shaderType', p => [\n        p.shaderBaseType,\n        `vec2<${p.shaderBaseType}>`,\n        `vec3<${p.shaderBaseType}>`,\n        `vec4<${p.shaderBaseType}>`,\n      ])\n  )\n  .fn(t => {\n    const { format, shaderBaseType, shaderType } = t.params;\n    const shader = t.generateTestVertexShader([\n      {\n        type: shaderType,\n        location: 0,\n      },\n    ]);\n\n    const requiredBaseType = {\n      sint: 'i32',\n      uint: 'u32',\n      snorm: 'f32',\n      unorm: 'f32',\n      float: 'f32',\n    }[kVertexFormatInfo[format].type];\n\n    const success = requiredBaseType === shaderBaseType;\n    t.testVertexState(\n      success,\n      [\n        {\n          arrayStride: 0,\n          attributes: [{ offset: 0, shaderLocation: 0, format }],\n        },\n      ],\n      shader\n    );\n  });\n\ng.test('vertex_attribute_offset_alignment')\n  .desc(\n    `\n    Test that vertex attribute offsets must be aligned to the format's component byte size.\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .combine('arrayStrideVariant', [\n        { mult: 0, add: 256 },\n        { mult: 1, add: 0 },\n      ])\n      .expand('offsetVariant', p => {\n        const formatSize = kVertexFormatInfo[p.format].byteSize;\n        return filterUniqueValueTestVariants([\n          { mult: 0, add: 0 },\n          { mult: 0, add: Math.floor(formatSize / 2) },\n          { mult: 0, add: formatSize },\n          { mult: 0, add: 2 },\n          { mult: 0, add: 4 },\n          { mult: 1, add: -formatSize },\n          { mult: 1, add: -formatSize - Math.floor(formatSize / 2) },\n          { mult: 1, add: -formatSize - 4 },\n          { mult: 1, add: -formatSize - 2 },\n        ]);\n      })\n      .beginSubcases()\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('extraAttributeCountVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStrideVariant,\n      offsetVariant,\n      vertexBufferIndexVariant,\n      extraAttributeCountVariant,\n      testAttributeAtStart,\n    } = t.params;\n    const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const extraAttributeCount = t.makeLimitVariant(\n      'maxVertexAttributes',\n      extraAttributeCountVariant\n    );\n    const offset = makeValueTestVariant(arrayStride, offsetVariant);\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.byteSize;\n    const success = offset % Math.min(4, formatSize) === 0;\n\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_contained_in_stride')\n  .desc(\n    `\n    Test that vertex attribute [offset, offset + formatSize) must be contained in the arrayStride if arrayStride is not 0:\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .params(u =>\n    u\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('arrayStrideVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 256 },\n        { mult: 1, add: -4 },\n        { mult: 1, add: 0 },\n      ])\n      .expand('offsetVariant', function* (p) {\n        // Compute a bunch of test offsets to test.\n        const formatSize = kVertexFormatInfo[p.format].byteSize;\n        yield { mult: 0, add: 0 };\n        yield { mult: 0, add: 4 };\n        yield { mult: 1, add: -formatSize };\n        yield { mult: 1, add: -formatSize + 4 };\n\n        // Avoid adding duplicate cases when formatSize == 4 (it is already tested above)\n        if (formatSize !== 4) {\n          yield { mult: 0, add: formatSize };\n          yield { mult: 1, add: 0 };\n        }\n      })\n      .combine('vertexBufferIndexVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('extraAttributeCountVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('testAttributeAtStart', [false, true])\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStrideVariant,\n      offsetVariant,\n      vertexBufferIndexVariant,\n      extraAttributeCountVariant,\n      testAttributeAtStart,\n    } = t.params;\n    const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n    const vertexBufferIndex = t.makeLimitVariant('maxVertexBuffers', vertexBufferIndexVariant);\n    const extraAttributeCount = t.makeLimitVariant(\n      'maxVertexAttributes',\n      extraAttributeCountVariant\n    );\n    // arrayStride = 0 is a special case because for the offset validation it acts the same\n    // as arrayStride = device.limits.maxVertexBufferArrayStride. We special case here so as to avoid adding\n    // negative offsets that would cause an IDL exception to be thrown instead of a validation\n    // error.\n    const stride = arrayStride !== 0 ? arrayStride : t.device.limits.maxVertexBufferArrayStride;\n    const offset = makeValueTestVariant(stride, offsetVariant);\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatSize = kVertexFormatInfo[format].byteSize;\n    const limit = arrayStride === 0 ? t.device.limits.maxVertexBufferArrayStride : arrayStride;\n\n    const success = offset + formatSize <= limit;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('many_attributes_overlapping')\n  .desc(`Test that it is valid to have many vertex attributes overlap`)\n  .fn(t => {\n    // Create many attributes, each of them intersects with at least 3 others.\n    const attributes = [];\n    const formats = ['float32x4', 'uint32x4', 'sint32x4'] as const;\n    for (let i = 0; i < t.device.limits.maxVertexAttributes; i++) {\n      attributes.push({ format: formats[i % 3], offset: i * 4, shaderLocation: i } as const);\n    }\n\n    t.testVertexState(true, [{ arrayStride: 0, attributes }]);\n  });\n"],"mappings":"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"}