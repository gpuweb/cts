{"version":3,"file":"error_scope.spec.js","names":["description","Fixture","makeTestGroup","getGPU","assert","raceWithRejectOnTimeout","kErrorScopeFilters","kGeneratableErrorScopeFilters","ErrorScopeTests","_device","undefined","device","init","gpu","rec","adapter","requestAdapter","requestDevice","generateError","filter","trackForCleanup","createTexture","format","usage","GPUTextureUsage","COPY_DST","size","limits","maxTextureDimension2D","maxTextureArrayLayers","createBuffer","queue","submit","isInstanceOfError","error","GPUOutOfMemoryError","GPUValidationError","GPUInternalError","expectUncapturedError","fn","immediateAsyncExpectation","TIMEOUT_IN_MS","promise","Promise","resolve","eventListener","event","debug","addEventListener","once","g","test","desc","params","u","combine","t","errorType","errorFilter","pushErrorScope","uncapturedErrorEvent","expect","popErrorScope","shouldReject","stackDepth","unmatchedFilters","i","length","promises","push","errors","all","every","e","numErrors"],"sources":["../../../../src/webgpu/api/validation/error_scope.spec.ts"],"sourcesContent":["export const description = `\nError scope validation tests.\n\nNote these must create their own device, not use GPUTest (that one already has error scopes on it).\n\nTODO: (POSTV1) Test error scopes of different threads and make sure they go to the right place.\nTODO: (POSTV1) Test that unhandled errors go the right device, and nowhere if the device was dropped.\n`;\n\nimport { Fixture } from '../../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { getGPU } from '../../../common/util/navigator_gpu.js';\nimport { assert, raceWithRejectOnTimeout } from '../../../common/util/util.js';\nimport { kErrorScopeFilters, kGeneratableErrorScopeFilters } from '../../capability_info.js';\n\nclass ErrorScopeTests extends Fixture {\n  _device: GPUDevice | undefined = undefined;\n\n  get device(): GPUDevice {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  async init(): Promise<void> {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null);\n    const device = await adapter.requestDevice();\n    assert(device !== null);\n    this._device = device;\n  }\n\n  // Generates an error of the given filter type. For now, the errors are generated by calling a\n  // known code-path to cause the error. This can be updated in the future should there be a more\n  // direct way to inject errors.\n  generateError(filter: GPUErrorFilter): void {\n    switch (filter) {\n      case 'out-of-memory':\n        this.trackForCleanup(\n          this.device.createTexture({\n            // One of the largest formats. With the base limits, the texture will be 256 GiB.\n            format: 'rgba32float',\n            usage: GPUTextureUsage.COPY_DST,\n            size: [\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureDimension2D,\n              this.device.limits.maxTextureArrayLayers,\n            ],\n          })\n        );\n        break;\n      case 'validation':\n        // Generating a validation error by passing in an invalid usage when creating a buffer.\n        this.trackForCleanup(\n          this.device.createBuffer({\n            size: 1024,\n            usage: 0xffff, // Invalid GPUBufferUsage\n          })\n        );\n        break;\n    }\n    // MAINTENANCE_TODO: This is a workaround for Chromium not flushing. Remove when not needed.\n    this.device.queue.submit([]);\n  }\n\n  // Checks whether the error is of the type expected given the filter.\n  isInstanceOfError(filter: GPUErrorFilter, error: GPUError | null): boolean {\n    switch (filter) {\n      case 'out-of-memory':\n        return error instanceof GPUOutOfMemoryError;\n      case 'validation':\n        return error instanceof GPUValidationError;\n      case 'internal':\n        return error instanceof GPUInternalError;\n    }\n  }\n\n  // Expect an uncapturederror event to occur. Note: this MUST be awaited, because\n  // otherwise it could erroneously pass by capturing an error from later in the test.\n  async expectUncapturedError(fn: Function): Promise<GPUUncapturedErrorEvent> {\n    return this.immediateAsyncExpectation(() => {\n      // MAINTENANCE_TODO: Make arbitrary timeout value a test runner variable\n      const TIMEOUT_IN_MS = 1000;\n\n      const promise: Promise<GPUUncapturedErrorEvent> = new Promise(resolve => {\n        const eventListener = ((event: GPUUncapturedErrorEvent) => {\n          this.debug(`Got uncaptured error event with ${event.error}`);\n          resolve(event);\n        }) as EventListener;\n\n        this.device.addEventListener('uncapturederror', eventListener, { once: true });\n      });\n\n      fn();\n\n      return raceWithRejectOnTimeout(\n        promise,\n        TIMEOUT_IN_MS,\n        'Timeout occurred waiting for uncaptured error'\n      );\n    });\n  }\n}\n\nexport const g = makeTestGroup(ErrorScopeTests);\n\ng.test('simple')\n  .desc(\n    `\nTests that error scopes catches their expected errors, firing an uncaptured error event otherwise.\n\n- Same error and error filter (popErrorScope should return the error)\n- Different error from filter (uncaptured error should result)\n    `\n  )\n  .params(u =>\n    u.combine('errorType', kGeneratableErrorScopeFilters).combine('errorFilter', kErrorScopeFilters)\n  )\n  .fn(async t => {\n    const { errorType, errorFilter } = t.params;\n    t.device.pushErrorScope(errorFilter);\n\n    if (errorType !== errorFilter) {\n      // Different error case\n      const uncapturedErrorEvent = await t.expectUncapturedError(() => {\n        t.generateError(errorType);\n      });\n      t.expect(t.isInstanceOfError(errorType, uncapturedErrorEvent.error));\n\n      const error = await t.device.popErrorScope();\n      t.expect(error === null);\n    } else {\n      // Same error as filter\n      t.generateError(errorType);\n      const error = await t.device.popErrorScope();\n      t.expect(t.isInstanceOfError(errorType, error));\n    }\n  });\n\ng.test('empty')\n  .desc(\n    `\nTests that popping an empty error scope stack should reject.\n    `\n  )\n  .fn(t => {\n    const promise = t.device.popErrorScope();\n    t.shouldReject('OperationError', promise);\n  });\n\ng.test('parent_scope')\n  .desc(\n    `\nTests that an error bubbles to the correct parent scope.\n\n- Different error types as the parent scope\n- Different depths of non-capturing filters for the generated error\n    `\n  )\n  .params(u =>\n    u\n      .combine('errorFilter', kGeneratableErrorScopeFilters)\n      .combine('stackDepth', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, stackDepth } = t.params;\n    t.device.pushErrorScope(errorFilter);\n\n    // Push a bunch of error filters onto the stack (none that match errorFilter)\n    const unmatchedFilters = kErrorScopeFilters.filter(filter => {\n      return filter !== errorFilter;\n    });\n    for (let i = 0; i < stackDepth; i++) {\n      t.device.pushErrorScope(unmatchedFilters[i % unmatchedFilters.length]);\n    }\n\n    // Cause the error and then pop all the unrelated filters.\n    t.generateError(errorFilter);\n    const promises = [];\n    for (let i = 0; i < stackDepth; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n\n    // Finally the actual error should have been caught by the parent scope.\n    const error = await t.device.popErrorScope();\n    t.expect(t.isInstanceOfError(errorFilter, error));\n  });\n\ng.test('current_scope')\n  .desc(\n    `\nTests that an error does not bubbles to parent scopes when local scope matches.\n\n- Different error types as the current scope\n- Different depths of non-capturing filters for the generated error\n    `\n  )\n  .params(u =>\n    u\n      .combine('errorFilter', kGeneratableErrorScopeFilters)\n      .combine('stackDepth', [1, 10, 100, 1000, 100000])\n  )\n  .fn(async t => {\n    const { errorFilter, stackDepth } = t.params;\n\n    // Push a bunch of error filters onto the stack\n    for (let i = 0; i < stackDepth; i++) {\n      t.device.pushErrorScope(kErrorScopeFilters[i % kErrorScopeFilters.length]);\n    }\n\n    // Current scope should catch the error immediately.\n    t.device.pushErrorScope(errorFilter);\n    t.generateError(errorFilter);\n    const error = await t.device.popErrorScope();\n    t.expect(t.isInstanceOfError(errorFilter, error));\n\n    // Remaining scopes shouldn't catch anything.\n    const promises = [];\n    for (let i = 0; i < stackDepth; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n  });\n\ng.test('balanced_siblings')\n  .desc(\n    `\nTests that sibling error scopes need to be balanced.\n\n- Different error types as the current scope\n- Different number of sibling errors\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('numErrors', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, numErrors } = t.params;\n\n    const promises = [];\n    for (let i = 0; i < numErrors; i++) {\n      t.device.pushErrorScope(errorFilter);\n      promises.push(t.device.popErrorScope());\n    }\n\n    {\n      // Trying to pop an additional non-existing scope should reject.\n      const promise = t.device.popErrorScope();\n      t.shouldReject('OperationError', promise);\n    }\n\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n  });\n\ng.test('balanced_nesting')\n  .desc(\n    `\nTests that nested error scopes need to be balanced.\n\n- Different error types as the current scope\n- Different number of nested errors\n    `\n  )\n  .params(u =>\n    u.combine('errorFilter', kErrorScopeFilters).combine('numErrors', [1, 10, 100, 1000])\n  )\n  .fn(async t => {\n    const { errorFilter, numErrors } = t.params;\n\n    for (let i = 0; i < numErrors; i++) {\n      t.device.pushErrorScope(errorFilter);\n    }\n\n    const promises = [];\n    for (let i = 0; i < numErrors; i++) {\n      promises.push(t.device.popErrorScope());\n    }\n    const errors = await Promise.all(promises);\n    t.expect(errors.every(e => e === null));\n\n    {\n      // Trying to pop an additional non-existing scope should reject.\n      const promise = t.device.popErrorScope();\n      t.shouldReject('OperationError', promise);\n    }\n  });\n"],"mappings":"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"}