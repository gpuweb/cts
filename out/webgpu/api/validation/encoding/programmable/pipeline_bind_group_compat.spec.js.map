{"version":3,"file":"pipeline_bind_group_compat.spec.js","names":["description","kUnitCaseParamsBuilder","makeTestGroup","memcpy","unreachable","kSamplerBindingTypes","kShaderStageCombinations","kBufferBindingTypes","GPUConst","MaxLimitsTestMixin","kProgrammableEncoderTypes","ValidationTest","kComputeCmds","kRenderCmds","kPipelineTypes","kBindingTypes","kEmptyBindGroup0Ndx","kEmptyBindGroup1Ndx","kNonEmptyBindGroup0Ndx","kNonEmptyBindGroup1Ndx","swapArrayElements","array","ndx1","ndx2","t","kResourceTypes","getTestCmds","encoderType","kCompatTestParams","combine","expand","p","F","getIndexBuffer","createBufferTracked","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","INDEX","getIndirectBuffer","indirectParams","buffer","mappedAtCreation","length","INDIRECT","COPY_DST","src","dst","getMappedRange","unmap","getBindingResourceType","entry","undefined","sampler","texture","storageTexture","access","createRenderPipelineWithLayout","bindGroups","shader","module","device","createShaderModule","code","pipeline","createRenderPipeline","layout","createPipelineLayout","bindGroupLayouts","map","entries","createBindGroupLayout","vertex","entryPoint","fragment","targets","format","primitive","topology","createComputePipelineWithLayout","createComputePipeline","compute","createBindGroupWithLayout","bglEntries","bgEntries","resource","getBindingResource","push","binding","createBindGroup","doCompute","pass","call","callWithZero","x","dispatchWorkgroups","dispatchWorkgroupsIndirect","doRender","vertexCount","draw","setIndexBuffer","drawIndexed","drawIndirect","drawIndexedIndirect","createBindGroupLayoutEntry","resourceType","useU32Array","visibility","GPUShaderStage","COMPUTE","FRAGMENT","hasDynamicOffset","runTest","dynamicOffsets","success","encoder","validateFinish","createEncoder","GPUComputePassEncoder","setPipeline","i","bindGroup","setBindGroup","runDefaultLayoutBindingTest","empty","pipelineType","bindingType","swap","makePipelinesFn","doCommandFn","explicitEmptyBindGroupLayout","explicitBindGroupLayout","explicitPipelineLayout","pipelineAuto0","pipelineAuto1","pipelineExplicit","UNIFORM","emptyBindGroupLayouts","nonEmptyBindGroupLayouts","getBindGroupLayout","bindGroupIndex","emptyBindGroups","nonEmptyBindGroups","createCommandEncoder","expectValidationError","finish","g","test","desc","params","beginSubcases","combineWithParams","setBindGroup0","setBindGroup1","setUnusedBindGroup2","_success","fn","VERTEX","bindGroup0","bindGroup1","unusedBindGroup2","u","type","skipIf","isCompatibility","limits","maxStorageBuffersInFragmentStage","uniformBuffer","getUniformBuffer","bglType","bgType","createSampler","compare","bgBindings","plBindings","plEntries","Array","fill","ShaderStage","bgVisibility","plVisibility","resourceIsStorageTexture","resourceIsStorageBuffer","bgResourceType","plResourceType","maxStorageTexturesInFragmentStage","emptyBindGroupLayoutType","bindGroupLayoutEntryCount","computeCommand","emptyBGLCount","emptyBGL","emptyBGLs","pipelineLayout","emptyBindGroup","computePass","beginComputePass","end","renderCommand","colorFormat","writeMask","attachmentTexture","createTextureTracked","width","height","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","renderPass","beginRenderPass","colorAttachments","view","createView","clearValue","r","b","a","loadOp","storeOp","kPipelineTypesAndBindingTypeParams","successWhenNonEmpty"],"sources":["../../../../../../src/webgpu/api/validation/encoding/programmable/pipeline_bind_group_compat.spec.ts"],"sourcesContent":["export const description = `\nTODO:\n- test compatibility between bind groups and pipelines\n    - the binding resource in bindGroups[i].layout is \"group-equivalent\" (value-equal) to pipelineLayout.bgls[i].\n    - in the test fn, test once without the dispatch/draw (should always be valid) and once with\n      the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    - x= {dispatch, all draws} (dispatch/draw should be size 0 to make sure validation still happens if no-op)\n    - x= all relevant stages\n\nTODO: subsume existing test, rewrite fixture as needed.\nTODO: Add externalTexture to kResourceTypes [1]\n`;\n\nimport { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { memcpy, unreachable } from '../../../../../common/util/util.js';\nimport {\n  kSamplerBindingTypes,\n  kShaderStageCombinations,\n  kBufferBindingTypes,\n  ValidBindableResource,\n} from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\nimport { MaxLimitsTestMixin } from '../../../../gpu_test.js';\nimport {\n  ProgrammableEncoderType,\n  kProgrammableEncoderTypes,\n} from '../../../../util/command_buffer_maker.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kComputeCmds = ['dispatch', 'dispatchIndirect'] as const;\ntype ComputeCmd = (typeof kComputeCmds)[number];\nconst kRenderCmds = ['draw', 'drawIndexed', 'drawIndirect', 'drawIndexedIndirect'] as const;\ntype RenderCmd = (typeof kRenderCmds)[number];\n\nconst kPipelineTypes = ['auto0', 'explicit'] as const;\ntype PipelineType = (typeof kPipelineTypes)[number];\nconst kBindingTypes = ['auto0', 'auto1', 'explicit'] as const;\ntype BindingType = (typeof kBindingTypes)[number];\n\nconst kEmptyBindGroup0Ndx = 0;\nconst kEmptyBindGroup1Ndx = 1;\nconst kNonEmptyBindGroup0Ndx = 2;\nconst kNonEmptyBindGroup1Ndx = 3;\n\n// Swaps 2 array elements in place.\nfunction swapArrayElements<T>(array: T[], ndx1: number, ndx2: number) {\n  const t = array[ndx1];\n  array[ndx1] = array[ndx2];\n  array[ndx2] = t;\n}\n\n// Test resource type compatibility in pipeline and bind group\n// [1]: Need to add externalTexture\nconst kResourceTypes: ValidBindableResource[] = [\n  'uniformBuf',\n  'filtSamp',\n  'sampledTex',\n  'readonlyStorageTex',\n  'writeonlyStorageTex',\n  'readwriteStorageTex',\n];\n\nfunction getTestCmds(\n  encoderType: ProgrammableEncoderType\n): readonly ComputeCmd[] | readonly RenderCmd[] {\n  return encoderType === 'compute pass' ? kComputeCmds : kRenderCmds;\n}\n\nconst kCompatTestParams = kUnitCaseParamsBuilder\n  .combine('encoderType', kProgrammableEncoderTypes)\n  .expand('call', p => getTestCmds(p.encoderType))\n  .combine('callWithZero', [true, false]);\n\nclass F extends ValidationTest {\n  getIndexBuffer(): GPUBuffer {\n    return this.createBufferTracked({\n      size: 8 * Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.INDEX,\n    });\n  }\n\n  getIndirectBuffer(indirectParams: Array<number>): GPUBuffer {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: indirectParams.length * Uint32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST,\n    });\n    memcpy({ src: new Uint32Array(indirectParams) }, { dst: buffer.getMappedRange() });\n    buffer.unmap();\n    return buffer;\n  }\n\n  getBindingResourceType(entry: GPUBindGroupLayoutEntry): ValidBindableResource {\n    if (entry.buffer !== undefined) return 'uniformBuf';\n    if (entry.sampler !== undefined) return 'filtSamp';\n    if (entry.texture !== undefined) return 'sampledTex';\n    if (entry.storageTexture !== undefined) {\n      switch (entry.storageTexture.access) {\n        case undefined:\n        case 'write-only':\n          return 'writeonlyStorageTex';\n        case 'read-only':\n          return 'readonlyStorageTex';\n        case 'read-write':\n          return 'readwriteStorageTex';\n      }\n    }\n    unreachable();\n  }\n\n  createRenderPipelineWithLayout(\n    bindGroups: Array<Array<GPUBindGroupLayoutEntry>>\n  ): GPURenderPipeline {\n    const shader = `\n      @vertex fn vs_main() -> @builtin(position) vec4<f32> {\n        return vec4<f32>(1.0, 1.0, 0.0, 1.0);\n      }\n\n      @fragment fn fs_main() -> @location(0) vec4<f32> {\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      }\n    `;\n    const module = this.device.createShaderModule({ code: shader });\n    const pipeline = this.device.createRenderPipeline({\n      layout: this.device.createPipelineLayout({\n        bindGroupLayouts: bindGroups.map(entries => this.device.createBindGroupLayout({ entries })),\n      }),\n      vertex: {\n        module,\n        entryPoint: 'vs_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n    return pipeline;\n  }\n\n  createComputePipelineWithLayout(\n    bindGroups: Array<Array<GPUBindGroupLayoutEntry>>\n  ): GPUComputePipeline {\n    const shader = `\n      @compute @workgroup_size(1)\n        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n      }\n    `;\n\n    const module = this.device.createShaderModule({ code: shader });\n    const pipeline = this.device.createComputePipeline({\n      layout: this.device.createPipelineLayout({\n        bindGroupLayouts: bindGroups.map(entries => this.device.createBindGroupLayout({ entries })),\n      }),\n      compute: {\n        module,\n        entryPoint: 'main',\n      },\n    });\n    return pipeline;\n  }\n\n  createBindGroupWithLayout(bglEntries: Array<GPUBindGroupLayoutEntry>): GPUBindGroup {\n    const bgEntries: Array<GPUBindGroupEntry> = [];\n    for (const entry of bglEntries) {\n      const resource = this.getBindingResource(this.getBindingResourceType(entry));\n      bgEntries.push({\n        binding: entry.binding,\n        resource,\n      });\n    }\n\n    return this.device.createBindGroup({\n      entries: bgEntries,\n      layout: this.device.createBindGroupLayout({ entries: bglEntries }),\n    });\n  }\n\n  doCompute(pass: GPUComputePassEncoder, call: ComputeCmd | undefined, callWithZero: boolean) {\n    const x = callWithZero ? 0 : 1;\n    switch (call) {\n      case 'dispatch':\n        pass.dispatchWorkgroups(x, 1, 1);\n        break;\n      case 'dispatchIndirect':\n        pass.dispatchWorkgroupsIndirect(this.getIndirectBuffer([x, 1, 1]), 0);\n        break;\n      default:\n        break;\n    }\n  }\n\n  doRender(\n    pass: GPURenderPassEncoder | GPURenderBundleEncoder,\n    call: RenderCmd | undefined,\n    callWithZero: boolean\n  ) {\n    const vertexCount = callWithZero ? 0 : 3;\n    switch (call) {\n      case 'draw':\n        pass.draw(vertexCount, 1, 0, 0);\n        break;\n      case 'drawIndexed':\n        pass.setIndexBuffer(this.getIndexBuffer(), 'uint32');\n        pass.drawIndexed(vertexCount, 1, 0, 0, 0);\n        break;\n      case 'drawIndirect':\n        pass.drawIndirect(this.getIndirectBuffer([vertexCount, 1, 0, 0, 0]), 0);\n        break;\n      case 'drawIndexedIndirect':\n        pass.setIndexBuffer(this.getIndexBuffer(), 'uint32');\n        pass.drawIndexedIndirect(this.getIndirectBuffer([vertexCount, 1, 0, 0, 0]), 0);\n        break;\n      default:\n        break;\n    }\n  }\n\n  createBindGroupLayoutEntry(\n    encoderType: ProgrammableEncoderType,\n    resourceType: ValidBindableResource,\n    useU32Array: boolean\n  ): GPUBindGroupLayoutEntry {\n    const entry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility: encoderType === 'compute pass' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n    };\n\n    switch (resourceType) {\n      case 'uniformBuf':\n        entry.buffer = { hasDynamicOffset: useU32Array }; // default type: uniform\n        break;\n      case 'filtSamp':\n        entry.sampler = {}; // default type: filtering\n        break;\n      case 'sampledTex':\n        entry.texture = {}; // default sampleType: float\n        break;\n      case 'readonlyStorageTex':\n        entry.storageTexture = { access: 'read-only', format: 'r32float' };\n        break;\n      case 'writeonlyStorageTex':\n        entry.storageTexture = { access: 'write-only', format: 'r32float' };\n        break;\n      case 'readwriteStorageTex':\n        entry.storageTexture = { access: 'read-write', format: 'r32float' };\n        break;\n    }\n\n    return entry;\n  }\n\n  runTest(\n    encoderType: ProgrammableEncoderType,\n    pipeline: GPUComputePipeline | GPURenderPipeline,\n    bindGroups: Array<GPUBindGroup | undefined>,\n    dynamicOffsets: Array<number> | undefined,\n    call: ComputeCmd | RenderCmd | undefined,\n    callWithZero: boolean,\n    success: boolean\n  ) {\n    const { encoder, validateFinish } = this.createEncoder(encoderType);\n\n    if (encoder instanceof GPUComputePassEncoder) {\n      encoder.setPipeline(pipeline as GPUComputePipeline);\n    } else {\n      encoder.setPipeline(pipeline as GPURenderPipeline);\n    }\n\n    for (let i = 0; i < bindGroups.length; i++) {\n      const bindGroup = bindGroups[i];\n      if (!bindGroup) {\n        break;\n      }\n      if (dynamicOffsets) {\n        encoder.setBindGroup(\n          i,\n          bindGroup,\n          new Uint32Array(dynamicOffsets),\n          0,\n          dynamicOffsets.length\n        );\n      } else {\n        encoder.setBindGroup(i, bindGroup);\n      }\n    }\n\n    if (encoder instanceof GPUComputePassEncoder) {\n      this.doCompute(encoder, call as ComputeCmd, callWithZero);\n    } else {\n      this.doRender(encoder, call as RenderCmd, callWithZero);\n    }\n\n    validateFinish(success);\n  }\n\n  runDefaultLayoutBindingTest<T extends GPURenderPipeline | GPUComputePipeline>({\n    visibility,\n    empty,\n    pipelineType,\n    bindingType,\n    swap,\n    success,\n    makePipelinesFn,\n    doCommandFn,\n  }: {\n    visibility: number;\n    empty: boolean;\n    pipelineType: PipelineType;\n    bindingType: BindingType;\n    swap: boolean;\n    success: boolean;\n    makePipelinesFn: (t: F, explicitPipelineLayout: GPUPipelineLayout) => T[];\n    doCommandFn: (params: {\n      t: F;\n      encoder: GPUCommandEncoder;\n      pipeline: T;\n      emptyBindGroups: GPUBindGroup[];\n      nonEmptyBindGroups: GPUBindGroup[];\n    }) => void;\n  }) {\n    const { device } = this;\n    const explicitEmptyBindGroupLayout = device.createBindGroupLayout({\n      entries: [],\n    });\n    const explicitBindGroupLayout = device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility,\n          buffer: {},\n        },\n      ],\n    });\n    const explicitPipelineLayout = device.createPipelineLayout({\n      bindGroupLayouts: [\n        explicitEmptyBindGroupLayout,\n        explicitEmptyBindGroupLayout,\n        explicitBindGroupLayout,\n        explicitBindGroupLayout,\n      ],\n    });\n\n    const [pipelineAuto0, pipelineAuto1, pipelineExplicit] = makePipelinesFn(\n      this,\n      explicitPipelineLayout\n    );\n\n    const buffer = this.createBufferTracked({\n      size: 16,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n\n    let emptyBindGroupLayouts;\n    let nonEmptyBindGroupLayouts;\n    const pipeline = pipelineType === 'auto0' ? pipelineAuto0 : pipelineExplicit;\n\n    // Gets a bindGroupLayout either from the explicit layout passed in\n    // or one of the 2 `layout: 'auto'` pipelines.\n    const getBindGroupLayout = (\n      explicitBindGroupLayout: GPUBindGroupLayout,\n      bindGroupIndex: number\n    ) =>\n      bindingType === 'explicit'\n        ? explicitBindGroupLayout\n        : bindingType === 'auto0'\n        ? pipelineAuto0.getBindGroupLayout(bindGroupIndex)\n        : pipelineAuto1.getBindGroupLayout(bindGroupIndex);\n\n    if (empty) {\n      // Testing empty:\n      // - emptyBindGroupLayout comes from a possibly incompatible place.\n      // - nonEmptyBindGroupLayout comes from the pipeline we'll render/compute with.\n      emptyBindGroupLayouts = [\n        getBindGroupLayout(explicitEmptyBindGroupLayout, kEmptyBindGroup0Ndx),\n        getBindGroupLayout(explicitEmptyBindGroupLayout, kEmptyBindGroup1Ndx),\n      ];\n      if (swap) {\n        swapArrayElements(emptyBindGroupLayouts, 0, 1);\n      }\n      nonEmptyBindGroupLayouts = [\n        pipeline.getBindGroupLayout(kNonEmptyBindGroup0Ndx),\n        pipeline.getBindGroupLayout(kNonEmptyBindGroup1Ndx),\n      ];\n    } else {\n      // Testing non-empty:\n      // - nonEmptyBindGroupLayout comes from a possibly incompatible place.\n      // - emptyBindGroupLayout comes from the pipeline we'll render/compute with.\n      nonEmptyBindGroupLayouts = [\n        getBindGroupLayout(explicitBindGroupLayout, kNonEmptyBindGroup0Ndx),\n        getBindGroupLayout(explicitBindGroupLayout, kNonEmptyBindGroup1Ndx),\n      ];\n      if (swap) {\n        swapArrayElements(nonEmptyBindGroupLayouts, 0, 1);\n      }\n      emptyBindGroupLayouts = [\n        pipeline.getBindGroupLayout(kEmptyBindGroup0Ndx),\n        pipeline.getBindGroupLayout(kEmptyBindGroup1Ndx),\n      ];\n    }\n\n    const emptyBindGroups = emptyBindGroupLayouts.map(layout =>\n      device.createBindGroup({\n        layout,\n        entries: [],\n      })\n    );\n\n    const nonEmptyBindGroups = nonEmptyBindGroupLayouts.map(layout =>\n      device.createBindGroup({\n        layout,\n        entries: [{ binding: 0, resource: { buffer } }],\n      })\n    );\n\n    const encoder = device.createCommandEncoder();\n\n    doCommandFn({ t: this, encoder, pipeline, emptyBindGroups, nonEmptyBindGroups });\n\n    this.expectValidationError(() => {\n      encoder.finish();\n    }, !success);\n  }\n}\n\nexport const g = makeTestGroup(MaxLimitsTestMixin(F));\n\ng.test('bind_groups_and_pipeline_layout_mismatch')\n  .desc(\n    `\n    Tests the bind groups must match the requirements of the pipeline layout.\n    - bind groups required by the pipeline layout are required.\n    - bind groups unused by the pipeline layout can be set or not.\n    `\n  )\n  .params(\n    kCompatTestParams\n      .beginSubcases()\n      .combineWithParams([\n        { setBindGroup0: true, setBindGroup1: true, setUnusedBindGroup2: true, _success: true },\n        { setBindGroup0: true, setBindGroup1: true, setUnusedBindGroup2: false, _success: true },\n        { setBindGroup0: true, setBindGroup1: false, setUnusedBindGroup2: true, _success: false },\n        { setBindGroup0: false, setBindGroup1: true, setUnusedBindGroup2: true, _success: false },\n        { setBindGroup0: false, setBindGroup1: false, setUnusedBindGroup2: false, _success: false },\n      ])\n      .combine('useU32Array', [false, true])\n  )\n  .fn(t => {\n    const {\n      encoderType,\n      call,\n      callWithZero,\n      setBindGroup0,\n      setBindGroup1,\n      setUnusedBindGroup2,\n      _success,\n      useU32Array,\n    } = t.params;\n    const visibility =\n      encoderType === 'compute pass' ? GPUShaderStage.COMPUTE : GPUShaderStage.VERTEX;\n\n    const bindGroupLayouts: Array<Array<GPUBindGroupLayoutEntry>> = [\n      // bind group layout 0\n      [\n        {\n          binding: 0,\n          visibility,\n          buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n        },\n      ],\n      // bind group layout 1\n      [\n        {\n          binding: 0,\n          visibility,\n          buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n        },\n      ],\n    ];\n\n    // Create required bind groups\n    const bindGroup0 = setBindGroup0 ? t.createBindGroupWithLayout(bindGroupLayouts[0]) : undefined;\n    const bindGroup1 = setBindGroup1 ? t.createBindGroupWithLayout(bindGroupLayouts[1]) : undefined;\n    const unusedBindGroup2 = setUnusedBindGroup2\n      ? t.createBindGroupWithLayout(bindGroupLayouts[1])\n      : undefined;\n\n    // Create fixed pipeline\n    const pipeline =\n      encoderType === 'compute pass'\n        ? t.createComputePipelineWithLayout(bindGroupLayouts)\n        : t.createRenderPipelineWithLayout(bindGroupLayouts);\n\n    const dynamicOffsets = useU32Array ? [0] : undefined;\n\n    // Test without the dispatch/draw (should always be valid)\n    t.runTest(\n      encoderType,\n      pipeline,\n      [bindGroup0, bindGroup1, unusedBindGroup2],\n      dynamicOffsets,\n      undefined,\n      false,\n      true\n    );\n\n    // Test with the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    t.runTest(\n      encoderType,\n      pipeline,\n      [bindGroup0, bindGroup1, unusedBindGroup2],\n      dynamicOffsets,\n      call,\n      callWithZero,\n      _success\n    );\n  });\n\ng.test('buffer_binding,render_pipeline')\n  .desc(\n    `\n  The GPUBufferBindingLayout bindings configure should be exactly\n  same in PipelineLayout and bindgroup.\n  - TODO: test more draw functions, e.g. indirect\n  - TODO: test more visibilities, e.g. vertex\n  - TODO: bind group should be created with different layout\n  `\n  )\n  .params(u => u.combine('type', kBufferBindingTypes))\n  .fn(t => {\n    const { type } = t.params;\n\n    t.skipIf(\n      (type === 'storage' || type === 'read-only-storage') &&\n        t.isCompatibility &&\n        !(t.device.limits.maxStorageBuffersInFragmentStage! > 1),\n      `maxStorageBuffersInFragmentStage(${t.device.limits.maxStorageBuffersInFragmentStage}) is not >= 1`\n    );\n\n    // Create fixed bindGroup\n    const uniformBuffer = t.getUniformBuffer();\n\n    const bindGroup = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            buffer: {}, // default type: uniform\n          },\n        ],\n      }),\n    });\n\n    // Create pipeline with different layouts\n    const pipeline = t.createRenderPipelineWithLayout([\n      [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT,\n          buffer: {\n            type,\n          },\n        },\n      ],\n    ]);\n\n    const { encoder, validateFinish } = t.createEncoder('render pass');\n    encoder.setPipeline(pipeline);\n    encoder.setBindGroup(0, bindGroup);\n    encoder.draw(3);\n\n    validateFinish(type === undefined || type === 'uniform');\n  });\n\ng.test('sampler_binding,render_pipeline')\n  .desc(\n    `\n  The GPUSamplerBindingLayout bindings configure should be exactly\n  same in PipelineLayout and bindgroup.\n  - TODO: test more draw functions, e.g. indirect\n  - TODO: test more visibilities, e.g. vertex\n  `\n  )\n  .params(u =>\n    u //\n      .combine('bglType', kSamplerBindingTypes)\n      .combine('bgType', kSamplerBindingTypes)\n  )\n  .fn(t => {\n    const { bglType, bgType } = t.params;\n    const bindGroup = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource:\n            bgType === 'comparison'\n              ? t.device.createSampler({ compare: 'always' })\n              : t.device.createSampler(),\n        },\n      ],\n      layout: t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            sampler: { type: bgType },\n          },\n        ],\n      }),\n    });\n\n    // Create pipeline with different layouts\n    const pipeline = t.createRenderPipelineWithLayout([\n      [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT,\n          sampler: {\n            type: bglType,\n          },\n        },\n      ],\n    ]);\n\n    const { encoder, validateFinish } = t.createEncoder('render pass');\n    encoder.setPipeline(pipeline);\n    encoder.setBindGroup(0, bindGroup);\n    encoder.draw(3);\n\n    validateFinish(bglType === bgType);\n  });\n\ng.test('bgl_binding_mismatch')\n  .desc(\n    'Tests the binding number must exist or not exist in both bindGroups[i].layout and pipelineLayout.bgls[i]'\n  )\n  .params(\n    kCompatTestParams\n      .beginSubcases()\n      .combineWithParams([\n        { bgBindings: [0, 1, 2], plBindings: [0, 1, 2], _success: true },\n        { bgBindings: [0, 1, 2], plBindings: [0, 1, 3], _success: false },\n        { bgBindings: [0, 2], plBindings: [0, 2], _success: true },\n        { bgBindings: [0, 2], plBindings: [2, 0], _success: true },\n        { bgBindings: [0, 1, 2], plBindings: [0, 1], _success: false },\n        { bgBindings: [0, 1], plBindings: [0, 1, 2], _success: false },\n      ])\n      .combine('useU32Array', [false, true])\n  )\n  .fn(t => {\n    const { encoderType, call, callWithZero, bgBindings, plBindings, _success, useU32Array } =\n      t.params;\n    const visibility =\n      encoderType === 'compute pass' ? GPUShaderStage.COMPUTE : GPUShaderStage.VERTEX;\n\n    const bglEntries: Array<GPUBindGroupLayoutEntry> = [];\n    for (const binding of bgBindings) {\n      bglEntries.push({\n        binding,\n        visibility,\n        buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n      });\n    }\n    const bindGroup = t.createBindGroupWithLayout(bglEntries);\n\n    const plEntries: Array<Array<GPUBindGroupLayoutEntry>> = [[]];\n    for (const binding of plBindings) {\n      plEntries[0].push({\n        binding,\n        visibility,\n        buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n      });\n    }\n    const pipeline =\n      encoderType === 'compute pass'\n        ? t.createComputePipelineWithLayout(plEntries)\n        : t.createRenderPipelineWithLayout(plEntries);\n\n    const dynamicOffsets = useU32Array ? new Array(bgBindings.length).fill(0) : undefined;\n\n    // Test without the dispatch/draw (should always be valid)\n    t.runTest(encoderType, pipeline, [bindGroup], dynamicOffsets, undefined, false, true);\n\n    // Test with the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    t.runTest(encoderType, pipeline, [bindGroup], dynamicOffsets, call, callWithZero, _success);\n  });\n\ng.test('bgl_visibility_mismatch')\n  .desc('Tests the visibility in bindGroups[i].layout and pipelineLayout.bgls[i] must be matched')\n  .params(\n    kCompatTestParams\n      .beginSubcases()\n      .combine('bgVisibility', kShaderStageCombinations)\n      .expand('plVisibility', p =>\n        p.encoderType === 'compute pass'\n          ? ([GPUConst.ShaderStage.COMPUTE] as const)\n          : ([\n              GPUConst.ShaderStage.VERTEX,\n              GPUConst.ShaderStage.FRAGMENT,\n              GPUConst.ShaderStage.VERTEX | GPUConst.ShaderStage.FRAGMENT,\n            ] as const)\n      )\n      .combine('useU32Array', [false, true])\n  )\n  .fn(t => {\n    const { encoderType, call, callWithZero, bgVisibility, plVisibility, useU32Array } = t.params;\n\n    const bglEntries: Array<GPUBindGroupLayoutEntry> = [\n      {\n        binding: 0,\n        visibility: bgVisibility,\n        buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n      },\n    ];\n    const bindGroup = t.createBindGroupWithLayout(bglEntries);\n\n    const plEntries: Array<Array<GPUBindGroupLayoutEntry>> = [\n      [\n        {\n          binding: 0,\n          visibility: plVisibility,\n          buffer: { hasDynamicOffset: useU32Array }, // default type: uniform\n        },\n      ],\n    ];\n    const pipeline =\n      encoderType === 'compute pass'\n        ? t.createComputePipelineWithLayout(plEntries)\n        : t.createRenderPipelineWithLayout(plEntries);\n\n    const dynamicOffsets = useU32Array ? [0] : undefined;\n\n    // Test without the dispatch/draw (should always be valid)\n    t.runTest(encoderType, pipeline, [bindGroup], dynamicOffsets, undefined, false, true);\n\n    // Test with the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    t.runTest(\n      encoderType,\n      pipeline,\n      [bindGroup],\n      dynamicOffsets,\n      call,\n      callWithZero,\n      bgVisibility === plVisibility\n    );\n  });\n\nfunction resourceIsStorageTexture(resourceType: ValidBindableResource) {\n  return (\n    resourceType === 'readonlyStorageTex' ||\n    resourceType === 'readwriteStorageTex' ||\n    resourceType === 'writeonlyStorageTex'\n  );\n}\n\nfunction resourceIsStorageBuffer(resourceType: ValidBindableResource) {\n  return resourceType === 'storageBuf';\n}\n\ng.test('bgl_resource_type_mismatch')\n  .desc(\n    `\n  Tests the binding resource type in bindGroups[i].layout and pipelineLayout.bgls[i] must be matched\n  - TODO: Test externalTexture\n  `\n  )\n  .params(\n    kCompatTestParams\n      .beginSubcases()\n      .combine('bgResourceType', kResourceTypes)\n      .combine('plResourceType', kResourceTypes)\n      .expand('useU32Array', p => (p.bgResourceType === 'uniformBuf' ? [true, false] : [false]))\n  )\n  .fn(t => {\n    const { encoderType, call, callWithZero, bgResourceType, plResourceType, useU32Array } =\n      t.params;\n\n    t.skipIf(\n      t.isCompatibility &&\n        resourceIsStorageTexture(plResourceType) &&\n        !(t.device.limits.maxStorageTexturesInFragmentStage! >= 1),\n      `maxStorageTexturesInFragmentStage(${t.device.limits.maxStorageTexturesInFragmentStage}) is not >= 1`\n    );\n\n    t.skipIf(\n      t.isCompatibility &&\n        resourceIsStorageBuffer(plResourceType) &&\n        !(t.device.limits.maxStorageBuffersInFragmentStage! >= 1),\n      `maxStorageBuffersInFragmentStage(${t.device.limits.maxStorageBuffersInFragmentStage}) is not >= 1`\n    );\n\n    const bglEntries: Array<GPUBindGroupLayoutEntry> = [\n      t.createBindGroupLayoutEntry(encoderType, bgResourceType, useU32Array),\n    ];\n    const bindGroup = t.createBindGroupWithLayout(bglEntries);\n\n    const plEntries: Array<Array<GPUBindGroupLayoutEntry>> = [\n      [t.createBindGroupLayoutEntry(encoderType, plResourceType, useU32Array)],\n    ];\n    const pipeline =\n      encoderType === 'compute pass'\n        ? t.createComputePipelineWithLayout(plEntries)\n        : t.createRenderPipelineWithLayout(plEntries);\n\n    const dynamicOffsets = useU32Array ? [0] : undefined;\n\n    // Test without the dispatch/draw (should always be valid)\n    t.runTest(encoderType, pipeline, [bindGroup], dynamicOffsets, undefined, false, true);\n\n    // Test with the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    t.runTest(\n      encoderType,\n      pipeline,\n      [bindGroup],\n      dynamicOffsets,\n      call,\n      callWithZero,\n      bgResourceType === plResourceType\n    );\n  });\n\ng.test('empty_bind_group_layouts_never_requires_empty_bind_groups,compute_pass')\n  .desc(\n    `\n  Test that a compute pipeline with empty bind group layouts doesn't require empty bind groups to be\n  set as empty bind group layout items should always be ignored.\n  `\n  )\n  .params(u =>\n    u\n      .combine('emptyBindGroupLayoutType', ['Null', 'Undefined', 'Empty'] as const)\n      .combine('bindGroupLayoutEntryCount', [3, 4])\n      .combine('computeCommand', ['dispatchIndirect', 'dispatch'] as const)\n  )\n  .fn(t => {\n    const { emptyBindGroupLayoutType, bindGroupLayoutEntryCount, computeCommand } = t.params;\n\n    const emptyBGLCount = 4;\n    const emptyBGL = t.device.createBindGroupLayout({ entries: [] });\n    const emptyBGLs = [];\n    for (let i = 0; i < emptyBGLCount; i++) {\n      switch (emptyBindGroupLayoutType) {\n        case 'Null':\n          emptyBGLs.push(null);\n          break;\n        case 'Undefined':\n          emptyBGLs.push(undefined);\n          break;\n        case 'Empty':\n          emptyBGLs.push(emptyBGL);\n          break;\n      }\n    }\n\n    const pipelineLayout = t.device.createPipelineLayout({\n      bindGroupLayouts: emptyBGLs,\n    });\n\n    const pipeline = t.device.createComputePipeline({\n      layout: pipelineLayout,\n      compute: {\n        module: t.device.createShaderModule({\n          code: '@compute @workgroup_size(1) fn main() {}',\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const emptyBindGroup = t.device.createBindGroup({\n      layout: emptyBGL,\n      entries: [],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setPipeline(pipeline);\n    for (let i = 0; i < bindGroupLayoutEntryCount; i++) {\n      computePass.setBindGroup(i, emptyBindGroup);\n    }\n\n    t.doCompute(computePass, computeCommand, true);\n    computePass.end();\n\n    const success = true;\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, !success);\n  });\n\ng.test('empty_bind_group_layouts_never_requires_empty_bind_groups,render_pass')\n  .desc(\n    `\n  Test that a render pipeline with empty bind groups layouts doesn't require empty bind groups to be\n  set as empty bind group layout items should always be ignored.\n  `\n  )\n  .params(u =>\n    u\n      .combine('emptyBindGroupLayoutType', ['Null', 'Undefined', 'Empty'] as const)\n      .combine('bindGroupLayoutEntryCount', [3, 4])\n      .combine('renderCommand', [\n        'draw',\n        'drawIndexed',\n        'drawIndirect',\n        'drawIndexedIndirect',\n      ] as const)\n  )\n  .fn(t => {\n    const { emptyBindGroupLayoutType, bindGroupLayoutEntryCount, renderCommand } = t.params;\n\n    const emptyBGLCount = 4;\n    const emptyBGL = t.device.createBindGroupLayout({ entries: [] });\n    const emptyBGLs = [];\n    for (let i = 0; i < emptyBGLCount; i++) {\n      switch (emptyBindGroupLayoutType) {\n        case 'Null':\n          emptyBGLs.push(null);\n          break;\n        case 'Undefined':\n          emptyBGLs.push(undefined);\n          break;\n        case 'Empty':\n          emptyBGLs.push(emptyBGL);\n          break;\n      }\n    }\n\n    const pipelineLayout = t.device.createPipelineLayout({\n      bindGroupLayouts: emptyBGLs,\n    });\n\n    const colorFormat = 'rgba8unorm';\n    const pipeline = t.device.createRenderPipeline({\n      layout: pipelineLayout,\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `@vertex fn main() -> @builtin(position) vec4<f32> { return vec4<f32>(); }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `@fragment fn main() {}`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: colorFormat, writeMask: 0 }],\n      },\n    });\n\n    const emptyBindGroup = t.device.createBindGroup({\n      layout: emptyBGL,\n      entries: [],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    const attachmentTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    renderPass.setPipeline(pipeline);\n    for (let i = 0; i < bindGroupLayoutEntryCount; i++) {\n      renderPass.setBindGroup(i, emptyBindGroup);\n    }\n    t.doRender(renderPass, renderCommand, true);\n    renderPass.end();\n\n    const success = true;\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, !success);\n  });\n\n// pipelineType specifies which pipeline to try to render/compute with\n//    auto0 = the first `layout: 'auto'` pipeline\n//    explicit = a pipeline crated with an explicit pipeline layout using explicit bind group layouts\n//\n// bindingType specifies where to get bindGroupLayouts to use to create bindGroups\n//    auto0 = the first `layout: 'auto'` pipeline\n//    auto1 = the second `layout: 'auto'` pipeline\n//    explicit = a pipeline crated with an explicit pipeline layout using explicit bind group layouts\n//\n// swap specifies to swap the bindgroups we're testing. We test 2 of each type, 2 empty bindgroups and\n// 2 non-empty bindgroups. The 2 empty bindgroups, when swapped should still be compatible. Similarly\n// the 2 non-empty bindgroups, when swapped, should still be compatible.\nconst kPipelineTypesAndBindingTypeParams = [\n  { pipelineType: 'auto0', bindingType: 'auto0', swap: false, _success: true },\n  { pipelineType: 'explicit', bindingType: 'explicit', swap: false, _success: true },\n  { pipelineType: 'explicit', bindingType: 'auto0', swap: false, _success: false },\n  { pipelineType: 'auto0', bindingType: 'explicit', swap: false, _success: false },\n  { pipelineType: 'auto0', bindingType: 'auto1', swap: false, _success: false },\n  { pipelineType: 'auto0', bindingType: 'auto0', swap: true, _success: true },\n] as const;\n\ng.test('default_bind_group_layouts_never_match,compute_pass')\n  .desc(\n    `\n  Test that bind groups created with default bind group layouts never match other layouts, except\n  when the default bind group layouts are empty because the empty bind group layouts should all be\n  treated as null bind group layouts and be ignored when checking setBindGroup() against the current\n  pipeline.\n\n  * Test that a pipeline with an explicit layout can not be used with a bindGroup from an auto\n    layout except the explicit layout is empty.\n  * Test that a pipeline with an auto layout can not be used with a bindGroup from an explicit\n    layout except the layout got from the pipeline is empty.\n  * Test that an auto layout from one pipeline can not be used with an auto layout from a different\n    pipeline except the layouts got from the pipeline are empty.\n  * Test matching bindgroup layouts on the same default layout pipeline are compatible. In other words if\n    you only define group(2) then group(0)'s empty layout and group(1)'s empty layout should be compatible.\n    Similarly if group(2) and group(3) have the same types of resources they should be compatible.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kPipelineTypesAndBindingTypeParams)\n      .combine('empty', [false, true])\n      .combine('computeCommand', ['dispatchIndirect', 'dispatch'] as const)\n  )\n  .fn(t => {\n    const {\n      pipelineType,\n      bindingType,\n      swap,\n      _success: successWhenNonEmpty,\n      computeCommand,\n      empty,\n    } = t.params;\n\n    const success = empty || successWhenNonEmpty;\n\n    t.runDefaultLayoutBindingTest<GPUComputePipeline>({\n      visibility: GPUShaderStage.COMPUTE,\n      empty,\n      pipelineType,\n      bindingType,\n      swap,\n      success,\n      makePipelinesFn: (t, explicitPipelineLayout) => {\n        return (['auto', 'auto', explicitPipelineLayout] as const).map<GPUComputePipeline>(layout =>\n          t.device.createComputePipeline({\n            layout,\n            compute: {\n              module: t.device.createShaderModule({\n                code: `\n                @group(2) @binding(0) var<uniform> u1: vec4f;\n                @group(3) @binding(0) var<uniform> u2: vec4f;\n                @compute @workgroup_size(2) fn main() { _ = u1; _ = u2; }\n              `,\n              }),\n              entryPoint: 'main',\n            },\n          })\n        );\n      },\n      doCommandFn: ({ t, encoder, pipeline, emptyBindGroups, nonEmptyBindGroups }) => {\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(kEmptyBindGroup0Ndx, emptyBindGroups[0]);\n        pass.setBindGroup(kEmptyBindGroup1Ndx, emptyBindGroups[1]);\n        pass.setBindGroup(kNonEmptyBindGroup0Ndx, nonEmptyBindGroups[0]);\n        pass.setBindGroup(kNonEmptyBindGroup1Ndx, nonEmptyBindGroups[1]);\n        t.doCompute(pass, computeCommand, true);\n        pass.end();\n      },\n    });\n  });\n\ng.test('default_bind_group_layouts_never_match,render_pass')\n  .desc(\n    `\n  Test that bind groups created with default bind group layouts never match other layouts, except\n  when the default bind group layouts are empty because the empty bind group layouts should all be\n  treated as null bind group layouts and be ignored when checking setBindGroup() against the current\n  pipeline.\n\n  * Test that a pipeline with an explicit layout can not be used with a bindGroup from an auto\n    layout except the explicit layout is empty.\n  * Test that a pipeline with an auto layout can not be used with a bindGroup from an explicit\n    layout except the layout got from the pipeline is empty.\n  * Test that an auto layout from one pipeline can not be used with an auto layout from a different\n    pipeline except the layouts got from the pipeline are empty.\n  * Test matching bindgroup layouts on the same default layout pipeline are compatible. In other words if\n    you only define group(2) then group(0)'s empty layout and group(1)'s empty layout should be compatible.\n    Similarly if group(2) and group(3) have the same types of resources they should be compatible.\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams(kPipelineTypesAndBindingTypeParams)\n      .combine('empty', [false, true])\n      .combine('renderCommand', [\n        'draw',\n        'drawIndexed',\n        'drawIndirect',\n        'drawIndexedIndirect',\n      ] as const)\n  )\n  .fn(t => {\n    const {\n      pipelineType,\n      bindingType,\n      swap,\n      _success: successWhenNonEmpty,\n      renderCommand,\n      empty,\n    } = t.params;\n\n    const success = empty || successWhenNonEmpty;\n\n    t.runDefaultLayoutBindingTest<GPURenderPipeline>({\n      visibility: GPUShaderStage.VERTEX,\n      empty,\n      pipelineType,\n      bindingType,\n      swap,\n      success,\n      makePipelinesFn: (t, explicitPipelineLayout) => {\n        return (['auto', 'auto', explicitPipelineLayout] as const).map<GPURenderPipeline>(\n          layout => {\n            const colorFormat = 'rgba8unorm';\n            return t.device.createRenderPipeline({\n              layout,\n              vertex: {\n                module: t.device.createShaderModule({\n                  code: `\n                @group(2) @binding(0) var<uniform> u1: vec4f;\n                @group(3) @binding(0) var<uniform> u2: vec4f;\n                @vertex fn main() -> @builtin(position) vec4f { return u1 + u2; }\n              `,\n                }),\n                entryPoint: 'main',\n              },\n              fragment: {\n                module: t.device.createShaderModule({\n                  code: `@fragment fn main() {}`,\n                }),\n                entryPoint: 'main',\n                targets: [{ format: colorFormat, writeMask: 0 }],\n              },\n            });\n          }\n        );\n      },\n      doCommandFn: ({ t, encoder, pipeline, emptyBindGroups, nonEmptyBindGroups }) => {\n        const attachmentTexture = t.createTextureTracked({\n          format: 'rgba8unorm',\n          size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const renderPass = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: attachmentTexture.createView(),\n              clearValue: [0, 0, 0, 0],\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n\n        renderPass.setPipeline(pipeline);\n        renderPass.setBindGroup(kEmptyBindGroup0Ndx, emptyBindGroups[0]);\n        renderPass.setBindGroup(kEmptyBindGroup1Ndx, emptyBindGroups[1]);\n        renderPass.setBindGroup(kNonEmptyBindGroup0Ndx, nonEmptyBindGroups[0]);\n        renderPass.setBindGroup(kNonEmptyBindGroup1Ndx, nonEmptyBindGroups[1]);\n        t.doRender(renderPass, renderCommand, true);\n        renderPass.end();\n      },\n    });\n  });\n"],"mappings":"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"}