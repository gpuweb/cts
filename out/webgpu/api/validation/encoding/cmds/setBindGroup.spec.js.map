{"version":3,"file":"setBindGroup.spec.js","names":["description","makeTestGroup","makeValueTestVariant","range","unreachable","kBufferBindingTypes","kMinDynamicBufferOffsetAlignment","kResourceStates","kProgrammableEncoderTypes","ValidationTest","F","encoderTypeToStageFlag","encoderType","GPUShaderStage","COMPUTE","FRAGMENT","createBindingResourceWithState","resourceType","state","texture","createTextureWithState","view","createView","destroy","buffer","createBufferWithState","size","usage","GPUBufferUsage","STORAGE","createBindGroup","indices","device","pushErrorScope","Array","length","fill","layout","createBindGroupLayout","entries","map","binding","visibility","type","bindGroup","resource","popErrorScope","g","test","desc","params","u","combine","fn","t","maxBindGroups","limits","runTest","index","encoder","validateFinishAndSubmit","createEncoder","setBindGroup","debug","beginSubcases","beforeAllSubcases","selectMismatchedDeviceOrSkipTestCase","undefined","useU32Array","mismatched","sourceDevice","mismatchedDevice","createBuffer","hasDynamicOffset","validateFinish","Uint32Array","dynamicOffsets","combineWithParams","_success","kBindingSize","bindGroupLayout","uniformBuffer","UNIFORM","storageBuffer","useU32array","paramsSubcasesOnly","offsets","dynamicOffsetsDataStart","dynamicOffsetsDataLength","i","doSetBindGroup","shouldThrow","mult","add","dynamicOffsetVariant","minAlignment","dynamicOffset","isValid"],"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/setBindGroup.spec.ts"],"sourcesContent":["export const description = `\nsetBindGroup validation tests.\n\nTODO: merge these notes and implement.\n> (Note: If there are errors with using certain binding types in certain passes, test those in the file for that pass type, not here.)\n>\n> - state tracking (probably separate file)\n>     - x= {compute pass, render pass}\n>     - {null, compatible, incompatible} current pipeline (should have no effect without draw/dispatch)\n>     - setBindGroup in different orders (e.g. 0,1,2 vs 2,0,1)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { makeValueTestVariant, range, unreachable } from '../../../../../common/util/util.js';\nimport {\n  kBufferBindingTypes,\n  kMinDynamicBufferOffsetAlignment,\n} from '../../../../capability_info.js';\nimport { kResourceStates, ResourceState } from '../../../../gpu_test.js';\nimport {\n  kProgrammableEncoderTypes,\n  ProgrammableEncoderType,\n} from '../../../../util/command_buffer_maker.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  encoderTypeToStageFlag(encoderType: ProgrammableEncoderType): GPUShaderStageFlags {\n    switch (encoderType) {\n      case 'compute pass':\n        return GPUShaderStage.COMPUTE;\n      case 'render pass':\n      case 'render bundle':\n        return GPUShaderStage.FRAGMENT;\n      default:\n        unreachable('Unknown encoder type');\n    }\n  }\n\n  createBindingResourceWithState(\n    resourceType: 'texture' | 'buffer',\n    state: 'valid' | 'destroyed'\n  ): GPUBindingResource {\n    switch (resourceType) {\n      case 'texture': {\n        const texture = this.createTextureWithState('valid');\n        const view = texture.createView();\n        if (state === 'destroyed') {\n          texture.destroy();\n        }\n        return view;\n      }\n      case 'buffer':\n        return {\n          buffer: this.createBufferWithState(state, {\n            size: 4,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n        };\n      default:\n        unreachable('unknown resource type');\n    }\n  }\n\n  /**\n   * If state is 'invalid', creates an invalid bind group with valid resources.\n   * If state is 'destroyed', creates a valid bind group with destroyed resources.\n   */\n  createBindGroup(\n    state: ResourceState,\n    resourceType: 'buffer' | 'texture',\n    encoderType: ProgrammableEncoderType,\n    indices: number[]\n  ) {\n    if (state === 'invalid') {\n      this.device.pushErrorScope('validation');\n      indices = new Array<number>(indices.length + 1).fill(0);\n    }\n\n    const layout = this.device.createBindGroupLayout({\n      entries: indices.map(binding => ({\n        binding,\n        visibility: this.encoderTypeToStageFlag(encoderType),\n        ...(resourceType === 'buffer' ? { buffer: { type: 'storage' } } : { texture: {} }),\n      })),\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout,\n      entries: indices.map(binding => ({\n        binding,\n        resource: this.createBindingResourceWithState(\n          resourceType,\n          state === 'destroyed' ? state : 'valid'\n        ),\n      })),\n    });\n\n    if (state === 'invalid') {\n      void this.device.popErrorScope();\n    }\n    return bindGroup;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('state_and_binding_index')\n  .desc('Tests that setBindGroup correctly handles {valid, invalid, destroyed} bindGroups.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combine('state', kResourceStates)\n      .combine('resourceType', ['buffer', 'texture'] as const)\n  )\n  .fn(t => {\n    const { encoderType, state, resourceType } = t.params;\n    const maxBindGroups = t.device.limits.maxBindGroups;\n\n    function runTest(index: number) {\n      const { encoder, validateFinishAndSubmit } = t.createEncoder(encoderType);\n      encoder.setBindGroup(index, t.createBindGroup(state, resourceType, encoderType, [index]));\n\n      validateFinishAndSubmit(state !== 'invalid' && index < maxBindGroups, state !== 'destroyed');\n    }\n\n    // MAINTENANCE_TODO: move to subcases() once we can query the device limits\n    for (const index of [1, maxBindGroups - 1, maxBindGroups]) {\n      t.debug(`test bind group index ${index}`);\n      runTest(index);\n    }\n  });\n\ng.test('bind_group,device_mismatch')\n  .desc(\n    `\n    Tests setBindGroup cannot be called with a bind group created from another device\n    - x= setBindGroup {sequence overload, Uint32Array overload}\n    `\n  )\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .beginSubcases()\n      .combine('useU32Array', [true, false])\n      .combine('mismatched', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    t.selectMismatchedDeviceOrSkipTestCase(undefined);\n  })\n  .fn(t => {\n    const { encoderType, useU32Array, mismatched } = t.params;\n    const sourceDevice = mismatched ? t.mismatchedDevice : t.device;\n\n    const buffer = sourceDevice.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.STORAGE,\n    });\n\n    const layout = sourceDevice.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: t.encoderTypeToStageFlag(encoderType),\n          buffer: { type: 'storage', hasDynamicOffset: useU32Array },\n        },\n      ],\n    });\n\n    const bindGroup = sourceDevice.createBindGroup({\n      layout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer },\n        },\n      ],\n    });\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    if (useU32Array) {\n      encoder.setBindGroup(0, bindGroup, new Uint32Array([0]), 0, 1);\n    } else {\n      encoder.setBindGroup(0, bindGroup);\n    }\n    validateFinish(!mismatched);\n  });\n\ng.test('dynamic_offsets_passed_but_not_expected')\n  .desc('Tests that setBindGroup correctly errors on unexpected dynamicOffsets.')\n  .params(u => u.combine('encoderType', kProgrammableEncoderTypes))\n  .fn(t => {\n    const { encoderType } = t.params;\n    const bindGroup = t.createBindGroup('valid', 'buffer', encoderType, []);\n    const dynamicOffsets = [0];\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n    validateFinish(false);\n  });\n\ng.test('dynamic_offsets_match_expectations_in_pass_encoder')\n  .desc('Tests that given dynamicOffsets match the specified bindGroup.')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .combineWithParams([\n        { dynamicOffsets: [256, 0], _success: true }, // Dynamic offsets aligned\n        { dynamicOffsets: [1, 2], _success: false }, // Dynamic offsets not aligned\n\n        // Wrong number of dynamic offsets\n        { dynamicOffsets: [256, 0, 0], _success: false },\n        { dynamicOffsets: [256], _success: false },\n        { dynamicOffsets: [], _success: false },\n\n        // Dynamic uniform buffer out of bounds because of binding size\n        { dynamicOffsets: [512, 0], _success: false },\n        { dynamicOffsets: [1024, 0], _success: false },\n        { dynamicOffsets: [0xffffffff, 0], _success: false },\n\n        // Dynamic storage buffer out of bounds because of binding size\n        { dynamicOffsets: [0, 512], _success: false },\n        { dynamicOffsets: [0, 1024], _success: false },\n        { dynamicOffsets: [0, 0xffffffff], _success: false },\n      ])\n      .combine('useU32array', [false, true])\n  )\n  .fn(t => {\n    const kBindingSize = 12;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'uniform',\n            hasDynamicOffset: true,\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n          buffer: {\n            type: 'storage',\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n\n    const uniformBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n\n    const storageBuffer = t.device.createBuffer({\n      size: 2 * kMinDynamicBufferOffsetAlignment + 8,\n      usage: GPUBufferUsage.STORAGE,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: kBindingSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: storageBuffer,\n            size: kBindingSize,\n          },\n        },\n      ],\n    });\n\n    const { encoderType, dynamicOffsets, useU32array, _success } = t.params;\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    if (useU32array) {\n      encoder.setBindGroup(0, bindGroup, new Uint32Array(dynamicOffsets), 0, dynamicOffsets.length);\n    } else {\n      encoder.setBindGroup(0, bindGroup, dynamicOffsets);\n    }\n    validateFinish(_success);\n  });\n\ng.test('u32array_start_and_length')\n  .desc('Tests that dynamicOffsetsData(Start|Length) apply to the given Uint32Array.')\n  .paramsSubcasesOnly([\n    // dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: false,\n    },\n    // dynamicOffsetsDataStart + dynamicOffsetsDataLength > offsets.length\n    {\n      offsets: [0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: false,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0, 0] as const,\n      dynamicOffsetsDataStart: 1,\n      dynamicOffsetsDataLength: 1,\n      _success: true,\n    },\n    {\n      offsets: [0, 0] as const,\n      dynamicOffsetsDataStart: 0,\n      dynamicOffsetsDataLength: 2,\n      _success: true,\n    },\n  ])\n  .fn(t => {\n    const { offsets, dynamicOffsetsDataStart, dynamicOffsetsDataLength, _success } = t.params;\n    const kBindingSize = 8;\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        visibility: GPUShaderStage.FRAGMENT,\n        buffer: {\n          type: 'storage',\n          hasDynamicOffset: true,\n        },\n      })),\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: range(dynamicOffsetsDataLength, i => ({\n        binding: i,\n        resource: {\n          buffer: t.createBufferWithState('valid', {\n            size: kBindingSize,\n            usage: GPUBufferUsage.STORAGE,\n          }),\n          size: kBindingSize,\n        },\n      })),\n    });\n\n    const { encoder, validateFinish } = t.createEncoder('render pass');\n\n    const doSetBindGroup = () => {\n      encoder.setBindGroup(\n        0,\n        bindGroup,\n        new Uint32Array(offsets),\n        dynamicOffsetsDataStart,\n        dynamicOffsetsDataLength\n      );\n    };\n\n    if (_success) {\n      doSetBindGroup();\n    } else {\n      t.shouldThrow('RangeError', doSetBindGroup);\n    }\n\n    // RangeError in setBindGroup does not cause the encoder to become invalid.\n    validateFinish(true);\n  });\n\ng.test('buffer_dynamic_offsets')\n  .desc(\n    `\n    Test that the dynamic offsets of the BufferLayout is a multiple of\n    'minUniformBufferOffsetAlignment|minStorageBufferOffsetAlignment' if the BindGroup entry defines\n    buffer and the buffer type is 'uniform|storage|read-only-storage'.\n  `\n  )\n  .params(u =>\n    u //\n      .combine('type', kBufferBindingTypes)\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .beginSubcases()\n      .combine('dynamicOffsetVariant', [\n        { mult: 1, add: 0 },\n        { mult: 0.5, add: 0 },\n        { mult: 1.5, add: 0 },\n        { mult: 2, add: 0 },\n        { mult: 1, add: 2 },\n      ])\n  )\n  .fn(t => {\n    const { type, dynamicOffsetVariant, encoderType } = t.params;\n    const kBindingSize = 12;\n\n    const minAlignment =\n      t.device.limits[\n        type === 'uniform' ? 'minUniformBufferOffsetAlignment' : 'minStorageBufferOffsetAlignment'\n      ];\n    const dynamicOffset = makeValueTestVariant(minAlignment, dynamicOffsetVariant);\n\n    const bindGroupLayout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: { type, hasDynamicOffset: true },\n        },\n      ],\n    });\n\n    const usage = type === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE;\n    const isValid = dynamicOffset % minAlignment === 0;\n\n    const buffer = t.device.createBuffer({\n      size: 3 * kMinDynamicBufferOffsetAlignment,\n      usage,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      entries: [{ binding: 0, resource: { buffer, size: kBindingSize } }],\n      layout: bindGroupLayout,\n    });\n\n    const { encoder, validateFinish } = t.createEncoder(encoderType);\n    encoder.setBindGroup(0, bindGroup, [dynamicOffset]);\n    validateFinish(isValid);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,+CAA+C;AAC7E,SAASC,oBAAoB,EAAEC,KAAK,EAAEC,WAAW,QAAQ,oCAAoC;AAC7F;EACEC,mBAAmB;EACnBC,gCAAgC;AAC3B,gCAAgC;AACvC,SAASC,eAAe,QAAuB,yBAAyB;AACxE;EACEC,yBAAyB;;AAEpB,0CAA0C;AACjD,SAASC,cAAc,QAAQ,0BAA0B;;AAEzD,MAAMC,CAAC,SAASD,cAAc,CAAC;EAC7BE,sBAAsBA,CAACC,WAAoC,EAAuB;IAChF,QAAQA,WAAW;MACjB,KAAK,cAAc;QACjB,OAAOC,cAAc,CAACC,OAAO;MAC/B,KAAK,aAAa;MAClB,KAAK,eAAe;QAClB,OAAOD,cAAc,CAACE,QAAQ;MAChC;QACEX,WAAW,CAAC,sBAAsB,CAAC;IACvC;EACF;;EAEAY,8BAA8BA;EAC5BC,YAAkC;EAClCC,KAA4B;EACR;IACpB,QAAQD,YAAY;MAClB,KAAK,SAAS,CAAE;UACd,MAAME,OAAO,GAAG,IAAI,CAACC,sBAAsB,CAAC,OAAO,CAAC;UACpD,MAAMC,IAAI,GAAGF,OAAO,CAACG,UAAU,CAAC,CAAC;UACjC,IAAIJ,KAAK,KAAK,WAAW,EAAE;YACzBC,OAAO,CAACI,OAAO,CAAC,CAAC;UACnB;UACA,OAAOF,IAAI;QACb;MACA,KAAK,QAAQ;QACX,OAAO;UACLG,MAAM,EAAE,IAAI,CAACC,qBAAqB,CAACP,KAAK,EAAE;YACxCQ,IAAI,EAAE,CAAC;YACPC,KAAK,EAAEC,cAAc,CAACC;UACxB,CAAC;QACH,CAAC;MACH;QACEzB,WAAW,CAAC,uBAAuB,CAAC;IACxC;EACF;;EAEA;AACF;AACA;AACA;EACE0B,eAAeA;EACbZ,KAAoB;EACpBD,YAAkC;EAClCL,WAAoC;EACpCmB,OAAiB;EACjB;IACA,IAAIb,KAAK,KAAK,SAAS,EAAE;MACvB,IAAI,CAACc,MAAM,CAACC,cAAc,CAAC,YAAY,CAAC;MACxCF,OAAO,GAAG,IAAIG,KAAK,CAASH,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;IACzD;;IAEA,MAAMC,MAAM,GAAG,IAAI,CAACL,MAAM,CAACM,qBAAqB,CAAC;MAC/CC,OAAO,EAAER,OAAO,CAACS,GAAG,CAAC,CAAAC,OAAO,MAAK;QAC/BA,OAAO;QACPC,UAAU,EAAE,IAAI,CAAC/B,sBAAsB,CAACC,WAAW,CAAC;QACpD,IAAIK,YAAY,KAAK,QAAQ,GAAG,EAAEO,MAAM,EAAE,EAAEmB,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,EAAExB,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;MACnF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,MAAMyB,SAAS,GAAG,IAAI,CAACZ,MAAM,CAACF,eAAe,CAAC;MAC5CO,MAAM;MACNE,OAAO,EAAER,OAAO,CAACS,GAAG,CAAC,CAAAC,OAAO,MAAK;QAC/BA,OAAO;QACPI,QAAQ,EAAE,IAAI,CAAC7B,8BAA8B;UAC3CC,YAAY;UACZC,KAAK,KAAK,WAAW,GAAGA,KAAK,GAAG;QAClC;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,IAAIA,KAAK,KAAK,SAAS,EAAE;MACvB,KAAK,IAAI,CAACc,MAAM,CAACc,aAAa,CAAC,CAAC;IAClC;IACA,OAAOF,SAAS;EAClB;AACF;;AAEA,OAAO,MAAMG,CAAC,GAAG9C,aAAa,CAACS,CAAC,CAAC;;AAEjCqC,CAAC,CAACC,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,IAAI,CAAC,mFAAmF,CAAC;AACzFC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAE5C,yBAAyB,CAAC;AACjD4C,OAAO,CAAC,OAAO,EAAE7C,eAAe,CAAC;AACjC6C,OAAO,CAAC,cAAc,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAU;AAC3D,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE1C,WAAW,EAAEM,KAAK,EAAED,YAAY,CAAC,CAAC,GAAGqC,CAAC,CAACJ,MAAM;EACrD,MAAMK,aAAa,GAAGD,CAAC,CAACtB,MAAM,CAACwB,MAAM,CAACD,aAAa;;EAEnD,SAASE,OAAOA,CAACC,KAAa,EAAE;IAC9B,MAAM,EAAEC,OAAO,EAAEC,uBAAuB,CAAC,CAAC,GAAGN,CAAC,CAACO,aAAa,CAACjD,WAAW,CAAC;IACzE+C,OAAO,CAACG,YAAY,CAACJ,KAAK,EAAEJ,CAAC,CAACxB,eAAe,CAACZ,KAAK,EAAED,YAAY,EAAEL,WAAW,EAAE,CAAC8C,KAAK,CAAC,CAAC,CAAC;;IAEzFE,uBAAuB,CAAC1C,KAAK,KAAK,SAAS,IAAIwC,KAAK,GAAGH,aAAa,EAAErC,KAAK,KAAK,WAAW,CAAC;EAC9F;;EAEA;EACA,KAAK,MAAMwC,KAAK,IAAI,CAAC,CAAC,EAAEH,aAAa,GAAG,CAAC,EAAEA,aAAa,CAAC,EAAE;IACzDD,CAAC,CAACS,KAAK,CAAE,yBAAwBL,KAAM,EAAC,CAAC;IACzCD,OAAO,CAACC,KAAK,CAAC;EAChB;AACF,CAAC,CAAC;;AAEJX,CAAC,CAACC,IAAI,CAAC,4BAA4B,CAAC;AACjCC,IAAI;EACF;AACL;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAE5C,yBAAyB,CAAC;AACjDwD,aAAa,CAAC,CAAC;AACfZ,OAAO,CAAC,aAAa,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACrCA,OAAO,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;AACxC,CAAC;AACAa,iBAAiB,CAAC,CAAAX,CAAC,KAAI;EACtBA,CAAC,CAACY,oCAAoC,CAACC,SAAS,CAAC;AACnD,CAAC,CAAC;AACDd,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE1C,WAAW,EAAEwD,WAAW,EAAEC,UAAU,CAAC,CAAC,GAAGf,CAAC,CAACJ,MAAM;EACzD,MAAMoB,YAAY,GAAGD,UAAU,GAAGf,CAAC,CAACiB,gBAAgB,GAAGjB,CAAC,CAACtB,MAAM;;EAE/D,MAAMR,MAAM,GAAG8C,YAAY,CAACE,YAAY,CAAC;IACvC9C,IAAI,EAAE,CAAC;IACPC,KAAK,EAAEC,cAAc,CAACC;EACxB,CAAC,CAAC;;EAEF,MAAMQ,MAAM,GAAGiC,YAAY,CAAChC,qBAAqB,CAAC;IAChDC,OAAO,EAAE;IACP;MACEE,OAAO,EAAE,CAAC;MACVC,UAAU,EAAEY,CAAC,CAAC3C,sBAAsB,CAACC,WAAW,CAAC;MACjDY,MAAM,EAAE,EAAEmB,IAAI,EAAE,SAAS,EAAE8B,gBAAgB,EAAEL,WAAW,CAAC;IAC3D,CAAC;;EAEL,CAAC,CAAC;;EAEF,MAAMxB,SAAS,GAAG0B,YAAY,CAACxC,eAAe,CAAC;IAC7CO,MAAM;IACNE,OAAO,EAAE;IACP;MACEE,OAAO,EAAE,CAAC;MACVI,QAAQ,EAAE,EAAErB,MAAM,CAAC;IACrB,CAAC;;EAEL,CAAC,CAAC;;EAEF,MAAM,EAAEmC,OAAO,EAAEe,cAAc,CAAC,CAAC,GAAGpB,CAAC,CAACO,aAAa,CAACjD,WAAW,CAAC;EAChE,IAAIwD,WAAW,EAAE;IACfT,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,EAAE,IAAI+B,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChE,CAAC,MAAM;IACLhB,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,CAAC;EACpC;EACA8B,cAAc,CAAC,CAACL,UAAU,CAAC;AAC7B,CAAC,CAAC;;AAEJtB,CAAC,CAACC,IAAI,CAAC,yCAAyC,CAAC;AAC9CC,IAAI,CAAC,wEAAwE,CAAC;AAC9EC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,aAAa,EAAE5C,yBAAyB,CAAC,CAAC;AAChE6C,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE1C,WAAW,CAAC,CAAC,GAAG0C,CAAC,CAACJ,MAAM;EAChC,MAAMN,SAAS,GAAGU,CAAC,CAACxB,eAAe,CAAC,OAAO,EAAE,QAAQ,EAAElB,WAAW,EAAE,EAAE,CAAC;EACvE,MAAMgE,cAAc,GAAG,CAAC,CAAC,CAAC;;EAE1B,MAAM,EAAEjB,OAAO,EAAEe,cAAc,CAAC,CAAC,GAAGpB,CAAC,CAACO,aAAa,CAACjD,WAAW,CAAC;EAChE+C,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,EAAEgC,cAAc,CAAC;EAClDF,cAAc,CAAC,KAAK,CAAC;AACvB,CAAC,CAAC;;AAEJ3B,CAAC,CAACC,IAAI,CAAC,oDAAoD,CAAC;AACzDC,IAAI,CAAC,gEAAgE,CAAC;AACtEC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,aAAa,EAAE5C,yBAAyB,CAAC;AACjDqE,iBAAiB,CAAC;AACjB,EAAED,cAAc,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,IAAI,CAAC,CAAC,EAAE;AAC9C,EAAEF,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC,EAAE;;AAE7C;AACA,EAAEF,cAAc,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAChD,EAAEF,cAAc,EAAE,CAAC,GAAG,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC1C,EAAEF,cAAc,EAAE,EAAE,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;;AAEvC;AACA,EAAEF,cAAc,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC7C,EAAEF,cAAc,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC9C,EAAEF,cAAc,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;;AAEpD;AACA,EAAEF,cAAc,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC7C,EAAEF,cAAc,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC9C,EAAEF,cAAc,EAAE,CAAC,CAAC,EAAE,UAAU,CAAC,EAAEE,QAAQ,EAAE,KAAK,CAAC,CAAC;AACrD,CAAC;AACD1B,OAAO,CAAC,aAAa,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC;AACzC,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMyB,YAAY,GAAG,EAAE;;EAEvB,MAAMC,eAAe,GAAG1B,CAAC,CAACtB,MAAM,CAACM,qBAAqB,CAAC;IACrDC,OAAO,EAAE;IACP;MACEE,OAAO,EAAE,CAAC;MACVC,UAAU,EAAE7B,cAAc,CAACC,OAAO,GAAGD,cAAc,CAACE,QAAQ;MAC5DS,MAAM,EAAE;QACNmB,IAAI,EAAE,SAAS;QACf8B,gBAAgB,EAAE;MACpB;IACF,CAAC;IACD;MACEhC,OAAO,EAAE,CAAC;MACVC,UAAU,EAAE7B,cAAc,CAACC,OAAO,GAAGD,cAAc,CAACE,QAAQ;MAC5DS,MAAM,EAAE;QACNmB,IAAI,EAAE,SAAS;QACf8B,gBAAgB,EAAE;MACpB;IACF,CAAC;;EAEL,CAAC,CAAC;;EAEF,MAAMQ,aAAa,GAAG3B,CAAC,CAACtB,MAAM,CAACwC,YAAY,CAAC;IAC1C9C,IAAI,EAAE,CAAC,GAAGpB,gCAAgC,GAAG,CAAC;IAC9CqB,KAAK,EAAEC,cAAc,CAACsD;EACxB,CAAC,CAAC;;EAEF,MAAMC,aAAa,GAAG7B,CAAC,CAACtB,MAAM,CAACwC,YAAY,CAAC;IAC1C9C,IAAI,EAAE,CAAC,GAAGpB,gCAAgC,GAAG,CAAC;IAC9CqB,KAAK,EAAEC,cAAc,CAACC;EACxB,CAAC,CAAC;;EAEF,MAAMe,SAAS,GAAGU,CAAC,CAACtB,MAAM,CAACF,eAAe,CAAC;IACzCO,MAAM,EAAE2C,eAAe;IACvBzC,OAAO,EAAE;IACP;MACEE,OAAO,EAAE,CAAC;MACVI,QAAQ,EAAE;QACRrB,MAAM,EAAEyD,aAAa;QACrBvD,IAAI,EAAEqD;MACR;IACF,CAAC;IACD;MACEtC,OAAO,EAAE,CAAC;MACVI,QAAQ,EAAE;QACRrB,MAAM,EAAE2D,aAAa;QACrBzD,IAAI,EAAEqD;MACR;IACF,CAAC;;EAEL,CAAC,CAAC;;EAEF,MAAM,EAAEnE,WAAW,EAAEgE,cAAc,EAAEQ,WAAW,EAAEN,QAAQ,CAAC,CAAC,GAAGxB,CAAC,CAACJ,MAAM;;EAEvE,MAAM,EAAES,OAAO,EAAEe,cAAc,CAAC,CAAC,GAAGpB,CAAC,CAACO,aAAa,CAACjD,WAAW,CAAC;EAChE,IAAIwE,WAAW,EAAE;IACfzB,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,EAAE,IAAI+B,WAAW,CAACC,cAAc,CAAC,EAAE,CAAC,EAAEA,cAAc,CAACzC,MAAM,CAAC;EAC/F,CAAC,MAAM;IACLwB,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,EAAEgC,cAAc,CAAC;EACpD;EACAF,cAAc,CAACI,QAAQ,CAAC;AAC1B,CAAC,CAAC;;AAEJ/B,CAAC,CAACC,IAAI,CAAC,2BAA2B,CAAC;AAChCC,IAAI,CAAC,6EAA6E,CAAC;AACnFoC,kBAAkB,CAAC;AAClB;AACA;EACEC,OAAO,EAAE,CAAC,CAAC,CAAU;EACrBC,uBAAuB,EAAE,CAAC;EAC1BC,wBAAwB,EAAE,CAAC;EAC3BV,QAAQ,EAAE;AACZ,CAAC;AACD;AACA;EACEQ,OAAO,EAAE,CAAC,CAAC,CAAU;EACrBC,uBAAuB,EAAE,CAAC;EAC1BC,wBAAwB,EAAE,CAAC;EAC3BV,QAAQ,EAAE;AACZ,CAAC;AACD;EACEQ,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAU;EACxBC,uBAAuB,EAAE,CAAC;EAC1BC,wBAAwB,EAAE,CAAC;EAC3BV,QAAQ,EAAE;AACZ,CAAC;AACD;EACEQ,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAU;EAC3BC,uBAAuB,EAAE,CAAC;EAC1BC,wBAAwB,EAAE,CAAC;EAC3BV,QAAQ,EAAE;AACZ,CAAC;AACD;EACEQ,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAU;EACxBC,uBAAuB,EAAE,CAAC;EAC1BC,wBAAwB,EAAE,CAAC;EAC3BV,QAAQ,EAAE;AACZ,CAAC;AACF,CAAC;AACDzB,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEgC,OAAO,EAAEC,uBAAuB,EAAEC,wBAAwB,EAAEV,QAAQ,CAAC,CAAC,GAAGxB,CAAC,CAACJ,MAAM;EACzF,MAAM6B,YAAY,GAAG,CAAC;;EAEtB,MAAMC,eAAe,GAAG1B,CAAC,CAACtB,MAAM,CAACM,qBAAqB,CAAC;IACrDC,OAAO,EAAEpC,KAAK,CAACqF,wBAAwB,EAAE,CAAAC,CAAC,MAAK;MAC7ChD,OAAO,EAAEgD,CAAC;MACV/C,UAAU,EAAE7B,cAAc,CAACE,QAAQ;MACnCS,MAAM,EAAE;QACNmB,IAAI,EAAE,SAAS;QACf8B,gBAAgB,EAAE;MACpB;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF,MAAM7B,SAAS,GAAGU,CAAC,CAACtB,MAAM,CAACF,eAAe,CAAC;IACzCO,MAAM,EAAE2C,eAAe;IACvBzC,OAAO,EAAEpC,KAAK,CAACqF,wBAAwB,EAAE,CAAAC,CAAC,MAAK;MAC7ChD,OAAO,EAAEgD,CAAC;MACV5C,QAAQ,EAAE;QACRrB,MAAM,EAAE8B,CAAC,CAAC7B,qBAAqB,CAAC,OAAO,EAAE;UACvCC,IAAI,EAAEqD,YAAY;UAClBpD,KAAK,EAAEC,cAAc,CAACC;QACxB,CAAC,CAAC;QACFH,IAAI,EAAEqD;MACR;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF,MAAM,EAAEpB,OAAO,EAAEe,cAAc,CAAC,CAAC,GAAGpB,CAAC,CAACO,aAAa,CAAC,aAAa,CAAC;;EAElE,MAAM6B,cAAc,GAAGA,CAAA,KAAM;IAC3B/B,OAAO,CAACG,YAAY;MAClB,CAAC;MACDlB,SAAS;MACT,IAAI+B,WAAW,CAACW,OAAO,CAAC;MACxBC,uBAAuB;MACvBC;IACF,CAAC;EACH,CAAC;;EAED,IAAIV,QAAQ,EAAE;IACZY,cAAc,CAAC,CAAC;EAClB,CAAC,MAAM;IACLpC,CAAC,CAACqC,WAAW,CAAC,YAAY,EAAED,cAAc,CAAC;EAC7C;;EAEA;EACAhB,cAAc,CAAC,IAAI,CAAC;AACtB,CAAC,CAAC;;AAEJ3B,CAAC,CAACC,IAAI,CAAC,wBAAwB,CAAC;AAC7BC,IAAI;EACF;AACL;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAA,CACCC,OAAO,CAAC,MAAM,EAAE/C,mBAAmB,CAAC;AACpC+C,OAAO,CAAC,aAAa,EAAE5C,yBAAyB,CAAC;AACjDwD,aAAa,CAAC,CAAC;AACfZ,OAAO,CAAC,sBAAsB,EAAE;AAC/B,EAAEwC,IAAI,EAAE,CAAC,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC;AACnB,EAAED,IAAI,EAAE,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC;AACrB,EAAED,IAAI,EAAE,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC;AACrB,EAAED,IAAI,EAAE,CAAC,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC;AACnB,EAAED,IAAI,EAAE,CAAC,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC;AACpB;AACL,CAAC;AACAxC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEX,IAAI,EAAEmD,oBAAoB,EAAElF,WAAW,CAAC,CAAC,GAAG0C,CAAC,CAACJ,MAAM;EAC5D,MAAM6B,YAAY,GAAG,EAAE;;EAEvB,MAAMgB,YAAY;EAChBzC,CAAC,CAACtB,MAAM,CAACwB,MAAM;EACbb,IAAI,KAAK,SAAS,GAAG,iCAAiC,GAAG,iCAAiC,CAC3F;;EACH,MAAMqD,aAAa,GAAG9F,oBAAoB,CAAC6F,YAAY,EAAED,oBAAoB,CAAC;;EAE9E,MAAMd,eAAe,GAAG1B,CAAC,CAACtB,MAAM,CAACM,qBAAqB,CAAC;IACrDC,OAAO,EAAE;IACP;MACEE,OAAO,EAAE,CAAC;MACVC,UAAU,EAAE7B,cAAc,CAACC,OAAO;MAClCU,MAAM,EAAE,EAAEmB,IAAI,EAAE8B,gBAAgB,EAAE,IAAI,CAAC;IACzC,CAAC;;EAEL,CAAC,CAAC;;EAEF,MAAM9C,KAAK,GAAGgB,IAAI,KAAK,SAAS,GAAGf,cAAc,CAACsD,OAAO,GAAGtD,cAAc,CAACC,OAAO;EAClF,MAAMoE,OAAO,GAAGD,aAAa,GAAGD,YAAY,KAAK,CAAC;;EAElD,MAAMvE,MAAM,GAAG8B,CAAC,CAACtB,MAAM,CAACwC,YAAY,CAAC;IACnC9C,IAAI,EAAE,CAAC,GAAGpB,gCAAgC;IAC1CqB;EACF,CAAC,CAAC;;EAEF,MAAMiB,SAAS,GAAGU,CAAC,CAACtB,MAAM,CAACF,eAAe,CAAC;IACzCS,OAAO,EAAE,CAAC,EAAEE,OAAO,EAAE,CAAC,EAAEI,QAAQ,EAAE,EAAErB,MAAM,EAAEE,IAAI,EAAEqD,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;IACnE1C,MAAM,EAAE2C;EACV,CAAC,CAAC;;EAEF,MAAM,EAAErB,OAAO,EAAEe,cAAc,CAAC,CAAC,GAAGpB,CAAC,CAACO,aAAa,CAACjD,WAAW,CAAC;EAChE+C,OAAO,CAACG,YAAY,CAAC,CAAC,EAAElB,SAAS,EAAE,CAACoD,aAAa,CAAC,CAAC;EACnDtB,cAAc,CAACuB,OAAO,CAAC;AACzB,CAAC,CAAC"}