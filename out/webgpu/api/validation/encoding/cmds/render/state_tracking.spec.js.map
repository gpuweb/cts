{"version":3,"sources":["../../../../../../../src/webgpu/api/validation/encoding/cmds/render/state_tracking.spec.ts"],"names":["description","makeTestGroup","range","ValidationTest","F","getVertexBuffer","device","createBuffer","size","usage","GPUBufferUsage","VERTEX","createRenderPipeline","bufferCount","vertex","module","createShaderModule","code","i","join","entryPoint","buffers","arrayStride","attributes","format","offset","shaderLocation","fragment","targets","primitive","topology","beginRenderPass","commandEncoder","attachmentTexture","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","test","desc","unimplemented","fn","t","pipeline1","pipeline2","vertexBuffer1","vertexBuffer2","createCommandEncoder","renderPass","setPipeline","draw","end","expectValidationError","finish","setVertexBuffer"],"mappings":"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","sourcesContent":["export const description = `\nValidation tests for setVertexBuffer/setIndexBuffer state (not validation). See also operation tests.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { range } from '../../../../../../common/util/util.js';\nimport { ValidationTest } from '../../../validation_test.js';\n\nclass F extends ValidationTest {\n  getVertexBuffer(): GPUBuffer {\n    return this.device.createBuffer({\n      size: 256,\n      usage: GPUBufferUsage.VERTEX,\n    });\n  }\n\n  createRenderPipeline(bufferCount: number): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            struct Inputs {\n            ${range(bufferCount, i => `\\n@location(${i}) a_position${i} : vec3<f32>,`).join('')}\n            };\n            @stage(vertex) fn main(input : Inputs\n              ) -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 3 * 4,\n            attributes: range(bufferCount, i => ({\n              format: 'float32x3',\n              offset: 0,\n              shaderLocation: i,\n            })),\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @stage(fragment) fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n  }\n\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test(`all_needed_vertex_buffer_should_be_bound`)\n  .desc(\n    `\nIn this test we test that any missing vertex buffer for a used slot will cause validation errors when drawing.\n- All (non/indexed, in/direct) draw commands\n    - A needed vertex buffer is not bound\n        - Was bound in another render pass but not the current one\n`\n  )\n  .unimplemented();\n\ng.test(`all_needed_index_buffer_should_be_bound`)\n  .desc(\n    `\nIn this test we test that missing index buffer for a used slot will cause validation errors when drawing.\n- All indexed in/direct draw commands\n    - No index buffer is bound\n`\n  )\n  .unimplemented();\n\ng.test('vertex_buffers_inherit_from_previous_pipeline').fn(async t => {\n  const pipeline1 = t.createRenderPipeline(1);\n  const pipeline2 = t.createRenderPipeline(2);\n\n  const vertexBuffer1 = t.getVertexBuffer();\n  const vertexBuffer2 = t.getVertexBuffer();\n\n  {\n    // Check failure when vertex buffer is not set\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = t.beginRenderPass(commandEncoder);\n    renderPass.setPipeline(pipeline1);\n    renderPass.draw(3);\n    renderPass.end();\n\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    });\n  }\n  {\n    // Check success when vertex buffer is inherited from previous pipeline\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = t.beginRenderPass(commandEncoder);\n    renderPass.setPipeline(pipeline2);\n    renderPass.setVertexBuffer(0, vertexBuffer1);\n    renderPass.setVertexBuffer(1, vertexBuffer2);\n    renderPass.draw(3);\n    renderPass.setPipeline(pipeline1);\n    renderPass.draw(3);\n    renderPass.end();\n\n    commandEncoder.finish();\n  }\n});\n\ng.test('vertex_buffers_do_not_inherit_between_render_passes').fn(async t => {\n  const pipeline1 = t.createRenderPipeline(1);\n  const pipeline2 = t.createRenderPipeline(2);\n\n  const vertexBuffer1 = t.getVertexBuffer();\n  const vertexBuffer2 = t.getVertexBuffer();\n\n  {\n    // Check success when vertex buffer is set for each render pass\n    const commandEncoder = t.device.createCommandEncoder();\n    {\n      const renderPass = t.beginRenderPass(commandEncoder);\n      renderPass.setPipeline(pipeline2);\n      renderPass.setVertexBuffer(0, vertexBuffer1);\n      renderPass.setVertexBuffer(1, vertexBuffer2);\n      renderPass.draw(3);\n      renderPass.end();\n    }\n    {\n      const renderPass = t.beginRenderPass(commandEncoder);\n      renderPass.setPipeline(pipeline1);\n      renderPass.setVertexBuffer(0, vertexBuffer1);\n      renderPass.draw(3);\n      renderPass.end();\n    }\n    commandEncoder.finish();\n  }\n  {\n    // Check failure because vertex buffer is not inherited in second subpass\n    const commandEncoder = t.device.createCommandEncoder();\n    {\n      const renderPass = t.beginRenderPass(commandEncoder);\n      renderPass.setPipeline(pipeline2);\n      renderPass.setVertexBuffer(0, vertexBuffer1);\n      renderPass.setVertexBuffer(1, vertexBuffer2);\n      renderPass.draw(3);\n      renderPass.end();\n    }\n    {\n      const renderPass = t.beginRenderPass(commandEncoder);\n      renderPass.setPipeline(pipeline1);\n      renderPass.draw(3);\n      renderPass.end();\n    }\n\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    });\n  }\n});\n"],"file":"state_tracking.spec.js"}