{"version":3,"sources":["../../../../../../../src/webgpu/api/validation/encoding/cmds/render/draw.spec.ts"],"names":["description","makeTestGroup","ValidationTest","callDrawIndexed","test","encoder","drawType","param","drawIndexed","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","indirectArray","Int32Array","indirectBuffer","makeBufferWithContents","GPUBufferUsage","INDIRECT","drawIndexedIndirect","g","desc","unimplemented","params","u","combine","beginSubcases","fn","t","indexFormat","bindingSizeInElements","bufferSizeInElements","drawIndexCount","useBundle","indexElementSize","bindingSize","bufferSize","size","usage","INDEX","COPY_DST","indexBuffer","device","createBuffer","drawCallParam","isFinishSuccess","renderPipeline","createNoOpRenderPipeline","commandBufferMaker","createEncoder","renderEncoder","setIndexBuffer","setPipeline","validateFinishAndSubmit"],"mappings":"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","sourcesContent":["export const description = `\nHere we test the validation for draw functions, mainly the buffer access validation. All four types\nof draw calls are tested, and test that validation errors do / don't occur for certain call type\nand parameters as expect.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport { ValidationTest } from '../../../validation_test.js';\n\ninterface DrawIndexedParameter {\n  indexCount: number;\n  instanceCount?: number;\n  firstIndex?: number;\n  baseVertex?: number;\n  firstInstance?: number;\n}\n\nfunction callDrawIndexed(\n  test: GPUTest,\n  encoder: GPURenderEncoderBase,\n  drawType: 'drawIndexed' | 'drawIndexedIndirect',\n  param: DrawIndexedParameter\n) {\n  switch (drawType) {\n    case 'drawIndexed': {\n      encoder.drawIndexed(\n        param.indexCount,\n        param.instanceCount ?? 1,\n        param.firstIndex ?? 0,\n        param.baseVertex ?? 0,\n        param.firstInstance ?? 0\n      );\n      break;\n    }\n    case 'drawIndexedIndirect': {\n      const indirectArray = new Int32Array([\n        param.indexCount,\n        param.instanceCount ?? 1,\n        param.firstIndex ?? 0,\n        param.baseVertex ?? 0,\n        param.firstInstance ?? 0,\n      ]);\n      const indirectBuffer = test.makeBufferWithContents(indirectArray, GPUBufferUsage.INDIRECT);\n      encoder.drawIndexedIndirect(indirectBuffer, 0);\n      break;\n    }\n  }\n}\n\nexport const g = makeTestGroup(ValidationTest);\n\ng.test(`unused_buffer_bound`)\n  .desc(\n    `\nIn this test we test that a small buffer bound to unused buffer slot won't cause validation error.\n- All draw commands,\n  - An unused {index , vertex} buffer with uselessly small range is bound (immediately before draw\n    call)\n`\n  )\n  .unimplemented();\n\ng.test(`index_buffer_OOB`)\n  .desc(\n    `\nIn this test we test that index buffer OOB is caught as a validation error in drawIndexed, but not in\ndrawIndexedIndirect as it is GPU-validated.\n- Issue an indexed draw call, with the following index buffer states, for {all index formats}:\n    - range and GPUBuffer are exactly the required size for the draw call\n    - range is too small but GPUBuffer is still large enough\n    - range and GPUBuffer are both too small\n`\n  )\n  .params(u =>\n    u\n      .combine('bufferSizeInElements', [10, 100])\n      // Binding size is always no larger than buffer size, make sure that setIndexBuffer succeed\n      .combine('bindingSizeInElements', [10])\n      .combine('drawIndexCount', [10, 11])\n      .combine('drawType', ['drawIndexed', 'drawIndexedIndirect'] as const)\n      .beginSubcases()\n      .combine('indexFormat', ['uint16', 'uint32'] as const)\n      .combine('useBundle', [false, true])\n  )\n  .fn(t => {\n    const {\n      indexFormat,\n      bindingSizeInElements,\n      bufferSizeInElements,\n      drawIndexCount,\n      drawType,\n      useBundle,\n    } = t.params;\n\n    const indexElementSize = indexFormat === 'uint16' ? 2 : 4;\n    const bindingSize = bindingSizeInElements * indexElementSize;\n    const bufferSize = bufferSizeInElements * indexElementSize;\n\n    const desc: GPUBufferDescriptor = {\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n    };\n    const indexBuffer = t.device.createBuffer(desc);\n\n    const drawCallParam: DrawIndexedParameter = {\n      indexCount: drawIndexCount,\n    };\n\n    // Encoder finish will succeed if no index buffer access OOB when calling drawIndexed,\n    // and always succeed when calling drawIndexedIndirect.\n    const isFinishSuccess =\n      drawIndexCount <= bindingSizeInElements || drawType === 'drawIndexedIndirect';\n\n    const renderPipeline = t.createNoOpRenderPipeline();\n\n    const commandBufferMaker = t.createEncoder(useBundle ? 'render bundle' : 'render pass');\n    const renderEncoder = commandBufferMaker.encoder;\n\n    renderEncoder.setIndexBuffer(indexBuffer, indexFormat, 0, bindingSize);\n\n    renderEncoder.setPipeline(renderPipeline);\n\n    callDrawIndexed(t, renderEncoder, drawType, drawCallParam);\n\n    commandBufferMaker.validateFinishAndSubmit(isFinishSuccess, true);\n  });\n\ng.test(`vertex_buffer_OOB`)\n  .desc(\n    `\nIn this test we test the vertex buffer OOB validation in draw calls. Specifically, only vertex step\nmode buffer OOB in draw and instance step mode buffer OOB in draw and drawIndexed are CPU-validated.\nOther cases are handled by robust access and no validation error occurs.\n- Test that:\n    - Draw call needs to read {=, >} any bound vertex buffer range, with GPUBuffer that is {large\n      enough, exactly the size of bound range}\n        - Binding size = 0 (ensure it's not treated as a special case)\n        - x= weird offset values\n        - x= weird arrayStride values\n        - x= {render pass, render bundle}\n- For vertex step mode vertex buffer,\n    - Test that:\n        - vertexCount largeish\n        - firstVertex {=, >} 0\n        - arrayStride is 0 and bound buffer size too small\n    - Validation error occurs in:\n        - draw\n        - drawIndexed with a zero array stride vertex step mode buffer OOB\n    - Otherwise no validation error in drawIndexed, draIndirect and drawIndexedIndirect\n- For instance step mode vertex buffer,\n    - Test with draw and drawIndexed:\n        - instanceCount largeish\n        - firstInstance {=, >} 0\n        - arrayStride is 0 and bound buffer size too small\n    - Validation error occurs in draw and drawIndexed\n    - No validation error in drawIndirect and drawIndexedIndirect\n\nIn this test, we use a a render pipeline requiring one vertex step mode and one instance step mode\nvertex buffer. Then for a given drawing parameter set (e.g., vertexCount, instanceCount, firstVertex,\nindexCount), we calculate the exactly required size for vertex step mode vertex buffer, instance\nstep mode vertex buffer and index buffer. Then, we generate buffer parameters (i.e. GPU buffer size,\nbinding offset and binding size) for all three buffer, covering both (bound size == required size)\nand (bound size == required size - 1), and test that draw and drawIndexed will success/error as\nexpected. Such set of buffer parameters should include cases like weird offset values.\n`\n  )\n  .unimplemented();\n\ng.test(`last_buffer_setting_take_account`)\n  .desc(\n    `\nIn this test we test that only the last setting for a buffer slot take account.\n- All (non/indexed, in/direct) draw commands\n  - setPl, setVB, setIB, draw, {setPl,setVB,setIB,nothing (control)}, then a larger draw that\n    wouldn't have been valid before that\n`\n  )\n  .unimplemented();\n\ng.test(`buffer_binding_overlap`)\n  .desc(\n    `\nIn this test we test that binding one GPU buffer to multiple vertex buffer slot or both vertex\nbuffer slot and index buffer will cause no validation error, with completely/partial overlap.\n    - x= all draw types\n`\n  )\n  .unimplemented();\n"],"file":"draw.spec.js"}