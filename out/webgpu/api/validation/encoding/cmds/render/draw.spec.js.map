{"version":3,"sources":["../../../../../../../src/webgpu/api/validation/encoding/cmds/render/draw.spec.ts"],"names":["description","makeTestGroup","kVertexFormatInfo","ValidationTest","callDrawIndexed","test","encoder","drawType","param","drawIndexed","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","indirectArray","Int32Array","indirectBuffer","makeBufferWithContents","GPUBufferUsage","INDIRECT","drawIndexedIndirect","callDraw","draw","vertexCount","firstVertex","drawIndirect","makeTestPipeline","buffers","bufferLayouts","b","slot","device","createRenderPipeline","layout","vertex","module","createShaderModule","code","getNoOpShaderCode","entryPoint","fragment","targets","format","writeMask","primitive","topology","makeTestPipelineWithVertexAndInstanceBuffer","arrayStride","attributeFormat","attributeOffset","vertexBufferLayouts","stepMode","attributes","shaderLocation","offset","kDefaultParameterForDraw","kDefaultParameterForNonIndexedDraw","kDefaultParameterForIndexedDraw","indexFormat","indexBufferSize","g","desc","params","u","combine","beginSubcases","unless","p","smallIndexBuffer","fn","t","smallVertexBuffer","smallInstanceBuffer","bufferOffset","boundSize","renderPipeline","createNoOpRenderPipeline","bufferSize","smallBuffer","createBufferWithState","size","usage","INDEX","VERTEX","indexBuffer","encoderType","setPipelineBeforeBuffer","commandBufferMaker","createEncoder","renderEncoder","setPipeline","setIndexBuffer","setVertexBuffer","drawParam","validateFinishAndSubmit","bindingSizeInElements","bufferSizeInElements","drawIndexCount","indexElementSize","bindingSize","COPY_DST","drawCallParam","isFinishSuccess","filter","VStride0","IStride0","type","VBSize","boundVertexBufferSizeState","IBSize","boundInstanceBufferSizeState","zeroVertexStrideCount","zeroInstanceStrideCount","AStride","arrayStrideState","attributeOffsetFactor","setBufferOffset","attributeFormatInfo","formatSize","bytesPerComponent","componentCount","Math","min","lastStride","calcSetBufferSize","boundBufferSizeState","strideCount","requiredBufferSize","setBufferSize","strideCountForVertexBuffer","setVertexBufferSize","vertexBufferSize","strideCountForInstanceBuffer","setInstanceBufferSize","instanceBufferSize","vertexBuffer","instanceBuffer","isVertexBufferOOB","isInstanceBufferOOB","vertexBoundOffestFactor","instanceBoundOffestFactor","indexBoundOffestFactor","calcAttributeBufferSize","calcSetBufferOffset","requiredSetBufferSize","offsetFactor","ceil","alignedOffset","setVertexBufferOffset","setInstanceBufferOffset","max","setIndexBufferSize","setIndexBufferOffset","sharedBuffer","unimplemented","expand","Set","maxDrawCount","bundleFirstHalf","bundleSecondHalf","drawCount","colorFormat","colorTexture","createTexture","width","height","depthOrArrayLayers","mipLevelCount","sampleCount","GPUTextureUsage","RENDER_ATTACHMENT","pipeline","Uint16Array","Uint32Array","indexedIndirectBuffer","commandEncoder","createCommandEncoder","renderPassEncoder","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","firstHalfEncoder","createRenderBundleEncoder","colorFormats","secondHalfEncoder","halfDrawCount","floor","i","bundles","push","finish","length","executeBundles","end","expectValidationError"],"mappings":"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","sourcesContent":["export const description = `\nHere we test the validation for draw functions, mainly the buffer access validation. All four types\nof draw calls are tested, and test that validation errors do / don't occur for certain call type\nand parameters as expect.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { kVertexFormatInfo } from '../../../../../capability_info.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport { ValidationTest } from '../../../validation_test.js';\n\ntype VertexAttrib<A> = A & { shaderLocation: number };\ntype VertexBuffer<V, A> = V & {\n  slot: number;\n  attributes: VertexAttrib<A>[];\n};\ntype VertexState<V, A> = VertexBuffer<V, A>[];\n\ntype VertexLayoutState<V, A> = VertexState<\n  { stepMode: GPUVertexStepMode; arrayStride: number } & V,\n  { format: GPUVertexFormat; offset: number } & A\n>;\n\ninterface DrawIndexedParameter {\n  indexCount: number;\n  instanceCount?: number;\n  firstIndex?: number;\n  baseVertex?: number;\n  firstInstance?: number;\n}\n\nfunction callDrawIndexed(\n  test: GPUTest,\n  encoder: GPURenderCommandsMixin,\n  drawType: 'drawIndexed' | 'drawIndexedIndirect',\n  param: DrawIndexedParameter\n) {\n  switch (drawType) {\n    case 'drawIndexed': {\n      encoder.drawIndexed(\n        param.indexCount,\n        param.instanceCount ?? 1,\n        param.firstIndex ?? 0,\n        param.baseVertex ?? 0,\n        param.firstInstance ?? 0\n      );\n      break;\n    }\n    case 'drawIndexedIndirect': {\n      const indirectArray = new Int32Array([\n        param.indexCount,\n        param.instanceCount ?? 1,\n        param.firstIndex ?? 0,\n        param.baseVertex ?? 0,\n        param.firstInstance ?? 0,\n      ]);\n      const indirectBuffer = test.makeBufferWithContents(indirectArray, GPUBufferUsage.INDIRECT);\n      encoder.drawIndexedIndirect(indirectBuffer, 0);\n      break;\n    }\n  }\n}\ninterface DrawParameter {\n  vertexCount: number;\n  instanceCount?: number;\n  firstVertex?: number;\n  firstInstance?: number;\n}\n\nfunction callDraw(\n  test: GPUTest,\n  encoder: GPURenderCommandsMixin,\n  drawType: 'draw' | 'drawIndirect',\n  param: DrawParameter\n) {\n  switch (drawType) {\n    case 'draw': {\n      encoder.draw(\n        param.vertexCount,\n        param.instanceCount ?? 1,\n        param.firstVertex ?? 0,\n        param.firstInstance ?? 0\n      );\n      break;\n    }\n    case 'drawIndirect': {\n      const indirectArray = new Int32Array([\n        param.vertexCount,\n        param.instanceCount ?? 1,\n        param.firstVertex ?? 0,\n        param.firstInstance ?? 0,\n      ]);\n      const indirectBuffer = test.makeBufferWithContents(indirectArray, GPUBufferUsage.INDIRECT);\n      encoder.drawIndirect(indirectBuffer, 0);\n      break;\n    }\n  }\n}\n\nfunction makeTestPipeline(\n  test: ValidationTest,\n  buffers: VertexState<\n    { stepMode: GPUVertexStepMode; arrayStride: number },\n    {\n      offset: number;\n      format: GPUVertexFormat;\n    }\n  >\n): GPURenderPipeline {\n  const bufferLayouts: GPUVertexBufferLayout[] = [];\n  for (const b of buffers) {\n    bufferLayouts[b.slot] = b;\n  }\n\n  return test.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: test.device.createShaderModule({\n        code: test.getNoOpShaderCode('VERTEX'),\n      }),\n      entryPoint: 'main',\n      buffers: bufferLayouts,\n    },\n    fragment: {\n      module: test.device.createShaderModule({\n        code: test.getNoOpShaderCode('FRAGMENT'),\n      }),\n      entryPoint: 'main',\n      targets: [{ format: 'rgba8unorm', writeMask: 0 }],\n    },\n    primitive: { topology: 'triangle-list' },\n  });\n}\n\nfunction makeTestPipelineWithVertexAndInstanceBuffer(\n  test: ValidationTest,\n  arrayStride: number,\n  attributeFormat: GPUVertexFormat,\n  attributeOffset: number = 0\n): GPURenderPipeline {\n  const vertexBufferLayouts: VertexLayoutState<{}, {}> = [\n    {\n      slot: 1,\n      stepMode: 'vertex',\n      arrayStride,\n      attributes: [\n        {\n          shaderLocation: 2,\n          format: attributeFormat,\n          offset: attributeOffset,\n        },\n      ],\n    },\n    {\n      slot: 7,\n      stepMode: 'instance',\n      arrayStride,\n      attributes: [\n        {\n          shaderLocation: 6,\n          format: attributeFormat,\n          offset: attributeOffset,\n        },\n      ],\n    },\n  ];\n\n  return makeTestPipeline(test, vertexBufferLayouts);\n}\n\n// Default parameters for all kind of draw call, arbitrary non-zero values that is not very large.\nconst kDefaultParameterForDraw = {\n  instanceCount: 100,\n  firstInstance: 100,\n};\n\n// Default parameters for non-indexed draw, arbitrary non-zero values that is not very large.\nconst kDefaultParameterForNonIndexedDraw = {\n  vertexCount: 100,\n  firstVertex: 100,\n};\n\n// Default parameters for indexed draw call and required index buffer, arbitrary non-zero values\n// that is not very large.\nconst kDefaultParameterForIndexedDraw = {\n  indexCount: 100,\n  firstIndex: 100,\n  baseVertex: 100,\n  indexFormat: 'uint16' as GPUIndexFormat,\n  indexBufferSize: 2 * 200, // exact required bound size for index buffer\n};\n\nexport const g = makeTestGroup(ValidationTest);\n\ng.test(`unused_buffer_bound`)\n  .desc(\n    `\nIn this test we test that a small buffer bound to unused buffer slot won't cause validation error.\n- All draw commands,\n  - An unused {index , vertex} buffer with uselessly small range is bound (immediately before draw\n    call)\n`\n  )\n  .params(u =>\n    u //\n      .combine('smallIndexBuffer', [false, true])\n      .combine('smallVertexBuffer', [false, true])\n      .combine('smallInstanceBuffer', [false, true])\n      .beginSubcases()\n      .combine('drawType', ['draw', 'drawIndexed', 'drawIndirect', 'drawIndexedIndirect'] as const)\n      .unless(\n        // Always provide index buffer of enough size if it is used by indexed draw\n        p =>\n          p.smallIndexBuffer &&\n          (p.drawType === 'drawIndexed' || p.drawType === 'drawIndexedIndirect')\n      )\n      .combine('bufferOffset', [0, 4])\n      .combine('boundSize', [0, 1])\n  )\n  .fn(async t => {\n    const {\n      smallIndexBuffer,\n      smallVertexBuffer,\n      smallInstanceBuffer,\n      drawType,\n      bufferOffset,\n      boundSize,\n    } = t.params;\n    const renderPipeline = t.createNoOpRenderPipeline();\n    const bufferSize = bufferOffset + boundSize;\n    const smallBuffer = t.createBufferWithState('valid', {\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.VERTEX,\n    });\n\n    // An index buffer of enough size, used if smallIndexBuffer === false\n    const { indexFormat, indexBufferSize } = kDefaultParameterForIndexedDraw;\n    const indexBuffer = t.createBufferWithState('valid', {\n      size: indexBufferSize,\n      usage: GPUBufferUsage.INDEX,\n    });\n\n    for (const encoderType of ['render bundle', 'render pass'] as const) {\n      for (const setPipelineBeforeBuffer of [false, true]) {\n        const commandBufferMaker = t.createEncoder(encoderType);\n        const renderEncoder = commandBufferMaker.encoder;\n\n        if (setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n\n        if (drawType === 'drawIndexed' || drawType === 'drawIndexedIndirect') {\n          // Always use large enough index buffer for indexed draw. Index buffer OOB validation is\n          // tested in index_buffer_OOB.\n          renderEncoder.setIndexBuffer(indexBuffer, indexFormat, 0, indexBufferSize);\n        } else if (smallIndexBuffer) {\n          renderEncoder.setIndexBuffer(smallBuffer, indexFormat, bufferOffset, boundSize);\n        }\n        if (smallVertexBuffer) {\n          renderEncoder.setVertexBuffer(1, smallBuffer, bufferOffset, boundSize);\n        }\n        if (smallInstanceBuffer) {\n          renderEncoder.setVertexBuffer(7, smallBuffer, bufferOffset, boundSize);\n        }\n\n        if (!setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n\n        if (drawType === 'draw' || drawType === 'drawIndirect') {\n          const drawParam: DrawParameter = {\n            ...kDefaultParameterForDraw,\n            ...kDefaultParameterForNonIndexedDraw,\n          };\n          callDraw(t, renderEncoder, drawType, drawParam);\n        } else {\n          const drawParam: DrawIndexedParameter = {\n            ...kDefaultParameterForDraw,\n            ...kDefaultParameterForIndexedDraw,\n          };\n          callDrawIndexed(t, renderEncoder, drawType, drawParam);\n        }\n\n        // Binding a unused small index/vertex buffer will never cause validation error.\n        commandBufferMaker.validateFinishAndSubmit(true, true);\n      }\n    }\n  });\n\ng.test(`index_buffer_OOB`)\n  .desc(\n    `\nIn this test we test that index buffer OOB is caught as a validation error in drawIndexed, but not in\ndrawIndexedIndirect as it is GPU-validated.\n- Issue an indexed draw call, with the following index buffer states, for {all index formats}:\n    - range and GPUBuffer are exactly the required size for the draw call\n    - range is too small but GPUBuffer is still large enough\n    - range and GPUBuffer are both too small\n`\n  )\n  .params(u =>\n    u\n      .combine('bufferSizeInElements', [10, 100])\n      // Binding size is always no larger than buffer size, make sure that setIndexBuffer succeed\n      .combine('bindingSizeInElements', [10])\n      .combine('drawIndexCount', [10, 11])\n      .combine('drawType', ['drawIndexed', 'drawIndexedIndirect'] as const)\n      .beginSubcases()\n      .combine('indexFormat', ['uint16', 'uint32'] as GPUIndexFormat[])\n  )\n  .fn(async t => {\n    const {\n      indexFormat,\n      bindingSizeInElements,\n      bufferSizeInElements,\n      drawIndexCount,\n      drawType,\n    } = t.params;\n\n    const indexElementSize = indexFormat === 'uint16' ? 2 : 4;\n    const bindingSize = bindingSizeInElements * indexElementSize;\n    const bufferSize = bufferSizeInElements * indexElementSize;\n\n    const desc: GPUBufferDescriptor = {\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n    };\n    const indexBuffer = t.createBufferWithState('valid', desc);\n\n    const drawCallParam: DrawIndexedParameter = {\n      indexCount: drawIndexCount,\n    };\n\n    // Encoder finish will succeed if no index buffer access OOB when calling drawIndexed,\n    // and always succeed when calling drawIndexedIndirect.\n    const isFinishSuccess =\n      drawIndexCount <= bindingSizeInElements || drawType === 'drawIndexedIndirect';\n\n    const renderPipeline = t.createNoOpRenderPipeline();\n\n    for (const encoderType of ['render bundle', 'render pass'] as const) {\n      for (const setPipelineBeforeBuffer of [false, true]) {\n        const commandBufferMaker = t.createEncoder(encoderType);\n        const renderEncoder = commandBufferMaker.encoder;\n\n        if (setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n        renderEncoder.setIndexBuffer(indexBuffer, indexFormat, 0, bindingSize);\n        if (!setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n\n        callDrawIndexed(t, renderEncoder, drawType, drawCallParam);\n\n        commandBufferMaker.validateFinishAndSubmit(isFinishSuccess, true);\n      }\n    }\n  });\n\ng.test(`vertex_buffer_OOB`)\n  .desc(\n    `\nIn this test we test the vertex buffer OOB validation in draw calls. Specifically, only vertex step\nmode buffer OOB in draw and instance step mode buffer OOB in draw and drawIndexed are CPU-validated.\nOther cases are handled by robust access and no validation error occurs.\n- Test that:\n    - Draw call needs to read {=, >} any bound vertex buffer range, with GPUBuffer that is {large\n      enough, exactly the size of bound range}\n        - Binding size = 0 (ensure it's not treated as a special case)\n        - x= weird buffer offset values\n        - x= weird attribute offset values\n        - x= weird arrayStride values\n        - x= {render pass, render bundle}\n- For vertex step mode vertex buffer,\n    - Test that:\n        - vertexCount largeish\n        - firstVertex {=, >} 0\n        - arrayStride is 0 and bound buffer size too small\n        - (vertexCount + firstVertex) is zero\n    - Validation error occurs in:\n        - draw\n        - drawIndexed with a zero array stride vertex step mode buffer OOB\n    - Otherwise no validation error in drawIndexed, draIndirect and drawIndexedIndirect\n- For instance step mode vertex buffer,\n    - Test with draw and drawIndexed:\n        - instanceCount largeish\n        - firstInstance {=, >} 0\n        - arrayStride is 0 and bound buffer size too small\n        - (instanceCount + firstInstance) is zero\n    - Validation error occurs in draw and drawIndexed\n    - No validation error in drawIndirect and drawIndexedIndirect\n\nIn this test, we use a a render pipeline requiring one vertex step mode with different vertex buffer\nlayouts (attribute offset, array stride, vertex format). Then for a given drawing parameter set (e.g.,\nvertexCount, instanceCount, firstVertex, indexCount), we calculate the exactly required size for\nvertex step mode vertex buffer. Then, we generate buffer parameters (i.e. GPU buffer size,\nbinding offset and binding size) for all buffers, covering both (bound size == required size),\n(bound size == required size - 1), and (bound size == 0), and test that draw and drawIndexed will\nsuccess/error as expected. Such set of buffer parameters should include cases like weird offset values.\n`\n  )\n  .params(u =>\n    u\n      // type of draw call\n      .combine('type', ['draw', 'drawIndexed', 'drawIndirect', 'drawIndexedIndirect'] as const)\n      // the state of vertex step mode vertex buffer bound size\n      .combine('VBSize', ['zero', 'exile', 'enough'] as const)\n      // the state of instance step mode vertex buffer bound size\n      .combine('IBSize', ['zero', 'exile', 'enough'] as const)\n      // should the vertex stride count be zero\n      .combine('VStride0', [false, true] as const)\n      // should the instance stride count be zero\n      .combine('IStride0', [false, true] as const)\n      // the state of array stride\n      .combine('AStride', ['zero', 'exact', 'oversize'] as const)\n      // the factor for offset of attributes in vertex layout\n      .combine('offset', [0, 1, 2, 7]) // the offset of attribute will be factor * MIN(4, sizeof(vertexFormat))\n      .beginSubcases()\n      .combine('setBufferOffset', [0, 200]) // must be a multiple of 4\n      .combine('attributeFormat', ['snorm8x2', 'float32', 'float16x4'] as GPUVertexFormat[])\n      .combine('vertexCount', [0, 1, 10000])\n      .combine('firstVertex', [0, 10000])\n      .filter(p => p.VStride0 === (p.firstVertex + p.vertexCount === 0))\n      .combine('instanceCount', [0, 1, 10000])\n      .combine('firstInstance', [0, 10000])\n      .filter(p => p.IStride0 === (p.firstInstance + p.instanceCount === 0))\n      .unless(p => p.vertexCount === 10000 && p.instanceCount === 10000)\n  )\n  .fn(async t => {\n    const {\n      type: drawType,\n      VBSize: boundVertexBufferSizeState,\n      IBSize: boundInstanceBufferSizeState,\n      VStride0: zeroVertexStrideCount,\n      IStride0: zeroInstanceStrideCount,\n      AStride: arrayStrideState,\n      offset: attributeOffsetFactor,\n      setBufferOffset,\n      attributeFormat,\n      vertexCount,\n      instanceCount,\n      firstVertex,\n      firstInstance,\n    } = t.params;\n\n    const attributeFormatInfo = kVertexFormatInfo[attributeFormat];\n    const formatSize = attributeFormatInfo.bytesPerComponent * attributeFormatInfo.componentCount;\n    const attributeOffset = attributeOffsetFactor * Math.min(4, formatSize);\n    const lastStride = attributeOffset + formatSize;\n    let arrayStride = 0;\n    if (arrayStrideState !== 'zero') {\n      arrayStride = lastStride;\n      if (arrayStrideState === 'oversize') {\n        // Add an arbitrary number to array stride to make it larger than required by attributes\n        arrayStride = arrayStride + 20;\n      }\n      arrayStride = arrayStride + (-arrayStride & 3); // Make sure arrayStride is a multiple of 4\n    }\n\n    const calcSetBufferSize = (\n      boundBufferSizeState: 'zero' | 'exile' | 'enough',\n      strideCount: number\n    ): number => {\n      let requiredBufferSize: number;\n      if (strideCount > 0) {\n        requiredBufferSize = arrayStride * (strideCount - 1) + lastStride;\n      } else {\n        // Spec do not validate bounded buffer size if strideCount == 0.\n        requiredBufferSize = lastStride;\n      }\n      let setBufferSize: number;\n      switch (boundBufferSizeState) {\n        case 'zero': {\n          setBufferSize = 0;\n          break;\n        }\n        case 'exile': {\n          setBufferSize = requiredBufferSize - 1;\n          break;\n        }\n        case 'enough': {\n          setBufferSize = requiredBufferSize;\n          break;\n        }\n      }\n      return setBufferSize;\n    };\n\n    const strideCountForVertexBuffer = firstVertex + vertexCount;\n    const setVertexBufferSize = calcSetBufferSize(\n      boundVertexBufferSizeState,\n      strideCountForVertexBuffer\n    );\n    const vertexBufferSize = setBufferOffset + setVertexBufferSize;\n    const strideCountForInstanceBuffer = firstInstance + instanceCount;\n    const setInstanceBufferSize = calcSetBufferSize(\n      boundInstanceBufferSizeState,\n      strideCountForInstanceBuffer\n    );\n    const instanceBufferSize = setBufferOffset + setInstanceBufferSize;\n\n    const vertexBuffer = t.createBufferWithState('valid', {\n      size: vertexBufferSize,\n      usage: GPUBufferUsage.VERTEX,\n    });\n    const instanceBuffer = t.createBufferWithState('valid', {\n      size: instanceBufferSize,\n      usage: GPUBufferUsage.VERTEX,\n    });\n\n    const renderPipeline = makeTestPipelineWithVertexAndInstanceBuffer(\n      t,\n      arrayStride,\n      attributeFormat,\n      attributeOffset\n    );\n\n    for (const encoderType of ['render bundle', 'render pass'] as const) {\n      for (const setPipelineBeforeBuffer of [false, true]) {\n        const commandBufferMaker = t.createEncoder(encoderType);\n        const renderEncoder = commandBufferMaker.encoder;\n\n        if (setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n        renderEncoder.setVertexBuffer(1, vertexBuffer, setBufferOffset, setVertexBufferSize);\n        renderEncoder.setVertexBuffer(7, instanceBuffer, setBufferOffset, setInstanceBufferSize);\n        if (!setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n\n        if (drawType === 'draw' || drawType === 'drawIndirect') {\n          const drawParam: DrawParameter = {\n            vertexCount,\n            instanceCount,\n            firstVertex,\n            firstInstance,\n          };\n\n          callDraw(t, renderEncoder, drawType, drawParam);\n        } else {\n          const {\n            indexFormat,\n            indexCount,\n            firstIndex,\n            indexBufferSize,\n          } = kDefaultParameterForIndexedDraw;\n\n          const desc: GPUBufferDescriptor = {\n            size: indexBufferSize,\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n          };\n          const indexBuffer = t.createBufferWithState('valid', desc);\n\n          const drawParam: DrawIndexedParameter = {\n            indexCount,\n            instanceCount,\n            firstIndex,\n            baseVertex: firstVertex,\n            firstInstance,\n          };\n\n          renderEncoder.setIndexBuffer(indexBuffer, indexFormat, 0, indexBufferSize);\n          callDrawIndexed(t, renderEncoder, drawType, drawParam);\n        }\n\n        const isVertexBufferOOB =\n          boundVertexBufferSizeState !== 'enough' &&\n          drawType === 'draw' && // drawIndirect, drawIndexed, and drawIndexedIndirect do not validate vertex step mode buffer\n          !zeroVertexStrideCount; // vertex step mode buffer never OOB if stride count = 0\n        const isInstanceBufferOOB =\n          boundInstanceBufferSizeState !== 'enough' &&\n          (drawType === 'draw' || drawType === 'drawIndexed') && // drawIndirect and drawIndexedIndirect do not validate instance step mode buffer\n          !zeroInstanceStrideCount; // vertex step mode buffer never OOB if stride count = 0\n        const isFinishSuccess = !isVertexBufferOOB && !isInstanceBufferOOB;\n\n        commandBufferMaker.validateFinishAndSubmit(isFinishSuccess, true);\n      }\n    }\n  });\n\ng.test(`buffer_binding_overlap`)\n  .desc(\n    `\nIn this test we test that binding one GPU buffer to multiple vertex buffer slot or both vertex\nbuffer slot and index buffer will cause no validation error, with completely/partial overlap.\n    - x= all draw types\n`\n  )\n  .params(u =>\n    u //\n      .combine('drawType', ['draw', 'drawIndexed', 'drawIndirect', 'drawIndexedIndirect'] as const)\n      .beginSubcases()\n      .combine('vertexBoundOffestFactor', [0, 0.5, 1, 1.5, 2])\n      .combine('instanceBoundOffestFactor', [0, 0.5, 1, 1.5, 2])\n      .combine('indexBoundOffestFactor', [0, 0.5, 1, 1.5, 2])\n      .combine('arrayStrideState', ['zero', 'exact', 'oversize'] as const)\n  )\n  .fn(async t => {\n    const {\n      drawType,\n      vertexBoundOffestFactor,\n      instanceBoundOffestFactor,\n      indexBoundOffestFactor,\n      arrayStrideState,\n    } = t.params;\n\n    // Compute the array stride for vertex step mode and instance step mode attribute\n    const attributeFormat = 'float32x4';\n    const attributeFormatInfo = kVertexFormatInfo[attributeFormat];\n    const formatSize = attributeFormatInfo.bytesPerComponent * attributeFormatInfo.componentCount;\n    const attributeOffset = 0;\n    const lastStride = attributeOffset + formatSize;\n    let arrayStride = 0;\n    if (arrayStrideState !== 'zero') {\n      arrayStride = lastStride;\n      if (arrayStrideState === 'oversize') {\n        // Add an arbitrary number to array stride\n        arrayStride = arrayStride + 20;\n      }\n      arrayStride = arrayStride + (-arrayStride & 3); // Make sure arrayStride is a multiple of 4\n    }\n\n    const calcAttributeBufferSize = (strideCount: number): number => {\n      let requiredBufferSize: number;\n      if (strideCount > 0) {\n        requiredBufferSize = arrayStride * (strideCount - 1) + lastStride;\n      } else {\n        // Spec do not validate bounded buffer size if strideCount == 0.\n        requiredBufferSize = lastStride;\n      }\n      return requiredBufferSize;\n    };\n\n    const calcSetBufferOffset = (requiredSetBufferSize: number, offsetFactor: number): number => {\n      const offset = Math.ceil(requiredSetBufferSize * offsetFactor);\n      const alignedOffset = offset + (-offset & 3); // Make sure offset is a multiple of 4\n      return alignedOffset;\n    };\n\n    // Compute required bound range for all vertex and index buffer to ensure the shared GPU buffer\n    // has enough size.\n    const { vertexCount, firstVertex } = kDefaultParameterForNonIndexedDraw;\n    const strideCountForVertexBuffer = firstVertex + vertexCount;\n    const setVertexBufferSize = calcAttributeBufferSize(strideCountForVertexBuffer);\n    const setVertexBufferOffset = calcSetBufferOffset(setVertexBufferSize, vertexBoundOffestFactor);\n    let requiredBufferSize = setVertexBufferOffset + setVertexBufferSize;\n\n    const { instanceCount, firstInstance } = kDefaultParameterForDraw;\n    const strideCountForInstanceBuffer = firstInstance + instanceCount;\n    const setInstanceBufferSize = calcAttributeBufferSize(strideCountForInstanceBuffer);\n    const setInstanceBufferOffset = calcSetBufferOffset(\n      setInstanceBufferSize,\n      instanceBoundOffestFactor\n    );\n    requiredBufferSize = Math.max(\n      requiredBufferSize,\n      setInstanceBufferOffset + setInstanceBufferSize\n    );\n\n    const { indexBufferSize: setIndexBufferSize, indexFormat } = kDefaultParameterForIndexedDraw;\n    const setIndexBufferOffset = calcSetBufferOffset(setIndexBufferSize, indexBoundOffestFactor);\n    requiredBufferSize = Math.max(requiredBufferSize, setIndexBufferOffset + setIndexBufferSize);\n\n    // Create the shared GPU buffer with both vertetx and index usage\n    const sharedBuffer = t.createBufferWithState('valid', {\n      size: requiredBufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.INDEX,\n    });\n\n    const renderPipeline = makeTestPipelineWithVertexAndInstanceBuffer(\n      t,\n      arrayStride,\n      attributeFormat\n    );\n\n    for (const encoderType of ['render bundle', 'render pass'] as const) {\n      for (const setPipelineBeforeBuffer of [false, true]) {\n        const commandBufferMaker = t.createEncoder(encoderType);\n        const renderEncoder = commandBufferMaker.encoder;\n\n        if (setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n        renderEncoder.setVertexBuffer(1, sharedBuffer, setVertexBufferOffset, setVertexBufferSize);\n        renderEncoder.setVertexBuffer(\n          7,\n          sharedBuffer,\n          setInstanceBufferOffset,\n          setInstanceBufferSize\n        );\n        renderEncoder.setIndexBuffer(\n          sharedBuffer,\n          indexFormat,\n          setIndexBufferOffset,\n          setIndexBufferSize\n        );\n        if (!setPipelineBeforeBuffer) {\n          renderEncoder.setPipeline(renderPipeline);\n        }\n\n        if (drawType === 'draw' || drawType === 'drawIndirect') {\n          const drawParam: DrawParameter = {\n            ...kDefaultParameterForDraw,\n            ...kDefaultParameterForNonIndexedDraw,\n          };\n          callDraw(t, renderEncoder, drawType, drawParam);\n        } else {\n          const drawParam: DrawIndexedParameter = {\n            ...kDefaultParameterForDraw,\n            ...kDefaultParameterForIndexedDraw,\n          };\n          callDrawIndexed(t, renderEncoder, drawType, drawParam);\n        }\n\n        // Since all bound buffer are of enough size, draw call should always succeed.\n        commandBufferMaker.validateFinishAndSubmit(true, true);\n      }\n    }\n  });\n\ng.test(`last_buffer_setting_take_account`)\n  .desc(\n    `\nIn this test we test that only the last setting for a buffer slot take account.\n- All (non/indexed, in/direct) draw commands\n  - setPl, setVB, setIB, draw, {setPl,setVB,setIB,nothing (control)}, then a larger draw that\n    wouldn't have been valid before that\n`\n  )\n  .unimplemented();\n\ng.test(`max_draw_count`)\n  .desc(\n    `\nIn this test we test that draw count which exceeds\nGPURenderPassDescriptor.maxDrawCount causes validation error on\nGPUCommandEncoder.finish(). The test sets specified maxDrawCount,\ncalls specified draw call specified times with or without bundles,\nand checks whether GPUCommandEncoder.finish() causes a validation error.\n    - x= whether to use a bundle for the first half of the draw calls\n    - x= whether to use a bundle for the second half of the draw calls\n    - x= several different draw counts\n    - x= several different maxDrawCounts\n`\n  )\n  .params(u =>\n    u\n      .combine('bundleFirstHalf', [false, true])\n      .combine('bundleSecondHalf', [false, true])\n      .combine('maxDrawCount', [0, 1, 4, 16])\n      .beginSubcases()\n      .expand('drawCount', p => new Set([0, p.maxDrawCount, p.maxDrawCount + 1]))\n  )\n  .fn(async t => {\n    const { bundleFirstHalf, bundleSecondHalf, maxDrawCount, drawCount } = t.params;\n\n    const colorFormat = 'rgba8unorm';\n    const colorTexture = t.device.createTexture({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: colorFormat,\n      mipLevelCount: 1,\n      sampleCount: 1,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex fn main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>();\n            }\n          `,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `@fragment fn main() {}`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: colorFormat, writeMask: 0 }],\n      },\n    });\n\n    const indexBuffer = t.makeBufferWithContents(new Uint16Array([0, 0, 0]), GPUBufferUsage.INDEX);\n    const indirectBuffer = t.makeBufferWithContents(\n      new Uint32Array([3, 1, 0, 0]),\n      GPUBufferUsage.INDIRECT\n    );\n    const indexedIndirectBuffer = t.makeBufferWithContents(\n      new Uint32Array([3, 1, 0, 0, 0]),\n      GPUBufferUsage.INDIRECT\n    );\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPassEncoder = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n      maxDrawCount,\n    });\n\n    const firstHalfEncoder = bundleFirstHalf\n      ? t.device.createRenderBundleEncoder({\n          colorFormats: [colorFormat],\n        })\n      : renderPassEncoder;\n\n    const secondHalfEncoder = bundleSecondHalf\n      ? t.device.createRenderBundleEncoder({\n          colorFormats: [colorFormat],\n        })\n      : renderPassEncoder;\n\n    firstHalfEncoder.setPipeline(pipeline);\n    firstHalfEncoder.setIndexBuffer(indexBuffer, 'uint16');\n    secondHalfEncoder.setPipeline(pipeline);\n    secondHalfEncoder.setIndexBuffer(indexBuffer, 'uint16');\n\n    const halfDrawCount = Math.floor(drawCount / 2);\n    for (let i = 0; i < drawCount; i++) {\n      const encoder = i < halfDrawCount ? firstHalfEncoder : secondHalfEncoder;\n      if (i % 4 === 0) {\n        encoder.draw(3);\n      }\n      if (i % 4 === 1) {\n        encoder.drawIndexed(3);\n      }\n      if (i % 4 === 2) {\n        encoder.drawIndirect(indirectBuffer, 0);\n      }\n      if (i % 4 === 3) {\n        encoder.drawIndexedIndirect(indexedIndirectBuffer, 0);\n      }\n    }\n\n    const bundles = [];\n    if (bundleFirstHalf) {\n      bundles.push((firstHalfEncoder as GPURenderBundleEncoder).finish());\n    }\n    if (bundleSecondHalf) {\n      bundles.push((secondHalfEncoder as GPURenderBundleEncoder).finish());\n    }\n\n    if (bundles.length > 0) {\n      renderPassEncoder.executeBundles(bundles);\n    }\n\n    renderPassEncoder.end();\n\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    }, drawCount > maxDrawCount);\n  });\n"],"file":"draw.spec.js"}