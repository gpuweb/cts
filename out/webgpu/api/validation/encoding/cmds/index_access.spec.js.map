{"version":3,"file":"index_access.spec.js","names":["description","makeTestGroup","AllFeaturesMaxLimitsValidationTest","F","createIndexBuffer","indexData","makeBufferWithContents","Uint32Array","GPUBufferUsage","INDEX","createRenderPipeline","device","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","stripIndexFormat","beginRenderPass","encoder","colorAttachment","createTextureTracked","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","drawIndexed","indexBuffer","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","isSuccess","pipeline","createCommandEncoder","pass","setPipeline","setIndexBuffer","end","queue","submit","finish","expectValidationError","test","desc","params","u","combineWithParams","combine","fn","t"],"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/index_access.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for indexed draws accessing the index buffer.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { AllFeaturesMaxLimitsValidationTest } from '../../validation_test.js';\n\nclass F extends AllFeaturesMaxLimitsValidationTest {\n  createIndexBuffer(indexData: Iterable<number>): GPUBuffer {\n    return this.makeBufferWithContents(new Uint32Array(indexData), GPUBufferUsage.INDEX);\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            @vertex fn main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'triangle-strip',\n        stripIndexFormat: 'uint32',\n      },\n    });\n  }\n\n  beginRenderPass(encoder: GPUCommandEncoder) {\n    const colorAttachment = this.createTextureTracked({\n      format: 'rgba8unorm',\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  drawIndexed(\n    indexBuffer: GPUBuffer,\n    indexCount: number,\n    instanceCount: number,\n    firstIndex: number,\n    baseVertex: number,\n    firstInstance: number,\n    isSuccess: boolean\n  ) {\n    const pipeline = this.createRenderPipeline();\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = this.beginRenderPass(encoder);\n    pass.setPipeline(pipeline);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    pass.end();\n\n    if (isSuccess) {\n      this.device.queue.submit([encoder.finish()]);\n    } else {\n      this.expectValidationError(() => {\n        encoder.finish();\n      });\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('out_of_bounds')\n  .desc(\n    `Test drawing with out of bound index access to make sure encoder validation catch the\n    following indexCount and firstIndex OOB conditions\n    - either is within bound but indexCount + firstIndex is out of bound\n    - only firstIndex is out of bound\n    - only indexCount is out of bound\n    - firstIndex much larger than indexCount\n    - indexCount much larger than firstIndex\n    - max uint32 value for both to make sure the sum doesn't overflow\n    - max uint32 indexCount and small firstIndex\n    - max uint32 firstIndex and small indexCount\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams([\n          { indexCount: 6, firstIndex: 0 }, // draw all 6 out of 6 index\n          { indexCount: 5, firstIndex: 1 }, // draw the last 5 out of 6 index\n          { indexCount: 1, firstIndex: 5 }, // draw the last 1 out of 6 index\n          { indexCount: 0, firstIndex: 6 }, // firstIndex point to the one after last, but (indexCount + firstIndex) * stride <= bufferSize, valid\n          { indexCount: 0, firstIndex: 7 }, // (indexCount + firstIndex) * stride > bufferSize, invalid\n          { indexCount: 7, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 6, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 1, firstIndex: 6 }, // indexCount valid, but (indexCount + firstIndex) out of bound\n          { indexCount: 6, firstIndex: 10000 }, // firstIndex much larger than the bound\n          { indexCount: 10000, firstIndex: 0 }, // indexCount much larger than the bound\n          { indexCount: 0xffffffff, firstIndex: 0xffffffff }, // max uint32 value\n          { indexCount: 0xffffffff, firstIndex: 2 }, // max uint32 indexCount and small firstIndex\n          { indexCount: 2, firstIndex: 0xffffffff }, // small indexCount and max uint32 firstIndex\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([0, 1, 2, 3, 1, 2]);\n    const isSuccess: boolean = indexCount + firstIndex <= 6;\n\n    t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n  });\n\ng.test('out_of_bounds_zero_sized_index_buffer')\n  .desc(\n    `Test drawing with an empty index buffer to make sure the encoder validation catch the\n    following indexCount and firstIndex conditions\n    - indexCount + firstIndex is out of bound\n    - indexCount is 0 but firstIndex is out of bound\n    - only indexCount is out of bound\n    - both are 0s (not out of bound) but index buffer size is 0\n    Together with normal and large instanceCount`\n  )\n  .params(\n    u =>\n      u\n        .combineWithParams([\n          { indexCount: 3, firstIndex: 1 }, // indexCount + firstIndex out of bound\n          { indexCount: 0, firstIndex: 1 }, // indexCount is 0 but firstIndex out of bound\n          { indexCount: 3, firstIndex: 0 }, // only indexCount out of bound\n          { indexCount: 0, firstIndex: 0 }, // just zeros, valid\n        ] as const)\n        .combine('instanceCount', [1, 10000]) // normal and large instanceCount\n  )\n  .fn(t => {\n    const { indexCount, firstIndex, instanceCount } = t.params;\n\n    const indexBuffer = t.createIndexBuffer([]);\n    const isSuccess: boolean = indexCount + firstIndex <= 0;\n\n    t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,+CAA+C;AAC7E,SAASC,kCAAkC,QAAQ,0BAA0B;;AAE7E,MAAMC,CAAC,SAASD,kCAAkC,CAAC;EACjDE,iBAAiBA,CAACC,SAA2B,EAAa;IACxD,OAAO,IAAI,CAACC,sBAAsB,CAAC,IAAIC,WAAW,CAACF,SAAS,CAAC,EAAEG,cAAc,CAACC,KAAK,CAAC;EACtF;;EAEAC,oBAAoBA,CAAA,EAAsB;IACxC,OAAO,IAAI,CAACC,MAAM,CAACD,oBAAoB,CAAC;MACtCE,MAAM,EAAE,MAAM;MACdC,MAAM,EAAE;QACNC,MAAM,EAAE,IAAI,CAACH,MAAM,CAACI,kBAAkB,CAAC;UACrCC,IAAI,EAAG;AACjB;AACA;AACA;QACQ,CAAC,CAAC;QACFC,UAAU,EAAE;MACd,CAAC;MACDC,QAAQ,EAAE;QACRJ,MAAM,EAAE,IAAI,CAACH,MAAM,CAACI,kBAAkB,CAAC;UACrCC,IAAI,EAAG;AACjB;AACA;AACA;QACQ,CAAC,CAAC;QACFC,UAAU,EAAE,MAAM;QAClBE,OAAO,EAAE,CAAC,EAAEC,MAAM,EAAE,YAAY,CAAC,CAAC;MACpC,CAAC;MACDC,SAAS,EAAE;QACTC,QAAQ,EAAE,gBAAgB;QAC1BC,gBAAgB,EAAE;MACpB;IACF,CAAC,CAAC;EACJ;;EAEAC,eAAeA,CAACC,OAA0B,EAAE;IAC1C,MAAMC,eAAe,GAAG,IAAI,CAACC,oBAAoB,CAAC;MAChDP,MAAM,EAAE,YAAY;MACpBQ,IAAI,EAAE,EAAEC,KAAK,EAAE,CAAC,EAAEC,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC,CAAC;MACpDC,KAAK,EAAEC,eAAe,CAACC;IACzB,CAAC,CAAC;;IAEF,OAAOT,OAAO,CAACD,eAAe,CAAC;MAC7BW,gBAAgB,EAAE;MAChB;QACEC,IAAI,EAAEV,eAAe,CAACW,UAAU,CAAC,CAAC;QAClCC,UAAU,EAAE,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;QAC9CC,MAAM,EAAE,OAAO;QACfC,OAAO,EAAE;MACX,CAAC;;IAEL,CAAC,CAAC;EACJ;;EAEAC,WAAWA;EACTC,WAAsB;EACtBC,UAAkB;EAClBC,aAAqB;EACrBC,UAAkB;EAClBC,UAAkB;EAClBC,aAAqB;EACrBC,SAAkB;EAClB;IACA,MAAMC,QAAQ,GAAG,IAAI,CAAC3C,oBAAoB,CAAC,CAAC;;IAE5C,MAAMe,OAAO,GAAG,IAAI,CAACd,MAAM,CAAC2C,oBAAoB,CAAC,CAAC;IAClD,MAAMC,IAAI,GAAG,IAAI,CAAC/B,eAAe,CAACC,OAAO,CAAC;IAC1C8B,IAAI,CAACC,WAAW,CAACH,QAAQ,CAAC;IAC1BE,IAAI,CAACE,cAAc,CAACX,WAAW,EAAE,QAAQ,CAAC;IAC1CS,IAAI,CAACV,WAAW,CAACE,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAEC,UAAU,EAAEC,aAAa,CAAC;IAClFI,IAAI,CAACG,GAAG,CAAC,CAAC;;IAEV,IAAIN,SAAS,EAAE;MACb,IAAI,CAACzC,MAAM,CAACgD,KAAK,CAACC,MAAM,CAAC,CAACnC,OAAO,CAACoC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC9C,CAAC,MAAM;MACL,IAAI,CAACC,qBAAqB,CAAC,MAAM;QAC/BrC,OAAO,CAACoC,MAAM,CAAC,CAAC;MAClB,CAAC,CAAC;IACJ;EACF;AACF;;AAEA,OAAO,MAAMrB,CAAC,GAAGvC,aAAa,CAACE,CAAC,CAAC;;AAEjCqC,CAAC,CAACuB,IAAI,CAAC,eAAe,CAAC;AACpBC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM;EACL,CAAAC,CAAC;EACCA,CAAC;EACEC,iBAAiB,CAAC;EACjB,EAAEpB,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,KAAK,CAAC,CAAC,EAAE;EACtC,EAAEF,UAAU,EAAE,KAAK,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EACtC,EAAEF,UAAU,EAAE,UAAU,EAAEE,UAAU,EAAE,UAAU,CAAC,CAAC,EAAE;EACpD,EAAEF,UAAU,EAAE,UAAU,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAC3C,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,UAAU,CAAC,CAAC,CAAE;EAAA,CACnC,CAAC;EACVmB,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAC5C,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEvB,UAAU,EAAEE,UAAU,EAAED,aAAa,CAAC,CAAC,GAAGsB,CAAC,CAACL,MAAM;;EAE1D,MAAMnB,WAAW,GAAGwB,CAAC,CAAClE,iBAAiB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3D,MAAMgD,SAAkB,GAAGL,UAAU,GAAGE,UAAU,IAAI,CAAC;;EAEvDqB,CAAC,CAACzB,WAAW,CAACC,WAAW,EAAEC,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAEG,SAAS,CAAC;AACpF,CAAC,CAAC;;AAEJZ,CAAC,CAACuB,IAAI,CAAC,uCAAuC,CAAC;AAC5CC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM;EACL,CAAAC,CAAC;EACCA,CAAC;EACEC,iBAAiB,CAAC;EACjB,EAAEpB,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE;EAClC,EAAEF,UAAU,EAAE,CAAC,EAAEE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAE;EAAA,CAC1B,CAAC;EACVmB,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAC5C,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEvB,UAAU,EAAEE,UAAU,EAAED,aAAa,CAAC,CAAC,GAAGsB,CAAC,CAACL,MAAM;;EAE1D,MAAMnB,WAAW,GAAGwB,CAAC,CAAClE,iBAAiB,CAAC,EAAE,CAAC;EAC3C,MAAMgD,SAAkB,GAAGL,UAAU,GAAGE,UAAU,IAAI,CAAC;;EAEvDqB,CAAC,CAACzB,WAAW,CAACC,WAAW,EAAEC,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAEG,SAAS,CAAC;AACpF,CAAC,CAAC"}