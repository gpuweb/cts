{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_oom.spec.ts"],"names":["description","kUnitCaseParamsBuilder","makeTestGroup","kBufferUsages","GPUTest","kMaxSafeMultipleOf8","oomAndSizeParams","combine","expand","oom","g","test","desc","params","beginSubcases","fn","t","write","size","buffer","expectGPUError","device","createBuffer","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","promise","mapAsync","GPUMapMode","WRITE","READ","shouldReject","shouldThrow","getMappedRange","unmap","arraybuffer","expect","byteLength","mappedAtCreation","f","mapping","undefined"],"mappings":"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","sourcesContent":["export const description =\n  'Test out-of-memory conditions creating large mappable/mappedAtCreation buffers.';\n\nimport { kUnitCaseParamsBuilder } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { kMaxSafeMultipleOf8 } from '../../../util/math.js';\n\nconst oomAndSizeParams = kUnitCaseParamsBuilder\n  .combine('oom', [false, true])\n  .expand('size', ({ oom }) => {\n    return oom\n      ? [\n          kMaxSafeMultipleOf8,\n          0x20_0000_0000, // 128 GB\n        ]\n      : [16];\n  });\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('mapAsync')\n  .desc(\n    `Test creating a large mappable buffer should produce an out-of-memory error if allocation fails.\n  - The resulting buffer is an error buffer, so mapAsync rejects and produces a validation error.\n  - Calling getMappedRange should throw an OperationError because the buffer is not in the mapped state.\n  - unmap() throws an OperationError if mapping failed, and otherwise should detach the ArrayBuffer.\n`\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('write', [false, true])\n  )\n  .fn(async t => {\n    const { oom, write, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () =>\n        t.device.createBuffer({\n          size,\n          usage: write ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n        }),\n      oom\n    );\n    const promise = t.expectGPUError(\n      'validation', // Should be a validation error since the buffer is invalid.\n      () => buffer.mapAsync(write ? GPUMapMode.WRITE : GPUMapMode.READ),\n      oom\n    );\n\n    if (oom) {\n      // Should also reject in addition to the validation error.\n      t.shouldReject('OperationError', promise);\n\n      // Should throw an OperationError because the buffer is not mapped.\n      // Note: not a RangeError because the state of the buffer is checked first.\n      t.shouldThrow('OperationError', () => {\n        buffer.getMappedRange();\n      });\n\n      // Should be a validation error since the buffer failed to be mapped.\n      t.expectGPUError('validation', () => buffer.unmap());\n    } else {\n      await promise;\n      const arraybuffer = buffer.getMappedRange();\n      t.expect(arraybuffer.byteLength === size);\n      buffer.unmap();\n      t.expect(arraybuffer.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation,full_getMappedRange')\n  .desc(\n    `Test creating a very large buffer mappedAtCreation buffer should produce\nan out-of-memory error if allocation fails.\n  - Because the buffer can be immediately mapped, getMappedRange throws an OperationError only\n    because such a large ArrayBuffer cannot be created.\n  - unmap() should not throw.\n  `\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('usage', kBufferUsages)\n  )\n  .fn(async t => {\n    const { oom, usage, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () => t.device.createBuffer({ mappedAtCreation: true, size, usage }),\n      oom\n    );\n\n    const f = () => buffer.getMappedRange();\n\n    let mapping: ArrayBuffer | undefined = undefined;\n    if (oom) {\n      // getMappedRange is normally valid on OOM buffers, but this one fails because the\n      // (default) range is too large to create the returned ArrayBuffer.\n      t.shouldThrow('RangeError', f);\n    } else {\n      mapping = f();\n    }\n\n    // Should be valid because buffer is mapped, regardless of OOM.\n    buffer.unmap();\n    if (mapping !== undefined) {\n      t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation,smaller_getMappedRange')\n  .desc(\n    `Test creating a very large mappedAtCreation buffer should produce\nan out-of-memory error if allocation fails.\n  - Because the buffer can be immediately mapped, getMappedRange does not throw an OperationError. Calling it on a small range of the buffer successfully returns an ArrayBuffer.\n  - unmap() should detach the ArrayBuffer.\n  `\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('usage', kBufferUsages)\n  )\n  .fn(async t => {\n    const { oom, usage, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () => t.device.createBuffer({ mappedAtCreation: true, size, usage }),\n      oom\n    );\n\n    // Note: It is always valid to get mapped ranges of a GPUBuffer that is mapped at creation,\n    // even if it is invalid, because the Content timeline might not know it is invalid.\n    // Should be valid because mappedAtCreation was set, regardless of OOM.\n    const mapping = buffer.getMappedRange(0, 16);\n    t.expect(mapping.byteLength === 16);\n\n    // Should be valid because buffer is mapped, regardless of OOM.\n    buffer.unmap();\n    t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n  });\n"],"file":"map_oom.spec.js"}