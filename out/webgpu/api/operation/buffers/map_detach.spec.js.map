{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_detach.spec.ts"],"names":["description","makeTestGroup","GPUConst","GPUTest","g","test","desc","paramsSubcasesOnly","u","combine","combineWithParams","usage","BufferUsage","COPY_SRC","MAP_WRITE","COPY_DST","MAP_READ","mapMode","MapMode","WRITE","READ","unmap","destroy","unless","p","mappedAtCreation","undefined","fn","t","params","buffer","device","createBuffer","size","mapAsync","arrayBuffer","getMappedRange","view","Uint8Array","expect","byteLength","length"],"mappings":"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","sourcesContent":["export const description = `\n  Tests that TypedArrays created when mapping a GPUBuffer are detached when the\n  buffer is unmapped or destroyed.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('while_mapped')\n  .desc(\n    `\n    Test that a mapped buffers are able to properly detach.\n    - Tests {mappable, unmappable mapAtCreation, mappable mapAtCreation}\n    - Tests while {mapped, mapped at creation, mapped at creation then unmapped and mapped again}`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('mappedAtCreation', [false, true])\n      .combineWithParams([\n        { usage: GPUConst.BufferUsage.COPY_SRC },\n        { usage: GPUConst.BufferUsage.MAP_WRITE | GPUConst.BufferUsage.COPY_SRC },\n        { usage: GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ },\n        {\n          usage: GPUConst.BufferUsage.MAP_WRITE | GPUConst.BufferUsage.COPY_SRC,\n          mapMode: GPUConst.MapMode.WRITE,\n        },\n        {\n          usage: GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n          mapMode: GPUConst.MapMode.READ,\n        },\n      ])\n      .combineWithParams([\n        { unmap: true, destroy: false },\n        { unmap: false, destroy: true },\n        { unmap: true, destroy: true },\n      ])\n      .unless(p => p.mappedAtCreation === false && p.mapMode === undefined)\n  )\n  .fn(async t => {\n    const { usage, mapMode, mappedAtCreation, unmap, destroy } = t.params;\n    const buffer = t.device.createBuffer({\n      size: 4,\n      usage,\n      mappedAtCreation,\n    });\n\n    if (mapMode !== undefined) {\n      if (mappedAtCreation) {\n        buffer.unmap();\n      }\n      await buffer.mapAsync(mapMode);\n    }\n\n    const arrayBuffer = buffer.getMappedRange();\n    const view = new Uint8Array(arrayBuffer);\n    t.expect(arrayBuffer.byteLength === 4);\n    t.expect(view.length === 4);\n\n    if (unmap) buffer.unmap();\n    if (destroy) buffer.destroy();\n\n    t.expect(arrayBuffer.byteLength === 0, 'ArrayBuffer should be detached');\n    t.expect(view.byteLength === 0, 'ArrayBufferView should be detached');\n  });\n"],"file":"map_detach.spec.js"}