{"version":3,"file":"read_only.spec.js","names":["description","makeTestGroup","unreachable","assert","Float16Array","kTextureDimensions","getBlockInfoForColorTextureFormat","getTextureFormatType","kPossibleStorageTextureFormats","AllFeaturesMaxLimitsGPUTest","kValidShaderStages","getComponentCountForFormat","format","F","initTextureAndGetExpectedOutputBufferData","storageTexture","bytesPerBlock","width","height","depthOrArrayLayers","texelData","ArrayBuffer","texelTypedDataView","getTypedArrayBufferViewForTexelData","componentCount","outputBufferData","outputBufferTypedData","getTypedArrayBufferForOutputBufferData","setData","texelValue","outputValue","texelDataIndex","component","outputComponent","texelComponentIndex","outputTexelComponentIndex","z","y","x","r","g","b","a","packedValue","kFloat11One","kFloat10Zero","signedValue","Math","max","f16Array","queue","writeTexture","texture","bytesPerRow","rowsPerImage","arrayBuffer","Uint32Array","Int32Array","Float32Array","Uint8Array","Uint16Array","Int8Array","Int16Array","getOutputBufferWGSLType","doTransform","shaderStage","outputBuffer","declaration","dimension","textureDeclaration","bindGroupEntries","binding","resource","createView","buffer","commandEncoder","device","createCommandEncoder","textureLoadCoord","computeShader","computePipeline","createComputePipeline","compute","module","createShaderModule","code","layout","bindGroup","createBindGroup","getBindGroupLayout","entries","computePassEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","shader","renderPipeline","createRenderPipeline","vertex","fragment","targets","primitive","topology","placeholderColorTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","renderPassEncoder","beginRenderPass","colorAttachments","view","loadOp","storeOp","draw","copyTextureToBuffer","loadFromTextureWGSL","concat","outputToBufferWGSL","layer","clearValue","texelCount","submit","finish","test","desc","params","u","combine","unless","p","fn","t","skipIfTextureFormatNotSupported","skipIfTextureFormatNotUsableWithStorageAccessMode","isCompatibility","skipIf","limits","maxStorageTexturesInFragmentStage","maxStorageTexturesInVertexStage","kWidth","COPY_DST","STORAGE_BINDING","expectedData","createBufferTracked","GPUBufferUsage","STORAGE","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/storage_texture/read_only.spec.ts"],"sourcesContent":["export const description = `\nTests for the behavior of read-only storage textures.\n\nTODO:\n- Test mipmap level > 0\n- Test resource usage transitions with read-only storage textures\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { unreachable, assert } from '../../../../common/util/util.js';\nimport { Float16Array } from '../../../../external/petamoriken/float16/float16.js';\nimport { kTextureDimensions } from '../../../capability_info.js';\nimport {\n  ColorTextureFormat,\n  getBlockInfoForColorTextureFormat,\n  getTextureFormatType,\n  kPossibleStorageTextureFormats,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { kValidShaderStages, TValidShaderStage } from '../../../util/shader.js';\n\nfunction getComponentCountForFormat(format: ColorTextureFormat): number {\n  switch (format) {\n    case 'r8unorm':\n    case 'r8uint':\n    case 'r8snorm':\n    case 'r8sint':\n    case 'r16unorm':\n    case 'r16uint':\n    case 'r16snorm':\n    case 'r16sint':\n    case 'r16float':\n    case 'r32float':\n    case 'r32sint':\n    case 'r32uint':\n      return 1;\n    case 'rg8unorm':\n    case 'rg8uint':\n    case 'rg8snorm':\n    case 'rg8sint':\n    case 'rg16unorm':\n    case 'rg16uint':\n    case 'rg16snorm':\n    case 'rg16sint':\n    case 'rg16float':\n    case 'rg32float':\n    case 'rg32sint':\n    case 'rg32uint':\n      return 2;\n    case 'rg11b10ufloat':\n      return 3;\n    case 'rgba32float':\n    case 'rgba32sint':\n    case 'rgba32uint':\n    case 'rgba8sint':\n    case 'rgba8uint':\n    case 'rgba8snorm':\n    case 'rgba8unorm':\n    case 'rgba16float':\n    case 'rgba16sint':\n    case 'rgba16uint':\n    case 'bgra8unorm':\n    case 'rgba16unorm':\n    case 'rgba16snorm':\n    case 'rgb10a2uint':\n    case 'rgb10a2unorm':\n      return 4;\n    default:\n      unreachable();\n      return 0;\n  }\n}\n\nclass F extends AllFeaturesMaxLimitsGPUTest {\n  initTextureAndGetExpectedOutputBufferData(\n    storageTexture: GPUTexture,\n    format: ColorTextureFormat\n  ): ArrayBuffer {\n    const { bytesPerBlock } = getBlockInfoForColorTextureFormat(format);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n\n    const texelData = new ArrayBuffer(bytesPerBlock * width * height * depthOrArrayLayers);\n    const texelTypedDataView = this.getTypedArrayBufferViewForTexelData(texelData, format);\n    const componentCount = getComponentCountForFormat(format);\n    const outputBufferData = new ArrayBuffer(4 * 4 * width * height * depthOrArrayLayers);\n    const outputBufferTypedData = this.getTypedArrayBufferForOutputBufferData(\n      outputBufferData,\n      format\n    );\n\n    const setData = (\n      texelValue: number,\n      outputValue: number,\n      texelDataIndex: number,\n      component: number,\n      outputComponent: number = component\n    ) => {\n      const texelComponentIndex = texelDataIndex * componentCount + component;\n      texelTypedDataView[texelComponentIndex] = texelValue;\n      const outputTexelComponentIndex = texelDataIndex * 4 + outputComponent;\n      outputBufferTypedData[outputTexelComponentIndex] = outputValue;\n    };\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const texelDataIndex = z * width * height + y * width + x;\n          outputBufferTypedData[4 * texelDataIndex] = 0;\n          outputBufferTypedData[4 * texelDataIndex + 1] = 0;\n          outputBufferTypedData[4 * texelDataIndex + 2] = 0;\n          outputBufferTypedData[4 * texelDataIndex + 3] = 1;\n          // Packed formats like rgb10a2unorm, rg11b10ufloat, and rgb10a2uint store multiple color components within a single 32-bit integer.\n          // This means their TypedArray uses a single element per texel, so they are handled separately from other formats\n          if (format === 'rgb10a2unorm') {\n            const texelValue = 4 * texelDataIndex + 1;\n            const r = texelValue % 1024;\n            const g = (texelValue * 2) % 1024;\n            const b = (texelValue * 3) % 1024;\n            const a = 3;\n            const packedValue = (a << 30) | (b << 20) | (g << 10) | r;\n            const texelComponentIndex = texelDataIndex;\n            texelTypedDataView[texelComponentIndex] = packedValue;\n            outputBufferTypedData[texelDataIndex * 4] = r / 1023.0;\n            outputBufferTypedData[texelDataIndex * 4 + 1] = g / 1023.0;\n            outputBufferTypedData[texelDataIndex * 4 + 2] = b / 1023.0;\n            outputBufferTypedData[texelDataIndex * 4 + 3] = a / 3.0;\n          } else if (format === 'rg11b10ufloat') {\n            const kFloat11One = 0x3c0;\n            const kFloat10Zero = 0;\n            const r = kFloat11One;\n            const g = kFloat11One;\n            const b = kFloat10Zero;\n            const packedValue = (b << 22) | (g << 11) | r;\n            const texelComponentIndex = texelDataIndex;\n            texelTypedDataView[texelComponentIndex] = packedValue;\n            outputBufferTypedData[texelDataIndex * 4] = 1.0;\n            outputBufferTypedData[texelDataIndex * 4 + 1] = 1.0;\n            outputBufferTypedData[texelDataIndex * 4 + 2] = 0;\n          } else if (format === 'rgb10a2uint') {\n            const texelValue = 4 * texelDataIndex + 1;\n            const r = texelValue % 1024;\n            const g = (texelValue * 2) % 1024;\n            const b = (texelValue * 3) % 1024;\n            const a = 3;\n            const packedValue = (a << 30) | (b << 20) | (g << 10) | r;\n            const texelComponentIndex = texelDataIndex;\n            texelTypedDataView[texelComponentIndex] = packedValue;\n            outputBufferTypedData[texelDataIndex * 4] = r;\n            outputBufferTypedData[texelDataIndex * 4 + 1] = g;\n            outputBufferTypedData[texelDataIndex * 4 + 2] = b;\n            outputBufferTypedData[texelDataIndex * 4 + 3] = a;\n          } else {\n            for (let component = 0; component < componentCount; ++component) {\n              switch (format) {\n                case 'r32uint':\n                case 'rg32uint':\n                case 'rgba16uint':\n                case 'rgba32uint':\n                case 'r8uint':\n                case 'rg8uint':\n                case 'rgba8uint': {\n                  const texelValue = (4 * texelDataIndex + component + 1) % 256;\n                  setData(texelValue, texelValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r16uint':\n                case 'rg16uint': {\n                  const texelValue = (4 * texelDataIndex + component + 1) % 65536;\n                  setData(texelValue, texelValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r8unorm':\n                case 'rg8unorm':\n                case 'rgba8unorm': {\n                  const texelValue = (4 * texelDataIndex + component + 1) % 256;\n                  const outputValue = texelValue / 255.0;\n                  setData(texelValue, outputValue, texelDataIndex, component);\n                  break;\n                }\n                case 'bgra8unorm': {\n                  const texelValue = (4 * texelDataIndex + component + 1) % 256;\n                  const outputValue = texelValue / 255.0;\n                  // BGRA -> RGBA\n                  assert(component < 4);\n                  const outputComponent = [2, 1, 0, 3][component];\n                  setData(texelValue, outputValue, texelDataIndex, component, outputComponent);\n                  break;\n                }\n                case 'r16unorm':\n                case 'rg16unorm':\n                case 'rgba16unorm': {\n                  const texelValue = (4 * texelDataIndex + component + 1) % 65536;\n                  const outputValue = texelValue / 65535.0;\n                  setData(texelValue, outputValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r32sint':\n                case 'rg32sint':\n                case 'rgba16sint':\n                case 'rgba32sint': {\n                  const texelValue =\n                    (texelDataIndex & 1 ? 1 : -1) * (4 * texelDataIndex + component + 1);\n                  setData(texelValue, texelValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r8sint':\n                case 'rg8sint':\n                case 'rgba8sint': {\n                  const texelValue = ((4 * texelDataIndex + component + 1) % 256) - 128;\n                  setData(texelValue, texelValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r16sint':\n                case 'rg16sint': {\n                  const signedValue =\n                    (texelDataIndex & 1 ? 1 : -1) *\n                    (((4 * texelDataIndex + component + 1) % 65536) - 32768);\n                  setData(signedValue, signedValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r8snorm':\n                case 'rg8snorm':\n                case 'rgba8snorm': {\n                  const texelValue = ((4 * texelDataIndex + component + 1) % 256) - 128;\n                  const outputValue = Math.max(texelValue / 127.0, -1.0);\n                  setData(texelValue, outputValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r16snorm':\n                case 'rg16snorm':\n                case 'rgba16snorm': {\n                  const texelValue = ((4 * texelDataIndex + component + 1) % 65536) - 32768;\n                  const outputValue = Math.max(texelValue / 32767.0, -1.0);\n                  setData(texelValue, outputValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r32float':\n                case 'rg32float':\n                case 'rgba32float': {\n                  const texelValue = (4 * texelDataIndex + component + 1) / 10.0;\n                  setData(texelValue, texelValue, texelDataIndex, component);\n                  break;\n                }\n                case 'r16float':\n                case 'rg16float':\n                case 'rgba16float': {\n                  const texelValue = (4 * texelDataIndex + component + 1) / 10.0;\n                  const f16Array = new Float16Array(1);\n                  f16Array[0] = texelValue;\n                  setData(texelValue, f16Array[0], texelDataIndex, component);\n                  break;\n                }\n                default:\n                  unreachable();\n                  break;\n              }\n            }\n          }\n        }\n      }\n    }\n    this.queue.writeTexture(\n      {\n        texture: storageTexture,\n      },\n      texelData,\n      {\n        bytesPerRow: bytesPerBlock * width,\n        rowsPerImage: height,\n      },\n      [width, height, depthOrArrayLayers]\n    );\n\n    return outputBufferData;\n  }\n\n  getTypedArrayBufferForOutputBufferData(arrayBuffer: ArrayBuffer, format: ColorTextureFormat) {\n    switch (getTextureFormatType(format)) {\n      case 'uint':\n        return new Uint32Array(arrayBuffer);\n      case 'sint':\n        return new Int32Array(arrayBuffer);\n      case 'float':\n      case 'unfilterable-float':\n        return new Float32Array(arrayBuffer);\n      default:\n        unreachable();\n    }\n  }\n\n  getTypedArrayBufferViewForTexelData(arrayBuffer: ArrayBuffer, format: ColorTextureFormat) {\n    switch (format) {\n      case 'r32uint':\n      case 'rg32uint':\n      case 'rgba32uint':\n      case 'rgb10a2uint':\n      case 'rgb10a2unorm':\n        return new Uint32Array(arrayBuffer);\n      case 'rgba8uint':\n      case 'rgba8unorm':\n      case 'bgra8unorm':\n      case 'r8unorm':\n      case 'r8uint':\n      case 'rg8unorm':\n      case 'rg8uint':\n        return new Uint8Array(arrayBuffer);\n      case 'rgba16uint':\n      case 'r16unorm':\n      case 'rg16unorm':\n      case 'rgba16unorm':\n      case 'r16uint':\n      case 'rg16uint':\n        return new Uint16Array(arrayBuffer);\n      case 'r32sint':\n      case 'rg32sint':\n      case 'rgba32sint':\n      case 'rg11b10ufloat':\n        return new Int32Array(arrayBuffer);\n      case 'rgba8sint':\n      case 'rgba8snorm':\n      case 'r8snorm':\n      case 'r8sint':\n      case 'rg8snorm':\n      case 'rg8sint':\n        return new Int8Array(arrayBuffer);\n      case 'rgba16sint':\n      case 'r16snorm':\n      case 'rg16snorm':\n      case 'rgba16snorm':\n      case 'r16sint':\n      case 'rg16sint':\n        return new Int16Array(arrayBuffer);\n      case 'r32float':\n      case 'rg32float':\n      case 'rgba32float':\n        return new Float32Array(arrayBuffer);\n      case 'r16float':\n      case 'rg16float':\n      case 'rgba16float':\n        return new Float16Array(arrayBuffer);\n      default:\n        unreachable();\n        return new Uint8Array(arrayBuffer);\n    }\n  }\n\n  getOutputBufferWGSLType(format: ColorTextureFormat) {\n    switch (getTextureFormatType(format)) {\n      case 'uint':\n        return 'vec4u';\n      case 'sint':\n        return 'vec4i';\n      case 'float':\n      case 'unfilterable-float':\n        return 'vec4f';\n      default:\n        unreachable();\n        return '';\n    }\n  }\n\n  doTransform(\n    storageTexture: GPUTexture,\n    shaderStage: TValidShaderStage,\n    format: ColorTextureFormat,\n    outputBuffer: GPUBuffer\n  ) {\n    let declaration = '';\n    switch (storageTexture.dimension) {\n      case '1d':\n        declaration = 'texture_storage_1d';\n        break;\n      case '2d':\n        declaration =\n          storageTexture.depthOrArrayLayers > 1 ? 'texture_storage_2d_array' : 'texture_storage_2d';\n        break;\n      case '3d':\n        declaration = 'texture_storage_3d';\n        break;\n    }\n    const textureDeclaration = `\n    @group(0) @binding(0) var readOnlyTexture: ${declaration}<${format}, read>;\n    `;\n\n    const bindGroupEntries = [\n      {\n        binding: 0,\n        resource: storageTexture.createView(),\n      },\n      ...(shaderStage === 'compute'\n        ? [\n            {\n              binding: 1,\n              resource: {\n                buffer: outputBuffer,\n              },\n            },\n          ]\n        : []),\n    ];\n\n    const commandEncoder = this.device.createCommandEncoder();\n\n    switch (shaderStage) {\n      case 'compute': {\n        let textureLoadCoord = '';\n        switch (storageTexture.dimension) {\n          case '1d':\n            textureLoadCoord = 'invocationID.x';\n            break;\n          case '2d':\n            textureLoadCoord =\n              storageTexture.depthOrArrayLayers > 1\n                ? `vec2u(invocationID.x, invocationID.y), invocationID.z`\n                : `vec2u(invocationID.x, invocationID.y)`;\n            break;\n          case '3d':\n            textureLoadCoord = 'invocationID';\n            break;\n        }\n\n        const computeShader = `\n      ${textureDeclaration}\n      @group(0) @binding(1)\n      var<storage,read_write> outputBuffer : array<${this.getOutputBufferWGSLType(format)}>;\n\n      @compute\n      @workgroup_size(\n        ${storageTexture.width}, ${storageTexture.height}, ${storageTexture.depthOrArrayLayers})\n      fn main(\n        @builtin(local_invocation_id) invocationID: vec3u,\n        @builtin(local_invocation_index) invocationIndex: u32) {\n        let initialValue = textureLoad(readOnlyTexture, ${textureLoadCoord});\n        outputBuffer[invocationIndex] = initialValue;\n      }`;\n        const computePipeline = this.device.createComputePipeline({\n          compute: {\n            module: this.device.createShaderModule({\n              code: computeShader,\n            }),\n          },\n          layout: 'auto',\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(0),\n          entries: bindGroupEntries,\n        });\n\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, bindGroup);\n        computePassEncoder.dispatchWorkgroups(1);\n        computePassEncoder.end();\n        break;\n      }\n      case 'fragment': {\n        let textureLoadCoord = '';\n        switch (storageTexture.dimension) {\n          case '1d':\n            textureLoadCoord = 'textureCoord.x';\n            break;\n          case '2d':\n            textureLoadCoord =\n              storageTexture.depthOrArrayLayers > 1 ? 'textureCoord, coordZ' : 'textureCoord';\n            break;\n          case '3d':\n            textureLoadCoord = 'vec3u(textureCoord, coordZ)';\n            break;\n        }\n\n        const shader = `\n        ${textureDeclaration}\n        @fragment\n        fn fs(@builtin(position) fragCoord: vec4f) -> @location(0) vec4u {\n          let coordX = u32(fragCoord.x);\n          let coordY = u32(fragCoord.y) % ${storageTexture.height}u;\n          let coordZ = u32(fragCoord.y) / ${storageTexture.height}u;\n          let textureCoord = vec2u(coordX, coordY);\n          return bitcast<vec4u>(textureLoad(readOnlyTexture, ${textureLoadCoord}));\n        }\n\n        @vertex\n        fn vs(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f {\n            var pos = array(\n              vec2f(-1.0,  3.0),\n              vec2f( 3.0, -1.0),\n              vec2f(-1.0, -1.0));\n            return vec4f(pos[vertexIndex], 0.0, 1.0);\n        }\n        `;\n\n        const module = this.device.createShaderModule({\n          code: shader,\n        });\n        const renderPipeline = this.device.createRenderPipeline({\n          layout: 'auto',\n          vertex: { module },\n          fragment: { module, targets: [{ format: 'rgba32uint' }] },\n          primitive: { topology: 'triangle-list' },\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: bindGroupEntries,\n        });\n\n        // This is just so our buffer compare is the same as the compute stage.\n        // Otherwise, we'd have to pad every row to a multiple of 256 bytes and\n        // change the comparison code to take that into account.\n        assert(storageTexture.width === 16, `width must be 16 because we require 256 bytesPerRow`);\n        const placeholderColorTexture = this.createTextureTracked({\n          size: [storageTexture.width, storageTexture.height * storageTexture.depthOrArrayLayers],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n          format: 'rgba32uint',\n        });\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: placeholderColorTexture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        renderPassEncoder.draw(3);\n        renderPassEncoder.end();\n\n        commandEncoder.copyTextureToBuffer(\n          { texture: placeholderColorTexture },\n          {\n            buffer: outputBuffer,\n            bytesPerRow: 256,\n          },\n          placeholderColorTexture\n        );\n        break;\n      }\n      case 'vertex': {\n        // We draw storageTexture.Width by (storageTexture.height * storageTexture.depthOrArrayLayers)\n        // points via 'point-list' to a placeholderColorTexture of the same size.\n        //\n        // We use the @builtin(vertex_index) to compute a coord in the source texture\n        // and use that same coord to compute a place to render in the point in the placeholder.\n        let loadFromTextureWGSL = '';\n        switch (storageTexture.dimension) {\n          case '1d':\n            loadFromTextureWGSL = `\n              output.vertex_out = textureLoad(readOnlyTexture, coordX);`;\n            break;\n          case '2d':\n            if (storageTexture.depthOrArrayLayers === 1) {\n              loadFromTextureWGSL = `\n                output.vertex_out = textureLoad(readOnlyTexture, vec2u(coordX, coordY));`;\n            } else {\n              loadFromTextureWGSL = loadFromTextureWGSL.concat(`\n                output.vertex_out =\n                  textureLoad(readOnlyTexture, vec2u(coordX, coordY), coordZ);`);\n            }\n            break;\n          case '3d':\n            loadFromTextureWGSL = loadFromTextureWGSL.concat(`\n              output.vertex_out = textureLoad(readOnlyTexture, vec3u(coordX, coordY, coordZ));`);\n            break;\n        }\n\n        let outputToBufferWGSL = '';\n        for (let layer = 0; layer < storageTexture.depthOrArrayLayers; ++layer) {\n          outputToBufferWGSL = outputToBufferWGSL.concat(\n            `\n            let outputIndex${layer} =\n              storageTextureTexelCountPerImage * ${layer}u +\n              fragmentInput.tex_coord.y * ${storageTexture.width}u + fragmentInput.tex_coord.x;\n            outputBuffer[outputIndex${layer}] = fragmentInput.vertex_out${layer};`\n          );\n        }\n\n        const shader = `\n        ${textureDeclaration}\n        struct VertexOutput {\n          @builtin(position) my_pos: vec4f,\n          @location(0) @interpolate(flat, either)\n            vertex_out: ${this.getOutputBufferWGSLType(format)},\n        }\n        @vertex\n        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n            var output : VertexOutput;\n            let coordX = vertexIndex % ${storageTexture.width}u;\n            let coordY = vertexIndex / ${storageTexture.width}u % ${storageTexture.height}u;\n            let coordZ = vertexIndex / ${storageTexture.width * storageTexture.height}u;\n            let writePos = vec2f(f32(coordX), f32(coordY + coordZ * ${storageTexture.height}));\n            let destSize = vec2f(\n              ${storageTexture.width},\n              ${storageTexture.height * storageTexture.depthOrArrayLayers});\n            output.my_pos = vec4f((((writePos + 0.5) / destSize) * 2.0 - 1.0) * vec2f(1, -1), 0.0, 1.0);\n            ${loadFromTextureWGSL}\n            return output;\n        }\n        @fragment\n        fn fs_main(fragmentInput : VertexOutput) -> @location(0) vec4u {\n          let v = fragmentInput.vertex_out;\n          return bitcast<vec4u>(v);\n        }\n        `;\n\n        const module = this.device.createShaderModule({ code: shader });\n        const renderPipeline = this.device.createRenderPipeline({\n          layout: 'auto',\n          vertex: { module },\n          fragment: { module, targets: [{ format: 'rgba32uint' }] },\n          primitive: { topology: 'point-list' },\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: bindGroupEntries,\n        });\n\n        const placeholderColorTexture = this.createTextureTracked({\n          size: [storageTexture.width, storageTexture.height * storageTexture.depthOrArrayLayers],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n          format: 'rgba32uint',\n        });\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: placeholderColorTexture.createView(),\n              loadOp: 'clear',\n              clearValue: { r: 0, g: 0, b: 0, a: 0 },\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        const texelCount =\n          storageTexture.width * storageTexture.height * storageTexture.depthOrArrayLayers;\n        renderPassEncoder.draw(texelCount);\n        renderPassEncoder.end();\n\n        commandEncoder.copyTextureToBuffer(\n          { texture: placeholderColorTexture },\n          {\n            buffer: outputBuffer,\n            bytesPerRow: 256,\n          },\n          placeholderColorTexture\n        );\n        break;\n      }\n    }\n\n    this.queue.submit([commandEncoder.finish()]);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic')\n  .desc(\n    `The basic functionality tests for read-only storage textures. In the test we read data from\n    the read-only storage texture, write the data into an output storage buffer, and check if the\n    data in the output storage buffer is exactly what we expect.`\n  )\n  .params(u =>\n    u\n      .combine('format', kPossibleStorageTextureFormats)\n      .combine('shaderStage', kValidShaderStages)\n      .combine('dimension', kTextureDimensions)\n      .combine('depthOrArrayLayers', [1, 2] as const)\n      .unless(p => p.dimension === '1d' && p.depthOrArrayLayers > 1)\n  )\n  .fn(t => {\n    const { format, shaderStage, dimension, depthOrArrayLayers } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotUsableWithStorageAccessMode('read-only', format);\n\n    if (t.isCompatibility) {\n      if (shaderStage === 'fragment') {\n        t.skipIf(\n          !(t.device.limits.maxStorageTexturesInFragmentStage! > 0),\n          `maxStorageTexturesInFragmentStage(${t.device.limits\n            .maxStorageTexturesInFragmentStage!}) is not > 0`\n        );\n      } else if (shaderStage === 'vertex') {\n        t.skipIf(\n          !(t.device.limits.maxStorageTexturesInVertexStage! > 0),\n          `maxStorageTexturesInVertexStage(${t.device.limits\n            .maxStorageTexturesInVertexStage!}) is not > 0`\n        );\n      }\n    }\n\n    const kWidth = 16;\n    const height = dimension === '1d' ? 1 : 8;\n    const storageTexture = t.createTextureTracked({\n      format,\n      dimension,\n      size: [kWidth, height, depthOrArrayLayers],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    const expectedData = t.initTextureAndGetExpectedOutputBufferData(storageTexture, format);\n\n    const bytesPerRow = 4 * 4 * kWidth;\n    assert(bytesPerRow === 256, 'bytesPerRow === 256');\n    const outputBuffer = t.createBufferTracked({\n      size: bytesPerRow * height * depthOrArrayLayers,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    t.doTransform(storageTexture, shaderStage, format, outputBuffer);\n\n    switch (getTextureFormatType(format)) {\n      case 'uint':\n        t.expectGPUBufferValuesEqual(outputBuffer, new Uint32Array(expectedData));\n        break;\n      case 'sint':\n        t.expectGPUBufferValuesEqual(outputBuffer, new Int32Array(expectedData));\n        break;\n      case 'float':\n      case 'unfilterable-float':\n        t.expectGPUBufferValuesEqual(outputBuffer, new Float32Array(expectedData));\n        break;\n      default:\n        unreachable();\n        break;\n    }\n  });\n"],"mappings":"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"}