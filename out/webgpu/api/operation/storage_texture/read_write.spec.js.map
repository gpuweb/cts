{"version":3,"file":"read_write.spec.js","names":["description","makeTestGroup","assert","unreachable","kTextureDimensions","getBlockInfoForColorTextureFormat","getBlockInfoForTextureFormat","kPossibleStorageTextureFormats","AllFeaturesMaxLimitsGPUTest","align","kShaderStagesForReadWriteStorageTexture","F","getInitialData","storageTexture","format","bytesPerBlock","undefined","width","height","depthOrArrayLayers","initialData","ArrayBuffer","initialTypedData","getTypedArrayBuffer","z","y","x","index","arrayBuffer","Int32Array","Uint32Array","Float32Array","Uint8Array","getExpectedData","shaderStage","bytesPerRowAlignment","itemsPerRow","expectedData","expectedTypedData","expectedIndex","initialIndex","recordCommandsToTransform","device","commandEncoder","rwTexture","declaration","dimension","textureDeclaration","vertexShader","textureLoadStoreCoord","fragmentShader","renderPipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","fragment","targets","primitive","topology","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","placeholderColorTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","renderPassEncoder","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","setPipeline","setBindGroup","draw","end","textureLoadCoord","textureStoreCoord","computeShader","computePipeline","createComputePipeline","compute","computePassEncoder","beginComputePass","dispatchWorkgroups","test","desc","params","u","combine","unless","p","textureDimension","fn","t","skipIfTextureFormatNotSupported","skipIfTextureFormatNotUsableAsReadWriteStorageTexture","isCompatibility","skipIf","limits","maxStorageTexturesInFragmentStage","kWidth","textureSize","COPY_SRC","COPY_DST","STORAGE_BINDING","queue","writeTexture","texture","bytesPerRow","rowsPerImage","createCommandEncoder","readbackBuffer","createBufferTracked","byteLength","GPUBufferUsage","copyTextureToBuffer","buffer","submit","finish","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/storage_texture/read_write.spec.ts"],"sourcesContent":["export const description = `\nTests for the behavior of read-write storage textures.\n\nTODO:\n- Test resource usage transitions with read-write storage textures\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { kTextureDimensions } from '../../../capability_info.js';\nimport {\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForTextureFormat,\n  kPossibleStorageTextureFormats,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kShaderStagesForReadWriteStorageTexture = ['fragment', 'compute'] as const;\ntype ShaderStageForReadWriteStorageTexture =\n  (typeof kShaderStagesForReadWriteStorageTexture)[number];\n\nclass F extends AllFeaturesMaxLimitsGPUTest {\n  getInitialData(storageTexture: GPUTexture): ArrayBuffer {\n    const format = storageTexture.format;\n    const { bytesPerBlock } = getBlockInfoForTextureFormat(format);\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const initialData = new ArrayBuffer(bytesPerBlock * width * height * depthOrArrayLayers);\n    const initialTypedData = this.getTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const index = z * width * height + y * width + x;\n          switch (format) {\n            case 'r32sint':\n              initialTypedData[index] = (index & 1 ? 1 : -1) * (2 * index + 1);\n              break;\n            case 'r32uint':\n              initialTypedData[index] = 2 * index + 1;\n              break;\n            case 'r32float':\n              initialTypedData[index] = (2 * index + 1) / 10.0;\n              break;\n          }\n        }\n      }\n    }\n    return initialData;\n  }\n\n  getTypedArrayBuffer(arrayBuffer: ArrayBuffer, format: GPUTextureFormat) {\n    switch (format) {\n      case 'r32sint':\n        return new Int32Array(arrayBuffer);\n      case 'r32uint':\n        return new Uint32Array(arrayBuffer);\n      case 'r32float':\n        return new Float32Array(arrayBuffer);\n      default:\n        unreachable();\n        return new Uint8Array(arrayBuffer);\n    }\n  }\n\n  getExpectedData(\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    storageTexture: GPUTexture,\n    initialData: ArrayBuffer\n  ): ArrayBuffer {\n    const format = storageTexture.format;\n    const { bytesPerBlock } = getBlockInfoForTextureFormat(format);\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const bytesPerRowAlignment = align(bytesPerBlock * width, 256);\n    const itemsPerRow = bytesPerRowAlignment / bytesPerBlock;\n\n    const expectedData = new ArrayBuffer(\n      bytesPerRowAlignment * (height * depthOrArrayLayers - 1) + bytesPerBlock * width\n    );\n    const expectedTypedData = this.getTypedArrayBuffer(expectedData, format);\n    const initialTypedData = this.getTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const expectedIndex = z * itemsPerRow * height + y * itemsPerRow + x;\n          switch (shaderStage) {\n            case 'compute': {\n              // In the compute shader we flip the texture along the diagonal.\n              const initialIndex =\n                (depthOrArrayLayers - 1 - z) * width * height +\n                (height - 1 - y) * width +\n                (width - 1 - x);\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex];\n              break;\n            }\n            case 'fragment': {\n              // In the fragment shader we double the original texel value of the read-write storage\n              // texture.\n              const initialIndex = z * width * height + y * width + x;\n              expectedTypedData[expectedIndex] = initialTypedData[initialIndex] * 2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return expectedData;\n  }\n\n  recordCommandsToTransform(\n    device: GPUDevice,\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    commandEncoder: GPUCommandEncoder,\n    rwTexture: GPUTexture\n  ) {\n    let declaration = '';\n    switch (rwTexture.dimension) {\n      case '1d':\n        declaration = 'texture_storage_1d';\n        break;\n      case '2d':\n        declaration =\n          rwTexture.depthOrArrayLayers > 1 ? 'texture_storage_2d_array' : 'texture_storage_2d';\n        break;\n      case '3d':\n        declaration = 'texture_storage_3d';\n        break;\n    }\n    const textureDeclaration = `\n    @group(0) @binding(0) var rwTexture: ${declaration}<${rwTexture.format}, read_write>;\n    `;\n\n    switch (shaderStage) {\n      case 'fragment': {\n        const vertexShader = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4f {\n            var pos = array(\n              vec2f(-1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f( 1.0,  1.0));\n            return vec4f(pos[VertexIndex], 0.0, 1.0);\n        }\n        `;\n        let textureLoadStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadStoreCoord = 'textureCoord.x';\n            break;\n          case '2d':\n            textureLoadStoreCoord =\n              rwTexture.depthOrArrayLayers > 1 ? 'textureCoord, z' : 'textureCoord';\n            break;\n          case '3d':\n            textureLoadStoreCoord = 'vec3u(textureCoord, z)';\n            break;\n        }\n        const fragmentShader = `\n        ${textureDeclaration}\n        @fragment\n        fn main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {\n          let textureCoord = vec2u(fragCoord.xy);\n\n          for (var z = 0u; z < ${rwTexture.depthOrArrayLayers}; z++) {\n            let initialValue = textureLoad(rwTexture, ${textureLoadStoreCoord});\n            let outputValue = initialValue * 2;\n            textureStore(rwTexture, ${textureLoadStoreCoord}, outputValue);\n          }\n\n          return vec4f(0.0, 1.0, 0.0, 1.0);\n        }\n        `;\n        const renderPipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: {\n            module: device.createShaderModule({\n              code: vertexShader,\n            }),\n          },\n          fragment: {\n            module: device.createShaderModule({\n              code: fragmentShader,\n            }),\n            targets: [\n              {\n                format: 'rgba8unorm',\n              },\n            ],\n          },\n          primitive: {\n            topology: 'triangle-list',\n          },\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n\n        const placeholderColorTexture = this.createTextureTracked({\n          size: [rwTexture.width, rwTexture.height, 1],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          format: 'rgba8unorm',\n        });\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: placeholderColorTexture.createView(),\n              loadOp: 'clear',\n              clearValue: { r: 0, g: 0, b: 0, a: 0 },\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        renderPassEncoder.draw(6);\n        renderPassEncoder.end();\n        break;\n      }\n      case 'compute': {\n        let textureLoadCoord = '';\n        let textureStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadCoord = 'dimension - 1u - invocationID.x';\n            textureStoreCoord = 'invocationID.x';\n            break;\n          case '2d':\n            textureLoadCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y),\n                   textureNumLayers(rwTexture) - 1u - invocationID.z`\n                : `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y)`;\n            textureStoreCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? 'invocationID.xy, invocationID.z'\n                : 'invocationID.xy';\n            break;\n          case '3d':\n            textureLoadCoord = `\n              vec3u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y,\n                    dimension.z - 1u - invocationID.z)`;\n            textureStoreCoord = 'invocationID';\n            break;\n        }\n\n        const computeShader = `\n        ${textureDeclaration}\n        @compute\n        @workgroup_size(${rwTexture.width}, ${rwTexture.height}, ${rwTexture.depthOrArrayLayers})\n        fn main(@builtin(local_invocation_id) invocationID: vec3u) {\n          let dimension = textureDimensions(rwTexture);\n\n          let initialValue = textureLoad(rwTexture, ${textureLoadCoord});\n          textureBarrier();\n\n          textureStore(rwTexture, ${textureStoreCoord}, initialValue);\n        }`;\n\n        const computePipeline = device.createComputePipeline({\n          compute: {\n            module: device.createShaderModule({\n              code: computeShader,\n            }),\n          },\n          layout: 'auto',\n        });\n        const bindGroup = device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, bindGroup);\n        computePassEncoder.dispatchWorkgroups(1);\n        computePassEncoder.end();\n        break;\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic')\n  .desc(\n    `The basic functionality tests for read-write storage textures. In the test we read data from\n    the read-write storage texture, do transforms and write the data back to the read-write storage\n    texture. textureBarrier() is also called in the tests using compute pipelines.`\n  )\n  .params(u =>\n    u\n      .combine('format', kPossibleStorageTextureFormats)\n      .combine('shaderStage', kShaderStagesForReadWriteStorageTexture)\n      .combine('textureDimension', kTextureDimensions)\n      .combine('depthOrArrayLayers', [1, 2] as const)\n      .unless(p => p.textureDimension === '1d' && p.depthOrArrayLayers > 1)\n  )\n  .fn(t => {\n    const { format, shaderStage, textureDimension, depthOrArrayLayers } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotUsableAsReadWriteStorageTexture(format);\n\n    if (t.isCompatibility) {\n      if (shaderStage === 'fragment') {\n        t.skipIf(\n          !(t.device.limits.maxStorageTexturesInFragmentStage! > 0),\n          `maxStorageTexturesInFragmentStage(${t.device.limits\n            .maxStorageTexturesInFragmentStage!}) is not > 0`\n        );\n      }\n    }\n\n    // In compatibility mode the lowest maxComputeInvocationsPerWorkgroup is 128 vs non-compat which is 256\n    // So in non-compat we get 16 * 8 * 2, vs compat where we get 8 * 8 * 2\n    const kWidth = t.isCompatibility ? 8 : 16;\n    const height = textureDimension === '1d' ? 1 : 8;\n    const textureSize = [kWidth, height, depthOrArrayLayers] as const;\n    const storageTexture = t.createTextureTracked({\n      format,\n      dimension: textureDimension,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    const { bytesPerBlock } = getBlockInfoForColorTextureFormat(format);\n    const initialData = t.getInitialData(storageTexture);\n    t.queue.writeTexture(\n      { texture: storageTexture },\n      initialData,\n      {\n        bytesPerRow: bytesPerBlock * kWidth,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n\n    const commandEncoder = t.device.createCommandEncoder();\n\n    t.recordCommandsToTransform(t.device, shaderStage, commandEncoder, storageTexture);\n\n    const expectedData = t.getExpectedData(shaderStage, storageTexture, initialData);\n    const readbackBuffer = t.createBufferTracked({\n      size: expectedData.byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const bytesPerRow = align(bytesPerBlock * kWidth, 256);\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: storageTexture,\n      },\n      {\n        buffer: readbackBuffer,\n        bytesPerRow,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n    t.queue.submit([commandEncoder.finish()]);\n\n    switch (format) {\n      case 'r32sint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Int32Array(expectedData));\n        break;\n      case 'r32uint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Uint32Array(expectedData));\n        break;\n      case 'r32float':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Float32Array(expectedData));\n        break;\n    }\n  });\n"],"mappings":"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"}