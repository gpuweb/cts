{"version":3,"file":"read_write.spec.js","names":["description","makeTestGroup","assert","unreachable","Float16Array","kTextureDimensions","getBlockInfoForColorTextureFormat","getBlockInfoForTextureFormat","getTextureFormatType","kPossibleStorageTextureFormats","AllFeaturesMaxLimitsGPUTest","align","kShaderStagesForReadWriteStorageTexture","F","getInitialData","storageTexture","format","bytesPerBlock","undefined","width","height","depthOrArrayLayers","initialData","ArrayBuffer","initialTypedData","getTypedArrayBuffer","z","y","x","index","baseValue","arrayBuffer","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Uint32Array","Float32Array","getExpectedData","shaderStage","bytesPerRowAlignment","itemsPerRow","expectedData","expectedTypedData","getFormatRange","fmt","min","max","Infinity","isRGBAChannel","startsWith","expectedIndex","initialIndex","c","value","Math","recordCommandsToTransform","device","commandEncoder","rwTexture","declaration","dimension","textureDeclaration","vertexShader","textureLoadStoreCoord","fragmentShader","renderPipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","fragment","targets","primitive","topology","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","placeholderColorTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","renderPassEncoder","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","setPipeline","setBindGroup","draw","end","textureLoadCoord","textureStoreCoord","computeShader","computePipeline","createComputePipeline","compute","computePassEncoder","beginComputePass","dispatchWorkgroups","test","desc","params","u","combine","unless","p","textureDimension","fn","t","skipIfTextureFormatNotSupported","skipIfTextureFormatNotUsableWithStorageAccessMode","isCompatibility","skipIf","limits","maxStorageTexturesInFragmentStage","kWidth","textureSize","COPY_SRC","COPY_DST","STORAGE_BINDING","queue","writeTexture","texture","bytesPerRow","rowsPerImage","createCommandEncoder","readbackBuffer","createBufferTracked","byteLength","GPUBufferUsage","copyTextureToBuffer","buffer","submit","finish","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/storage_texture/read_write.spec.ts"],"sourcesContent":["export const description = `\nTests for the behavior of read-write storage textures.\n\nTODO:\n- Test resource usage transitions with read-write storage textures\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { Float16Array } from '../../../../external/petamoriken/float16/float16.js';\nimport { kTextureDimensions } from '../../../capability_info.js';\nimport {\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForTextureFormat,\n  getTextureFormatType,\n  kPossibleStorageTextureFormats,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kShaderStagesForReadWriteStorageTexture = ['fragment', 'compute'] as const;\ntype ShaderStageForReadWriteStorageTexture =\n  (typeof kShaderStagesForReadWriteStorageTexture)[number];\n\nclass F extends AllFeaturesMaxLimitsGPUTest {\n  getInitialData(storageTexture: GPUTexture): ArrayBuffer {\n    const format = storageTexture.format;\n    const { bytesPerBlock } = getBlockInfoForTextureFormat(format);\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const initialData = new ArrayBuffer(bytesPerBlock * width * height * depthOrArrayLayers);\n    const initialTypedData = this.getTypedArrayBuffer(initialData, format);\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const index = z * width * height + y * width + x;\n          const baseValue = 2 * index + 1;\n          switch (format) {\n            case 'r8unorm':\n            case 'r8uint':\n              initialTypedData[index] = baseValue % 256;\n              break;\n            case 'r8sint':\n              initialTypedData[index] = (baseValue % 256) - 128;\n              break;\n            case 'rgba8unorm':\n            case 'rgba8uint':\n              initialTypedData[index * 4 + 0] = (baseValue * 1) % 256; // R\n              initialTypedData[index * 4 + 1] = (baseValue * 2) % 256; // G\n              initialTypedData[index * 4 + 2] = (baseValue * 3) % 256; // B\n              initialTypedData[index * 4 + 3] = 255;\n              break;\n            case 'rgba8sint':\n              initialTypedData[index * 4 + 0] = ((baseValue * 1) % 256) - 128; // R\n              initialTypedData[index * 4 + 1] = ((baseValue * 2) % 256) - 128; // G\n              initialTypedData[index * 4 + 2] = ((baseValue * 3) % 256) - 128; // B\n              initialTypedData[index * 4 + 3] = 127;\n              break;\n            case 'r16uint':\n              initialTypedData[index] = baseValue % 65536;\n              break;\n            case 'r16sint':\n              initialTypedData[index] = (baseValue % 65536) - 32768;\n              break;\n            case 'r16float':\n              initialTypedData[index] = baseValue;\n              break;\n            case 'rgba16uint':\n              initialTypedData[index * 4 + 0] = (baseValue * 1) % 65536; // R\n              initialTypedData[index * 4 + 1] = (baseValue * 2) % 65536; // G\n              initialTypedData[index * 4 + 2] = (baseValue * 3) % 65536; // B\n              initialTypedData[index * 4 + 3] = 65535;\n              break;\n            case 'rgba16sint':\n              initialTypedData[index * 4 + 0] = ((baseValue * 1) % 65536) - 32768; // R\n              initialTypedData[index * 4 + 1] = ((baseValue * 2) % 65536) - 32768; // G\n              initialTypedData[index * 4 + 2] = ((baseValue * 3) % 65536) - 32768; // B\n              initialTypedData[index * 4 + 3] = 32767;\n              break;\n            case 'rgba16float':\n              initialTypedData[index * 4 + 0] = baseValue * 1; // R\n              initialTypedData[index * 4 + 1] = baseValue * 2; // G\n              initialTypedData[index * 4 + 2] = baseValue * 3; // B\n              initialTypedData[index * 4 + 3] = 1.0;\n              break;\n            case 'r32sint':\n              initialTypedData[index] = (index & 1 ? 1 : -1) * baseValue;\n              break;\n            case 'r32uint':\n              initialTypedData[index] = baseValue;\n              break;\n            case 'r32float':\n              initialTypedData[index] = baseValue / 10.0;\n              break;\n            case 'rgba32uint':\n              initialTypedData[index * 4 + 0] = baseValue * 1; // R\n              initialTypedData[index * 4 + 1] = baseValue * 2; // G\n              initialTypedData[index * 4 + 2] = baseValue * 3; // B\n              initialTypedData[index * 4 + 3] = baseValue;\n              break;\n            case 'rgba32sint':\n              initialTypedData[index * 4 + 0] = (index & 1 ? 1 : -1) * baseValue * 1; // R\n              initialTypedData[index * 4 + 1] = (index & 1 ? 1 : -1) * baseValue * 2; // G\n              initialTypedData[index * 4 + 2] = (index & 1 ? 1 : -1) * baseValue * 3; // B\n              initialTypedData[index * 4 + 3] = baseValue;\n              break;\n            case 'rgba32float':\n              initialTypedData[index * 4 + 0] = (baseValue * 1) / 10.0; // R\n              initialTypedData[index * 4 + 1] = (baseValue * 2) / 10.0; // G\n              initialTypedData[index * 4 + 2] = (baseValue * 3) / 10.0; // B\n              initialTypedData[index * 4 + 3] = 1.0;\n              break;\n          }\n        }\n      }\n    }\n    return initialData;\n  }\n\n  getTypedArrayBuffer(arrayBuffer: ArrayBuffer, format: GPUTextureFormat) {\n    switch (format) {\n      case 'r8unorm':\n      case 'r8uint':\n      case 'rgba8unorm':\n      case 'rgba8uint':\n        return new Uint8Array(arrayBuffer);\n      case 'r8sint':\n      case 'rgba8sint':\n        return new Int8Array(arrayBuffer);\n      case 'r16uint':\n      case 'rgba16uint':\n        return new Uint16Array(arrayBuffer);\n      case 'r16sint':\n      case 'rgba16sint':\n        return new Int16Array(arrayBuffer);\n      case 'r16float':\n      case 'rgba16float':\n        return new Float16Array(arrayBuffer);\n      case 'r32sint':\n      case 'rgba32sint':\n        return new Int32Array(arrayBuffer);\n      case 'r32uint':\n      case 'rgba32uint':\n        return new Uint32Array(arrayBuffer);\n      case 'r32float':\n      case 'rgba32float':\n        return new Float32Array(arrayBuffer);\n      default:\n        unreachable();\n        return new Uint8Array(arrayBuffer);\n    }\n  }\n\n  getExpectedData(\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    storageTexture: GPUTexture,\n    initialData: ArrayBuffer\n  ): ArrayBuffer {\n    const format = storageTexture.format;\n    const { bytesPerBlock } = getBlockInfoForTextureFormat(format);\n    assert(bytesPerBlock !== undefined);\n\n    const width = storageTexture.width;\n    const height = storageTexture.height;\n    const depthOrArrayLayers = storageTexture.depthOrArrayLayers;\n    const bytesPerRowAlignment = align(bytesPerBlock * width, 256);\n    const itemsPerRow = bytesPerRowAlignment / bytesPerBlock;\n\n    const expectedData = new ArrayBuffer(\n      bytesPerRowAlignment * (height * depthOrArrayLayers - 1) + bytesPerBlock * width\n    );\n    const expectedTypedData = this.getTypedArrayBuffer(expectedData, format);\n    const initialTypedData = this.getTypedArrayBuffer(initialData, format);\n\n    const getFormatRange = (fmt: GPUTextureFormat) => {\n      switch (fmt) {\n        case 'r8uint':\n        case 'r8unorm':\n        case 'rgba8unorm':\n          return { min: 0, max: 255 };\n        case 'r8sint':\n          return { min: -128, max: 127 };\n        case 'rgba8uint':\n          return { min: 0, max: 255 };\n        case 'rgba8sint':\n          return { min: -128, max: 127 };\n        case 'r16uint':\n          return { min: 0, max: 65535 };\n        case 'r16sint':\n          return { min: -32768, max: 32767 };\n        case 'rgba16uint':\n          return { min: 0, max: 65535 };\n        case 'rgba16sint':\n          return { min: -32768, max: 32767 };\n        case 'r32uint':\n          return { min: 0, max: 4294967295 };\n        case 'r32sint':\n          return { min: -2147483648, max: 2147483647 };\n        case 'rgba32uint':\n          return { min: 0, max: 4294967295 };\n        case 'rgba32sint':\n          return { min: -2147483648, max: 2147483647 };\n        case 'r16float':\n          return { min: -65504, max: 65504 };\n        case 'rgba16float':\n          return { min: -65504, max: 65504 };\n        default:\n          return { min: -Infinity, max: Infinity };\n      }\n    };\n\n    const isRGBAChannel = format.startsWith('rgba');\n\n    const { min, max } = getFormatRange(format);\n\n    for (let z = 0; z < depthOrArrayLayers; ++z) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const expectedIndex = z * itemsPerRow * height + y * itemsPerRow + x;\n          switch (shaderStage) {\n            case 'compute': {\n              // In the compute shader we flip the texture along the diagonal.\n              const initialIndex =\n                (depthOrArrayLayers - 1 - z) * width * height +\n                (height - 1 - y) * width +\n                (width - 1 - x);\n              if (isRGBAChannel) {\n                for (let c = 0; c < 4; c++) {\n                  expectedTypedData[expectedIndex * 4 + c] = initialTypedData[initialIndex * 4 + c];\n                }\n              } else {\n                expectedTypedData[expectedIndex] = initialTypedData[initialIndex];\n              }\n              break;\n            }\n            case 'fragment': {\n              // In the fragment shader we double the original texel value of the read-write storage\n              // texture.\n              const initialIndex = z * width * height + y * width + x;\n              if (isRGBAChannel) {\n                for (let c = 0; c < 4; c++) {\n                  let value = initialTypedData[initialIndex * 4 + c] * 2;\n                  value = Math.max(min, Math.min(max, value));\n                  expectedTypedData[expectedIndex * 4 + c] = value;\n                }\n              } else {\n                let value = initialTypedData[initialIndex] * 2;\n                value = Math.max(min, Math.min(max, value));\n                expectedTypedData[expectedIndex] = value;\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    return expectedData;\n  }\n\n  recordCommandsToTransform(\n    device: GPUDevice,\n    shaderStage: ShaderStageForReadWriteStorageTexture,\n    commandEncoder: GPUCommandEncoder,\n    rwTexture: GPUTexture\n  ) {\n    let declaration = '';\n    switch (rwTexture.dimension) {\n      case '1d':\n        declaration = 'texture_storage_1d';\n        break;\n      case '2d':\n        declaration =\n          rwTexture.depthOrArrayLayers > 1 ? 'texture_storage_2d_array' : 'texture_storage_2d';\n        break;\n      case '3d':\n        declaration = 'texture_storage_3d';\n        break;\n    }\n    const textureDeclaration = `\n    @group(0) @binding(0) var rwTexture: ${declaration}<${rwTexture.format}, read_write>;\n    `;\n\n    switch (shaderStage) {\n      case 'fragment': {\n        const vertexShader = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4f {\n            var pos = array(\n              vec2f(-1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f(-1.0,  1.0),\n              vec2f( 1.0, -1.0),\n              vec2f( 1.0,  1.0));\n            return vec4f(pos[VertexIndex], 0.0, 1.0);\n        }\n        `;\n        let textureLoadStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadStoreCoord = 'textureCoord.x';\n            break;\n          case '2d':\n            textureLoadStoreCoord =\n              rwTexture.depthOrArrayLayers > 1 ? 'textureCoord, z' : 'textureCoord';\n            break;\n          case '3d':\n            textureLoadStoreCoord = 'vec3u(textureCoord, z)';\n            break;\n        }\n        const fragmentShader = `\n        ${textureDeclaration}\n        @fragment\n        fn main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {\n          let textureCoord = vec2u(fragCoord.xy);\n\n          for (var z = 0u; z < ${rwTexture.depthOrArrayLayers}; z++) {\n            let initialValue = textureLoad(rwTexture, ${textureLoadStoreCoord});\n            let outputValue = initialValue * 2;\n            textureStore(rwTexture, ${textureLoadStoreCoord}, outputValue);\n          }\n\n          return vec4f(0.0, 1.0, 0.0, 1.0);\n        }\n        `;\n        const renderPipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: {\n            module: device.createShaderModule({\n              code: vertexShader,\n            }),\n          },\n          fragment: {\n            module: device.createShaderModule({\n              code: fragmentShader,\n            }),\n            targets: [\n              {\n                format: 'rgba8unorm',\n              },\n            ],\n          },\n          primitive: {\n            topology: 'triangle-list',\n          },\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout: renderPipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n\n        const placeholderColorTexture = this.createTextureTracked({\n          size: [rwTexture.width, rwTexture.height, 1],\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n          format: 'rgba8unorm',\n        });\n\n        const renderPassEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: placeholderColorTexture.createView(),\n              loadOp: 'clear',\n              clearValue: { r: 0, g: 0, b: 0, a: 0 },\n              storeOp: 'store',\n            },\n          ],\n        });\n        renderPassEncoder.setPipeline(renderPipeline);\n        renderPassEncoder.setBindGroup(0, bindGroup);\n        renderPassEncoder.draw(6);\n        renderPassEncoder.end();\n        break;\n      }\n      case 'compute': {\n        let textureLoadCoord = '';\n        let textureStoreCoord = '';\n        switch (rwTexture.dimension) {\n          case '1d':\n            textureLoadCoord = 'dimension - 1u - invocationID.x';\n            textureStoreCoord = 'invocationID.x';\n            break;\n          case '2d':\n            textureLoadCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y),\n                   textureNumLayers(rwTexture) - 1u - invocationID.z`\n                : `vec2u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y)`;\n            textureStoreCoord =\n              rwTexture.depthOrArrayLayers > 1\n                ? 'invocationID.xy, invocationID.z'\n                : 'invocationID.xy';\n            break;\n          case '3d':\n            textureLoadCoord = `\n              vec3u(dimension.x - 1u - invocationID.x, dimension.y - 1u - invocationID.y,\n                    dimension.z - 1u - invocationID.z)`;\n            textureStoreCoord = 'invocationID';\n            break;\n        }\n\n        const computeShader = `\n        ${textureDeclaration}\n        @compute\n        @workgroup_size(${rwTexture.width}, ${rwTexture.height}, ${rwTexture.depthOrArrayLayers})\n        fn main(@builtin(local_invocation_id) invocationID: vec3u) {\n          let dimension = textureDimensions(rwTexture);\n\n          let initialValue = textureLoad(rwTexture, ${textureLoadCoord});\n          textureBarrier();\n\n          textureStore(rwTexture, ${textureStoreCoord}, initialValue);\n        }`;\n\n        const computePipeline = device.createComputePipeline({\n          compute: {\n            module: device.createShaderModule({\n              code: computeShader,\n            }),\n          },\n          layout: 'auto',\n        });\n        const bindGroup = device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(0),\n          entries: [\n            {\n              binding: 0,\n              resource: rwTexture.createView(),\n            },\n          ],\n        });\n        const computePassEncoder = commandEncoder.beginComputePass();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.setBindGroup(0, bindGroup);\n        computePassEncoder.dispatchWorkgroups(1);\n        computePassEncoder.end();\n        break;\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic')\n  .desc(\n    `The basic functionality tests for read-write storage textures. In the test we read data from\n    the read-write storage texture, do transforms and write the data back to the read-write storage\n    texture. textureBarrier() is also called in the tests using compute pipelines.`\n  )\n  .params(u =>\n    u\n      .combine('format', kPossibleStorageTextureFormats)\n      .combine('shaderStage', kShaderStagesForReadWriteStorageTexture)\n      .combine('textureDimension', kTextureDimensions)\n      .combine('depthOrArrayLayers', [1, 2] as const)\n      .unless(p => p.textureDimension === '1d' && p.depthOrArrayLayers > 1)\n  )\n  .fn(t => {\n    const { format, shaderStage, textureDimension, depthOrArrayLayers } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotUsableWithStorageAccessMode('read-write', format);\n\n    if (t.isCompatibility) {\n      if (shaderStage === 'fragment') {\n        t.skipIf(\n          !(t.device.limits.maxStorageTexturesInFragmentStage! > 0),\n          `maxStorageTexturesInFragmentStage(${t.device.limits\n            .maxStorageTexturesInFragmentStage!}) is not > 0`\n        );\n      }\n    }\n\n    // In compatibility mode the lowest maxComputeInvocationsPerWorkgroup is 128 vs non-compat which is 256\n    // So in non-compat we get 16 * 8 * 2, vs compat where we get 8 * 8 * 2\n    const kWidth = t.isCompatibility ? 8 : 16;\n    const height = textureDimension === '1d' ? 1 : 8;\n    const textureSize = [kWidth, height, depthOrArrayLayers] as const;\n    const storageTexture = t.createTextureTracked({\n      format,\n      dimension: textureDimension,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    const { bytesPerBlock } = getBlockInfoForColorTextureFormat(format);\n    const initialData = t.getInitialData(storageTexture);\n    t.queue.writeTexture(\n      { texture: storageTexture },\n      initialData,\n      {\n        bytesPerRow: bytesPerBlock * kWidth,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n\n    const commandEncoder = t.device.createCommandEncoder();\n\n    t.recordCommandsToTransform(t.device, shaderStage, commandEncoder, storageTexture);\n\n    const expectedData = t.getExpectedData(shaderStage, storageTexture, initialData);\n    const readbackBuffer = t.createBufferTracked({\n      size: expectedData.byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const bytesPerRow = align(bytesPerBlock * kWidth, 256);\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: storageTexture,\n      },\n      {\n        buffer: readbackBuffer,\n        bytesPerRow,\n        rowsPerImage: height,\n      },\n      textureSize\n    );\n    t.queue.submit([commandEncoder.finish()]);\n\n    switch (getTextureFormatType(format)) {\n      case 'uint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Uint32Array(expectedData));\n        break;\n      case 'sint':\n        t.expectGPUBufferValuesEqual(readbackBuffer, new Int32Array(expectedData));\n\n        break;\n      case 'float':\n      case 'unfilterable-float':\n        if (format === 'r8unorm' || format === 'rgba8unorm') {\n          t.expectGPUBufferValuesEqual(readbackBuffer, new Uint8Array(expectedData));\n        } else {\n          t.expectGPUBufferValuesEqual(readbackBuffer, new Float32Array(expectedData));\n        }\n        break;\n      default:\n        unreachable();\n        break;\n    }\n  });\n"],"mappings":"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"}