{"version":3,"file":"resolve.spec.js","names":["description","makeTestGroup","AllFeaturesMaxLimitsGPUTest","ttu","kSlotsToResolve","kSize","kFormat","g","test","desc","params","u","combine","beginSubcases","fn","t","targets","i","numColorAttachments","push","format","pipeline","device","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","primitive","topology","multisample","count","resolveTargets","drawPassAttachments","resolvePassAttachments","kResolveTargetSize","resolveTargetBaseMipLevel","colorAttachment","createTextureTracked","size","sampleCount","mipLevelCount","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","createView","resolveTarget","slotsToResolve","includes","resolveTargetTexture","resolveTargetBaseArrayLayer","baseMipLevel","baseArrayLayer","separateResolvePass","view","clearValue","r","b","a","loadOp","storeOp","storeOperation","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","setPipeline","draw","end","queue","submit","finish","z","expectSinglePixelComparisonsAreOkInTexture","texture","mipLevel","coord","x","y","exp","R","G","B","A"],"sources":["../../../../../src/webgpu/api/operation/render_pass/resolve.spec.ts"],"sourcesContent":["export const description = `API Operation Tests for multisample resolve in render passes.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport * as ttu from '../../../texture_test_utils.js';\n\nconst kSlotsToResolve = [\n  [0, 2],\n  [1, 3],\n  [0, 1, 2, 3],\n];\n\nconst kSize = 4;\nconst kFormat: GPUTextureFormat = 'rgba8unorm';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('render_pass_resolve')\n  .desc(\n    `\nTest basic render pass resolve behavior for combinations of:\n  - number of color attachments, some with and some without a resolveTarget\n  - {a single draw+resolve pass, one draw-store pass and one empty load-resolve pass}\n    (attempts to test known driver bugs with empty resolve passes)\n  - in the resolve pass, storeOp set to {'store', 'discard'}\n  - mip levels {0, 1} and array layers {0, 1}\n    TODO: cases where color attachment and resolve target don't have the same mip level\n  - resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    TODO: cases where color attachment and resolve target don't have the same z (slice or layer)\n  - TODO: test all renderable color formats\n  - TODO: test that any not-resolved attachments are rendered to correctly.\n  - TODO: test different loadOps\n  - TODO?: resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - TODO?: resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (different z from colorAttachment)\n`\n  )\n  .params(u =>\n    u\n      .combine('separateResolvePass', [false, true])\n      .combine('storeOperation', ['discard', 'store'] as const)\n      .beginSubcases()\n      .combine('numColorAttachments', [2, 4] as const)\n      .combine('slotsToResolve', kSlotsToResolve)\n      .combine('resolveTargetBaseMipLevel', [0, 1] as const)\n      .combine('resolveTargetBaseArrayLayer', [0, 1] as const)\n  )\n  .fn(t => {\n    const targets: GPUColorTargetState[] = [];\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      targets.push({ format: kFormat });\n    }\n\n    // These shaders will draw a white triangle into a texture. After draw, the top left\n    // half of the texture will be white, and the bottom right half will be unchanged. When this\n    // texture is resolved, there will be two distinct colors in each portion of the texture, as\n    // well as a line between the portions that contain the midpoint color due to the multisample\n    // resolve.\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex fn main(\n              @builtin(vertex_index) VertexIndex : u32\n              ) -> @builtin(position) vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0));\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            struct Output {\n              @location(0) fragColor0 : vec4<f32>,\n              @location(1) fragColor1 : vec4<f32>,\n              @location(2) fragColor2 : vec4<f32>,\n              @location(3) fragColor3 : vec4<f32>,\n            };\n\n            @fragment fn main() -> Output {\n              return Output(\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0)\n              );\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: { count: 4 },\n    });\n\n    const resolveTargets: GPUTexture[] = [];\n    const drawPassAttachments: GPURenderPassColorAttachment[] = [];\n    const resolvePassAttachments: GPURenderPassColorAttachment[] = [];\n\n    // The resolve target must be the same size as the color attachment. If we're resolving to mip\n    // level 1, the resolve target base mip level should be 2x the color attachment size.\n    const kResolveTargetSize = kSize << t.params.resolveTargetBaseMipLevel;\n\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      const colorAttachment = t\n        .createTextureTracked({\n          format: kFormat,\n          size: [kSize, kSize, 1],\n          sampleCount: 4,\n          mipLevelCount: 1,\n          usage:\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        })\n        .createView();\n\n      let resolveTarget: GPUTextureView | undefined;\n      if (t.params.slotsToResolve.includes(i)) {\n        const resolveTargetTexture = t.createTextureTracked({\n          format: kFormat,\n          size: [kResolveTargetSize, kResolveTargetSize, t.params.resolveTargetBaseArrayLayer + 1],\n          sampleCount: 1,\n          mipLevelCount: t.params.resolveTargetBaseMipLevel + 1,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        resolveTargets.push(resolveTargetTexture);\n\n        resolveTarget = resolveTargetTexture.createView({\n          baseMipLevel: t.params.resolveTargetBaseMipLevel,\n          baseArrayLayer: t.params.resolveTargetBaseArrayLayer,\n        });\n      }\n\n      // Clear to black for the load operation. After the draw, the top left half of the attachment\n      // will be white and the bottom right half will be black.\n      if (t.params.separateResolvePass) {\n        drawPassAttachments.push({\n          view: colorAttachment,\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        });\n        resolvePassAttachments.push({\n          view: colorAttachment,\n          resolveTarget,\n          loadOp: 'load',\n          storeOp: t.params.storeOperation,\n        });\n      } else {\n        drawPassAttachments.push({\n          view: colorAttachment,\n          resolveTarget,\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: t.params.storeOperation,\n        });\n      }\n    }\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({ colorAttachments: drawPassAttachments });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n    if (t.params.separateResolvePass) {\n      const pass = encoder.beginRenderPass({ colorAttachments: resolvePassAttachments });\n      pass.end();\n    }\n    t.device.queue.submit([encoder.finish()]);\n\n    // Verify the resolve targets contain the correct values. Note that we use z to specify the\n    // array layer from which to pull the pixels for testing.\n    const z = t.params.resolveTargetBaseArrayLayer;\n    for (const resolveTarget of resolveTargets) {\n      ttu.expectSinglePixelComparisonsAreOkInTexture(\n        t,\n        { texture: resolveTarget, mipLevel: t.params.resolveTargetBaseMipLevel },\n        [\n          // Top left pixel should be {1.0, 1.0, 1.0, 1.0}.\n          { coord: { x: 0, y: 0, z }, exp: { R: 1.0, G: 1.0, B: 1.0, A: 1.0 } },\n          // Bottom right pixel should be {0, 0, 0, 0}.\n          { coord: { x: kSize - 1, y: kSize - 1, z }, exp: { R: 0, G: 0, B: 0, A: 0 } },\n          // Top right pixel should be {0.5, 0.5, 0.5, 0.5} due to the multisampled resolve.\n          { coord: { x: kSize - 1, y: 0, z }, exp: { R: 0.5, G: 0.5, B: 0.5, A: 0.5 } },\n        ]\n      );\n    }\n  });\n"],"mappings":"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"}