{"version":3,"file":"resolve.spec.js","names":["description","makeTestGroup","GPUTest","TextureTestMixin","kSlotsToResolve","kSize","kFormat","g","test","params","u","combine","beginSubcases","fn","t","targets","i","numColorAttachments","push","format","pipeline","device","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","primitive","topology","multisample","count","resolveTargets","renderPassColorAttachments","kResolveTargetSize","resolveTargetBaseMipLevel","colorAttachment","createTexture","size","width","height","depthOrArrayLayers","sampleCount","mipLevelCount","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","slotsToResolve","includes","resolveTarget","resolveTargetBaseArrayLayer","view","createView","clearValue","r","b","a","loadOp","storeOp","storeOperation","baseMipLevel","baseArrayLayer","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","setPipeline","draw","end","queue","submit","finish","z","expectSinglePixelComparisonsAreOkInTexture","texture","mipLevel","coord","x","y","exp","R","G","B","A"],"sources":["../../../../../src/webgpu/api/operation/render_pass/resolve.spec.ts"],"sourcesContent":["export const description = `API Operation Tests for RenderPass StoreOp.\nTests a render pass with a resolveTarget resolves correctly for many combinations of:\n  - number of color attachments, some with and some without a resolveTarget\n  - renderPass storeOp set to {'store', 'discard'}\n  - resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (TODO?: different z from colorAttachment)\n  - TODO: test all renderable color formats\n  - TODO: test that any not-resolved attachments are rendered to correctly.\n  - TODO: test different loadOps\n  - TODO?: resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - TODO?: resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (different z from colorAttachment)\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\n\nconst kSlotsToResolve = [\n  [0, 2],\n  [1, 3],\n  [0, 1, 2, 3],\n];\n\nconst kSize = 4;\nconst kFormat: GPUTextureFormat = 'rgba8unorm';\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('render_pass_resolve')\n  .params(u =>\n    u\n      .combine('storeOperation', ['discard', 'store'] as const)\n      .beginSubcases()\n      .combine('numColorAttachments', [2, 4] as const)\n      .combine('slotsToResolve', kSlotsToResolve)\n      .combine('resolveTargetBaseMipLevel', [0, 1] as const)\n      .combine('resolveTargetBaseArrayLayer', [0, 1] as const)\n  )\n  .fn(t => {\n    const targets: GPUColorTargetState[] = [];\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      targets.push({ format: kFormat });\n    }\n\n    // These shaders will draw a white triangle into a texture. After draw, the top left\n    // half of the texture will be white, and the bottom right half will be unchanged. When this\n    // texture is resolved, there will be two distinct colors in each portion of the texture, as\n    // well as a line between the portions that contain the midpoint color due to the multisample\n    // resolve.\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex fn main(\n              @builtin(vertex_index) VertexIndex : u32\n              ) -> @builtin(position) vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0));\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            struct Output {\n              @location(0) fragColor0 : vec4<f32>,\n              @location(1) fragColor1 : vec4<f32>,\n              @location(2) fragColor2 : vec4<f32>,\n              @location(3) fragColor3 : vec4<f32>,\n            };\n\n            @fragment fn main() -> Output {\n              return Output(\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0)\n              );\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: { count: 4 },\n    });\n\n    const resolveTargets: GPUTexture[] = [];\n    const renderPassColorAttachments: GPURenderPassColorAttachment[] = [];\n\n    // The resolve target must be the same size as the color attachment. If we're resolving to mip\n    // level 1, the resolve target base mip level should be 2x the color attachment size.\n    const kResolveTargetSize = kSize << t.params.resolveTargetBaseMipLevel;\n\n    for (let i = 0; i < t.params.numColorAttachments; i++) {\n      const colorAttachment = t.device.createTexture({\n        format: kFormat,\n        size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n        sampleCount: 4,\n        mipLevelCount: 1,\n        usage:\n          GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      });\n\n      if (t.params.slotsToResolve.includes(i)) {\n        const colorAttachment = t.device.createTexture({\n          format: kFormat,\n          size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n          sampleCount: 4,\n          mipLevelCount: 1,\n          usage:\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const resolveTarget = t.device.createTexture({\n          format: kFormat,\n          size: {\n            width: kResolveTargetSize,\n            height: kResolveTargetSize,\n            depthOrArrayLayers: t.params.resolveTargetBaseArrayLayer + 1,\n          },\n          sampleCount: 1,\n          mipLevelCount: t.params.resolveTargetBaseMipLevel + 1,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        // Clear to black for the load operation. After the draw, the top left half of the attachment\n        // will be white and the bottom right half will be black.\n        renderPassColorAttachments.push({\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: t.params.storeOperation,\n          resolveTarget: resolveTarget.createView({\n            baseMipLevel: t.params.resolveTargetBaseMipLevel,\n            baseArrayLayer: t.params.resolveTargetBaseArrayLayer,\n          }),\n        });\n\n        resolveTargets.push(resolveTarget);\n      } else {\n        renderPassColorAttachments.push({\n          view: colorAttachment.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: t.params.storeOperation,\n        });\n      }\n    }\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = encoder.beginRenderPass({\n      colorAttachments: renderPassColorAttachments,\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n\n    // Verify the resolve targets contain the correct values. Note that we use z to specify the\n    // array layer from which to pull the pixels for testing.\n    const z = t.params.resolveTargetBaseArrayLayer;\n    for (const resolveTarget of resolveTargets) {\n      t.expectSinglePixelComparisonsAreOkInTexture(\n        { texture: resolveTarget, mipLevel: t.params.resolveTargetBaseMipLevel },\n        [\n          // Top left pixel should be {1.0, 1.0, 1.0, 1.0}.\n          { coord: { x: 0, y: 0, z }, exp: { R: 1.0, G: 1.0, B: 1.0, A: 1.0 } },\n          // Bottom right pixel should be {0, 0, 0, 0}.\n          { coord: { x: kSize - 1, y: kSize - 1, z }, exp: { R: 0, G: 0, B: 0, A: 0 } },\n          // Top right pixel should be {0.5, 0.5, 0.5, 0.5} due to the multisampled resolve.\n          { coord: { x: kSize - 1, y: 0, z }, exp: { R: 0.5, G: 0.5, B: 0.5, A: 0.5 } },\n        ]\n      );\n    }\n  });\n"],"mappings":"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"}