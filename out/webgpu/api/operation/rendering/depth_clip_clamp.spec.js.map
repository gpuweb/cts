{"version":3,"file":"depth_clip_clamp.spec.js","names":["description","makeTestGroup","canCopyFromAspectOfTextureFormat","getBlockInfoForTextureFormat","isStencilTextureFormat","kDepthTextureFormats","AllFeaturesMaxLimitsGPUTest","checkElementsBetween","checkElementsPassPredicate","g","test","desc","params","u","combine","undefined","fn","t","format","unclippedDepth","writeDepth","multisampled","skipIfTextureFormatNotSupported","skipIfDeviceDoesNotHaveFeature","kNumDepthValues","kNumTestPoints","kViewportMinDepth","kViewportMaxDepth","shaderSource","module","device","createShaderModule","code","testPipeline","createRenderPipeline","label","layout","vertex","entryPoint","primitive","topology","depthStencil","depthWriteEnabled","depthCompare","multisample","count","fragment","targets","checkBindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","texture","sampleType","checkPipelineLayout","createPipelineLayout","bindGroupLayouts","checkPipeline","dsTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","COPY_SRC","sampleCount","dsTextureView","createView","checkTextureDesc","checkTexture","checkTextureView","checkTextureMSView","bytesPerBlock","dsActual","createBufferTracked","GPUBufferUsage","COPY_DST","MAP_READ","dsExpected","checkBuffer","fragInputZFailedBuffer","STORAGE","testBindGroup","createBindGroup","getBindGroupLayout","resource","buffer","enc","createCommandEncoder","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","setPipeline","setBindGroup","setViewport","draw","end","copyTextureToBuffer","aspect","checkBindGroup","clearValue","resolveTarget","loadOp","storeOp","queue","submit","finish","expectGPUBufferValuesPassCheck","a","type","Float32Array","typedLength","kCheckPassedValue","predicatePrinter","leftHeader","getValueForCell","_index","Promise","all","mapAsync","GPUMapMode","READ","act","getMappedRange","exp","push","index","toFixed","value","Uint8Array","method","initPipeline","testTextureDesc","testTexture","testTextureView","testTextureMSView","resultBuffer","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/rendering/depth_clip_clamp.spec.ts"],"sourcesContent":["export const description = `\nTests for depth clipping, depth clamping (at various points in the pipeline), and maybe extended\ndepth ranges as well.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  canCopyFromAspectOfTextureFormat,\n  getBlockInfoForTextureFormat,\n  isStencilTextureFormat,\n  kDepthTextureFormats,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport {\n  checkElementsBetween,\n  checkElementsPassPredicate,\n  CheckElementsSupplementalTableRows,\n} from '../../../util/check_contents.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('depth_clamp_and_clip')\n  .desc(\n    `\nDepth written to the depth attachment should always be in the range of the viewport depth,\neven if it was written by the fragment shader (using frag_depth). If depth clipping is enabled,\nprimitives should be clipped to the viewport depth before rasterization; if not, these fragments\nshould be rasterized, and the fragment shader should receive out-of-viewport position.z values.\n\nTo test this, render NxN points, with N vertex depth values, by (if writeDepth=true) N\nfrag_depth values with the viewport depth set to [0.25,0.75].\n\nWhile rendering, check the fragment input position.z has the expected value (for all fragments that\nwere produced by the rasterizer) by writing the diff to a storage buffer, which is later checked to\nbe all (near) 0.\n\nThen, run another pass (which outputs every point at z=0.5 to avoid clipping) to verify the depth\nbuffer contents by outputting the expected depth with depthCompare:'not-equal': any fragments that\nhave unexpected values then get drawn to the color buffer, which is later checked to be empty.`\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthTextureFormats)\n      .combine('unclippedDepth', [undefined, false, true])\n      .combine('writeDepth', [false, true])\n      .combine('multisampled', [false, true])\n  )\n  .fn(async t => {\n    const { format, unclippedDepth, writeDepth, multisampled } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    if (unclippedDepth) {\n      t.skipIfDeviceDoesNotHaveFeature('depth-clip-control');\n    }\n\n    /** Number of depth values to test for both vertex output and frag_depth output. */\n    const kNumDepthValues = 8;\n    /** Test every combination of vertex output and frag_depth output. */\n    const kNumTestPoints = kNumDepthValues * kNumDepthValues;\n    const kViewportMinDepth = 0.25;\n    const kViewportMaxDepth = 0.75;\n\n    const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumTestPoints}.0 - 1.0;\n      }\n\n      // Test vertex shader's position.z output.\n      // Here, the viewport range corresponds to position.z in [0,1].\n      fn vertexZ(idx: u32) -> f32 {\n        return kDepths[idx / ${kNumDepthValues}u];\n      }\n\n      // Test fragment shader's expected position.z input.\n      // Here, the viewport range corresponds to position.z in [vpMin,vpMax], but\n      // unclipped values extend beyond that range.\n      fn expectedFragPosZ(idx: u32) -> f32 {\n        return vpMin + vertexZ(idx) * (vpMax - vpMin);\n      }\n\n      //////// \"Test\" entry points\n\n      struct VFTest {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vtest(@builtin(vertex_index) idx: u32) -> VFTest {\n        var vf: VFTest;\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, vertexZ(idx), 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct Output {\n        // Each fragment (that didn't get clipped) writes into one element of this output.\n        // (Anything that doesn't get written is already zero.)\n        fragInputZDiff: array<f32, ${kNumTestPoints}>\n      };\n      @group(0) @binding(0) var <storage, read_write> output: Output;\n\n      fn checkZ(vf: VFTest) {\n        output.fragInputZDiff[vf.vertexIndex] = vf.pos.z - expectedFragPosZ(vf.vertexIndex);\n      }\n\n      @fragment\n      fn ftest_WriteDepth(vf: VFTest) -> @builtin(frag_depth) f32 {\n        checkZ(vf);\n        return kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n      }\n\n      @fragment\n      fn ftest_NoWriteDepth(vf: VFTest) {\n        checkZ(vf);\n      }\n\n      //////// \"Check\" entry points\n\n      struct VFCheck {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vcheck(@builtin(vertex_index) idx: u32) -> VFCheck {\n        var vf: VFCheck;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct FCheck {\n        @location(0) color: f32,\n      };\n\n      ${\n        multisampled\n          ? '@group(0) @binding(0) var depthTex: texture_multisampled_2d<f32>;'\n          : '@group(0) @binding(0) var depthTex: texture_2d<f32>;'\n      }\n\n      @fragment\n      fn fcheck(vf: VFCheck) -> FCheck {\n        let vertZ = vertexZ(vf.vertexIndex);\n        let outOfRange = vertZ < 0.0 || vertZ > 1.0;\n        let expFragPosZ = expectedFragPosZ(vf.vertexIndex);\n\n        let writtenDepth = kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n\n        let expectedDepthWriteInput = ${writeDepth ? 'writtenDepth' : 'expFragPosZ'};\n        var expectedDepthBufferValue = clamp(expectedDepthWriteInput, vpMin, vpMax);\n        if (${!unclippedDepth} && outOfRange) {\n          // Test fragment should have been clipped; expect the depth attachment to\n          // have its clear value (0.5).\n          expectedDepthBufferValue = 0.5;\n        }\n\n        let actualDepthBufferValue = textureLoad(depthTex, vec2u(vf.vertexIndex, 0), 0).r;\n        let actualVsExpectedDiff = abs(expectedDepthBufferValue - actualDepthBufferValue);\n        var f: FCheck;\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        if (actualVsExpectedDiff < 1e-5) {\n          f.color = 0.0;\n        }\n        return f;\n      }\n    `;\n    const module = t.device.createShaderModule({ code: shaderSource });\n\n    // Draw points at different vertex depths and fragment depths into the depth attachment,\n    // with a viewport of [0.25,0.75].\n    const testPipeline = t.device.createRenderPipeline({\n      label: 'testPipeline',\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vtest' },\n      primitive: {\n        topology: 'point-list',\n        unclippedDepth,\n      },\n      depthStencil: { format, depthWriteEnabled: true, depthCompare: 'always' },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: {\n        module,\n        entryPoint: writeDepth ? 'ftest_WriteDepth' : 'ftest_NoWriteDepth',\n        targets: [],\n      },\n    });\n\n    const checkBindGroupLayout = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT,\n          texture: {\n            sampleType: 'unfilterable-float',\n            multisampled,\n          },\n        },\n      ],\n    });\n\n    const checkPipelineLayout = t.device.createPipelineLayout({\n      bindGroupLayouts: [checkBindGroupLayout],\n    });\n\n    // Read the depth values and output 0 if they match expected, 1 if they don't\n    const checkPipeline = t.device.createRenderPipeline({\n      label: 'checkPipeline',\n      layout: checkPipelineLayout,\n      vertex: { module, entryPoint: 'vcheck' },\n      primitive: { topology: 'point-list' },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'fcheck', targets: [{ format: 'r8unorm' }] },\n    });\n\n    const dsTexture = t.createTextureTracked({\n      format,\n      size: [kNumTestPoints],\n      usage:\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_SRC,\n      sampleCount: multisampled ? 4 : 1,\n    });\n    const dsTextureView = dsTexture.createView();\n\n    const checkTextureDesc = {\n      format: 'r8unorm' as const,\n      size: [kNumTestPoints],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    };\n    const checkTexture = t.createTextureTracked(checkTextureDesc);\n    const checkTextureView = checkTexture.createView();\n    const checkTextureMSView = multisampled\n      ? t.createTextureTracked({ ...checkTextureDesc, sampleCount: 4 }).createView()\n      : undefined;\n\n    const { bytesPerBlock } = getBlockInfoForTextureFormat(format);\n    const dsActual =\n      canCopyFromAspectOfTextureFormat(format, 'depth-only') && !multisampled && bytesPerBlock\n        ? t.createBufferTracked({\n            size: kNumTestPoints * bytesPerBlock,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          })\n        : undefined;\n    const dsExpected =\n      canCopyFromAspectOfTextureFormat(format, 'depth-only') && !multisampled && bytesPerBlock\n        ? t.createBufferTracked({\n            size: kNumTestPoints * bytesPerBlock,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          })\n        : undefined;\n    const checkBuffer = t.createBufferTracked({\n      size: kNumTestPoints,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const fragInputZFailedBuffer = t.createBufferTracked({\n      size: 4 * kNumTestPoints,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    const testBindGroup = t.device.createBindGroup({\n      layout: testPipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: fragInputZFailedBuffer } }],\n    });\n\n    const enc = t.device.createCommandEncoder();\n    {\n      const pass = enc.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthClearValue: 0.5, // Will see this depth value if the fragment was clipped.\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          ...(isStencilTextureFormat(format) && {\n            stencilClearValue: 0,\n            stencilLoadOp: 'clear',\n            stencilStoreOp: 'discard',\n          }),\n        },\n      });\n      pass.setPipeline(testPipeline);\n      pass.setBindGroup(0, testBindGroup);\n      pass.setViewport(0, 0, kNumTestPoints, 1, kViewportMinDepth, kViewportMaxDepth);\n      pass.draw(kNumTestPoints);\n      pass.end();\n    }\n    if (dsActual) {\n      enc.copyTextureToBuffer({ texture: dsTexture, aspect: 'depth-only' }, { buffer: dsActual }, [\n        kNumTestPoints,\n      ]);\n    }\n    {\n      const checkBindGroup = t.device.createBindGroup({\n        layout: checkBindGroupLayout,\n        entries: [{ binding: 0, resource: dsTexture.createView({ aspect: 'depth-only' }) }],\n      });\n      const clearValue = [0.5, 0.5, 0.5, 0.5]; // We should only see 0.0 or 1.0\n      const pass = enc.beginRenderPass({\n        colorAttachments: [\n          checkTextureMSView\n            ? {\n                view: checkTextureMSView,\n                resolveTarget: checkTextureView,\n                clearValue,\n                loadOp: 'clear',\n                storeOp: 'discard',\n              }\n            : { view: checkTextureView, clearValue, loadOp: 'clear', storeOp: 'store' },\n        ],\n      });\n      pass.setPipeline(checkPipeline);\n      pass.setBindGroup(0, checkBindGroup);\n      pass.setViewport(0, 0, kNumTestPoints, 1, 0.0, 1.0);\n      pass.draw(kNumTestPoints);\n      pass.end();\n    }\n    enc.copyTextureToBuffer({ texture: checkTexture }, { buffer: checkBuffer }, [kNumTestPoints]);\n    if (dsExpected) {\n      enc.copyTextureToBuffer(\n        { texture: dsTexture, aspect: 'depth-only' },\n        { buffer: dsExpected },\n        [kNumTestPoints]\n      );\n    }\n    t.device.queue.submit([enc.finish()]);\n\n    t.expectGPUBufferValuesPassCheck(\n      fragInputZFailedBuffer,\n      a => checkElementsBetween(a, [() => -1e-5, () => 1e-5]),\n      { type: Float32Array, typedLength: kNumTestPoints }\n    );\n\n    const kCheckPassedValue = 0;\n    const predicatePrinter: CheckElementsSupplementalTableRows = [\n      { leftHeader: 'expected ==', getValueForCell: _index => kCheckPassedValue },\n    ];\n    if (dsActual && dsExpected && format === 'depth32float') {\n      await Promise.all([dsActual.mapAsync(GPUMapMode.READ), dsExpected.mapAsync(GPUMapMode.READ)]);\n      const act = new Float32Array(dsActual.getMappedRange());\n      const exp = new Float32Array(dsExpected.getMappedRange());\n      predicatePrinter.push(\n        { leftHeader: 'act ==', getValueForCell: index => act[index].toFixed(2) },\n        { leftHeader: 'exp ==', getValueForCell: index => exp[index].toFixed(2) }\n      );\n    }\n    t.expectGPUBufferValuesPassCheck(\n      checkBuffer,\n      a =>\n        checkElementsPassPredicate(a, (_index, value) => value === kCheckPassedValue, {\n          predicatePrinter,\n        }),\n      { type: Uint8Array, typedLength: kNumTestPoints, method: 'map' }\n    );\n  });\n\ng.test('depth_test_input_clamped')\n  .desc(\n    `\nInput to the depth test should always be in the range of viewport depth, even if it was written by\nthe fragment shader (using frag_depth).\n\nTo test this, first initialize the depth buffer with N expected values (by writing frag_depth, with\nthe default viewport). These expected values are clamped by the shader to [0.25, 0.75].\n\nThen, run another pass with the viewport depth set to [0.25,0.75], and output various (unclamped)\nfrag_depth values from its fragment shader with depthCompare:'not-equal'. These should get clamped;\nany fragments that have unexpected values then get drawn to the color buffer, which is later checked\nto be empty.`\n  )\n  .params(u =>\n    u //\n      .combine('format', kDepthTextureFormats)\n      .combine('unclippedDepth', [false, true])\n      .combine('multisampled', [false, true])\n  )\n  .fn(t => {\n    const { format, unclippedDepth, multisampled } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    if (unclippedDepth) {\n      t.skipIfDeviceDoesNotHaveFeature('depth-clip-control');\n    }\n\n    const kNumDepthValues = 8;\n    const kViewportMinDepth = 0.25;\n    const kViewportMaxDepth = 0.75;\n\n    const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumDepthValues}.0 - 1.0;\n      }\n\n      struct VF {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vmain(@builtin(vertex_index) idx: u32) -> VF {\n        var vf: VF;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      @fragment\n      fn finit(vf: VF) -> @builtin(frag_depth) f32 {\n        // Expected values of the ftest pipeline.\n        return clamp(kDepths[vf.vertexIndex], vpMin, vpMax);\n      }\n\n      struct FTest {\n        @builtin(frag_depth) depth: f32,\n        @location(0) color: f32,\n      };\n\n      @fragment\n      fn ftest(vf: VF) -> FTest {\n        var f: FTest;\n        f.depth = kDepths[vf.vertexIndex]; // Should get clamped to the viewport.\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        return f;\n      }\n    `;\n\n    const module = t.device.createShaderModule({ code: shaderSource });\n\n    // Initialize depth attachment with expected values, in [0.25,0.75].\n    const initPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      primitive: { topology: 'point-list' },\n      depthStencil: { format, depthWriteEnabled: true, depthCompare: 'always' },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'finit', targets: [] },\n    });\n\n    // With a viewport set to [0.25,0.75], output values in [0.0,1.0] and check they're clamped\n    // before the depth test, regardless of whether unclippedDepth is enabled.\n    const testPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module, entryPoint: 'vmain' },\n      primitive: {\n        topology: 'point-list',\n        unclippedDepth,\n      },\n      depthStencil: { format, depthCompare: 'not-equal', depthWriteEnabled: false },\n      multisample: multisampled ? { count: 4 } : undefined,\n      fragment: { module, entryPoint: 'ftest', targets: [{ format: 'r8unorm' }] },\n    });\n\n    const dsTexture = t.createTextureTracked({\n      format,\n      size: [kNumDepthValues],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      sampleCount: multisampled ? 4 : 1,\n    });\n    const dsTextureView = dsTexture.createView();\n\n    const testTextureDesc = {\n      format: 'r8unorm' as const,\n      size: [kNumDepthValues],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    };\n    const testTexture = t.createTextureTracked(testTextureDesc);\n    const testTextureView = testTexture.createView();\n    const testTextureMSView = multisampled\n      ? t.createTextureTracked({ ...testTextureDesc, sampleCount: 4 }).createView()\n      : undefined;\n\n    const resultBuffer = t.createBufferTracked({\n      size: kNumDepthValues,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const enc = t.device.createCommandEncoder();\n    {\n      const pass = enc.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthClearValue: 1.0,\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          ...(isStencilTextureFormat(format) && {\n            stencilClearValue: 0,\n            stencilLoadOp: 'clear',\n            stencilStoreOp: 'discard',\n          }),\n        },\n      });\n      pass.setPipeline(initPipeline);\n      pass.draw(kNumDepthValues);\n      pass.end();\n    }\n    {\n      const clearValue = [0, 0, 0, 0]; // Will see this color if the test passed.\n      const pass = enc.beginRenderPass({\n        colorAttachments: [\n          testTextureMSView\n            ? {\n                view: testTextureMSView,\n                resolveTarget: testTextureView,\n                clearValue,\n                loadOp: 'clear',\n                storeOp: 'discard',\n              }\n            : { view: testTextureView, clearValue, loadOp: 'clear', storeOp: 'store' },\n        ],\n        depthStencilAttachment: {\n          view: dsTextureView,\n          depthLoadOp: 'load',\n          depthStoreOp: 'store',\n          ...(isStencilTextureFormat(format) && {\n            stencilClearValue: 0,\n            stencilLoadOp: 'clear',\n            stencilStoreOp: 'discard',\n          }),\n        },\n      });\n      pass.setPipeline(testPipeline);\n      pass.setViewport(0, 0, kNumDepthValues, 1, kViewportMinDepth, kViewportMaxDepth);\n      pass.draw(kNumDepthValues);\n      pass.end();\n    }\n    enc.copyTextureToBuffer({ texture: testTexture }, { buffer: resultBuffer }, [kNumDepthValues]);\n    t.device.queue.submit([enc.finish()]);\n\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint8Array(kNumDepthValues), 0, {\n      method: 'map',\n    });\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,4CAA4C;AAC1E;EACEC,gCAAgC;EAChCC,4BAA4B;EAC5BC,sBAAsB;EACtBC,oBAAoB;AACf,yBAAyB;AAChC,SAASC,2BAA2B,QAAQ,sBAAsB;AAClE;EACEC,oBAAoB;EACpBC,0BAA0B;;AAErB,iCAAiC;;AAExC,OAAO,MAAMC,CAAC,GAAGR,aAAa,CAACK,2BAA2B,CAAC;;AAE3DG,CAAC,CAACC,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC,CAAC;AAAA,CACCC,OAAO,CAAC,QAAQ,EAAET,oBAAoB,CAAC;AACvCS,OAAO,CAAC,gBAAgB,EAAE,CAACC,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AACnDD,OAAO,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACpCA,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC;AAC1C,CAAC;AACAE,EAAE,CAAC,OAAMC,CAAC,KAAI;EACb,MAAM,EAAEC,MAAM,EAAEC,cAAc,EAAEC,UAAU,EAAEC,YAAY,CAAC,CAAC,GAAGJ,CAAC,CAACL,MAAM;EACrEK,CAAC,CAACK,+BAA+B,CAACJ,MAAM,CAAC;EACzC,IAAIC,cAAc,EAAE;IAClBF,CAAC,CAACM,8BAA8B,CAAC,oBAAoB,CAAC;EACxD;;EAEA;EACA,MAAMC,eAAe,GAAG,CAAC;EACzB;EACA,MAAMC,cAAc,GAAGD,eAAe,GAAGA,eAAe;EACxD,MAAME,iBAAiB,GAAG,IAAI;EAC9B,MAAMC,iBAAiB,GAAG,IAAI;;EAE9B,MAAMC,YAAY,GAAI;AAC1B;AACA,yCAAyCJ,eAAgB,kBAAiBA,eAAgB;AAC1F;AACA;AACA,2BAA2BE,iBAAkB;AAC7C,2BAA2BC,iBAAkB;AAC7C;AACA;AACA;AACA,0CAA0CF,cAAe;AACzD;AACA;AACA;AACA;AACA;AACA,+BAA+BD,eAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqCC,cAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0CD,eAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQH,YAAY;EACR,mEAAmE;EACnE;EACL;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsDG,eAAgB;AACtE;AACA,wCAAwCJ,UAAU,GAAG,cAAc,GAAG,aAAc;AACpF;AACA,cAAc,CAACD,cAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACD,MAAMU,MAAM,GAAGZ,CAAC,CAACa,MAAM,CAACC,kBAAkB,CAAC,EAAEC,IAAI,EAAEJ,YAAY,CAAC,CAAC,CAAC;;EAElE;EACA;EACA,MAAMK,YAAY,GAAGhB,CAAC,CAACa,MAAM,CAACI,oBAAoB,CAAC;IACjDC,KAAK,EAAE,cAAc;IACrBC,MAAM,EAAE,MAAM;IACdC,MAAM,EAAE,EAAER,MAAM,EAAES,UAAU,EAAE,OAAO,CAAC,CAAC;IACvCC,SAAS,EAAE;MACTC,QAAQ,EAAE,YAAY;MACtBrB;IACF,CAAC;IACDsB,YAAY,EAAE,EAAEvB,MAAM,EAAEwB,iBAAiB,EAAE,IAAI,EAAEC,YAAY,EAAE,QAAQ,CAAC,CAAC;IACzEC,WAAW,EAAEvB,YAAY,GAAG,EAAEwB,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG9B,SAAS;IACpD+B,QAAQ,EAAE;MACRjB,MAAM;MACNS,UAAU,EAAElB,UAAU,GAAG,kBAA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"}