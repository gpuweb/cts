{"version":3,"file":"3d_texture_slices.spec.js","names":["description","makeTestGroup","kTextureFormatInfo","GPUTest","kBytesPerRowAlignment","kSize","kFormat","F","createShaderModule","attachmentCount","locations","outputs","i","device","code","getBufferSizeAndOffset","attachmentWidth","attachmentHeight","bufferSize","bufferOffset","checkAttachmentResult","buffer","expectedData","Uint8Array","j","k","expectGPUBufferValuesEqual","g","test","desc","params","u","combine","fn","t","mipLevel","depthSlice","texture","createTextureTracked","size","dimension","format","mipLevelCount","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","createBufferTracked","GPUBufferUsage","COPY_DST","module","pipeline","createRenderPipeline","layout","vertex","fragment","targets","primitive","topology","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","baseMipLevel","clearValue","r","b","a","loadOp","storeOp","setPipeline","draw","end","copyTextureToBuffer","origin","x","y","z","bytesPerRow","width","height","depthOrArrayLayers","queue","submit","finish","beginSubcases","sameTexture","samePass","formatByteCost","colorRender","byteCost","maxAttachmentCountPerSample","Math","trunc","limits","maxColorAttachmentBytesPerSample","min","maxColorAttachments","descriptor","textures","push","diffTexture","colorAttachment","Array","fill","offset","kBaseSize"],"sources":["../../../../../src/webgpu/api/operation/rendering/3d_texture_slices.spec.ts"],"sourcesContent":["export const description = `\nTest rendering to 3d texture slices.\n- Render to same slice on different render pass, different textures, or texture [1, 1, N]'s different mip levels\n- Render to different slices at mip levels on same texture in render pass\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kTextureFormatInfo } from '../../../format_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { kBytesPerRowAlignment } from '../../../util/texture/layout.js';\n\nconst kSize = 4;\nconst kFormat = 'rgba8unorm' as const;\n\nclass F extends GPUTest {\n  createShaderModule(attachmentCount: number = 1): GPUShaderModule {\n    let locations = '';\n    let outputs = '';\n    for (let i = 0; i < attachmentCount; i++) {\n      locations = locations + `@location(${i}) color${i} : vec4f, \\n`;\n      outputs = outputs + `output.color${i} = vec4f(0.0, 1.0, 0.0, 1.0);\\n`;\n    }\n\n    return this.device.createShaderModule({\n      code: `\n        struct Output {\n          ${locations}\n        }\n\n        @vertex\n        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n          var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n              // Triangle is slightly extended so its edge doesn't cut through pixel centers.\n              vec2<f32>(-1.0, 1.01),\n              vec2<f32>(1.01, -1.0),\n              vec2<f32>(-1.0, -1.0));\n          return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        }\n\n        @fragment\n        fn main_fs() -> Output {\n          var output : Output;\n          ${outputs}\n          return output;\n        }\n        `,\n    });\n  }\n\n  getBufferSizeAndOffset(\n    attachmentWidth: number,\n    attachmentHeight: number,\n    attachmentCount: number\n  ): { bufferSize: number; bufferOffset: number } {\n    const bufferSize =\n      (attachmentCount * attachmentHeight - 1) * kBytesPerRowAlignment + attachmentWidth * 4;\n    const bufferOffset = attachmentCount > 1 ? attachmentHeight * kBytesPerRowAlignment : 0;\n    return { bufferSize, bufferOffset };\n  }\n\n  checkAttachmentResult(\n    attachmentWidth: number,\n    attachmentHeight: number,\n    attachmentCount: number,\n    buffer: GPUBuffer\n  ) {\n    const { bufferSize, bufferOffset } = this.getBufferSizeAndOffset(\n      attachmentWidth,\n      attachmentHeight,\n      attachmentCount\n    );\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < attachmentCount; i++) {\n      for (let j = 0; j < attachmentHeight; j++) {\n        for (let k = 0; k < attachmentWidth; k++) {\n          expectedData[i * bufferOffset + j * 256 + k * 4] = k <= j ? 0x00 : 0xff;\n          expectedData[i * bufferOffset + j * 256 + k * 4 + 1] = k <= j ? 0xff : 0x00;\n          expectedData[i * bufferOffset + j * 256 + k * 4 + 2] = 0x00;\n          expectedData[i * bufferOffset + j * 256 + k * 4 + 3] = 0xff;\n        }\n      }\n    }\n\n    this.expectGPUBufferValuesEqual(buffer, expectedData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('one_color_attachment,mip_levels')\n  .desc(\n    `\n  Render to a 3d texture slice with mip levels.\n  `\n  )\n  .params(u => u.combine('mipLevel', [0, 1, 2]).combine('depthSlice', [0, 1]))\n  .fn(t => {\n    const { mipLevel, depthSlice } = t.params;\n\n    const texture = t.createTextureTracked({\n      size: [kSize << mipLevel, kSize << mipLevel, 2 << mipLevel],\n      dimension: '3d',\n      format: kFormat,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const { bufferSize } = t.getBufferSizeAndOffset(kSize, kSize, 1);\n\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const module = t.createShaderModule();\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module },\n      fragment: {\n        module,\n        targets: [{ format: kFormat }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView({\n            baseMipLevel: mipLevel,\n            mipLevelCount: 1,\n          }),\n          depthSlice,\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n    encoder.copyTextureToBuffer(\n      { texture, mipLevel, origin: { x: 0, y: 0, z: depthSlice } },\n      { buffer, bytesPerRow: 256 },\n      { width: kSize, height: kSize, depthOrArrayLayers: 1 }\n    );\n    t.device.queue.submit([encoder.finish()]);\n\n    t.checkAttachmentResult(kSize, kSize, 1, buffer);\n  });\n\ng.test('multiple_color_attachments,same_mip_level')\n  .desc(\n    `\n  Render to the different slices of 3d texture in multiple color attachments.\n  - Same 3d texture with different slices at same mip level\n  - Different 3d textures with same slice at same mip level\n  `\n  )\n  .params(u =>\n    u\n      .combine('sameTexture', [true, false])\n      .beginSubcases()\n      .combine('samePass', [true, false])\n      .combine('mipLevel', [0, 1])\n  )\n  .fn(t => {\n    const { sameTexture, samePass, mipLevel } = t.params;\n\n    const formatByteCost = kTextureFormatInfo[kFormat].colorRender.byteCost;\n    const maxAttachmentCountPerSample = Math.trunc(\n      t.device.limits.maxColorAttachmentBytesPerSample / formatByteCost\n    );\n    const attachmentCount = Math.min(\n      maxAttachmentCountPerSample,\n      t.device.limits.maxColorAttachments\n    );\n\n    const descriptor = {\n      size: [kSize << mipLevel, kSize << mipLevel, (1 << attachmentCount) << mipLevel],\n      dimension: '3d',\n      format: kFormat,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    } as const;\n\n    const texture = t.createTextureTracked(descriptor);\n\n    const textures: GPUTexture[] = [];\n    const colorAttachments: GPURenderPassColorAttachment[] = [];\n    for (let i = 0; i < attachmentCount; i++) {\n      if (sameTexture) {\n        textures.push(texture);\n      } else {\n        const diffTexture = t.createTextureTracked(descriptor);\n        textures.push(diffTexture);\n      }\n\n      const colorAttachment = {\n        view: textures[i].createView({\n          baseMipLevel: mipLevel,\n          mipLevelCount: 1,\n        }),\n        depthSlice: sameTexture ? i : 0,\n        clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n      } as const;\n\n      colorAttachments.push(colorAttachment);\n    }\n\n    const encoder = t.device.createCommandEncoder();\n\n    if (samePass) {\n      const module = t.createShaderModule(attachmentCount);\n\n      const pipeline = t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: { module },\n        fragment: {\n          module,\n          targets: new Array<GPUColorTargetState>(attachmentCount).fill({ format: kFormat }),\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n\n      const pass = encoder.beginRenderPass({ colorAttachments });\n      pass.setPipeline(pipeline);\n      pass.draw(3);\n      pass.end();\n    } else {\n      const module = t.createShaderModule();\n\n      const pipeline = t.device.createRenderPipeline({\n        layout: 'auto',\n        vertex: { module },\n        fragment: {\n          module,\n          targets: [{ format: kFormat }],\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n\n      for (let i = 0; i < attachmentCount; i++) {\n        const pass = encoder.beginRenderPass({ colorAttachments: [colorAttachments[i]] });\n        pass.setPipeline(pipeline);\n        pass.draw(3);\n        pass.end();\n      }\n    }\n\n    const { bufferSize, bufferOffset } = t.getBufferSizeAndOffset(kSize, kSize, attachmentCount);\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    for (let i = 0; i < attachmentCount; i++) {\n      encoder.copyTextureToBuffer(\n        {\n          texture: textures[i],\n          mipLevel,\n          origin: { x: 0, y: 0, z: sameTexture ? i : 0 },\n        },\n        { buffer, bytesPerRow: 256, offset: bufferOffset * i },\n        { width: kSize, height: kSize, depthOrArrayLayers: 1 }\n      );\n    }\n\n    t.device.queue.submit([encoder.finish()]);\n\n    t.checkAttachmentResult(kSize, kSize, attachmentCount, buffer);\n  });\n\ng.test('multiple_color_attachments,same_slice_with_diff_mip_levels')\n  .desc(\n    `\n  Render to the same slice of a 3d texture at different mip levels in multiple color attachments.\n  - For texture size with 1x1xN, the same depth slice of different mip levels can be rendered.\n  `\n  )\n  .params(u => u.combine('depthSlice', [0, 1]))\n  .fn(t => {\n    const { depthSlice } = t.params;\n\n    const kBaseSize = 1;\n\n    const formatByteCost = kTextureFormatInfo[kFormat].colorRender.byteCost;\n    const maxAttachmentCountPerSample = Math.trunc(\n      t.device.limits.maxColorAttachmentBytesPerSample / formatByteCost\n    );\n    const attachmentCount = Math.min(\n      maxAttachmentCountPerSample,\n      t.device.limits.maxColorAttachments\n    );\n\n    const module = t.createShaderModule(attachmentCount);\n\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module },\n      fragment: {\n        module,\n        targets: new Array<GPUColorTargetState>(attachmentCount).fill({ format: kFormat }),\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n\n    const texture = t.createTextureTracked({\n      size: [kBaseSize, kBaseSize, (depthSlice + 1) << attachmentCount],\n      dimension: '3d',\n      format: kFormat,\n      mipLevelCount: attachmentCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const colorAttachments: GPURenderPassColorAttachment[] = [];\n    for (let i = 0; i < attachmentCount; i++) {\n      const colorAttachment = {\n        view: texture.createView({\n          baseMipLevel: i,\n          mipLevelCount: 1,\n        }),\n        depthSlice,\n        clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n      } as const;\n\n      colorAttachments.push(colorAttachment);\n    }\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = encoder.beginRenderPass({ colorAttachments });\n    pass.setPipeline(pipeline);\n    pass.draw(3);\n    pass.end();\n\n    const { bufferSize, bufferOffset } = t.getBufferSizeAndOffset(\n      kBaseSize,\n      kBaseSize,\n      attachmentCount\n    );\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    for (let i = 0; i < attachmentCount; i++) {\n      encoder.copyTextureToBuffer(\n        { texture, mipLevel: i, origin: { x: 0, y: 0, z: depthSlice } },\n        { buffer, bytesPerRow: 256, offset: bufferOffset * i },\n        { width: kBaseSize, height: kBaseSize, depthOrArrayLayers: 1 }\n      );\n    }\n\n    t.device.queue.submit([encoder.finish()]);\n\n    t.checkAttachmentResult(kBaseSize, kBaseSize, attachmentCount, buffer);\n  });\n"],"mappings":"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"}