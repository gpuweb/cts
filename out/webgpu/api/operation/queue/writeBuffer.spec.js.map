{"version":3,"file":"writeBuffer.spec.js","names":["description","makeTestGroup","memcpy","range","GPUTest","align","kTypedArrays","F","calculateRequiredBufferSize","writes","bufferSize","bufferOffset","data","arrayType","useArrayBuffer","dataOffset","dataSize","TypedArrayConstructor","globalThis","bytesPerElement","BYTES_PER_ELEMENT","bytesWritten","length","Math","min","requiredBufferSize","max","testWriteBuffer","expectedData","Uint8Array","fill","buffer","makeBufferWithContents","GPUBufferUsage","COPY_SRC","COPY_DST","writeData","writeSrc","queue","writeBuffer","src","start","dst","debug","join","expectGPUBufferValuesEqual","g","kTestData","i","test","desc","params","u","combine","fn","t","paramsSubcasesOnly","Uint32Array"],"sources":["../../../../../src/webgpu/api/operation/queue/writeBuffer.spec.ts"],"sourcesContent":["export const description = 'Operation tests for GPUQueue.writeBuffer()';\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { memcpy, range } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { align } from '../../../util/math.js';\n\nconst kTypedArrays = [\n  'Uint8Array',\n  'Uint16Array',\n  'Uint32Array',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Float32Array',\n  'Float64Array',\n] as const;\n\ntype WriteBufferSignature = {\n  bufferOffset: number;\n  data: readonly number[];\n  arrayType: (typeof kTypedArrays)[number];\n  useArrayBuffer: boolean;\n  dataOffset?: number; // In elements when useArrayBuffer === false, bytes otherwise\n  dataSize?: number; // In elements when useArrayBuffer === false, bytes otherwise\n};\n\nclass F extends GPUTest {\n  calculateRequiredBufferSize(writes: WriteBufferSignature[]): number {\n    let bufferSize = 0;\n    // Calculate size of final buffer\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n\n      // When passing data as an ArrayBuffer, dataOffset and dataSize use byte instead of number of\n      // elements. bytesPerElement is used to convert dataOffset and dataSize from elements to bytes\n      // when useArrayBuffer === false.\n      const bytesPerElement = useArrayBuffer ? 1 : TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n      // Calculate the number of bytes written to the buffer. data is always an array of elements.\n      let bytesWritten =\n        data.length * TypedArrayConstructor.BYTES_PER_ELEMENT - (dataOffset || 0) * bytesPerElement;\n\n      if (dataSize) {\n        // When defined, dataSize clamps the number of bytes written\n        bytesWritten = Math.min(bytesWritten, dataSize * bytesPerElement);\n      }\n\n      // The minimum buffer size required for the write to succeed is the number of bytes written +\n      // the bufferOffset\n      const requiredBufferSize = bufferOffset + bytesWritten;\n\n      // Find the largest required size by all writes\n      bufferSize = Math.max(bufferSize, requiredBufferSize);\n    }\n    // writeBuffer requires buffers to be a multiple of 4\n    return align(bufferSize, 4);\n  }\n\n  testWriteBuffer(...writes: WriteBufferSignature[]) {\n    const bufferSize = this.calculateRequiredBufferSize(writes);\n\n    // Initialize buffer to non-zero data (0xff) for easier debug.\n    const expectedData = new Uint8Array(bufferSize).fill(0xff);\n\n    const buffer = this.makeBufferWithContents(\n      expectedData,\n      GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    );\n\n    for (const { bufferOffset, data, arrayType, useArrayBuffer, dataOffset, dataSize } of writes) {\n      const TypedArrayConstructor = globalThis[arrayType];\n      const writeData = new TypedArrayConstructor(data);\n      const writeSrc = useArrayBuffer ? writeData.buffer : writeData;\n      this.queue.writeBuffer(buffer, bufferOffset, writeSrc, dataOffset, dataSize);\n      memcpy(\n        { src: writeSrc, start: dataOffset, length: dataSize },\n        { dst: expectedData, start: bufferOffset }\n      );\n    }\n\n    this.debug(`expectedData: [${expectedData.join(', ')}]`);\n    this.expectGPUBufferValuesEqual(buffer, expectedData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kTestData = range<number>(16, i => i);\n\ng.test('array_types')\n  .desc('Tests that writeBuffer correctly handles different TypedArrays and ArrayBuffer.')\n  .params(u =>\n    u //\n      .combine('arrayType', kTypedArrays)\n      .combine('useArrayBuffer', [false, true])\n  )\n  .fn(t => {\n    const { arrayType, useArrayBuffer } = t.params;\n    const dataOffset = 1;\n    const dataSize = 8;\n    t.testWriteBuffer({\n      bufferOffset: 0,\n      arrayType,\n      data: kTestData,\n      dataOffset,\n      dataSize,\n      useArrayBuffer,\n    });\n  });\n\ng.test('multiple_writes_at_different_offsets_and_sizes')\n  .desc(\n    `\nTests that writeBuffer currently handles different offsets and writes. This includes:\n- Non-overlapping TypedArrays and ArrayLists\n- Overlapping TypedArrays and ArrayLists\n- Writing zero data\n- Writing on zero sized buffers\n- Unaligned source\n- Multiple overlapping writes with decreasing sizes\n    `\n  )\n  .paramsSubcasesOnly([\n    {\n      // Concatenate 2 Uint32Arrays\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 2,\n          dataSize: 2,\n        }, // [2, 3]\n        {\n          bufferOffset: 2 * Uint32Array.BYTES_PER_ELEMENT,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n          dataOffset: 0,\n          dataSize: 2,\n        }, // [0, 1]\n      ], // Expected [2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\n    },\n    {\n      // Concatenate 2 Uint8Arrays\n      writes: [\n        { bufferOffset: 0, data: [0, 1, 2, 3], arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [4, 5, 6, 7], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5, 6, 7]\n    },\n    {\n      // Overlap in the middle\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 4, data: [0], arrayType: 'Uint32Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 0, 0 ,0 ,0, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Overlapping arrayLists\n      writes: [\n        {\n          bufferOffset: 0,\n          data: kTestData,\n          arrayType: 'Uint32Array',\n          useArrayBuffer: true,\n          dataOffset: 2,\n          dataSize: 4 * Uint32Array.BYTES_PER_ELEMENT,\n        },\n        { bufferOffset: 4, data: [0x04030201], arrayType: 'Uint32Array', useArrayBuffer: true },\n      ], // Expected [0, 0, 1, 0, 1, 2, 3, 4, 0, 0, 3, 0, 0, 0, 4, 0]\n    },\n    {\n      // Write over with empty buffer\n      writes: [\n        { bufferOffset: 0, data: kTestData, arrayType: 'Uint8Array', useArrayBuffer: false },\n        { bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Zero buffer\n      writes: [{ bufferOffset: 0, data: [], arrayType: 'Uint8Array', useArrayBuffer: false }],\n    }, // Expected []\n    {\n      // Unaligned source\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x77, ...kTestData],\n          arrayType: 'Uint8Array',\n          useArrayBuffer: false,\n          dataOffset: 1,\n        },\n      ], // Expected [0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    {\n      // Multiple overlapping writes\n      writes: [\n        {\n          bufferOffset: 0,\n          data: [0x05050505, 0x05050505, 0x05050505, 0x05050505, 0x05050505],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x04040404, 0x04040404, 0x04040404, 0x04040404],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x03030303, 0x03030303, 0x03030303],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x02020202, 0x02020202],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n        {\n          bufferOffset: 0,\n          data: [0x01010101],\n          arrayType: 'Uint32Array',\n          useArrayBuffer: false,\n        },\n      ], // Expected [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]\n    },\n  ] as const)\n  .fn(t => {\n    t.testWriteBuffer(...t.params.writes);\n  });\n"],"mappings":"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"}