{"version":3,"file":"filter_mode.spec.js","names":["description","makeTestGroup","kAddressModes","kMipmapFilterModes","kRenderableColorTextureFormats","kTextureFormatInfo","GPUTest","TextureTestMixin","getTextureCopyLayout","TexelView","kCheckerTextureSize","kCheckerTextureData","R","G","B","A","FilterModeTest","runFilterRenderPipeline","sampler","module","format","renderSize","vertexCount","instanceCount","sampleTexture","createTextureFromTexelView","fromTexelsAsColors","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","renderTexture","createTextureTracked","RENDER_ATTACHMENT","COPY_SRC","pipeline","device","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","bindgroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","setBindGroup","draw","end","queue","submit","finish","g","kNearestRenderSize","kNearestRenderDim","kNearestURepeatVRepeat","kNearestURepeatVClamped","kNearestURepeatVMirror","kNearestUClampedVRepeat","kNearestUClampedVClamped","kNearestUClampedVMirror","kNearestUMirrorVRepeat","kNearestUMirrorVClamped","kNearestUMirrorVMirror","kLinearRenderSize","kLinearRenderDim","kLinearURepeatVRepeat","kLinearURepeatVClamped","kLinearURepeatVMirror","kLinearUClampedVRepeat","kLinearUClampedVClamped","kLinearUClampedVMirror","kLinearUMirrorVRepeat","kLinearUMirrorVClamped","kLinearUMirrorVMirror","expectedNearestColors","addressModeU","addressModeV","expectedColors","c","expectedLinearColors","filterMode","test","desc","params","u","combine","filter","t","color","type","beginSubcases","beforeAllSubcases","skipIfTextureFormatNotSupported","selectDeviceOrSkipTestCase","fn","createSampler","magFilter","createShaderModule","code","reduce","sink","current","render","expectTexelViewComparisonIsOkInTexture","texture","minFilter","kTextureSize","kRenderSize","mipmapFilter","createTextureFromTexelViewsMultipleMipmaps","_coords","buffer","copyWholeTextureToNewBufferSimple","expectGPUBufferValuesPassCheck","actual","fromTextureDataByReference","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","Ri","z","Rj","Error","toString","width","height","depthOrArrayLayers","changes","undefined","srcByteOffset","Uint8Array","typedLength"],"sources":["../../../../../src/webgpu/api/operation/sampling/filter_mode.spec.ts"],"sourcesContent":["export const description = `\nTests the behavior of different filtering modes in minFilter/magFilter/mipmapFilter.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kAddressModes, kMipmapFilterModes } from '../../../capability_info.js';\nimport {\n  EncodableTextureFormat,\n  kRenderableColorTextureFormats,\n  kTextureFormatInfo,\n} from '../../../format_info.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\n// Simple checkerboard 2x2 texture used as a base for the sampling.\nconst kCheckerTextureSize = 2;\nconst kCheckerTextureData = [\n  { R: 1.0, G: 1.0, B: 1.0, A: 1.0 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 1.0 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 1.0 },\n  { R: 1.0, G: 1.0, B: 1.0, A: 1.0 },\n];\n\nclass FilterModeTest extends TextureTestMixin(GPUTest) {\n  runFilterRenderPipeline(\n    sampler: GPUSampler,\n    module: GPUShaderModule,\n    format: EncodableTextureFormat,\n    renderSize: number[],\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    const sampleTexture = this.createTextureFromTexelView(\n      TexelView.fromTexelsAsColors(format, coord => {\n        const id = coord.x + coord.y * kCheckerTextureSize;\n        return kCheckerTextureData[id];\n      }),\n      {\n        size: [kCheckerTextureSize, kCheckerTextureSize],\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n      }\n    );\n    const renderTexture = this.createTextureTracked({\n      format,\n      size: renderSize,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    const pipeline = this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs_main',\n        targets: [{ format }],\n      },\n    });\n    const bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: sampler },\n        { binding: 1, resource: sampleTexture.createView() },\n      ],\n    });\n    const commandEncoder = this.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, bindgroup);\n    renderPass.draw(vertexCount, instanceCount);\n    renderPass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    return renderTexture;\n  }\n}\n\nexport const g = makeTestGroup(FilterModeTest);\n\n/* eslint-disable prettier/prettier */\n\n/* For filter mode 'nearest', we need to check a 6x6 of pixels because 4x4s are identical when using\n * address mode 'clamp-to-edge' and 'mirror-repeat'. The minFilter and magFilter tests are setup so\n * that they both render the same results. (See the respective test for details.) The following\n * table shows the expected results:\n *                                                u\n *\n *                               repeat     clamp-to-edge  mirror-repeat\n *\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *             repeat        │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *  v       clamp-to-edge    │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *          mirror-repeat    │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n*/\nconst kNearestRenderSize = 6;\nconst kNearestRenderDim = [kNearestRenderSize, kNearestRenderSize];\nconst kNearestURepeatVRepeat = [\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n];\nconst kNearestURepeatVClamped = [\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n];\nconst kNearestURepeatVMirror = [\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n];\nconst kNearestUClampedVRepeat = [\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n];\nconst kNearestUClampedVClamped = [\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n];\nconst kNearestUClampedVMirror = [\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n];\nconst kNearestUMirrorVRepeat = [\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n];\nconst kNearestUMirrorVClamped = [\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n];\nconst kNearestUMirrorVMirror = [\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n];\n\n/* For filter mode 'linear', the tests samples 16 points (to create a 4x4) on what the effective 8x8\n * expanded texture via the address modes looks like (see table below for what those look like). The\n * sample points are selected such that no combination of address modes result in the same render.\n * There is exactly one sample point in each sub 2x2 of the 8x8 texture, thereby yielding the 4x4\n * result. Note that sampling from the 8x8 texture instead of the 6x6 texture is necessary because\n * that allows us to keep the results in powers of 2 to minimize floating point errors on different\n * backends.\n *\n * The 8x8 effective textures:\n *                                                  u\n *\n *                                repeat          clamp-to-edge      mirror-repeat\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *             repeat        │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *  v       clamp-to-edge    │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *          mirror-repeat    │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *\n *\n * Sample points:\n *   The sample points are always at a 25% corner of a pixel such that the contributions come from\n *   the 2x2 (doubly outlined) with ratios 1/16, 3/16, or 9/16.\n *                                    ╔══╤══╦══╤══╦══╤══╦══╤══╗\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │▘ ║ ▝│  ║  │▘ ║ ▝│  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │▘ ║ ▝│  ║  │▘ ║ ▝│  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │▖ ║ ▗│  ║  │▖ ║ ▗│  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │▖ ║ ▗│  ║  │▖ ║ ▗│  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╚══╧══╩══╧══╩══╧══╩══╧══╝\n */\nconst kLinearRenderSize = 4;\nconst kLinearRenderDim = [kLinearRenderSize, kLinearRenderSize];\nconst kLinearURepeatVRepeat = [\n  [10, 6, 10, 6],\n  [10, 6, 10, 6],\n  [6, 10, 6, 10],\n  [6, 10, 6, 10],\n];\nconst kLinearURepeatVClamped = [\n  [12, 4, 12, 4],\n  [12, 4, 12, 4],\n  [4, 12, 4, 12],\n  [4, 12, 4, 12],\n];\nconst kLinearURepeatVMirror = [\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n];\nconst kLinearUClampedVRepeat = [\n  [12, 12, 4, 4],\n  [12, 12, 4, 4],\n  [4, 4, 12, 12],\n  [4, 4, 12, 12],\n];\nconst kLinearUClampedVClamped = [\n  [16, 16, 0, 0],\n  [16, 16, 0, 0],\n  [0, 0, 16, 16],\n  [0, 0, 16, 16],\n];\nconst kLinearUClampedVMirror = [\n  [0, 0, 16, 16],\n  [16, 16, 0, 0],\n  [0, 0, 16, 16],\n  [16, 16, 0, 0],\n];\nconst kLinearUMirrorVRepeat = [\n  [4, 12, 4, 12],\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n  [12, 4, 12, 4],\n];\nconst kLinearUMirrorVClamped = [\n  [0, 16, 0, 16],\n  [0, 16, 0, 16],\n  [16, 0, 16, 0],\n  [16, 0, 16, 0],\n];\nconst kLinearUMirrorVMirror = [\n  [16, 0, 16, 0],\n  [0, 16, 0, 16],\n  [16, 0, 16, 0],\n  [0, 16, 0, 16],\n];\n\n/* eslint-enable prettier/prettier */\n\nfunction expectedNearestColors(\n  format: EncodableTextureFormat,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  let expectedColors: number[][];\n  switch (addressModeU) {\n    case 'clamp-to-edge': {\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestUClampedVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestUClampedVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestUClampedVMirror;\n          break;\n      }\n      break;\n    }\n    case 'repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestURepeatVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestURepeatVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestURepeatVMirror;\n          break;\n      }\n      break;\n    case 'mirror-repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestUMirrorVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestUMirrorVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestUMirrorVMirror;\n          break;\n      }\n      break;\n  }\n  return TexelView.fromTexelsAsColors(format, coord => {\n    const c = expectedColors[coord.y][coord.x];\n    return { R: c, G: c, B: c, A: 1.0 };\n  });\n}\nfunction expectedLinearColors(\n  format: EncodableTextureFormat,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  let expectedColors: number[][];\n  switch (addressModeU) {\n    case 'clamp-to-edge': {\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearUClampedVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearUClampedVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearUClampedVMirror;\n          break;\n      }\n      break;\n    }\n    case 'repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearURepeatVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearURepeatVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearURepeatVMirror;\n          break;\n      }\n      break;\n    case 'mirror-repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearUMirrorVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearUMirrorVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearUMirrorVMirror;\n          break;\n      }\n      break;\n  }\n  return TexelView.fromTexelsAsColors(format, coord => {\n    const c = expectedColors[coord.y][coord.x];\n    return { R: c / 16, G: c / 16, B: c / 16, A: 1.0 };\n  });\n}\nfunction expectedColors(\n  format: EncodableTextureFormat,\n  filterMode: GPUFilterMode,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  switch (filterMode) {\n    case 'nearest':\n      return expectedNearestColors(format, addressModeU, addressModeV);\n    case 'linear':\n      return expectedLinearColors(format, addressModeU, addressModeV);\n  }\n}\n\n/* For the magFilter tests, each rendered pixel is an instanced quad such that the center of the\n * quad coincides with the center of the pixel. The uv coordinates for each quad are shifted\n * according to the test so that the center of the quad is at the point we want to sample.\n *\n * For the grid offset logic, see this codelab for reference:\n *   https://codelabs.developers.google.com/your-first-webgpu-app#4\n */\n\n/* The following diagram shows the UV shift (almost to scale) for what the pixel at cell (0,0) looks\n * like w.r.t the UV of the texture if we just mapped the entire 2x2 texture to the quad. Note that\n * the square representing the mapped location on the bottom left is actually slighly smaller than a\n * pixel in order to ensure that we are magnifying the texture and hence using the magFilter. It\n * should be fairly straightforwards to derive that for each pixel, we are shifting (.5, -.5) from\n * the picture.\n *\n *                    ┌─┬─┬─┬─┬─┬─┐\n *                    ├─┼─┼─┼─┼─┼─┤ (0,0) (1,0)\n *                    ├─┼─╔═╪═╗─┼─┤    ╔═══╗\n *                    ├─┼─╫─┼─╫─┼─┤    ║─┼─║\n *                    ├─┼─╚═╪═╝─┼─┤    ╚═══╝       (-.875,1.625) (-.625,1.625)\n *                    ╔═╗─┼─┼─┼─┼─┤ (0,1) (1,1)                ╔═╗\n *                    ╚═╝─┴─┴─┴─┴─┘                            ╚═╝\n *                                                 (-.875,1.875) (-.625,1.875)\n */\ng.test('magFilter,nearest')\n  .desc(\n    `\n  Test that for filterable formats, magFilter 'nearest' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kRenderableColorTextureFormats)\n      .filter(t => {\n        return (\n          kTextureFormatInfo[t.format].color.type === 'float' ||\n          kTextureFormatInfo[t.format].color.type === 'unfilterable-float'\n        );\n      })\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    if (kTextureFormatInfo[t.params.format].color.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      magFilter: 'nearest',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kNearestRenderSize}, ${kNearestRenderSize});\n        const posBases = array(\n          vec2f(1, 1), vec2f(1, -1), vec2f(-1, -1),\n          vec2f(1, 1), vec2f(-1, -1), vec2f(-1, 1),\n        );\n        const uvBases = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of instance plane.\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n        let cellOffset = cell / grid * 2;\n        let pos = (posBases[vi] + 1) / grid - 1 + cellOffset;\n\n        // Compute the offset of the UVs.\n        let uvBase = uvBases[vi] * 0.25 + vec2f(-0.875, 1.625);\n        const uvPerPixelOffset = vec2f(0.5, -0.5);\n        return VertexOut(vec4f(pos, 0.0, 1.0), uvBase + uvPerPixelOffset * cell);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kNearestRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kNearestRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    t.expectTexelViewComparisonIsOkInTexture(\n      { texture: render },\n      expectedColors(format, 'nearest', addressModeU, addressModeV),\n      kNearestRenderDim\n    );\n  });\n\n/* The following diagram shows the UV shift (almost to scale) for what the pixel at cell (0,0) (the\n * dark square) looks like w.r.t the UV of the texture if we just mapped the entire 2x2 texture to\n * the quad. The other small squares represent the other locations that we are sampling the texture\n * at. The offsets are defined in the shader.\n *\n *             ┌────┬────┬────┬────┬────┬────┬────┬────┐\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │□   │   □│    │    │□   │   □│    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │       (0,0)     (1,0)\n *             ├────┼────┼────╔════╪════╗────┼────┼────┤         ╔═════════╗\n *             │    │□   │   □║    │    ║□   │   □│    │         ║    │    ║\n *             │    │    │    ║    │    ║    │    │    │         ║    │    ║\n *             ├────┼────┼────╫────┼────╫────┼────┼────┤         ║────┼────║\n *             │    │    │    ║    │    ║    │    │    │         ║    │    ║\n *             │    │□   │   □║    │    ║□   │   □│    │         ║    │    ║\n *             ├────┼────┼────╚════╪════╝────┼────┼────┤         ╚═════════╝\n *             │    │    │    │    │    │    │    │    │       (0,1)     (1,1)\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │    (-1,1.75) (-.75,1.75)\n *             │    │■   │   □│    │    │□   │   □│    │             ■\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤       (-1,2) (-.75,2)\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             └────┴────┴────┴────┴────┴────┴────┴────┘\n */\ng.test('magFilter,linear')\n  .desc(\n    `\n  Test that for filterable formats, magFilter 'linear' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kRenderableColorTextureFormats)\n      .filter(t => {\n        return (\n          kTextureFormatInfo[t.format].color.type === 'float' ||\n          kTextureFormatInfo[t.format].color.type === 'unfilterable-float'\n        );\n      })\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    if (kTextureFormatInfo[t.params.format].color.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      magFilter: 'linear',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kLinearRenderSize}, ${kLinearRenderSize});\n        const posBases = array(\n          vec2f(1, 1), vec2f(1, -1), vec2f(-1, -1),\n          vec2f(1, 1), vec2f(-1, -1), vec2f(-1, 1),\n        );\n        const uvBases = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of instance plane.\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n        let cellOffset = cell / grid * 2;\n        let pos = (posBases[vi] + 1) / grid - 1 + cellOffset;\n\n        // Compute the offset of the UVs.\n        const uOffsets = array(0., 0.75, 2., 2.75);\n        const vOffsets = array(0., 1., 1.75, 2.75);\n        let uvBase = uvBases[vi] * 0.25 + vec2f(-1., 1.75);\n        let uvPixelOffset = vec2f(uOffsets[u32(cell.x)], -vOffsets[u32(cell.y)]);\n        return VertexOut(vec4f(pos, 0.0, 1.0), uvBase + uvPixelOffset);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kLinearRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kLinearRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    t.expectTexelViewComparisonIsOkInTexture(\n      { texture: render },\n      expectedColors(format, 'linear', addressModeU, addressModeV),\n      kLinearRenderDim\n    );\n  });\n\n/* For the minFilter tests, each rendered pixel is a small instanced quad that is UV mapped such\n * that it is either the 6x6 or 8x8 textures from above. Each quad in each cell is then offsetted\n * and scaled so that the target sample point coincides with the center of the pixel and the texture\n * is significantly smaller than the pixel to force minFilter mode.\n *\n * For the grid offset logic, see this codelab for reference:\n *   https://codelabs.developers.google.com/your-first-webgpu-app#4\n */\n\n/* The following diagram depicts a single pixel and the sub-pixel sized 6x6 textured quad. The\n * distances shown in the diagram are pre-grid transformation and relative to the quad. Notice that\n * for cell (0,0) marked with an x, we need to offset the center by (5/12,5/12), and per cell, the\n * offset is (-1/6, -1/6).\n *\n *\n *              ┌───────────────────────────────────────────────┐\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │           ┌───┬───┬───┬───┬───┬───┐           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───┼───┼───┼───┤           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───┼───┼───┼───┤           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───x───┼───┼───┤           │         ┐\n *              │           │   │   │   │   │   │   │           │         │\n *              │           ├───┼───┼───┼───┼───┼───┤           │         │ 5/12\n *              │           │   │   │   │   │   │   │           │ ┐       │\n *              │           ├───┼───┼───┼───┼───┼───┤           │ │ 1/6   │\n *              │           │ x │   │   │   │   │   │           │ ┘       ┘\n *              │           └───┴───┴───┴───┴───┴───┘           │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              └───────────────────────────────────────────────┘\n */\ng.test('minFilter,nearest')\n  .desc(\n    `\n  Test that for filterable formats, minFilter 'nearest' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kRenderableColorTextureFormats)\n      .filter(t => {\n        return (\n          kTextureFormatInfo[t.format].color.type === 'float' ||\n          kTextureFormatInfo[t.format].color.type === 'unfilterable-float'\n        );\n      })\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    if (kTextureFormatInfo[t.params.format].color.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      minFilter: 'nearest',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kNearestRenderSize}, ${kNearestRenderSize});\n        const posBases = array(\n          vec2f(.5, .5), vec2f(.5, -.5), vec2f(-.5, -.5),\n          vec2f(.5, .5), vec2f(-.5, -.5), vec2f(-.5, .5),\n        );\n        // Choose UVs so that the quad ends up being the 6x6 texture.\n        const uvBases = array(\n          vec2f(2., -1.), vec2f(2., 2.), vec2f(-1., 2.),\n          vec2f(2., -1.), vec2f(-1., 2.), vec2f(-1., -1.),\n        );\n\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n\n        // Compute the offset of instance plane (pre-grid transformation).\n        const constantPlaneOffset = vec2f(5. / 12., 5. / 12.);\n        const perPixelOffset = vec2f(1. / 6., 1. / 6.);\n        let posBase = posBases[vi] + constantPlaneOffset - perPixelOffset * cell;\n\n        // Apply the grid transformation.\n        let cellOffset = cell / grid * 2;\n        let absPos = (posBase + 1) / grid - 1 + cellOffset;\n\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uvBases[vi]);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kNearestRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kNearestRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    t.expectTexelViewComparisonIsOkInTexture(\n      { texture: render },\n      expectedColors(format, 'nearest', addressModeU, addressModeV),\n      kNearestRenderDim\n    );\n  });\n\n/* The following diagram shows the sub-pixel quad and the relative distances between the sample\n * points and the origin. The pixel is not shown in this diagram but is a 2x bounding box around the\n * quad similar to the one in the diagram for minFilter,nearest above. The dark square is where the\n * cell (0,0) is, and the offsets are all relative to that point.\n *\n *                        11/32\n *                   ┌─────────────┐\n *\n *                     3/16      5/16       3/16\n *                   ┌───────┬───────────┬───────┐\n *\n *             ┌────┬────┬────┬────┬────┬────┬────┬────┐\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │□   │   □│    │    │□   │   □│    │  ┐\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │\n *             │    │    │    │    │    │    │    │    │  │  1/4\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │\n *             │    │□   │   □│    │    │□   │   □│    │  ┤\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────x────┼────┼────┼────┤  │  3/16    ┐\n *             │    │    │    │    │    │    │    │    │  │          │\n *             │    │□   │   □│    │    │□   │   □│    │  ┤          │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │          │\n *             │    │    │    │    │    │    │    │    │  │          │  11/32\n *             │    │    │    │    │    │    │    │    │  │  1/4     │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │          │\n *             │    │    │    │    │    │    │    │    │  │          │\n *             │    │■   │   □│    │    │□   │   □│    │  ┘          ┘\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             └────┴────┴────┴────┴────┴────┴────┴────┘\n */\ng.test('minFilter,linear')\n  .desc(\n    `\n  Test that for filterable formats, minFilter 'linear' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kRenderableColorTextureFormats)\n      .filter(t => {\n        return (\n          kTextureFormatInfo[t.format].color.type === 'float' ||\n          kTextureFormatInfo[t.format].color.type === 'unfilterable-float'\n        );\n      })\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    if (kTextureFormatInfo[t.params.format].color.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      minFilter: 'linear',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kLinearRenderSize}, ${kLinearRenderSize});\n        const posBases = array(\n          vec2f(.5, .5), vec2f(.5, -.5), vec2f(-.5, -.5),\n          vec2f(.5, .5), vec2f(-.5, -.5), vec2f(-.5, .5),\n        );\n        // Choose UVs so that the quad ends up being the 8x8 texture.\n        const uvBases = array(\n          vec2f(2.5, -1.5), vec2f(2.5, 2.5), vec2f(-1.5, 2.5),\n          vec2f(2.5, -1.5), vec2f(-1.5, 2.5), vec2f(-1.5, -1.5),\n        );\n\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n\n        // Compute the offset of instance plane (pre-grid transformation).\n        const constantPlaneOffset = vec2f(11. / 32., 11. / 32.);\n        const xOffsets = array(0., 3. / 16., 1. / 2., 11. / 16.);\n        const yOffsets = array(0., 1. / 4., 7. / 16., 11. / 16.);\n        let pixelOffset = vec2f(xOffsets[u32(cell.x)], yOffsets[u32(cell.y)]);\n        let posBase = posBases[vi] + constantPlaneOffset - pixelOffset;\n\n        // Compute the offset of instance plane.\n        let cellOffset = cell / grid * 2;\n        let absPos = (posBase + 1) / grid - 1 + cellOffset;\n\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uvBases[vi]);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kLinearRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kLinearRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    t.expectTexelViewComparisonIsOkInTexture(\n      { texture: render },\n      expectedColors(format, 'linear', addressModeU, addressModeV),\n      kLinearRenderDim\n    );\n  });\n\ng.test('mipmapFilter')\n  .desc(\n    `\n  Test that for filterable formats, mipmapFilter modes correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - filterMode= {'nearest', 'linear'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kRenderableColorTextureFormats)\n      .filter(t => {\n        return (\n          kTextureFormatInfo[t.format].color.type === 'float' ||\n          kTextureFormatInfo[t.format].color.type === 'unfilterable-float'\n        );\n      })\n      .beginSubcases()\n      .combine('filterMode', kMipmapFilterModes)\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.format);\n    if (kTextureFormatInfo[t.params.format].color.type === 'unfilterable-float') {\n      t.selectDeviceOrSkipTestCase('float32-filterable');\n    }\n  })\n  .fn(t => {\n    const { format, filterMode } = t.params;\n    // Takes a 8x8/4x4 mipmapped texture and renders it on multiple quads with different UVs such\n    // that each instanced quad from left to right emulates moving the quad further and further from\n    // the camera. Each quad is then rendered to a single pixel in a 1-dimensional texture. Since\n    // the 8x8 is fully black and the 4x4 is fully white, we should see the pixels increase in\n    // brightness from left to right when sampling linearly, and jump from black to white when\n    // sampling for the nearest mip level.\n    const kTextureSize = 8;\n    const kRenderSize = 8;\n\n    const sampler = t.device.createSampler({\n      mipmapFilter: filterMode,\n    });\n    const sampleTexture = t.createTextureFromTexelViewsMultipleMipmaps(\n      [\n        TexelView.fromTexelsAsColors(format, () => {\n          return { R: 0.0, G: 0.0, B: 0.0, A: 1.0 };\n        }),\n        TexelView.fromTexelsAsColors(format, _coords => {\n          return { R: 1.0, G: 1.0, B: 1.0, A: 1.0 };\n        }),\n      ],\n      {\n        size: [kTextureSize, 1],\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n      }\n    );\n    const renderTexture = t.createTextureTracked({\n      format,\n      size: [kRenderSize, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kRenderSize}., 1.);\n        const pos = array(\n          vec2f( 1.0,  1.0), vec2f( 1.0, -1.0), vec2f(-1.0, -1.0),\n          vec2f( 1.0,  1.0), vec2f(-1.0, -1.0), vec2f(-1.0,  1.0),\n        );\n        const uv = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of the plane.\n        let cell = vec2f(f32(ii) % grid.x, 0.);\n        let cellOffset = cell / grid * 2;\n        let absPos = (pos[vi] + 1) / grid - 1 + cellOffset;\n        let uvFactor = (1. / 8.) * (1 + (f32(ii) / (grid.x - 1)));\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uv[vi] * uvFactor);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs_main',\n        targets: [{ format }],\n      },\n    });\n    const bindgroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: sampler },\n        { binding: 1, resource: sampleTexture.createView() },\n      ],\n    });\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, bindgroup);\n    renderPass.draw(6, kRenderSize);\n    renderPass.end();\n    t.device.queue.submit([commandEncoder.finish()]);\n\n    // Since mipmap filtering varies across different backends, we verify that the result exhibits\n    // filtered characteristics without strict value equalities via copies to a buffer.\n    const buffer = t.copyWholeTextureToNewBufferSimple(renderTexture, 0);\n    t.expectGPUBufferValuesPassCheck(\n      buffer,\n      actual => {\n        // Convert the buffer to texel view so we can do comparisons.\n        const layout = getTextureCopyLayout(format, '2d', [kRenderSize, 1, 1]);\n        const view = TexelView.fromTextureDataByReference(format, actual, {\n          bytesPerRow: layout.bytesPerRow,\n          rowsPerImage: layout.rowsPerImage,\n          subrectOrigin: [0, 0, 0],\n          subrectSize: [kRenderSize, 1, 1],\n        });\n\n        // We only check the R component for the conditions, since all components should be equal if\n        // specified in the format.\n        switch (filterMode) {\n          case 'linear': {\n            // For 'linear' mode, we check that the resulting 1d image is monotonically increasing.\n            for (let x = 1; x < kRenderSize; x++) {\n              const { R: Ri } = view.color({ x: x - 1, y: 0, z: 0 });\n              const { R: Rj } = view.color({ x, y: 0, z: 0 });\n              if (Ri! >= Rj!) {\n                return Error(\n                  'Linear filtering on mipmaps should be a monotonically increasing sequence:\\n' +\n                    view.toString(\n                      { x: 0, y: 0, z: 0 },\n                      { width: kRenderSize, height: 1, depthOrArrayLayers: 1 }\n                    )\n                );\n              }\n            }\n            break;\n          }\n          case 'nearest': {\n            // For 'nearest' mode, we check that the resulting 1d image changes from 0.0 to 1.0\n            // exactly once.\n            let changes = 0;\n            for (let x = 1; x < kRenderSize; x++) {\n              const { R: Ri } = view.color({ x: x - 1, y: 0, z: 0 });\n              const { R: Rj } = view.color({ x, y: 0, z: 0 });\n              if (Ri! !== Rj!) {\n                changes++;\n              }\n            }\n            if (changes !== 1) {\n              return Error(\n                `Nearest filtering on mipmaps should change exacly once but found (${changes}):\\n` +\n                  view.toString(\n                    { x: 0, y: 0, z: 0 },\n                    { width: kRenderSize, height: 1, depthOrArrayLayers: 1 }\n                  )\n              );\n            }\n            break;\n          }\n        }\n        return undefined;\n      },\n      { srcByteOffset: 0, type: Uint8Array, typedLength: buffer.size }\n    );\n  });\n"],"mappings":"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pB,YAAY;IACZC,YAAY;IACZoB,SAAS,EAAE;EACb,CAAC,CAAC;EACF,MAAMjG,MAAM,GAAGwF,CAAC,CAAClE,MAAM,CAAC4E,kBAAkB,CAAC;IACzCC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6BnC,iBAAkB,KAAIA,iBAAkB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;EACF,MAAM7D,WAAW,GAAG,CAAC;EACrB,MAAMC,aAAa,GAAG6D,gBAAgB,CAACmC,MAAM,CAAC,CAACC,IAAI,EAAEC,OAAO,KAAKD,IAAI,GAAGC,OAAO,CAAC;EAChF,MAAMC,MAAM,GAAGf,CAAC,CAAC1F,uBAAuB;IACtCC,OAAO;IACPC,MAAM;IACNC,MAAM;IACNgE,gBAAgB;IAChB9D,WAAW;IACXC;EACF,CAAC;EACDoF,CAAC,CAACgB,sCAAsC;IACtC,EAAEC,OAAO,EAAEF,MAAM,CAAC,CAAC;IACnBzB,cAAc,CAAC7E,MAAM,EAAE,QAAQ,EAAE2E,YAAY,EAAEC,YAAY,CAAC;IAC5DZ;EACF,CAAC;AACH,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,CAAC,CAAC8B,IAAI,CAAC,mBAAmB,CAAC;AACxBC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAErG,8BAA8B,CAAC;AACjDsG,MAAM,CAAC,CAAAC,CAAC,KAAI;EACX;IACEtG,kBAAkB,CAACs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"}