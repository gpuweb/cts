{"version":3,"file":"filter_mode.spec.js","names":["description","makeTestGroup","kAddressModes","kMipmapFilterModes","getTextureFormatType","isTextureFormatColorRenderable","kPossibleColorRenderableTextureFormats","AllFeaturesMaxLimitsGPUTest","ttu","getTextureCopyLayout","TexelView","kCheckerTextureSize","kCheckerTextureData","R","G","B","A","kPossiblyRenderablePossiblyFilterableColorTextureFormats","filter","format","FilterModeTest","runFilterRenderPipeline","sampler","module","renderSize","vertexCount","instanceCount","renderTargetFormat","device","sampleTexture","createTextureFromTexelView","fromTexelsAsColors","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","renderTexture","createTextureTracked","RENDER_ATTACHMENT","COPY_SRC","pipeline","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","bindgroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","setBindGroup","draw","end","queue","submit","finish","texture","g","kNearestRenderSize","kNearestRenderDim","kNearestURepeatVRepeat","kNearestURepeatVClamped","kNearestURepeatVMirror","kNearestUClampedVRepeat","kNearestUClampedVClamped","kNearestUClampedVMirror","kNearestUMirrorVRepeat","kNearestUMirrorVClamped","kNearestUMirrorVMirror","kLinearRenderSize","kLinearRenderDim","kLinearURepeatVRepeat","kLinearURepeatVClamped","kLinearURepeatVMirror","kLinearUClampedVRepeat","kLinearUClampedVClamped","kLinearUClampedVMirror","kLinearUMirrorVRepeat","kLinearUMirrorVClamped","kLinearUMirrorVMirror","expectedNearestColors","addressModeU","addressModeV","expectedColors","c","expectedLinearColors","filterMode","test","desc","params","u","combine","beginSubcases","fn","t","skipIfTextureFormatNotSupported","skipIfTextureFormatNotFilterable","createSampler","magFilter","createShaderModule","code","reduce","sink","current","render","expectTexelViewComparisonIsOkInTexture","minFilter","kTextureSize","kRenderSize","mipmapFilter","createTextureFromTexelViewsMultipleMipmaps","_coords","buffer","copyWholeTextureToNewBufferSimple","expectGPUBufferValuesPassCheck","actual","fromTextureDataByReference","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","Ri","color","z","Rj","Error","toString","width","height","depthOrArrayLayers","changes","undefined","srcByteOffset","type","Uint8Array","typedLength"],"sources":["../../../../../src/webgpu/api/operation/sampling/filter_mode.spec.ts"],"sourcesContent":["export const description = `\nTests the behavior of different filtering modes in minFilter/magFilter/mipmapFilter.\n\nNote: It's possible these tests duplicated tests under shader/execution/expression/call/builtin/textureXXX.\nFurther, these tests only test encodable/filterable/renderable color formats. Depth, sint, uint,\nand compressed formats are not tested.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kAddressModes, kMipmapFilterModes } from '../../../capability_info.js';\nimport {\n  EncodableTextureFormat,\n  getTextureFormatType,\n  isTextureFormatColorRenderable,\n  kPossibleColorRenderableTextureFormats,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport * as ttu from '../../../texture_test_utils.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\n// Simple checkerboard 2x2 texture used as a base for the sampling.\nconst kCheckerTextureSize = 2;\nconst kCheckerTextureData = [\n  { R: 1.0, G: 1.0, B: 1.0, A: 1.0 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 1.0 },\n  { R: 0.0, G: 0.0, B: 0.0, A: 1.0 },\n  { R: 1.0, G: 1.0, B: 1.0, A: 1.0 },\n];\n\n/**\n * These formats are possibly renderable and possibly filterable.\n * One more both may required certain features to be enabled.\n */\nconst kPossiblyRenderablePossiblyFilterableColorTextureFormats =\n  kPossibleColorRenderableTextureFormats.filter(\n    format =>\n      getTextureFormatType(format) === 'float' ||\n      getTextureFormatType(format) === 'unfilterable-float'\n  );\n\nclass FilterModeTest extends AllFeaturesMaxLimitsGPUTest {\n  runFilterRenderPipeline(\n    sampler: GPUSampler,\n    module: GPUShaderModule,\n    format: EncodableTextureFormat,\n    renderSize: number[],\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    let renderTargetFormat = format;\n    if (!isTextureFormatColorRenderable(this.device, format)) {\n      // If the format is not renderable, we use rgba32float as the render target format\n      // to verify the result, which is always renderable.\n      renderTargetFormat = 'rgba32float';\n    }\n    const sampleTexture = ttu.createTextureFromTexelView(\n      this,\n      TexelView.fromTexelsAsColors(format, coord => {\n        const id = coord.x + coord.y * kCheckerTextureSize;\n        return kCheckerTextureData[id];\n      }),\n      {\n        size: [kCheckerTextureSize, kCheckerTextureSize],\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n      }\n    );\n    const renderTexture = this.createTextureTracked({\n      format: renderTargetFormat,\n      size: renderSize,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    const pipeline = this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs_main',\n        targets: [{ format: renderTargetFormat }],\n      },\n    });\n    const bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: sampler },\n        { binding: 1, resource: sampleTexture.createView() },\n      ],\n    });\n    const commandEncoder = this.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, bindgroup);\n    renderPass.draw(vertexCount, instanceCount);\n    renderPass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n    return { texture: renderTexture, format: renderTargetFormat };\n  }\n}\n\nexport const g = makeTestGroup(FilterModeTest);\n\n/* eslint-disable prettier/prettier */\n\n/* For filter mode 'nearest', we need to check a 6x6 of pixels because 4x4s are identical when using\n * address mode 'clamp-to-edge' and 'mirror-repeat'. The minFilter and magFilter tests are setup so\n * that they both render the same results. (See the respective test for details.) The following\n * table shows the expected results:\n *                                                u\n *\n *                               repeat     clamp-to-edge  mirror-repeat\n *\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *             repeat        │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *  v       clamp-to-edge    │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n *          mirror-repeat    │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │ │█│ │█│ │█│  │ │ │ │█│█│█│  │█│ │ │█│█│ │\n *                           │█│ │█│ │█│ │  │█│█│█│ │ │ │  │ │█│█│ │ │█│\n*/\nconst kNearestRenderSize = 6;\nconst kNearestRenderDim = [kNearestRenderSize, kNearestRenderSize];\nconst kNearestURepeatVRepeat = [\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n];\nconst kNearestURepeatVClamped = [\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n];\nconst kNearestURepeatVMirror = [\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n  [1, 0, 1, 0, 1, 0],\n  [0, 1, 0, 1, 0, 1],\n  [0, 1, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1, 0],\n];\nconst kNearestUClampedVRepeat = [\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n];\nconst kNearestUClampedVClamped = [\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n];\nconst kNearestUClampedVMirror = [\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n  [1, 1, 1, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 1, 1, 1],\n  [1, 1, 1, 0, 0, 0],\n];\nconst kNearestUMirrorVRepeat = [\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n];\nconst kNearestUMirrorVClamped = [\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n];\nconst kNearestUMirrorVMirror = [\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n  [0, 1, 1, 0, 0, 1],\n  [1, 0, 0, 1, 1, 0],\n  [1, 0, 0, 1, 1, 0],\n  [0, 1, 1, 0, 0, 1],\n];\n\n/* For filter mode 'linear', the tests samples 16 points (to create a 4x4) on what the effective 8x8\n * expanded texture via the address modes looks like (see table below for what those look like). The\n * sample points are selected such that no combination of address modes result in the same render.\n * There is exactly one sample point in each sub 2x2 of the 8x8 texture, thereby yielding the 4x4\n * result. Note that sampling from the 8x8 texture instead of the 6x6 texture is necessary because\n * that allows us to keep the results in powers of 2 to minimize floating point errors on different\n * backends.\n *\n * The 8x8 effective textures:\n *                                                  u\n *\n *                                repeat          clamp-to-edge      mirror-repeat\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *             repeat        │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *  v       clamp-to-edge    │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *          mirror-repeat    │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │█│ │█│ │█│ │█│ │  │ │ │ │ │█│█│█│█│  │█│█│ │ │█│█│ │ │\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *                           │ │█│ │█│ │█│ │█│  │█│█│█│█│ │ │ │ │  │ │ │█│█│ │ │█│█│\n *\n *\n * Sample points:\n *   The sample points are always at a 25% corner of a pixel such that the contributions come from\n *   the 2x2 (doubly outlined) with ratios 1/16, 3/16, or 9/16.\n *                                    ╔══╤══╦══╤══╦══╤══╦══╤══╗\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │▘ ║ ▝│  ║  │▘ ║ ▝│  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │▘ ║ ▝│  ║  │▘ ║ ▝│  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │▖ ║ ▗│  ║  │▖ ║ ▗│  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╠══╪══╬══╪══╬══╪══╬══╪══╣\n *                                    ║  │▖ ║ ▗│  ║  │▖ ║ ▗│  ║\n *                                    ╟──┼──╫──┼──╫──┼──╫──┼──╢\n *                                    ║  │  ║  │  ║  │  ║  │  ║\n *                                    ╚══╧══╩══╧══╩══╧══╩══╧══╝\n */\nconst kLinearRenderSize = 4;\nconst kLinearRenderDim = [kLinearRenderSize, kLinearRenderSize];\nconst kLinearURepeatVRepeat = [\n  [10, 6, 10, 6],\n  [10, 6, 10, 6],\n  [6, 10, 6, 10],\n  [6, 10, 6, 10],\n];\nconst kLinearURepeatVClamped = [\n  [12, 4, 12, 4],\n  [12, 4, 12, 4],\n  [4, 12, 4, 12],\n  [4, 12, 4, 12],\n];\nconst kLinearURepeatVMirror = [\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n];\nconst kLinearUClampedVRepeat = [\n  [12, 12, 4, 4],\n  [12, 12, 4, 4],\n  [4, 4, 12, 12],\n  [4, 4, 12, 12],\n];\nconst kLinearUClampedVClamped = [\n  [16, 16, 0, 0],\n  [16, 16, 0, 0],\n  [0, 0, 16, 16],\n  [0, 0, 16, 16],\n];\nconst kLinearUClampedVMirror = [\n  [0, 0, 16, 16],\n  [16, 16, 0, 0],\n  [0, 0, 16, 16],\n  [16, 16, 0, 0],\n];\nconst kLinearUMirrorVRepeat = [\n  [4, 12, 4, 12],\n  [4, 12, 4, 12],\n  [12, 4, 12, 4],\n  [12, 4, 12, 4],\n];\nconst kLinearUMirrorVClamped = [\n  [0, 16, 0, 16],\n  [0, 16, 0, 16],\n  [16, 0, 16, 0],\n  [16, 0, 16, 0],\n];\nconst kLinearUMirrorVMirror = [\n  [16, 0, 16, 0],\n  [0, 16, 0, 16],\n  [16, 0, 16, 0],\n  [0, 16, 0, 16],\n];\n\n/* eslint-enable prettier/prettier */\n\nfunction expectedNearestColors(\n  format: EncodableTextureFormat,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  let expectedColors: number[][];\n  switch (addressModeU) {\n    case 'clamp-to-edge': {\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestUClampedVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestUClampedVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestUClampedVMirror;\n          break;\n      }\n      break;\n    }\n    case 'repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestURepeatVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestURepeatVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestURepeatVMirror;\n          break;\n      }\n      break;\n    case 'mirror-repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kNearestUMirrorVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kNearestUMirrorVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kNearestUMirrorVMirror;\n          break;\n      }\n      break;\n  }\n  return TexelView.fromTexelsAsColors(format, coord => {\n    const c = expectedColors[coord.y][coord.x];\n    return { R: c, G: c, B: c, A: 1.0 };\n  });\n}\nfunction expectedLinearColors(\n  format: EncodableTextureFormat,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  let expectedColors: number[][];\n  switch (addressModeU) {\n    case 'clamp-to-edge': {\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearUClampedVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearUClampedVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearUClampedVMirror;\n          break;\n      }\n      break;\n    }\n    case 'repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearURepeatVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearURepeatVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearURepeatVMirror;\n          break;\n      }\n      break;\n    case 'mirror-repeat':\n      switch (addressModeV) {\n        case 'clamp-to-edge':\n          expectedColors = kLinearUMirrorVClamped;\n          break;\n        case 'repeat':\n          expectedColors = kLinearUMirrorVRepeat;\n          break;\n        case 'mirror-repeat':\n          expectedColors = kLinearUMirrorVMirror;\n          break;\n      }\n      break;\n  }\n  return TexelView.fromTexelsAsColors(format, coord => {\n    const c = expectedColors[coord.y][coord.x];\n    return { R: c / 16, G: c / 16, B: c / 16, A: 1.0 };\n  });\n}\nfunction expectedColors(\n  format: EncodableTextureFormat,\n  filterMode: GPUFilterMode,\n  addressModeU: GPUAddressMode,\n  addressModeV: GPUAddressMode\n): TexelView {\n  switch (filterMode) {\n    case 'nearest':\n      return expectedNearestColors(format, addressModeU, addressModeV);\n    case 'linear':\n      return expectedLinearColors(format, addressModeU, addressModeV);\n  }\n}\n\n/* For the magFilter tests, each rendered pixel is an instanced quad such that the center of the\n * quad coincides with the center of the pixel. The uv coordinates for each quad are shifted\n * according to the test so that the center of the quad is at the point we want to sample.\n *\n * For the grid offset logic, see this codelab for reference:\n *   https://codelabs.developers.google.com/your-first-webgpu-app#4\n */\n\n/* The following diagram shows the UV shift (almost to scale) for what the pixel at cell (0,0) looks\n * like w.r.t the UV of the texture if we just mapped the entire 2x2 texture to the quad. Note that\n * the square representing the mapped location on the bottom left is actually slighly smaller than a\n * pixel in order to ensure that we are magnifying the texture and hence using the magFilter. It\n * should be fairly straightforwards to derive that for each pixel, we are shifting (.5, -.5) from\n * the picture.\n *\n *                    ┌─┬─┬─┬─┬─┬─┐\n *                    ├─┼─┼─┼─┼─┼─┤ (0,0) (1,0)\n *                    ├─┼─╔═╪═╗─┼─┤    ╔═══╗\n *                    ├─┼─╫─┼─╫─┼─┤    ║─┼─║\n *                    ├─┼─╚═╪═╝─┼─┤    ╚═══╝       (-.875,1.625) (-.625,1.625)\n *                    ╔═╗─┼─┼─┼─┼─┤ (0,1) (1,1)                ╔═╗\n *                    ╚═╝─┴─┴─┴─┴─┘                            ╚═╝\n *                                                 (-.875,1.875) (-.625,1.875)\n */\ng.test('magFilter,nearest')\n  .desc(\n    `\n  Test that for filterable formats, magFilter 'nearest' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kPossiblyRenderablePossiblyFilterableColorTextureFormats)\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotFilterable(format);\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      magFilter: 'nearest',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kNearestRenderSize}, ${kNearestRenderSize});\n        const posBases = array(\n          vec2f(1, 1), vec2f(1, -1), vec2f(-1, -1),\n          vec2f(1, 1), vec2f(-1, -1), vec2f(-1, 1),\n        );\n        const uvBases = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of instance plane.\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n        let cellOffset = cell / grid * 2;\n        let pos = (posBases[vi] + 1) / grid - 1 + cellOffset;\n\n        // Compute the offset of the UVs.\n        let uvBase = uvBases[vi] * 0.25 + vec2f(-0.875, 1.625);\n        const uvPerPixelOffset = vec2f(0.5, -0.5);\n        return VertexOut(vec4f(pos, 0.0, 1.0), uvBase + uvPerPixelOffset * cell);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kNearestRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kNearestRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    ttu.expectTexelViewComparisonIsOkInTexture(\n      t,\n      { texture: render.texture },\n      expectedColors(render.format, 'nearest', addressModeU, addressModeV),\n      kNearestRenderDim\n    );\n  });\n\n/* The following diagram shows the UV shift (almost to scale) for what the pixel at cell (0,0) (the\n * dark square) looks like w.r.t the UV of the texture if we just mapped the entire 2x2 texture to\n * the quad. The other small squares represent the other locations that we are sampling the texture\n * at. The offsets are defined in the shader.\n *\n *             ┌────┬────┬────┬────┬────┬────┬────┬────┐\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │□   │   □│    │    │□   │   □│    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │       (0,0)     (1,0)\n *             ├────┼────┼────╔════╪════╗────┼────┼────┤         ╔═════════╗\n *             │    │□   │   □║    │    ║□   │   □│    │         ║    │    ║\n *             │    │    │    ║    │    ║    │    │    │         ║    │    ║\n *             ├────┼────┼────╫────┼────╫────┼────┼────┤         ║────┼────║\n *             │    │    │    ║    │    ║    │    │    │         ║    │    ║\n *             │    │□   │   □║    │    ║□   │   □│    │         ║    │    ║\n *             ├────┼────┼────╚════╪════╝────┼────┼────┤         ╚═════════╝\n *             │    │    │    │    │    │    │    │    │       (0,1)     (1,1)\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │    (-1,1.75) (-.75,1.75)\n *             │    │■   │   □│    │    │□   │   □│    │             ■\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤       (-1,2) (-.75,2)\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             └────┴────┴────┴────┴────┴────┴────┴────┘\n */\ng.test('magFilter,linear')\n  .desc(\n    `\n  Test that for filterable formats, magFilter 'linear' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kPossiblyRenderablePossiblyFilterableColorTextureFormats)\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotFilterable(format);\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      magFilter: 'linear',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kLinearRenderSize}, ${kLinearRenderSize});\n        const posBases = array(\n          vec2f(1, 1), vec2f(1, -1), vec2f(-1, -1),\n          vec2f(1, 1), vec2f(-1, -1), vec2f(-1, 1),\n        );\n        const uvBases = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of instance plane.\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n        let cellOffset = cell / grid * 2;\n        let pos = (posBases[vi] + 1) / grid - 1 + cellOffset;\n\n        // Compute the offset of the UVs.\n        const uOffsets = array(0., 0.75, 2., 2.75);\n        const vOffsets = array(0., 1., 1.75, 2.75);\n        let uvBase = uvBases[vi] * 0.25 + vec2f(-1., 1.75);\n        let uvPixelOffset = vec2f(uOffsets[u32(cell.x)], -vOffsets[u32(cell.y)]);\n        return VertexOut(vec4f(pos, 0.0, 1.0), uvBase + uvPixelOffset);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kLinearRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kLinearRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    ttu.expectTexelViewComparisonIsOkInTexture(\n      t,\n      { texture: render.texture },\n      expectedColors(render.format, 'linear', addressModeU, addressModeV),\n      kLinearRenderDim\n    );\n  });\n\n/* For the minFilter tests, each rendered pixel is a small instanced quad that is UV mapped such\n * that it is either the 6x6 or 8x8 textures from above. Each quad in each cell is then offsetted\n * and scaled so that the target sample point coincides with the center of the pixel and the texture\n * is significantly smaller than the pixel to force minFilter mode.\n *\n * For the grid offset logic, see this codelab for reference:\n *   https://codelabs.developers.google.com/your-first-webgpu-app#4\n */\n\n/* The following diagram depicts a single pixel and the sub-pixel sized 6x6 textured quad. The\n * distances shown in the diagram are pre-grid transformation and relative to the quad. Notice that\n * for cell (0,0) marked with an x, we need to offset the center by (5/12,5/12), and per cell, the\n * offset is (-1/6, -1/6).\n *\n *\n *              ┌───────────────────────────────────────────────┐\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │           ┌───┬───┬───┬───┬───┬───┐           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───┼───┼───┼───┤           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───┼───┼───┼───┤           │\n *              │           │   │   │   │   │   │   │           │\n *              │           ├───┼───┼───x───┼───┼───┤           │         ┐\n *              │           │   │   │   │   │   │   │           │         │\n *              │           ├───┼───┼───┼───┼───┼───┤           │         │ 5/12\n *              │           │   │   │   │   │   │   │           │ ┐       │\n *              │           ├───┼───┼───┼───┼───┼───┤           │ │ 1/6   │\n *              │           │ x │   │   │   │   │   │           │ ┘       ┘\n *              │           └───┴───┴───┴───┴───┴───┘           │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              │                                               │\n *              └───────────────────────────────────────────────┘\n */\ng.test('minFilter,nearest')\n  .desc(\n    `\n  Test that for filterable formats, minFilter 'nearest' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kPossiblyRenderablePossiblyFilterableColorTextureFormats)\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotFilterable(format);\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      minFilter: 'nearest',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kNearestRenderSize}, ${kNearestRenderSize});\n        const posBases = array(\n          vec2f(.5, .5), vec2f(.5, -.5), vec2f(-.5, -.5),\n          vec2f(.5, .5), vec2f(-.5, -.5), vec2f(-.5, .5),\n        );\n        // Choose UVs so that the quad ends up being the 6x6 texture.\n        const uvBases = array(\n          vec2f(2., -1.), vec2f(2., 2.), vec2f(-1., 2.),\n          vec2f(2., -1.), vec2f(-1., 2.), vec2f(-1., -1.),\n        );\n\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n\n        // Compute the offset of instance plane (pre-grid transformation).\n        const constantPlaneOffset = vec2f(5. / 12., 5. / 12.);\n        const perPixelOffset = vec2f(1. / 6., 1. / 6.);\n        let posBase = posBases[vi] + constantPlaneOffset - perPixelOffset * cell;\n\n        // Apply the grid transformation.\n        let cellOffset = cell / grid * 2;\n        let absPos = (posBase + 1) / grid - 1 + cellOffset;\n\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uvBases[vi]);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kNearestRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kNearestRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    ttu.expectTexelViewComparisonIsOkInTexture(\n      t,\n      { texture: render.texture },\n      expectedColors(render.format, 'nearest', addressModeU, addressModeV),\n      kNearestRenderDim\n    );\n  });\n\n/* The following diagram shows the sub-pixel quad and the relative distances between the sample\n * points and the origin. The pixel is not shown in this diagram but is a 2x bounding box around the\n * quad similar to the one in the diagram for minFilter,nearest above. The dark square is where the\n * cell (0,0) is, and the offsets are all relative to that point.\n *\n *                        11/32\n *                   ┌─────────────┐\n *\n *                     3/16      5/16       3/16\n *                   ┌───────┬───────────┬───────┐\n *\n *             ┌────┬────┬────┬────┬────┬────┬────┬────┐\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │□   │   □│    │    │□   │   □│    │  ┐\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │\n *             │    │    │    │    │    │    │    │    │  │  1/4\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │\n *             │    │□   │   □│    │    │□   │   □│    │  ┤\n *             │    │    │    │    │    │    │    │    │  │\n *             ├────┼────┼────┼────x────┼────┼────┼────┤  │  3/16    ┐\n *             │    │    │    │    │    │    │    │    │  │          │\n *             │    │□   │   □│    │    │□   │   □│    │  ┤          │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │          │\n *             │    │    │    │    │    │    │    │    │  │          │  11/32\n *             │    │    │    │    │    │    │    │    │  │  1/4     │\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤  │          │\n *             │    │    │    │    │    │    │    │    │  │          │\n *             │    │■   │   □│    │    │□   │   □│    │  ┘          ┘\n *             ├────┼────┼────┼────┼────┼────┼────┼────┤\n *             │    │    │    │    │    │    │    │    │\n *             │    │    │    │    │    │    │    │    │\n *             └────┴────┴────┴────┴────┴────┴────┴────┘\n */\ng.test('minFilter,linear')\n  .desc(\n    `\n  Test that for filterable formats, minFilter 'linear' mode correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - addressModeU= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n    - addressModeV= {'clamp-to-edge', 'repeat', 'mirror-repeat'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kPossiblyRenderablePossiblyFilterableColorTextureFormats)\n      .beginSubcases()\n      .combine('addressModeU', kAddressModes)\n      .combine('addressModeV', kAddressModes)\n  )\n  .fn(t => {\n    const { format, addressModeU, addressModeV } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotFilterable(format);\n    const sampler = t.device.createSampler({\n      addressModeU,\n      addressModeV,\n      minFilter: 'linear',\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kLinearRenderSize}, ${kLinearRenderSize});\n        const posBases = array(\n          vec2f(.5, .5), vec2f(.5, -.5), vec2f(-.5, -.5),\n          vec2f(.5, .5), vec2f(-.5, -.5), vec2f(-.5, .5),\n        );\n        // Choose UVs so that the quad ends up being the 8x8 texture.\n        const uvBases = array(\n          vec2f(2.5, -1.5), vec2f(2.5, 2.5), vec2f(-1.5, 2.5),\n          vec2f(2.5, -1.5), vec2f(-1.5, 2.5), vec2f(-1.5, -1.5),\n        );\n\n        let cell = vec2f(f32(ii) % grid.x, floor(f32(ii) / grid.y));\n\n        // Compute the offset of instance plane (pre-grid transformation).\n        const constantPlaneOffset = vec2f(11. / 32., 11. / 32.);\n        const xOffsets = array(0., 3. / 16., 1. / 2., 11. / 16.);\n        const yOffsets = array(0., 1. / 4., 7. / 16., 11. / 16.);\n        let pixelOffset = vec2f(xOffsets[u32(cell.x)], yOffsets[u32(cell.y)]);\n        let posBase = posBases[vi] + constantPlaneOffset - pixelOffset;\n\n        // Compute the offset of instance plane.\n        let cellOffset = cell / grid * 2;\n        let absPos = (posBase + 1) / grid - 1 + cellOffset;\n\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uvBases[vi]);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const vertexCount = 6;\n    const instanceCount = kLinearRenderDim.reduce((sink, current) => sink * current);\n    const render = t.runFilterRenderPipeline(\n      sampler,\n      module,\n      format,\n      kLinearRenderDim,\n      vertexCount,\n      instanceCount\n    );\n    ttu.expectTexelViewComparisonIsOkInTexture(\n      t,\n      { texture: render.texture },\n      expectedColors(render.format, 'linear', addressModeU, addressModeV),\n      kLinearRenderDim\n    );\n  });\n\ng.test('mipmapFilter')\n  .desc(\n    `\n  Test that for filterable formats, mipmapFilter modes correctly modifies the sampling.\n    - format= {<filterable formats>}\n    - filterMode= {'nearest', 'linear'}\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kPossiblyRenderablePossiblyFilterableColorTextureFormats)\n      .beginSubcases()\n      .combine('filterMode', kMipmapFilterModes)\n  )\n  .fn(t => {\n    const { format, filterMode } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureFormatNotFilterable(format);\n    let renderTargetFormat = format;\n    if (!isTextureFormatColorRenderable(t.device, format)) {\n      // If the format is not renderable, we use rgba32float as the render target format\n      // to verify the result, which is always renderable.\n      renderTargetFormat = 'rgba32float';\n    }\n    // Takes a 8x8/4x4 mipmapped texture and renders it on multiple quads with different UVs such\n    // that each instanced quad from left to right emulates moving the quad further and further from\n    // the camera. Each quad is then rendered to a single pixel in a 1-dimensional texture. Since\n    // the 8x8 is fully black and the 4x4 is fully white, we should see the pixels increase in\n    // brightness from left to right when sampling linearly, and jump from black to white when\n    // sampling for the nearest mip level.\n    const kTextureSize = 8;\n    const kRenderSize = 8;\n\n    const sampler = t.device.createSampler({\n      mipmapFilter: filterMode,\n    });\n    const sampleTexture = ttu.createTextureFromTexelViewsMultipleMipmaps(\n      t,\n      [\n        TexelView.fromTexelsAsColors(format, () => {\n          return { R: 0.0, G: 0.0, B: 0.0, A: 1.0 };\n        }),\n        TexelView.fromTexelsAsColors(format, _coords => {\n          return { R: 1.0, G: 1.0, B: 1.0, A: 1.0 };\n        }),\n      ],\n      {\n        size: [kTextureSize, 1],\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n      }\n    );\n    const renderTexture = t.createTextureTracked({\n      format: renderTargetFormat,\n      size: [kRenderSize, 1],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    const module = t.device.createShaderModule({\n      code: `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n\n      struct VertexOut {\n        @builtin(position) pos: vec4f,\n        @location(0) uv: vec2f,\n      };\n\n      @vertex\n      fn vs_main(@builtin(vertex_index) vi : u32,\n                 @builtin(instance_index) ii: u32) -> VertexOut {\n        const grid = vec2f(${kRenderSize}., 1.);\n        const pos = array(\n          vec2f( 1.0,  1.0), vec2f( 1.0, -1.0), vec2f(-1.0, -1.0),\n          vec2f( 1.0,  1.0), vec2f(-1.0, -1.0), vec2f(-1.0,  1.0),\n        );\n        const uv = array(\n          vec2f(1., 0.), vec2f(1., 1.), vec2f(0., 1.),\n          vec2f(1., 0.), vec2f(0., 1.), vec2f(0., 0.),\n        );\n\n        // Compute the offset of the plane.\n        let cell = vec2f(f32(ii) % grid.x, 0.);\n        let cellOffset = cell / grid * 2;\n        let absPos = (pos[vi] + 1) / grid - 1 + cellOffset;\n        let uvFactor = (1. / 8.) * (1 + (f32(ii) / (grid.x - 1)));\n        return VertexOut(vec4f(absPos, 0.0, 1.0), uv[vi] * uvFactor);\n      }\n\n      @fragment\n      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n        return textureSample(t, s, uv);\n      }\n      `,\n    });\n    const pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs_main',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs_main',\n        targets: [{ format: renderTargetFormat }],\n      },\n    });\n    const bindgroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: sampler },\n        { binding: 1, resource: sampleTexture.createView() },\n      ],\n    });\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, bindgroup);\n    renderPass.draw(6, kRenderSize);\n    renderPass.end();\n    t.device.queue.submit([commandEncoder.finish()]);\n\n    // Since mipmap filtering varies across different backends, we verify that the result exhibits\n    // filtered characteristics without strict value equalities via copies to a buffer.\n    const buffer = ttu.copyWholeTextureToNewBufferSimple(t, renderTexture, 0);\n    t.expectGPUBufferValuesPassCheck(\n      buffer,\n      actual => {\n        // Convert the buffer to texel view so we can do comparisons.\n        const layout = getTextureCopyLayout(renderTargetFormat, '2d', [kRenderSize, 1, 1]);\n        const view = TexelView.fromTextureDataByReference(renderTargetFormat, actual, {\n          bytesPerRow: layout.bytesPerRow,\n          rowsPerImage: layout.rowsPerImage,\n          subrectOrigin: [0, 0, 0],\n          subrectSize: [kRenderSize, 1, 1],\n        });\n\n        // We only check the R component for the conditions, since all components should be equal if\n        // specified in the format.\n        switch (filterMode) {\n          case 'linear': {\n            // For 'linear' mode, we check that the resulting 1d image is monotonically increasing.\n            for (let x = 1; x < kRenderSize; x++) {\n              const { R: Ri } = view.color({ x: x - 1, y: 0, z: 0 });\n              const { R: Rj } = view.color({ x, y: 0, z: 0 });\n              if (Ri! >= Rj!) {\n                return Error(\n                  'Linear filtering on mipmaps should be a monotonically increasing sequence:\\n' +\n                    view.toString(\n                      { x: 0, y: 0, z: 0 },\n                      { width: kRenderSize, height: 1, depthOrArrayLayers: 1 }\n                    )\n                );\n              }\n            }\n            break;\n          }\n          case 'nearest': {\n            // For 'nearest' mode, we check that the resulting 1d image changes from 0.0 to 1.0\n            // exactly once.\n            let changes = 0;\n            for (let x = 1; x < kRenderSize; x++) {\n              const { R: Ri } = view.color({ x: x - 1, y: 0, z: 0 });\n              const { R: Rj } = view.color({ x, y: 0, z: 0 });\n              if (Ri! !== Rj!) {\n                changes++;\n              }\n            }\n            if (changes !== 1) {\n              return Error(\n                `Nearest filtering on mipmaps should change exactly once but found (${changes}):\\n` +\n                  view.toString(\n                    { x: 0, y: 0, z: 0 },\n                    { width: kRenderSize, height: 1, depthOrArrayLayers: 1 }\n                  )\n              );\n            }\n            break;\n          }\n        }\n        return undefined;\n      },\n      { srcByteOffset: 0, type: Uint8Array, typedLength: buffer.size }\n    );\n  });\n"],"mappings":"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G,OAAO,GAAG2F,CAAC,CAACrF,MAAM,CAACwF,aAAa,CAAC;IACrChB,YAAY;IACZC,YAAY;IACZwB,SAAS,EAAE;EACb,CAAC,CAAC;EACF,MAAMtG,MAAM,GAAG0F,CAAC,CAACrF,MAAM,CAAC0F,kBAAkB,CAAC;IACzCC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B1C,kBAAmB,KAAIA,kBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;EACF,MAAMpD,WAAW,GAAG,CAAC;EACrB,MAAMC,aAAa,GAAGoD,iBAAiB,CAAC0C,MAAM,CAAC,CAACC,IAAI,EAAEC,OAAO,KAAKD,IAAI,GAAGC,OAAO,CAAC;EACjF,MAAMC,MAAM,GAAGV,CAAC,CAAC5F,uBAAuB;IACtCC,OAAO;IACPC,MAAM;IACNJ,MAAM;IACN2D,iBAAiB;IACjBrD,WAAW;IACXC;EACF,CAAC;EACDlB,GAAG,CAACoH,sCAAsC;IACxCX,CAAC;IACD,EAAEtC,OAAO,EAAEgD,MAAM,CAAChD,OAAO,CAAC,CAAC;IAC3B2B,cAAc,CAACqB,MAAM,CAACxG,MAAM,EAAE,SAAS,EAAEiF,YAAY,EAAEC,YAAY,CAAC;IACpEvB;EACF,CAAC;AACH,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,CAAC,CAAC8B,IAAI,CAAC,kBAAkB,CAAC;AACvBC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAE7F,wDAAwD,CAAC;AAC3E8F,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,cAAc,EAAE5G,aAAa,CAAC;AACtC4G,OAAO,CAAC,cAAc,EAAE5G,aAAa;AAC1C,CAAC;AACA8G,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE9F,MAAM,EAAEiF,YAAY,EAAEC,YAAY,CAAC,CAAC,GAAGY,CAAC,CAACL,MAAM;EACvDK,CAAC,CAACC,+BAA+B,CAAC/F,MAAM,CAAC;EACzC8F,CAAC,CAACE,gCAAgC,CAAChG,MAAM,CAAC;EAC1C,MAAMG,OAAO,GAAG2F,CAAC,CAACrF,MAAM,CAACwF,aAAa,CAAC;IACrChB,YAAY;IACZC,YAAY;IACZwB,SAAS,EAAE;EACb,CAAC,CAAC;EACF,MAAMtG,MAAM,GAAG0F,CAAC,CAACrF,MAAM,CAAC0F,kBAAkB,CAAC;IACzCC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B/B,iBAAkB,KAAIA,iBAAkB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;EACF,MAAM/D,WAAW,GAAG,CAAC;EACrB,MAAMC,aAAa,GAAG+D,gBAAgB,CAAC+B,MAAM,CAAC,CAACC,IAAI,EAAEC,OAAO,KAAKD,IAAI,GAAGC,OAAO,CAAC;EAChF,MAAMC,MAAM,GAAGV,CAAC,CAAC5F,uBAAuB;IACtCC,OAAO;IACPC,MAAM;IACNJ,MAAM;IACNsE,gBAAgB;IAChBhE,WAAW;IACXC;EACF,CAAC;EACDlB,GAAG,CAACoH,sCAAsC;IACxCX,CAAC;IACD,EAAEtC,OAAO,EAAEgD,MAAM,CAAChD,OAAO,CAAC,CAAC;IAC3B2B,cAAc,CAACqB,MAAM,CAACxG,MAAM,EAAE,QAAQ,EAAEiF,YAAY,EAAEC,YAAY,CAAC;IACnEZ;EACF,CAAC;AACH,CAAC,CAAC;;AAEJb,CAAC,CAAC8B,IAAI,CAAC,cAAc,CAAC;AACnBC,IAAI;EACF;AACL;AACA;AACA;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,QAAQ,EAAE7F,wDAAwD,CAAC;AAC3E8F,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,YAAY,EAAE3G,kBAAkB;AAC7C,CAAC;AACA6G,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAE9F,MAAM,EAAEsF,UAAU,CAAC,CAAC,GAAGQ,CAAC,CAACL,MAAM;EACvCK,CAAC,CAACC,+BAA+B,CAAC/F,MAAM,CAAC;EACzC8F,CAAC,CAACE,gCAAgC,CAAChG,MAAM,CAAC;EAC1C,IAAIQ,kBAAkB,GAAGR,MAAM;EAC/B,IAAI,CAACd,8BAA8B,CAAC4G,CAAC,CAACrF,MAAM,EAAET,MAAM,CAAC,EAAE;IACrD;IACA;IACAQ,kBAAkB,GAAG,aAAa;EACpC;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMmG,YAAY,GAAG,CAAC;EACtB,MAAMC,WAAW,GAAG,CAAC;;EAErB,MAAMzG,OAAO,GAAG2F,CAAC,CAACrF,MAAM,CAACwF,aAAa,CAAC;IACrCY,YAAY,EAAEvB;EAChB,CAAC,CAAC;EACF,MAAM5E,aAAa,GAAGrB,GAAG,CAACyH,0CAA0C;IAClEhB,CAAC;IACD;IACEvG,SAAS,CAACqB,kBAAkB,CAACZ,MAAM,EAAE,MAAM;MACzC,OAAO,EAAEN,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;IAC3C,CAAC,CAAC;IACFN,SAAS,CAACqB,kBAAkB,CAACZ,MAAM,EAAE,CAAA+G,OAAO,KAAI;MAC9C,OAAO,EAAErH,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,EAAEC,CAAC,EAAE,GAAG,CAAC,CAAC;IAC3C,CAAC,CAAC,CACH;;IACD;MACEoB,IAAI,EAAE,CAAC0F,YAAY,EAAE,CAAC,CAAC;MACvBzF,KAAK,EAAEC,eAAe,CAACC,eAAe,GAAGD,eAAe,CAACE;IAC3D;EACF,CAAC;EACD,MAAMC,aAAa,GAAGwE,CAAC,CAACvE,oBAAoB,CAAC;IAC3CvB,MAAM,EAAEQ,kBAAkB;IAC1BS,IAAI,EAAE,CAAC2F,WAAW,EAAE,CAAC,CAAC;IACtB1F,KAAK,EAAEC,eAAe,CAACK,iBAAiB,GAAGL,eAAe,CAACM;EAC7D,CAAC,CAAC;EACF,MAAMrB,MAAM,GAAG0F,CAAC,CAACrF,MAAM,CAAC0F,kBAAkB,CAAC;IACzCC,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6BQ,WAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAAC,CAAC;EACF,MAAMlF,QAAQ,GAAGoE,CAAC,CAACrF,MAAM,CAACkB,oBAAoB,CAAC;IAC7CC,MAAM,EAAE,MAAM;IACdC,MAAM,EAAE;MACNzB,MAAM;MACN0B,UAAU,EAAE;IACd,CAAC;IACDC,QAAQ,EAAE;MACR3B,MAAM;MACN0B,UAAU,EAAE,SAAS;MACrBE,OAAO,EAAE,CAAC,EAAEhC,MAAM,EAAEQ,kBAAkB,CAAC,CAAC;IAC1C;EACF,CAAC,CAAC;EACF,MAAMyB,SAAS,GAAG6D,CAAC,CAACrF,MAAM,CAACyB,eAAe,CAAC;IACzCN,MAAM,EAAEF,QAAQ,CAACS,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE;IACP,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAEnC,OAAO,CAAC,CAAC;IACjC,EAAEkC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE5B,aAAa,CAAC6B,UAAU,CAAC,CAAC,CAAC,CAAC;;EAExD,CAAC,CAAC;EACF,MAAMC,cAAc,GAAGsD,CAAC,CAACrF,MAAM,CAACgC,oBAAoB,CAAC,CAAC;EACtD,MAAMC,UAAU,GAAGF,cAAc,CAACG,eAAe,CAAC;IAChDC,gBAAgB,EAAE;IAChB;MACEC,IAAI,EAAEvB,aAAa,CAACiB,UAAU,CAAC,CAAC;MAChCO,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACxBC,MAAM,EAAE,OAAO;MACfC,OAAO,EAAE;IACX,CAAC;;EAEL,CAAC,CAAC;EACFN,UAAU,CAACO,WAAW,CAACvB,QAAQ,CAAC;EAChCgB,UAAU,CAACQ,YAAY,CAAC,CAAC,EAAEjB,SAAS,CAAC;EACrCS,UAAU,CAACS,IAAI,CAAC,CAAC,EAAEyD,WAAW,CAAC;EAC/BlE,UAAU,CAACU,GAAG,CAAC,CAAC;EAChB0C,CAAC,CAACrF,MAAM,CAAC4C,KAAK,CAACC,MAAM,CAAC,CAACd,cAAc,CAACe,MAAM,CAAC,CAAC,CAAC,CAAC;;EAEhD;EACA;EACA,MAAMyD,MAAM,GAAG3H,GAAG,CAAC4H,iCAAiC,CAACnB,CAAC,EAAExE,aAAa,EAAE,CAAC,CAAC;EACzEwE,CAAC,CAACoB,8BAA8B;IAC9BF,MAAM;IACN,CAAAG,MAAM,KAAI;MACR;MACA,MAAMvF,MAAM,GAAGtC,oBAAoB,CAACkB,kBAAkB,EAAE,IAAI,EAAE,CAACoG,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAClF,MAAM/D,IAAI,GAAGtD,SAAS,CAAC6H,0BAA0B,CAAC5G,kBAAkB,EAAE2G,MAAM,EAAE;QAC5EE,WAAW,EAAEzF,MAAM,CAACyF,WAAW;QAC/BC,YAAY,EAAE1F,MAAM,CAAC0F,YAAY;QACjCC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACxBC,WAAW,EAAE,CAACZ,WAAW,EAAE,CAAC,EAAE,CAAC;MACjC,CAAC,CAAC;;MAEF;MACA;MACA,QAAQtB,UAAU;QAChB,KAAK,QAAQ,CAAE;YACb;YACA,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6F,WAAW,EAAE7F,CAAC,EAAE,EAAE;cACpC,MAAM,EAAErB,CAAC,EAAE+H,EAAE,CAAC,CAAC,GAAG5E,IAAI,CAAC6E,KAAK,CAAC,EAAE3G,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cACtD,MAAM,EAAEjI,CAAC,EAAEkI,EAAE,CAAC,CAAC,GAAG/E,IAAI,CAAC6E,KAAK,CAAC,EAAE3G,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cAC/C,IAAIF,EAAE,IAAKG,EAAG,EAAE;gBACd,OAAOC,KAAK;kBACV,8EAA8E;kBAC5EhF,IAAI,CAACiF,QAAQ;oBACX,EAAE/G,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC;oBACpB,EAAEI,KAAK,EAAEnB,WAAW,EAAEoB,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;kBACzD;gBACJ,CAAC;cACH;YACF;YACA;UACF;QACA,KAAK,SAAS,CAAE;YACd;YACA;YACA,IAAIC,OAAO,GAAG,CAAC;YACf,KAAK,IAAInH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6F,WAAW,EAAE7F,CAAC,EAAE,EAAE;cACpC,MAAM,EAAErB,CAAC,EAAE+H,EAAE,CAAC,CAAC,GAAG5E,IAAI,CAAC6E,KAAK,CAAC,EAAE3G,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cACtD,MAAM,EAAEjI,CAAC,EAAEkI,EAAE,CAAC,CAAC,GAAG/E,IAAI,CAAC6E,KAAK,CAAC,EAAE3G,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cAC/C,IAAIF,EAAE,KAAMG,EAAG,EAAE;gBACfM,OAAO,EAAE;cACX;YACF;YACA,IAAIA,OAAO,KAAK,CAAC,EAAE;cACjB,OAAOL,KAAK;gBACT,sEAAqEK,OAAQ,MAAK;gBACjFrF,IAAI,CAACiF,QAAQ;kBACX,EAAE/G,CAAC,EAAE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE2G,CAAC,EAAE,CAAC,CAAC,CAAC;kBACpB,EAAEI,KAAK,EAAEnB,WAAW,EAAEoB,MAAM,EAAE,CAAC,EAAEC,kBAAkB,EAAE,CAAC,CAAC;gBACzD;cACJ,CAAC;YACH;YACA;UACF;MACF;MACA,OAAOE,SAAS;IAClB,CAAC;IACD,EAAEC,aAAa,EAAE,CAAC,EAAEC,IAAI,EAAEC,UAAU,EAAEC,WAAW,EAAEvB,MAAM,CAAC/F,IAAI,CAAC;EACjE,CAAC;AACH,CAAC,CAAC"}