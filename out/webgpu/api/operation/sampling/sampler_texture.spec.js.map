{"version":3,"file":"sampler_texture.spec.js","names":["description","makeTestGroup","assert","range","GPUTest","MaxLimitsTestMixin","TextureTestMixin","TexelView","g","test","desc","fn","t","device","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage","maxBindingsPerBindGroup","limits","maxTestableCombosPerStage","isCompatibility","Math","min","textures","declarationLines","groups","layouts","textureIds","Set","samplerIds","expected","addResource","stage","resourceId","resource","bindGroupEntries","length","bindGroupLayoutEntries","push","resourceType","GPUSampler","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","sampler","texture","addTexture","textureNum","textureId","has","add","createTextureTracked","format","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","data","Uint16Array","rg","x","offset","samplerNum","queue","writeTexture","createView","kAddressModes","getAddressMode","hash","depth","pow","addSampler","samplerId","addressHash","createSampler","minFilter","magFilter","mipmapFilter","addressModeU","addressModeV","addressModeW","code","i","texNum","smpNum","join","module","createShaderModule","bindGroupLayouts","map","entries","createBindGroupLayout","pipeline","createRenderPipeline","layout","createPipelineLayout","vertex","fragment","targets","primitive","topology","bindGroups","createBindGroup","getBindGroupLayout","renderTarget","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","forEach","bindGroup","setBindGroup","y","setViewport","draw","end","submit","finish","expectedData","tid","sid","expTexelView","fromTextureDataByReference","Uint8Array","buffer","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","expectTexelViewComparisonIsOkInTexture","destroy"],"sources":["../../../../../src/webgpu/api/operation/sampling/sampler_texture.spec.ts"],"sourcesContent":["export const description = `\nTests samplers with textures.\n\n- test that you can use the maximum number of textures\n  with the maximum number of samplers.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\nimport { GPUTest, MaxLimitsTestMixin, TextureTestMixin } from '../../../gpu_test.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nexport const g = makeTestGroup(TextureTestMixin(MaxLimitsTestMixin(GPUTest)));\n\ng.test('sample_texture_combos')\n  .desc(\n    `\nTest that you can use the maximum number of textures with the maximum number of samplers.\n\nThe test works by making the maximum number of texture+sampler combos.\nEach texture is [maxSamplersPerShaderStage, 1] in size where each texel is [textureId, samplerId]\nA function \"useCombo<StageNum>(comboId)\" is made that returns stage[stageNum].combo[comboId].texel[id, 0]\nor to put it another way, it returns the nth texel from the nth combo for that stage.\n\nThese are read in both the vertex shader and fragment shader and written to a [maxSamplerPerShaderStage, 2]\ntexture where the top row is the values from the vertex shader and the bottom row from the fragment shader.\n\nThe result should be a texture that has a value in each texel unique to a particular combo\n`\n  )\n  .fn(t => {\n    const { device } = t;\n    const { maxSampledTexturesPerShaderStage, maxSamplersPerShaderStage, maxBindingsPerBindGroup } =\n      device.limits;\n\n    assert(maxSampledTexturesPerShaderStage < 0xfffe);\n    assert(maxSamplersPerShaderStage < 0xfffe);\n\n    const maxTestableCombosPerStage = t.isCompatibility\n      ? Math.min(maxSampledTexturesPerShaderStage, maxSamplersPerShaderStage)\n      : maxSampledTexturesPerShaderStage * maxSamplersPerShaderStage;\n\n    const textures: GPUTexture[] = [];\n    const declarationLines: string[] = [];\n    const groups: GPUBindGroupEntry[][] = [[]];\n    const layouts: GPUBindGroupLayoutEntry[][] = [[]];\n    const textureIds = new Set<string>();\n    const samplerIds = new Set<string>();\n    // per stage, per texel, each texel has 2 numbers, the texture id, and sampler id\n    const expected: number[][][] = [[], []];\n\n    function addResource(stage: number, resourceId: string, resource: GPUTextureView | GPUSampler) {\n      let bindGroupEntries = groups[groups.length - 1];\n      let bindGroupLayoutEntries = layouts[groups.length - 1];\n      if (bindGroupEntries.length === maxBindingsPerBindGroup) {\n        bindGroupEntries = [];\n        bindGroupLayoutEntries = [];\n        groups.push(bindGroupEntries);\n        layouts.push(bindGroupLayoutEntries);\n      }\n      const resourceType = resource instanceof GPUSampler ? 'sampler' : 'texture_2d<f32>';\n      const binding = bindGroupEntries.length;\n      declarationLines.push(\n        `    @group(${groups.length - 1}) @binding(${binding}) var ${resourceId}: ${resourceType};`\n      );\n      bindGroupEntries.push({\n        binding,\n        resource,\n      });\n      bindGroupLayoutEntries.push({\n        binding,\n        visibility: stage === 0 ? GPUShaderStage.VERTEX : GPUShaderStage.FRAGMENT,\n        ...(resource instanceof GPUSampler\n          ? {\n              sampler: {},\n            }\n          : {\n              texture: {},\n            }),\n      });\n    }\n\n    function addTexture(stage: number, textureNum: number) {\n      const textureId = `tex${stage}_${textureNum}`;\n      if (!textureIds.has(textureId)) {\n        textureIds.add(textureId);\n        const texture = t.createTextureTracked({\n          format: 'rgba8unorm',\n          size: [maxSamplersPerShaderStage, 1],\n          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        });\n        textures.push(texture);\n        // Encode an rgba8unorm texture with rg16uint data where each texel is\n        // [(textureId + 1) | (stage << 15), {samplerId + 1}]\n        // The +1 is to avoid 0.\n        const data = new Uint16Array(maxSamplersPerShaderStage * 2);\n        const rg = (textureNum + 1) | (stage << 15);\n        for (let x = 0; x < maxSamplersPerShaderStage; ++x) {\n          const offset = x * 2;\n          const samplerNum = x + 1;\n          data[offset + 0] = rg;\n          data[offset + 1] = samplerNum;\n        }\n        device.queue.writeTexture({ texture }, data, {}, [maxSamplersPerShaderStage]);\n        addResource(stage, textureId, texture.createView());\n      }\n      return textureId;\n    }\n\n    const kAddressModes = ['repeat', 'clamp-to-edge', 'mirror-repeat'] as const;\n    const getAddressMode = (hash: number, depth: number) => {\n      return kAddressModes[\n        ((hash / Math.pow(kAddressModes.length, depth)) | 0) % kAddressModes.length\n      ];\n    };\n\n    function addSampler(stage: number, samplerNum: number) {\n      const samplerId = `smp${stage}_${samplerNum}`;\n      if (!samplerIds.has(samplerId)) {\n        const samplerNum = samplerIds.size;\n        samplerIds.add(samplerId);\n        // try to make each sampler unique. This is because some backends\n        // coalesce samplers with the same settings.\n        const addressHash = samplerNum >> 3;\n        const sampler = device.createSampler({\n          minFilter: samplerNum & 1 ? 'linear' : 'nearest',\n          magFilter: samplerNum & 2 ? 'linear' : 'nearest',\n          mipmapFilter: samplerNum & 4 ? 'linear' : 'nearest',\n          addressModeU: getAddressMode(addressHash, 0),\n          addressModeV: getAddressMode(addressHash, 1),\n          addressModeW: getAddressMode(addressHash, 2),\n        });\n        addResource(stage, samplerId, sampler);\n      }\n      return samplerId;\n    }\n\n    // Note: We are storing textureId, samplerId in the texture. That suggests we could use rgba32uint\n    // texture but we can't do that because we want to be able to set the samplers to linear.\n    // Similarly we can't use rgba32float since they're not filterable by default.\n    // So, we encode via rgba8unorm where rg is a 16bit textureId and ba is a 16bit samplerId\n    const code = `\n    // maxTestableCombosPerStage: ${maxTestableCombosPerStage}\n\n    fn sample(t: texture_2d<f32>, s: sampler, validId: u32, currentId: u32, c: vec4f) -> vec4f {\n      let size = textureDimensions(t, 0);\n      let uv = vec2f((f32(currentId) + 0.5) / f32(size.x), 0.5);\n      let v = textureSampleLevel(t, s, uv, 0);\n      return select(c, v, currentId == validId);\n    }\n\n    ${range(\n      2,\n      stage => `\n      fn useCombos${stage}(id: u32) -> vec4f {\n        var c: vec4f;\n${range(maxTestableCombosPerStage, i => {\n  const texNum = (i / maxSamplersPerShaderStage) | 0;\n  const textureId = addTexture(stage, texNum);\n  const smpNum = i % maxSamplersPerShaderStage;\n  const samplerId = addSampler(stage, smpNum);\n  expected[stage].push([(texNum + 1) | (stage << 15), smpNum + 1]);\n  return `        c = sample(${textureId}, ${samplerId}, ${i}, id, c);`;\n}).join('\\n')}\n        return c;\n      }\n    `\n    ).join('\\n\\n')}\n\n${declarationLines.join('\\n')}\n\n    struct VOut {\n      @builtin(position) pos: vec4f,\n      @location(0) value: vec4f,\n    };\n\n    @vertex fn vs(@builtin(instance_index) iNdx: u32) -> VOut {\n      return VOut(\n        vec4f(0, 0, 0, 1),\n        useCombos0(iNdx),\n      );\n    }\n\n    @fragment fn fs(vin: VOut) -> @location(0) vec4u {\n      let ndx = u32(vin.pos.x);\n      let f = select(vin.value, useCombos1(ndx), vin.pos.y > 1.0);\n\n      // We're putting two u16 values in the source data but as rgba8unorm.\n      // Convert them back to u32 then split them back into two u16s\n      let bytes = pack4x8unorm(f);\n      return vec4u(bytes & 0xffff, bytes >> 16, 0, 0);\n    }\n    `;\n\n    const module = device.createShaderModule({ code });\n    const bindGroupLayouts = layouts.map(entries => device.createBindGroupLayout({ entries }));\n\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({ bindGroupLayouts }),\n      vertex: {\n        module,\n      },\n      fragment: {\n        module,\n        targets: [{ format: 'rg16uint' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n\n    const bindGroups = groups.map((entries, i) =>\n      device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(i),\n        entries,\n      })\n    );\n\n    const renderTarget = t.createTextureTracked({\n      format: 'rg16uint',\n      size: [maxTestableCombosPerStage, 2],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    textures.push(renderTarget);\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    bindGroups.forEach((bindGroup, i) => pass.setBindGroup(i, bindGroup));\n    for (let y = 0; y < 2; ++y) {\n      for (let x = 0; x < maxTestableCombosPerStage; ++x) {\n        pass.setViewport(x, y, 1, 1, 0, 1);\n        pass.draw(1, 1, 0, x);\n      }\n    }\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n\n    const expectedData = new Uint16Array(maxTestableCombosPerStage * 2 * 2);\n    for (let stage = 0; stage < 2; ++stage) {\n      expected[stage].forEach(([tid, sid], i) => {\n        const offset = (maxTestableCombosPerStage * stage + i) * 2;\n        expectedData[offset + 0] = tid;\n        expectedData[offset + 1] = sid;\n      });\n    }\n\n    const expTexelView = TexelView.fromTextureDataByReference(\n      'rg16uint',\n      new Uint8Array(expectedData.buffer),\n      {\n        bytesPerRow: maxTestableCombosPerStage * 4,\n        rowsPerImage: 2,\n        subrectOrigin: [0, 0, 0],\n        subrectSize: [maxTestableCombosPerStage, 2],\n      }\n    );\n\n    const size = [maxSamplersPerShaderStage, 2];\n    t.expectTexelViewComparisonIsOkInTexture({ texture: renderTarget }, expTexelView, size);\n\n    textures.forEach(texture => texture.destroy());\n  });\n"],"mappings":"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"}