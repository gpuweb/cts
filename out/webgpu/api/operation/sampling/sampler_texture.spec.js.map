{"version":3,"file":"sampler_texture.spec.js","names":["description","makeTestGroup","assert","range","AllFeaturesMaxLimitsGPUTest","TextureTestMixin","TexelView","g","test","desc","fn","t","device","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage","maxBindingsPerBindGroup","maxStorageTexturesInVertexStage","maxStorageTexturesInFragmentStage","maxStorageTexturesPerShaderStage","limits","numStorageTexturesInVertexStage","numStorageTexturesInFragmentStage","maxTestableCombosPerStage","isCompatibility","Math","min","textures","declarationLines","groups","layouts","textureIdToTexelValue","Map","samplerIds","Set","expected","addResource","stage","resourceId","resource","storageTexture","bindGroupEntries","length","bindGroupLayoutEntries","push","resourceType","GPUSampler","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","sampler","access","format","texture","width","max","debug","addTexture","textureNum","textureId","texelValue","get","undefined","set","createTextureTracked","size","usage","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","COPY_DST","data","Uint16Array","rg","x","offset","samplerNum","queue","writeTexture","createView","kAddressModes","getAddressMode","hash","depth","pow","addSampler","samplerId","has","add","addressHash","createSampler","minFilter","magFilter","mipmapFilter","addressModeU","addressModeV","addressModeW","numStorageTexturesInStage","code","i","texNum","smpNum","join","module","createShaderModule","bindGroupLayouts","map","entries","createBindGroupLayout","pipeline","createRenderPipeline","layout","createPipelineLayout","vertex","fragment","targets","primitive","topology","bindGroups","createBindGroup","getBindGroupLayout","numAcross","renderTarget","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","loadOp","storeOp","setPipeline","forEach","bindGroup","setBindGroup","y","setViewport","draw","end","submit","finish","expectedData","tid","sid","expTexelView","fromTextureDataByReference","Uint8Array","buffer","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","expectTexelViewComparisonIsOkInTexture","destroy"],"sources":["../../../../../src/webgpu/api/operation/sampling/sampler_texture.spec.ts"],"sourcesContent":["export const description = `\nTests samplers with textures.\n\n- test that you can use the maximum number of textures\n  with the maximum number of samplers.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\nimport { AllFeaturesMaxLimitsGPUTest, TextureTestMixin } from '../../../gpu_test.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nexport const g = makeTestGroup(TextureTestMixin(AllFeaturesMaxLimitsGPUTest));\n\ng.test('sample_texture_combos')\n  .desc(\n    `\nTest that you can use the maximum number of textures with the maximum number of samplers.\nand the maximum number of storage textures.\n\nThe test works by making the maximum number of texture+sampler combos and the max storage\ntextures per stage. Each texture is [maxSamplersPerShaderStage + maxStorageTexturesInStage, 1]\nin size and each texel is [textureId, samplerId]. A function \"useCombo<StageNum>(comboId)\" is\nmade that returns stage[stageNum].combo[comboId].texel[id, 0] or to put it another way, it\nreturns the nth texel from the nth combo for that stage.\n\nThese are read in both the vertex shader and fragment shader and written to a\n[maxSamplerPerShaderStage + maxStorageTexturesInStage, 2] texture where the top row is the\nvalues from the vertex shader and the bottom row from the fragment shader.\n\nThe result should be a texture that has a value in each texel unique to a particular combo\nor storage texture.\n`\n  )\n  .fn(t => {\n    const { device } = t;\n    const {\n      maxSampledTexturesPerShaderStage,\n      maxSamplersPerShaderStage,\n      maxBindingsPerBindGroup,\n      maxStorageTexturesInVertexStage,\n      maxStorageTexturesInFragmentStage,\n      maxStorageTexturesPerShaderStage,\n    } = device.limits;\n\n    assert(maxSampledTexturesPerShaderStage < 0xfffe);\n    assert(maxSamplersPerShaderStage < 0xfffe);\n\n    const numStorageTexturesInVertexStage =\n      maxStorageTexturesInVertexStage ?? maxStorageTexturesPerShaderStage;\n    const numStorageTexturesInFragmentStage =\n      maxStorageTexturesInFragmentStage ?? maxStorageTexturesPerShaderStage;\n\n    const maxTestableCombosPerStage = t.isCompatibility\n      ? Math.min(maxSampledTexturesPerShaderStage, maxSamplersPerShaderStage)\n      : maxSampledTexturesPerShaderStage * maxSamplersPerShaderStage;\n\n    const textures: GPUTexture[] = [];\n    const declarationLines: string[] = [];\n    const groups: GPUBindGroupEntry[][] = [[]];\n    const layouts: GPUBindGroupLayoutEntry[][] = [[]];\n    const textureIdToTexelValue = new Map<string, number>();\n    const samplerIds = new Set<string>();\n    // per stage, per texel, each texel has 2 numbers, the texture id, and sampler id\n    const expected: number[][][] = [[], []];\n\n    function addResource(\n      stage: number,\n      resourceId: string,\n      resource: GPUTextureView | GPUSampler,\n      storageTexture?: boolean\n    ) {\n      let bindGroupEntries = groups[groups.length - 1];\n      let bindGroupLayoutEntries = layouts[groups.length - 1];\n      if (bindGroupEntries.length === maxBindingsPerBindGroup) {\n        bindGroupEntries = [];\n        bindGroupLayoutEntries = [];\n        groups.push(bindGroupEntries);\n        layouts.push(bindGroupLayoutEntries);\n      }\n      const resourceType =\n        resource instanceof GPUSampler\n          ? 'sampler'\n          : storageTexture\n          ? 'texture_storage_2d<rgba8unorm, read>'\n          : 'texture_2d<f32>';\n      const binding = bindGroupEntries.length;\n      declarationLines.push(\n        `    @group(${groups.length - 1}) @binding(${binding}) var ${resourceId}: ${resourceType};`\n      );\n      bindGroupEntries.push({\n        binding,\n        resource,\n      });\n      bindGroupLayoutEntries.push({\n        binding,\n        visibility: stage === 0 ? GPUShaderStage.VERTEX : GPUShaderStage.FRAGMENT,\n        ...(resource instanceof GPUSampler\n          ? {\n              sampler: {},\n            }\n          : storageTexture\n          ? {\n              storageTexture: {\n                access: 'read-only',\n                format: 'rgba8unorm',\n              },\n            }\n          : {\n              texture: {},\n            }),\n      });\n    }\n\n    const width =\n      maxSamplersPerShaderStage +\n      Math.max(numStorageTexturesInVertexStage, numStorageTexturesInFragmentStage);\n    t.debug(`width: ${width}`);\n\n    function addTexture(stage: number, textureNum: number, storageTexture: boolean) {\n      const textureId = `tex${stage}_${textureNum}`;\n      let texelValue = textureIdToTexelValue.get(textureId);\n      if (texelValue === undefined) {\n        texelValue = textures.length + 1;\n        textureIdToTexelValue.set(textureId, texelValue);\n        const texture = t.createTextureTracked({\n          format: 'rgba8unorm',\n          size: [width, 1],\n          usage:\n            GPUTextureUsage.STORAGE_BINDING |\n            GPUTextureUsage.TEXTURE_BINDING |\n            GPUTextureUsage.COPY_DST,\n        });\n        textures.push(texture);\n        // Encode an rgba8unorm texture with rg16uint data where each texel is\n        // [texelValue | (stage << 15), {samplerId + 1}]\n        // The +1 is to avoid 0.\n        const data = new Uint16Array(width * 2);\n        const rg = texelValue | (stage << 15);\n        for (let x = 0; x < width; ++x) {\n          const offset = x * 2;\n          const samplerNum = (x % maxSamplersPerShaderStage) + 1;\n          data[offset + 0] = rg;\n          data[offset + 1] = storageTexture ? 0 : samplerNum;\n        }\n        device.queue.writeTexture({ texture }, data, {}, [width]);\n        addResource(stage, textureId, texture.createView(), storageTexture);\n      }\n      return { textureId, texelValue };\n    }\n\n    const kAddressModes = ['repeat', 'clamp-to-edge', 'mirror-repeat'] as const;\n    const getAddressMode = (hash: number, depth: number) => {\n      return kAddressModes[\n        ((hash / Math.pow(kAddressModes.length, depth)) | 0) % kAddressModes.length\n      ];\n    };\n\n    function addSampler(stage: number, samplerNum: number) {\n      const samplerId = `smp${stage}_${samplerNum}`;\n      if (!samplerIds.has(samplerId)) {\n        const samplerNum = samplerIds.size;\n        samplerIds.add(samplerId);\n        // try to make each sampler unique. This is because some backends\n        // coalesce samplers with the same settings.\n        const addressHash = samplerNum >> 3;\n        const sampler = device.createSampler({\n          minFilter: samplerNum & 1 ? 'linear' : 'nearest',\n          magFilter: samplerNum & 2 ? 'linear' : 'nearest',\n          mipmapFilter: samplerNum & 4 ? 'linear' : 'nearest',\n          addressModeU: getAddressMode(addressHash, 0),\n          addressModeV: getAddressMode(addressHash, 1),\n          addressModeW: getAddressMode(addressHash, 2),\n        });\n        addResource(stage, samplerId, sampler);\n      }\n      return samplerId;\n    }\n\n    const numStorageTexturesInStage = [\n      numStorageTexturesInVertexStage,\n      numStorageTexturesInFragmentStage,\n    ];\n\n    // Note: We are storing textureId, samplerId in the texture. That suggests we could use rgba32uint\n    // texture but we can't do that because we want to be able to set the samplers to linear.\n    // Similarly we can't use rgba32float since they're not filterable by default.\n    // So, we encode via rgba8unorm where rg is a 16bit textureId and ba is a 16bit samplerId\n    const code = `\n    // maxTestableCombosPerStage: ${maxTestableCombosPerStage}\n    // numStorageTexturesPerVertexStage: ${numStorageTexturesInVertexStage}\n    // numStorageTexturesPerFragmentStage: ${numStorageTexturesInFragmentStage}\n\n    fn sample(t: texture_2d<f32>, s: sampler, validId: u32, currentId: u32, c: vec4f) -> vec4f {\n      let size = textureDimensions(t, 0);\n      let uv = vec2f((f32(currentId % ${maxSamplersPerShaderStage}) + 0.5) / f32(size.x), 0.5);\n      let v = textureSampleLevel(t, s, uv, 0);\n      return select(c, v, currentId == validId);\n    }\n\n    fn load(t: texture_storage_2d<rgba8unorm, read>, validId: u32, currentId: u32, c: vec4f) -> vec4f {\n      let size = textureDimensions(t);\n      let uv = vec2u(currentId % size.x, 0);\n      let v = textureLoad(t, uv);\n      return select(c, v, currentId == validId);\n    }\n\n    ${range(\n      2,\n      stage => `\n      fn useCombos${stage}(id: u32) -> vec4f {\n        var c: vec4f;\n${range(maxTestableCombosPerStage, i => {\n  const texNum = (i / maxSamplersPerShaderStage) | 0;\n  const { textureId, texelValue } = addTexture(stage, texNum, false);\n  const smpNum = i % maxSamplersPerShaderStage;\n  const samplerId = addSampler(stage, smpNum);\n  expected[stage].push([texelValue | (stage << 15), smpNum + 1]);\n  return `        c = sample(${textureId}, ${samplerId}, ${i}, id, c);`;\n}).join('\\n')}\n${range(numStorageTexturesInStage[stage], i => {\n  const texNum = textures.length;\n  const { textureId, texelValue } = addTexture(stage, texNum, true);\n  expected[stage].push([texelValue | (stage << 15), 0]);\n  return `        c = load(${textureId}, ${i + maxTestableCombosPerStage}, id, c);`;\n}).join('\\n')}\n        return c;\n      }\n    `\n    ).join('\\n\\n')}\n\n${declarationLines.join('\\n')}\n\n    struct VOut {\n      @builtin(position) pos: vec4f,\n      @location(0) value: vec4f,\n    };\n\n    @vertex fn vs(@builtin(instance_index) iNdx: u32) -> VOut {\n      return VOut(\n        vec4f(0, 0, 0, 1),\n        useCombos0(iNdx),\n      );\n    }\n\n    @fragment fn fs(vin: VOut) -> @location(0) vec4u {\n      let ndx = u32(vin.pos.x);\n      let f = select(vin.value, useCombos1(ndx), vin.pos.y > 1.0);\n\n      // We're putting two u16 values in the source data but as rgba8unorm.\n      // Convert them back to u32 then split them back into two u16s\n      let bytes = pack4x8unorm(f);\n      return vec4u(bytes & 0xffff, bytes >> 16, 0, 0);\n    }\n    `;\n\n    t.debug(code);\n\n    const module = device.createShaderModule({ code });\n    const bindGroupLayouts = layouts.map(entries => device.createBindGroupLayout({ entries }));\n\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({ bindGroupLayouts }),\n      vertex: {\n        module,\n      },\n      fragment: {\n        module,\n        targets: [{ format: 'rg16uint' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n\n    const bindGroups = groups.map((entries, i) =>\n      device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(i),\n        entries,\n      })\n    );\n\n    const numAcross =\n      maxTestableCombosPerStage +\n      numStorageTexturesInVertexStage +\n      numStorageTexturesInFragmentStage;\n\n    const renderTarget = t.createTextureTracked({\n      format: 'rg16uint',\n      size: [numAcross, 2],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    textures.push(renderTarget);\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    bindGroups.forEach((bindGroup, i) => pass.setBindGroup(i, bindGroup));\n    for (let y = 0; y < 2; ++y) {\n      for (let x = 0; x < numAcross; ++x) {\n        pass.setViewport(x, y, 1, 1, 0, 1);\n        pass.draw(1, 1, 0, x);\n      }\n    }\n    pass.end();\n\n    device.queue.submit([encoder.finish()]);\n\n    const expectedData = new Uint16Array(numAcross * 2 * 2);\n    for (let stage = 0; stage < 2; ++stage) {\n      expected[stage].forEach(([tid, sid], i) => {\n        const offset = (numAcross * stage + i) * 2;\n        expectedData[offset + 0] = tid;\n        expectedData[offset + 1] = sid;\n      });\n    }\n\n    const expTexelView = TexelView.fromTextureDataByReference(\n      'rg16uint',\n      new Uint8Array(expectedData.buffer),\n      {\n        bytesPerRow: numAcross * 4,\n        rowsPerImage: 2,\n        subrectOrigin: [0, 0, 0],\n        subrectSize: [numAcross, 2],\n      }\n    );\n\n    const size = [numAcross, 2];\n    t.expectTexelViewComparisonIsOkInTexture({ texture: renderTarget }, expTexelView, size);\n\n    textures.forEach(texture => texture.destroy());\n  });\n"],"mappings":"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"}