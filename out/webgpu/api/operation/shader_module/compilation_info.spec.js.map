{"version":3,"file":"compilation_info.spec.js","names":["description","makeTestGroup","keysOf","assert","GPUTest","g","kValidShaderSources","valid","name","_code","kInvalidShaderSources","_errorLine","_errorLinePos","kAllShaderSources","kOriginalSource","Array","fill","map","_","i","join","kSourceMaps","none","undefined","empty","version","sources","sourcesContent","names","mappings","invalid","notAnything","nonMatching","kSourceMapsKeys","test","desc","params","u","combineWithParams","beginSubcases","combine","fn","t","sourceMapName","shaderModule","expectGPUError","sourceMap","device","createShaderModule","code","info","getCompilationInfo","expect","GPUCompilationInfo","errorCount","message","messages","type","foundAppropriateError","lineNum","linePos","offset","length","lineOffset","indexOf","expectedOffset"],"sources":["../../../../../src/webgpu/api/operation/shader_module/compilation_info.spec.ts"],"sourcesContent":["export const description = `\nShaderModule CompilationInfo tests.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kValidShaderSources = [\n  {\n    valid: true,\n    name: 'ascii',\n    _code: `\n      @vertex fn main() -> @builtin(position) vec4<f32> {\n        return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      }`,\n  },\n  {\n    valid: true,\n    name: 'unicode',\n    _code: `\n      // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ ðŸ‘©â€ðŸ’»\n      @vertex fn main() -> @builtin(position) vec4<f32> {\n        return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      }`,\n  },\n];\n\nconst kInvalidShaderSources = [\n  {\n    valid: false,\n    name: 'ascii',\n    _errorLine: 4,\n    _code: `\n      @vertex fn main() -> @builtin(position) vec4<f32> {\n        // Expected Error: unknown function 'unknown'\n        return unknown(0.0, 0.0, 0.0, 1.0);\n      }`,\n  },\n  {\n    valid: false,\n    name: 'unicode',\n    _errorLine: 5,\n    _code: `\n      // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ ðŸ‘©â€ðŸ’»\n      @vertex fn main() -> @builtin(position) vec4<f32> {\n        // Expected Error: unknown function 'unknown'\n        return unknown(0.0, 0.0, 0.0, 1.0);\n      }`,\n  },\n  {\n    valid: false,\n    name: 'carriage-return',\n    _errorLine: 5,\n    _code:\n      `\n      @vertex fn main() -> @builtin(position) vec4<f32> {` +\n      '\\r\\n' +\n      `\n        // Expected Error: unknown function 'unknown'\n        return unknown(0.0, 0.0, 0.0, 1.0);\n      }`,\n  },\n  {\n    valid: false,\n    name: 'unicode-multi-byte-characters',\n    _errorLine: 1,\n    // This shader is simplistic enough to always result in the same error position.\n    // Generally, various backends may choose to report the error at different positions within the\n    // line, so it's difficult to meaningfully validate them.\n    _errorLinePos: 19,\n    _code: `/*ðŸˆðŸˆðŸˆðŸˆðŸˆðŸˆðŸˆ*/?\n// Expected Error: invalid character found`,\n  },\n];\n\nconst kAllShaderSources = [...kValidShaderSources, ...kInvalidShaderSources];\n\n// This is the source the sourcemap refers to.\nconst kOriginalSource = new Array(20)\n  .fill(0)\n  .map((_, i) => `original line ${i}`)\n  .join('\\n');\n\nconst kSourceMaps: { [name: string]: undefined | object } = {\n  none: undefined,\n  empty: {},\n  // A valid source map. It maps `unknown` on lines 4 and line 5 to\n  // `wasUnknown` from lines 20, 21 respectively\n  valid: {\n    version: 3,\n    sources: ['myCode'],\n    sourcesContent: [kOriginalSource],\n    names: ['myMain', 'wasUnknown'],\n    mappings: ';kBAYkCA,OACd;SAElB;gBAKOC;gBACAA',\n  },\n  // not a valid sourcemap\n  invalid: {\n    version: -123,\n    notAnything: {},\n  },\n  // The correct format but this data is for lines 11,12 even\n  // though the source only has 5 or 6 lines\n  nonMatching: {\n    version: 3,\n    sources: ['myCode'],\n    sourcesContent: [kOriginalSource],\n    names: ['myMain'],\n    mappings: ';;;;;;;;;;kBAYkCA,OACd;SAElB',\n  },\n};\nconst kSourceMapsKeys = keysOf(kSourceMaps);\n\ng.test('getCompilationInfo_returns')\n  .desc(\n    `\n    Test that getCompilationInfo() can be called on any ShaderModule.\n\n    Note: sourcemaps are not used in the WebGPU API. We are only testing that\n    browser that happen to use them don't fail or crash if the sourcemap is\n    bad or invalid.\n\n    - Test for both valid and invalid shader modules.\n    - Test for shader modules containing only ASCII and those containing unicode characters.\n    - Test that the compilation info for valid shader modules contains no errors.\n    - Test that the compilation info for invalid shader modules contains at least one error.`\n  )\n  .params(u =>\n    u.combineWithParams(kAllShaderSources).beginSubcases().combine('sourceMapName', kSourceMapsKeys)\n  )\n  .fn(async t => {\n    const { _code, valid, sourceMapName } = t.params;\n\n    const shaderModule = t.expectGPUError(\n      'validation',\n      () => {\n        const sourceMap = kSourceMaps[sourceMapName];\n        return t.device.createShaderModule({ code: _code, ...(sourceMap && { sourceMap }) });\n      },\n      !valid\n    );\n\n    const info = await shaderModule.getCompilationInfo();\n\n    t.expect(\n      info instanceof GPUCompilationInfo,\n      'Expected a GPUCompilationInfo object to be returned'\n    );\n\n    // Expect that we get zero error messages from a valid shader.\n    // Message types other than errors are OK.\n    let errorCount = 0;\n    for (const message of info.messages) {\n      if (message.type === 'error') {\n        errorCount++;\n      }\n    }\n    if (valid) {\n      t.expect(errorCount === 0, \"Expected zero GPUCompilationMessages of type 'error'\");\n    } else {\n      t.expect(errorCount > 0, \"Expected at least one GPUCompilationMessages of type 'error'\");\n    }\n  });\n\ng.test('line_number_and_position')\n  .desc(\n    `\n    Test that line numbers reported by compilationInfo either point at an appropriate line and\n    position or at 0:0, indicating an unknown position.\n\n    Note: sourcemaps are not used in the WebGPU API. We are only testing that\n    browser that happen to use them don't fail or crash if the sourcemap is\n    bad or invalid.\n\n    - Test for invalid shader modules containing containing at least one error.\n    - Test for shader modules containing only ASCII and those containing unicode characters.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kInvalidShaderSources)\n      .beginSubcases()\n      .combine('sourceMapName', kSourceMapsKeys)\n  )\n  .fn(async t => {\n    const { _code, _errorLine, _errorLinePos, sourceMapName } = t.params;\n\n    const shaderModule = t.expectGPUError('validation', () => {\n      const sourceMap = kSourceMaps[sourceMapName];\n      return t.device.createShaderModule({ code: _code, ...(sourceMap && { sourceMap }) });\n    });\n\n    const info = await shaderModule.getCompilationInfo();\n\n    let foundAppropriateError = false;\n    for (const message of info.messages) {\n      if (message.type === 'error') {\n        // Some backends may not be able to indicate a precise location for the error. In those\n        // cases a line and position of 0 should be reported.\n        // If a line is reported, it should point at the correct line (1-based).\n        t.expect(\n          (message.lineNum === 0) === (message.linePos === 0),\n          `Got message.lineNum ${message.lineNum}, .linePos ${message.linePos}, but GPUCompilationMessage should specify both or neither`\n        );\n\n        if (message.lineNum === 0) {\n          foundAppropriateError = true;\n          break;\n        }\n\n        if (message.lineNum === _errorLine) {\n          foundAppropriateError = true;\n          if (_errorLinePos !== undefined) {\n            t.expect(\n              message.linePos === _errorLinePos,\n              `Got message.linePos ${message.linePos}, expected ${_errorLinePos}`\n            );\n          }\n          break;\n        }\n      }\n    }\n    t.expect(\n      foundAppropriateError,\n      'Expected to find an error which corresponded with the erroneous line'\n    );\n  });\n\ng.test('offset_and_length')\n  .desc(\n    `Test that message offsets and lengths are valid and align with any reported lineNum and linePos.\n\n     Note: sourcemaps are not used in the WebGPU API. We are only testing that\n     browser that happen to use them don't fail or crash if the sourcemap is\n     bad or invalid.\n\n    - Test for valid and invalid shader modules.\n    - Test for shader modules containing only ASCII and those containing unicode characters.`\n  )\n  .params(u =>\n    u.combineWithParams(kAllShaderSources).beginSubcases().combine('sourceMapName', kSourceMapsKeys)\n  )\n  .fn(async t => {\n    const { _code, valid, sourceMapName } = t.params;\n\n    const shaderModule = t.expectGPUError(\n      'validation',\n      () => {\n        const sourceMap = kSourceMaps[sourceMapName];\n        return t.device.createShaderModule({ code: _code, ...(sourceMap && { sourceMap }) });\n      },\n      !valid\n    );\n\n    const info = await shaderModule.getCompilationInfo();\n\n    for (const message of info.messages) {\n      // Any offsets and lengths should reference valid spans of the shader code.\n      t.expect(\n        message.offset <= _code.length && message.offset + message.length <= _code.length,\n        'message.offset and .length should be within the shader source'\n      );\n\n      // If a valid line number and position are given, the offset should point the the same\n      // location in the shader source.\n      if (message.lineNum !== 0 && message.linePos !== 0) {\n        let lineOffset = 0;\n        for (let i = 0; i < message.lineNum - 1; ++i) {\n          lineOffset = _code.indexOf('\\n', lineOffset);\n          assert(lineOffset !== -1);\n          lineOffset += 1;\n        }\n\n        const expectedOffset = lineOffset + message.linePos - 1;\n        t.expect(\n          message.offset === expectedOffset,\n          `message.lineNum (${message.lineNum}) and .linePos (${message.linePos}) point to a different offset (${lineOffset} + ${message.linePos} - 1 = ${expectedOffset}) than .offset (${message.offset})`\n        );\n      }\n    }\n  });\n"],"mappings":"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"}