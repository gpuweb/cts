{"version":3,"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"names":["description","makeTestGroup","assert","memcpy","unreachable","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kPerStageBindingLimits","kVertexFormatInfo","kVertexFormats","GPUTest","float32ToFloat16Bits","normalizedIntegerAsFloat","align","clamp","mapBufferAttribs","buffer","f","newAttributes","a","attributes","push","shaderLocation","mapStateAttribs","buffers","map","b","VertexStateTest","makeTestWGSL","vertexCount","instanceCount","maxUniformBuffers","max","vsInputs","vsChecks","vsBindings","format","shaderComponentCount","componentCount","i","shaderType","shaderBaseType","maxCount","indexBuiltin","stepMode","storageType","component","expected","attribComponent","providedData","type","floatTolerance","makeTestPipeline","module","device","createShaderModule","code","bufferLayouts","slot","createRenderPipeline","vertex","entryPoint","primitive","topology","fragment","targets","submitRenderPass","pipeline","expectedData","testTexture","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","setBindGroup","setVertexBuffer","vbOffset","draw","end","queue","submit","finish","expectSingleColor","exp","R","generateTestData","formatInfo","bitSize","bytesPerComponent","data","Float32Array","vertexData","Uint16Array","testComponentCount","length","Math","pow","Int32Array","Int16Array","Int8Array","Uint32Array","Uint8Array","v","expandTestData","vertexComponentSize","byteLength","expectedComponentSize","expandedVertexData","expandedExpectedData","index","targetVertexOffset","sourceVertexOffset","src","start","dst","targetExpectedOffset","sourceExpectedOffset","interleaveVertexDataInto","target","targetStride","offset","srcStart","dstStart","createTestAndPipelineData","state","attrib","testData","createExpectedBG","bgEntries","expectedDataBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","STORAGE","binding","resource","createBindGroup","layout","getBindGroupLayout","entries","createVertexBuffers","vertexBuffers","ArrayBuffer","arrayStride","fill","VERTEX","runTest","expectedDataBG","g","test","desc","params","u","combine","beginSubcases","fn","t","expand","p","formatSize","Set","min","paramsSubcasesOnly","stepModes","vbCount","additionalVBOffset","kVertexCount","kInstanceCount","formatByteSize","alignedFormatByteSize","baseDataVertexCount","baseData","vertexBuffer","baseTestData","expectedDataBytesPerVertex","slice","attribs","attributesPerBuffer","ceil","attributesEmitted","j","kCount","stride0TestData","stride0VertexBuffer","originalData","expandedData","set","varyingTestData","varyingVertexBuffer"],"mappings":"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","sourcesContent":["export const description = `\nTODO: Test more corner case values for Float16 / Float32 (INF, NaN, +-0, ...) and reduce the\nfloat tolerance.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, memcpy, unreachable } from '../../../../common/util/util.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kPerStageBindingLimits,\n  kVertexFormatInfo,\n  kVertexFormats,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { float32ToFloat16Bits, normalizedIntegerAsFloat } from '../../../util/conversion.js';\nimport { align, clamp } from '../../../util/math.js';\n\n// These types mirror the structure of GPUVertexBufferLayout but allow defining the extra\n// dictionary members at the GPUVertexBufferLayout and GPUVertexAttribute level. The are used\n// like so:\n//\n//   VertexState<{arrayStride: number}, {format: VertexFormat}>\n//   VertexBuffer<{arrayStride: number}, {format: VertexFormat}>\n//   VertexAttrib<{format: VertexFormat}>\ntype VertexAttrib<A> = A & { shaderLocation: number };\ntype VertexBuffer<V, A> = V & {\n  slot: number;\n  attributes: VertexAttrib<A>[];\n};\ntype VertexState<V, A> = VertexBuffer<V, A>[];\n\ntype VertexLayoutState<V, A> = VertexState<\n  { stepMode: GPUVertexStepMode; arrayStride: number } & V,\n  { format: GPUVertexFormat; offset: number } & A\n>;\n\nfunction mapBufferAttribs<V, A1, A2>(\n  buffer: VertexBuffer<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexBuffer<V, A2> {\n  const newAttributes: VertexAttrib<A2>[] = [];\n  for (const a of buffer.attributes) {\n    newAttributes.push({\n      shaderLocation: a.shaderLocation,\n      ...f(buffer, a),\n    });\n  }\n\n  return { ...buffer, attributes: newAttributes };\n}\n\nfunction mapStateAttribs<V, A1, A2>(\n  buffers: VertexState<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexState<V, A2> {\n  return buffers.map(b => mapBufferAttribs(b, f));\n}\n\ntype TestData = {\n  shaderBaseType: string;\n  floatTolerance?: number;\n  // The number of vertex components in the vertexData (expectedData might contain more because\n  // it is padded to 4 components).\n  testComponentCount: number;\n  // The data that will be in the uniform buffer and used to check the vertex inputs.\n  expectedData: ArrayBuffer;\n  // The data that will be in the vertex buffer.\n  vertexData: ArrayBuffer;\n};\n\nclass VertexStateTest extends GPUTest {\n  // Generate for VS + FS (entrypoints vsMain / fsMain) that for each attribute will check that its\n  // value corresponds to what's expected (as provided by a uniform buffer per attribute) and then\n  // renders each vertex at position (vertexIndex, instanceindex) with either 1 (success) or\n  // a negative number corresponding to the check number (in case you need to debug a failure).\n  makeTestWGSL(\n    buffers: VertexState<\n      { stepMode: GPUVertexStepMode },\n      {\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): string {\n    // In the base WebGPU spec maxVertexAttributes is larger than maxUniformBufferPerStage. We'll\n    // use a combination of uniform and storage buffers to cover all possible attributes. This\n    // happens to work because maxUniformBuffer + maxStorageBuffer = 12 + 8 = 20 which is larger\n    // than maxVertexAttributes = 16.\n    // However this might not work in the future for implementations that allow even more vertex\n    // attributes so there will need to be larger changes when that happens.\n    const maxUniformBuffers = kPerStageBindingLimits['uniformBuf'].max;\n    assert(maxUniformBuffers + kPerStageBindingLimits['storageBuf'].max >= kMaxVertexAttributes);\n\n    let vsInputs = '';\n    let vsChecks = '';\n    let vsBindings = '';\n\n    for (const b of buffers) {\n      for (const a of b.attributes) {\n        const format = kVertexFormatInfo[a.format];\n        const shaderComponentCount = a.shaderComponentCount ?? format.componentCount;\n        const i = a.shaderLocation;\n\n        // shaderType is either a scalar type like f32 or a vecN<scalarType>\n        let shaderType = a.shaderBaseType;\n        if (shaderComponentCount !== 1) {\n          shaderType = `vec${shaderComponentCount}<${shaderType}>`;\n        }\n\n        let maxCount = `${vertexCount}`;\n        let indexBuiltin = `input.vertexIndex`;\n        if (b.stepMode === 'instance') {\n          maxCount = `${instanceCount}`;\n          indexBuiltin = `input.instanceIndex`;\n        }\n\n        // Start using storage buffers when we run out of uniform buffers.\n        let storageType = 'uniform';\n        if (i >= maxUniformBuffers) {\n          storageType = 'storage, read';\n        }\n\n        vsInputs += `  @location(${i}) attrib${i} : ${shaderType},\\n`;\n        vsBindings += `struct S${i} { data : array<vec4<${a.shaderBaseType}>, ${maxCount}> };\\n`;\n        vsBindings += `@group(0) @binding(${i}) var<${storageType}> providedData${i} : S${i};\\n`;\n\n        // Generate the all the checks for the attributes.\n        for (let component = 0; component < shaderComponentCount; component++) {\n          // Components are filled with (0, 0, 0, 1) if they aren't provided data from the pipeline.\n          if (component >= format.componentCount) {\n            const expected = component === 3 ? '1' : '0';\n            vsChecks += `  check(input.attrib${i}[${component}] == ${a.shaderBaseType}(${expected}));\\n`;\n            continue;\n          }\n\n          // Check each component individually, with special handling of tolerance for floats.\n          const attribComponent =\n            shaderComponentCount === 1 ? `input.attrib${i}` : `input.attrib${i}[${component}]`;\n          const providedData = `providedData${i}.data[${indexBuiltin}][${component}]`;\n          if (format.type === 'uint' || format.type === 'sint') {\n            vsChecks += `  check(${attribComponent} == ${providedData});\\n`;\n          } else {\n            vsChecks += `  check(floatsSimilar(${attribComponent}, ${providedData}, f32(${\n              a.floatTolerance ?? 0\n            })));\\n`;\n          }\n        }\n      }\n    }\n\n    return `\nstruct Inputs {\n${vsInputs}\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n};\n\n${vsBindings}\n\nvar<private> vsResult : i32 = 1;\nvar<private> checkIndex : i32 = 0;\nfn check(success : bool) {\n  if (!success) {\n    vsResult = -checkIndex;\n  }\n  checkIndex = checkIndex + 1;\n}\n\nfn floatsSimilar(a : f32, b : f32, tolerance : f32) -> bool {\n  // TODO do we check for + and - 0?\n  return abs(a - b) < tolerance;\n}\n\nfn doTest(input : Inputs) {\n${vsChecks}\n}\n\nstruct VSOutputs {\n  @location(0) @interpolate(flat) result : i32,\n  @builtin(position) position : vec4<f32>,\n};\n\n@stage(vertex) fn vsMain(input : Inputs) -> VSOutputs {\n  doTest(input);\n\n  // Place that point at pixel (vertexIndex, instanceIndex) in a framebuffer of size\n  // (vertexCount , instanceCount).\n  var output : VSOutputs;\n  output.position = vec4<f32>(\n    ((f32(input.vertexIndex) + 0.5) / ${vertexCount}.0 * 2.0) - 1.0,\n    ((f32(input.instanceIndex) + 0.5) / ${instanceCount}.0 * 2.0) - 1.0,\n    0.0, 1.0\n  );\n  output.result = vsResult;\n  return output;\n}\n\n@stage(fragment) fn fsMain(@location(0) @interpolate(flat) result : i32)\n  -> @location(0) i32 {\n  return result;\n}\n    `;\n  }\n\n  makeTestPipeline(\n    buffers: VertexState<\n      { stepMode: GPUVertexStepMode; arrayStride: number },\n      {\n        offset: number;\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): GPURenderPipeline {\n    const module = this.device.createShaderModule({\n      code: this.makeTestWGSL(buffers, vertexCount, instanceCount),\n    });\n\n    const bufferLayouts: GPUVertexBufferLayout[] = [];\n    for (const b of buffers) {\n      bufferLayouts[b.slot] = b;\n    }\n\n    return this.device.createRenderPipeline({\n      vertex: {\n        module,\n        entryPoint: 'vsMain',\n        buffers: bufferLayouts,\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fsMain',\n        targets: [\n          {\n            format: 'r32sint',\n          },\n        ],\n      },\n    });\n  }\n\n  // Runs the render pass drawing points in a vertexCount*instanceCount rectangle, then check each\n  // of produced a value of 1 which means that the tests in the shader passed.\n  submitRenderPass(\n    pipeline: GPURenderPipeline,\n    buffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}>,\n    expectedData: GPUBindGroup,\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    const testTexture = this.device.createTexture({\n      format: 'r32sint',\n      size: [vertexCount, instanceCount],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: testTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, expectedData);\n    for (const buffer of buffers) {\n      pass.setVertexBuffer(buffer.slot, buffer.buffer, buffer.vbOffset ?? 0);\n    }\n    pass.draw(vertexCount, instanceCount);\n    pass.end();\n\n    this.device.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(testTexture, 'r32sint', {\n      size: [vertexCount, instanceCount, 1],\n      exp: { R: 1 },\n    });\n  }\n\n  // Generate TestData for the format with interesting test values.\n  // MAINTENANCE_TODO cache the result on the fixture?\n  // Note that the test data always starts with an interesting value, so that using the first\n  // test value in a test is still meaningful.\n  generateTestData(format: GPUVertexFormat): TestData {\n    const formatInfo = kVertexFormatInfo[format];\n    const bitSize = formatInfo.bytesPerComponent * 8;\n\n    switch (formatInfo.type) {\n      case 'float': {\n        const data = [42.42, 0.0, 1.0, -1.0, 1000, -18.7, 25.17];\n        const expectedData = new Float32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data.map(float32ToFloat16Bits)).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n          floatTolerance: 0.05,\n        };\n      }\n\n      case 'sint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1), // min value\n        ];\n        const expectedData = new Int32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Int16Array(data).buffer\n            : new Int8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'i32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'uint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const expectedData = new Uint32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data).buffer\n            : new Uint8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'u32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'snorm': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2,bitSize - 2),\n          Math.pow(2,bitSize - 1) - 1, // max value\n          -Math.pow(2,bitSize - 2),\n          -Math.pow(2,bitSize - 1), // min value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Int16Array(data).buffer\n            : bitSize === 8\n            ? new Int8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, true)))\n            .buffer,\n          vertexData,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, true),\n        };\n      }\n\n      case 'unorm': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Uint16Array(data).buffer\n            : bitSize === 8\n            ? new Uint8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, false)))\n            .buffer,\n          vertexData: vertexData!,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, false),\n        };\n      }\n    }\n  }\n\n  // The TestData generated for a format might not contain enough data for all the vertices we are\n  // going to draw, so we expand them by adding additional copies of the vertexData as needed.\n  // expectedData is a bit different because it also needs to be unpacked to have `componentCount`\n  // components every 4 components (because the shader uses vec4 for the expected data).\n  expandTestData(data: TestData, maxCount: number, componentCount: number): TestData {\n    const vertexComponentSize = data.vertexData.byteLength / data.testComponentCount;\n    const expectedComponentSize = data.expectedData.byteLength / data.testComponentCount;\n\n    const expandedVertexData = new Uint8Array(maxCount * componentCount * vertexComponentSize);\n    const expandedExpectedData = new Uint8Array(4 * maxCount * expectedComponentSize);\n\n    for (let index = 0; index < maxCount; index++) {\n      for (let component = 0; component < componentCount; component++) {\n        // If only we had some builtin JS memcpy function between ArrayBuffers...\n        const targetVertexOffset = (index * componentCount + component) * vertexComponentSize;\n        const sourceVertexOffset = targetVertexOffset % data.vertexData.byteLength;\n        memcpy(\n          { src: data.vertexData, start: sourceVertexOffset, length: vertexComponentSize },\n          { dst: expandedVertexData, start: targetVertexOffset }\n        );\n\n        const targetExpectedOffset = (index * 4 + component) * expectedComponentSize;\n        const sourceExpectedOffset =\n          ((index * componentCount + component) * expectedComponentSize) %\n          data.expectedData.byteLength;\n        memcpy(\n          { src: data.expectedData, start: sourceExpectedOffset, length: expectedComponentSize },\n          { dst: expandedExpectedData, start: targetExpectedOffset }\n        );\n      }\n    }\n\n    return {\n      shaderBaseType: data.shaderBaseType,\n      testComponentCount: maxCount * componentCount,\n      floatTolerance: data.floatTolerance,\n      expectedData: expandedExpectedData.buffer,\n      vertexData: expandedVertexData.buffer,\n    };\n  }\n\n  // Copies `size` bytes from `source` to `target` starting at `offset` each `targetStride`.\n  // (the data in `source` is assumed packed)\n  interleaveVertexDataInto(\n    target: ArrayBuffer,\n    src: ArrayBuffer,\n    { targetStride, offset, size }: { targetStride: number; offset: number; size: number }\n  ) {\n    const dst = new Uint8Array(target);\n    for (\n      let srcStart = 0, dstStart = offset;\n      srcStart < src.byteLength;\n      srcStart += size, dstStart += targetStride\n    ) {\n      memcpy({ src, start: srcStart, length: size }, { dst, start: dstStart });\n    }\n  }\n\n  createTestAndPipelineData<V, A>(\n    state: VertexLayoutState<V, A>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexLayoutState<V, A & TestData> {\n    // Gather the test data and some additional test state for attribs.\n    return mapStateAttribs(state, (buffer, attrib) => {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n      const formatInfo = kVertexFormatInfo[attrib.format];\n\n      let testData = this.generateTestData(attrib.format);\n      testData = this.expandTestData(testData, maxCount, formatInfo.componentCount);\n\n      return {\n        ...testData,\n        ...attrib,\n      };\n    });\n  }\n\n  createExpectedBG(state: VertexState<{}, TestData>, pipeline: GPURenderPipeline): GPUBindGroup {\n    // Create the bindgroups from that test data\n    const bgEntries: GPUBindGroupEntry[] = [];\n\n    for (const buffer of state) {\n      for (const attrib of buffer.attributes) {\n        const expectedDataBuffer = this.makeBufferWithContents(\n          new Uint8Array(attrib.expectedData),\n          GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE\n        );\n        bgEntries.push({\n          binding: attrib.shaderLocation,\n          resource: { buffer: expectedDataBuffer },\n        });\n      }\n    }\n\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: bgEntries,\n    });\n  }\n\n  createVertexBuffers(\n    state: VertexLayoutState<{ vbOffset?: number }, TestData>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> {\n    // Create the vertex buffers\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> = [];\n\n    for (const buffer of state) {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n\n      // Fill the vertex data with garbage so that we don't get `0` (which could be a test value)\n      // if the vertex shader loads the vertex data incorrectly.\n      const vertexData = new ArrayBuffer(\n        align(buffer.arrayStride * maxCount + (buffer.vbOffset ?? 0), 4)\n      );\n      new Uint8Array(vertexData).fill(0xc4);\n\n      for (const attrib of buffer.attributes) {\n        const formatInfo = kVertexFormatInfo[attrib.format];\n        this.interleaveVertexDataInto(vertexData, attrib.vertexData, {\n          targetStride: buffer.arrayStride,\n          offset: (buffer.vbOffset ?? 0) + attrib.offset,\n          size: formatInfo.componentCount * formatInfo.bytesPerComponent,\n        });\n      }\n\n      vertexBuffers.push({\n        slot: buffer.slot,\n        buffer: this.makeBufferWithContents(new Uint8Array(vertexData), GPUBufferUsage.VERTEX),\n        vbOffset: buffer.vbOffset,\n        attributes: [],\n      });\n    }\n\n    return vertexBuffers;\n  }\n\n  runTest(\n    buffers: VertexLayoutState<{ vbOffset?: number }, { shaderComponentCount?: number }>,\n    // Default to using 20 vertices and 20 instances so that we cover each of the test data at least\n    // once (at the time of writing the largest testData has 16 values).\n    vertexCount: number = 20,\n    instanceCount: number = 20\n  ) {\n    const testData = this.createTestAndPipelineData(buffers, vertexCount, instanceCount);\n    const pipeline = this.makeTestPipeline(testData, vertexCount, instanceCount);\n    const expectedDataBG = this.createExpectedBG(testData, pipeline);\n    const vertexBuffers = this.createVertexBuffers(testData, vertexCount, instanceCount);\n    this.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, vertexCount, instanceCount);\n  }\n}\n\nexport const g = makeTestGroup(VertexStateTest);\n\ng.test('vertex_format_to_shader_format_conversion')\n  .desc(\n    `Test that the raw data passed in vertex buffers is correctly converted to the input type in the shader. Test for:\n  - all formats\n  - 1 to 4 components in the shader's input type (unused components are filled with 0 and except the 4th with 1)\n  - various locations\n  - various slots`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .combine('shaderComponentCount', [1, 2, 3, 4])\n      .beginSubcases()\n      .combine('slot', [0, 1, kMaxVertexBuffers - 1])\n      .combine('shaderLocation', [0, 1, kMaxVertexAttributes - 1])\n  )\n  .fn(t => {\n    const { format, shaderComponentCount, slot, shaderLocation } = t.params;\n    t.runTest([\n      {\n        slot,\n        arrayStride: 16,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation,\n            format,\n            offset: 0,\n            shaderComponentCount,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('setVertexBuffer_offset_and_attribute_offset')\n  .desc(\n    `Test that the vertex buffer offset and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various setVertexBuffer offsets\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbOffset', [0, 4, 400, 1004])\n      .combine('arrayStride', [128])\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n        return new Set([\n          0,\n          4,\n          8,\n          formatSize,\n          formatSize * 2,\n          p.arrayStride / 2,\n          p.arrayStride - formatSize - 4,\n          p.arrayStride - formatSize - 8,\n          p.arrayStride - formatSize - formatSize,\n          p.arrayStride - formatSize - formatSize * 2,\n          p.arrayStride - formatSize,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, vbOffset, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        vbOffset,\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('non_zero_array_stride_and_attribute_offset')\n  .desc(\n    `Test that the array stride and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various array strides\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .expand('arrayStride', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n\n        return [align(formatSize, 4), align(formatSize, 4) + 4, kMaxVertexBufferArrayStride];\n      })\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n        return new Set(\n          [\n            0,\n            formatSize,\n            4,\n            p.arrayStride / 2,\n            p.arrayStride - formatSize * 2,\n            p.arrayStride - formatSize - 4,\n            p.arrayStride - formatSize,\n          ].map(offset => clamp(offset, { min: 0, max: p.arrayStride - formatSize }))\n        );\n      })\n  )\n  .fn(t => {\n    const { format, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('buffers_with_varying_step_mode')\n  .desc(\n    `Test buffers with varying step modes in the same vertex state.\n  - Various combination of step modes`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('stepModes', [\n        ['instance'],\n        ['vertex', 'vertex', 'instance'],\n        ['instance', 'vertex', 'instance'],\n        ['vertex', 'instance', 'vertex', 'vertex'],\n      ])\n  )\n  .fn(t => {\n    const { stepModes } = t.params;\n    const state = (stepModes as GPUVertexStepMode[]).map((stepMode, i) => ({\n      slot: i,\n      arrayStride: 4,\n      stepMode,\n      attributes: [\n        {\n          shaderLocation: i,\n          format: 'float32' as const,\n          offset: 0,\n        },\n      ],\n    }));\n    t.runTest(state);\n  });\n\ng.test('vertex_buffer_used_multiple_times_overlapped')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer overlapping.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCount', [2, 3, kMaxVertexBuffers])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCount, additionalVBOffset } = t.params;\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a1, a2, a3, ..., a<baseDataVertexCount>\n    // We also create the expected data for the vertex fetching from that buffer so we can modify it\n    // below.\n    const baseDataVertexCount = kVertexCount + vbCount - 1;\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: [{ shaderLocation: 0, format, offset: 0 }],\n        },\n      ],\n      baseDataVertexCount,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, baseDataVertexCount, kInstanceCount)[0]\n      .buffer;\n\n    // We are going to bind the vertex buffer multiple times, each time at a different offset that's\n    // a multiple of the data size. So what should be fetched by the vertex shader is:\n    //    - attrib0: a0, a1, ..., a19\n    //    - attrib1: a1, a2, ..., a20\n    //    - attrib2: a2, a3, ..., a21\n    //    etc.\n    // We re-create the test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) selecting what parts of the expectedData each attribute will see in the expectedData for\n    //      the full vertex buffer.\n    const baseTestData = baseData[0].attributes[0];\n    assert(baseTestData.testComponentCount === formatInfo.componentCount * baseDataVertexCount);\n    const expectedDataBytesPerVertex = baseTestData.expectedData.byteLength / baseDataVertexCount;\n\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        buffer: vertexBuffer,\n        slot: i,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n\n      testData.push({\n        slot: i,\n        arrayStride: alignedFormatByteSize,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: i,\n            format,\n            offset: 0,\n\n            shaderBaseType: baseTestData.shaderBaseType,\n            floatTolerance: baseTestData.floatTolerance,\n            // Select vertices [i, i + kVertexCount]\n            testComponentCount: kVertexCount * formatInfo.componentCount,\n            expectedData: baseTestData.expectedData.slice(\n              expectedDataBytesPerVertex * i,\n              expectedDataBytesPerVertex * (kVertexCount + i)\n            ),\n            vertexData: new ArrayBuffer(0),\n          },\n        ],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('vertex_buffer_used_multiple_times_interleaved')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer interleaved.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCount', [2, 3, kMaxVertexBuffers])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCount, additionalVBOffset } = t.params;\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // Create data for a single vertex buffer with many attributes, that will be split between\n    // many vertex buffers set at different offsets.\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a0, a0, a1, a1, a1, ...\n    // To do that we create a single vertex buffer with `vbCount` attributes that all have the same\n    // format.\n    const attribs: GPUVertexAttribute[] = [];\n    for (let i = 0; i < vbCount; i++) {\n      attribs.push({ format, offset: i * alignedFormatByteSize, shaderLocation: i });\n    }\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize * vbCount,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: attribs,\n        },\n      ],\n      // Request one vertex more than what we need so we have an extra full stride. Otherwise WebGPU\n      // validation of vertex being in bounds will fail for all vertex buffers at an offset that's\n      // not 0 (since their last stride will go beyond the data for vertex kVertexCount -1).\n      kVertexCount + 1,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, kVertexCount + 1, kInstanceCount)[0]\n      .buffer;\n\n    // Then we recreate test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) have multiple vertex buffer, each with one attributes that will expect a0, a1, ...\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        slot: i,\n        buffer: vertexBuffer,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n      testData.push({\n        ...baseData[0],\n        slot: i,\n        attributes: [{ ...baseData[0].attributes[i], offset: 0 }],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('max_buffers_and_attribs')\n  .desc(\n    `Test a vertex state that loads as many attributes and buffers as possible.\n  - For each format.\n  `\n  )\n  .params(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n    const attributesPerBuffer = Math.ceil(kMaxVertexAttributes / kMaxVertexBuffers);\n    let attributesEmitted = 0;\n\n    const state: VertexLayoutState<{}, {}> = [];\n    for (let i = 0; i < kMaxVertexBuffers; i++) {\n      const attributes: GPUVertexAttribute[] = [];\n      for (let j = 0; j < attributesPerBuffer && attributesEmitted < kMaxVertexAttributes; j++) {\n        attributes.push({ format, offset: 0, shaderLocation: attributesEmitted });\n        attributesEmitted++;\n      }\n      state.push({\n        slot: i,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      });\n    }\n    t.runTest(state);\n  });\n\ng.test('array_stride_zero')\n  .desc(\n    `Test that arrayStride 0 correctly uses the same data for all vertex/instances, while another test vertex buffer with arrayStride != 0 gets different data.\n  - Test for all formats\n  - Test for both step modes`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('stepMode', ['vertex', 'instance'] as const)\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n        return new Set([\n          0,\n          4,\n          8,\n          formatSize,\n          formatSize * 2,\n          kMaxVertexBufferArrayStride / 2,\n          kMaxVertexBufferArrayStride - formatSize - 4,\n          kMaxVertexBufferArrayStride - formatSize - 8,\n          kMaxVertexBufferArrayStride - formatSize,\n          kMaxVertexBufferArrayStride - formatSize * 2,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, stepMode, offset } = t.params;\n    const kCount = 10;\n\n    // Create the stride 0 part of the test, first by faking a single vertex being drawn and\n    // then expanding the data to cover kCount vertex / instances\n    const stride0TestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: 2048,\n          stepMode,\n          vbOffset: offset, // used to push data in the vertex buffer\n          attributes: [{ format, offset: 0, shaderLocation: 0 }],\n        },\n      ],\n      1,\n      1\n    )[0];\n    const stride0VertexBuffer = t.createVertexBuffers([stride0TestData], kCount, kCount)[0];\n\n    // Expand the stride0 test data to have kCount values for expectedData.\n    const originalData = stride0TestData.attributes[0].expectedData;\n    const expandedData = new ArrayBuffer(kCount * originalData.byteLength);\n    for (let i = 0; i < kCount; i++) {\n      new Uint8Array(expandedData, originalData.byteLength * i).set(new Uint8Array(originalData));\n    }\n\n    // Fixup stride0TestData to use arrayStride 0.\n    stride0TestData.attributes[0].offset = offset;\n    stride0TestData.attributes[0].expectedData = expandedData;\n    stride0TestData.attributes[0].testComponentCount *= kCount;\n    stride0TestData.arrayStride = 0;\n    stride0VertexBuffer.vbOffset = 0;\n\n    // Create the part of the state that will be varying for each vertex / instance\n    const varyingTestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 1,\n          arrayStride: 32,\n          stepMode,\n          attributes: [{ format, offset: 0, shaderLocation: 1 }],\n        },\n      ],\n      kCount,\n      kCount\n    )[0];\n    const varyingVertexBuffer = t.createVertexBuffers([varyingTestData], kCount, kCount)[0];\n\n    // Run the test with the merged test state.\n    const state = [stride0TestData, varyingTestData];\n    const vertexBuffers = [stride0VertexBuffer, varyingVertexBuffer];\n\n    const pipeline = t.makeTestPipeline(state, kCount, kCount);\n    const expectedDataBG = t.createExpectedBG(state, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kCount, kCount);\n  });\n\ng.test('discontiguous_location_and_attribs')\n  .desc('Test that using far away slots / shaderLocations works as expected')\n  .fn(t => {\n    t.runTest([\n      {\n        slot: kMaxVertexBuffers - 1,\n        arrayStride: 4,\n        stepMode: 'vertex',\n        attributes: [\n          { format: 'uint8x2', offset: 2, shaderLocation: 0 },\n          { format: 'uint8x2', offset: 0, shaderLocation: 8 },\n        ],\n      },\n      {\n        slot: 1,\n        arrayStride: 16,\n        stepMode: 'instance',\n        vbOffset: 1000,\n        attributes: [{ format: 'uint32x4', offset: 0, shaderLocation: kMaxVertexAttributes - 1 }],\n      },\n    ]);\n  });\n\ng.test('overlapping_attributes')\n  .desc(\n    `Test that overlapping attributes in the same vertex buffer works\n   - Test for all formats`\n  )\n  .params(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    for (let i = 0; i < kMaxVertexAttributes; i++) {\n      attributes.push({ format, offset: 0, shaderLocation: i });\n    }\n\n    t.runTest([\n      {\n        slot: 0,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      },\n    ]);\n  });\n"],"file":"correctness.spec.js"}