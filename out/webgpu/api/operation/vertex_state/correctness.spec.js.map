{"version":3,"file":"correctness.spec.js","names":["description","makeTestGroup","assert","filterUniqueValueTestVariants","makeValueTestVariant","memcpy","unreachable","kVertexFormatInfo","kVertexFormats","GPUTest","MaxLimitsTestMixin","float32ToFloat16Bits","normalizedIntegerAsFloat","align","clamp","mapBufferAttribs","buffer","f","newAttributes","a","attributes","push","shaderLocation","mapStateAttribs","buffers","map","b","makeRgb10a2","rgba","r","g","normalizeRgb10a2","index","normalizationFactor","VertexStateTest","makeTestWGSL","vertexCount","instanceCount","vsInputs","vsChecks","providedDataDefs","format","shaderComponentCount","componentCount","i","shaderType","shaderBaseType","maxCount","indexBuiltin","stepMode","component","expected","attribComponent","providedData","type","floatTolerance","makeTestPipeline","module","device","createShaderModule","code","bufferLayouts","slot","createRenderPipeline","layout","vertex","entryPoint","primitive","topology","fragment","targets","submitRenderPass","pipeline","expectedData","testTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","setBindGroup","setVertexBuffer","vbOffset","draw","end","queue","submit","finish","expectSingleColor","exp","R","generateTestData","formatInfo","bitSize","bytesPerComponent","data","Float32Array","vertexData","Uint16Array","testComponentCount","length","Math","pow","Int32Array","Int16Array","Int8Array","Uint32Array","Uint8Array","v","flat","expandTestData","vertexComponentSize","byteLength","expectedComponentSize","expandedVertexData","expandedExpectedData","targetVertexOffset","sourceVertexOffset","src","start","dst","targetExpectedOffset","sourceExpectedOffset","slice","interleaveVertexDataInto","target","targetStride","offset","srcStart","dstStart","createTestAndPipelineData","state","attrib","testData","createExpectedBG","numBytes","arrayBuffers","allExpectedData","arrayBuffer","set","expectedDataBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","createBindGroup","getBindGroupLayout","entries","binding","resource","createVertexBuffers","vertexBuffers","ArrayBuffer","arrayStride","fill","byteSize","VERTEX","runTest","expectedDataBG","test","desc","params","u","combine","beginSubcases","mult","add","fn","t","slotVariant","shaderLocationVariant","makeLimitVariant","expand","p","formatSize","Set","arrayStrideVariant","offsetVariant","min","max","paramsSubcasesOnly","stepModes","vbCountVariant","additionalVBOffset","vbCount","kVertexCount","kInstanceCount","formatByteSize","alignedFormatByteSize","baseDataVertexCount","baseData","vertexBuffer","baseTestData","expectedDataBytesPerVertex","attribs","maxVertexBuffers","limits","deviceMaxVertexAttributes","maxVertexAttributes","isCompatibility","attributesPerBuffer","ceil","attributesEmitted","j","kCount","stride0TestData","stride0VertexBuffer","originalData","expandedData","varyingTestData","varyingVertexBuffer"],"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"sourcesContent":["export const description = `\nTODO: Test more corner case values for Float16 / Float32 (INF, NaN, ...) and reduce the\nfloat tolerance.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  assert,\n  filterUniqueValueTestVariants,\n  makeValueTestVariant,\n  memcpy,\n  unreachable,\n} from '../../../../common/util/util.js';\nimport { kVertexFormatInfo, kVertexFormats } from '../../../capability_info.js';\nimport { GPUTest, MaxLimitsTestMixin } from '../../../gpu_test.js';\nimport { float32ToFloat16Bits, normalizedIntegerAsFloat } from '../../../util/conversion.js';\nimport { align, clamp } from '../../../util/math.js';\n\n// These types mirror the structure of GPUVertexBufferLayout but allow defining the extra\n// dictionary members at the GPUVertexBufferLayout and GPUVertexAttribute level. The are used\n// like so:\n//\n//   VertexState<{arrayStride: number}, {format: VertexFormat}>\n//   VertexBuffer<{arrayStride: number}, {format: VertexFormat}>\n//   VertexAttrib<{format: VertexFormat}>\ntype VertexAttrib<A> = A & { shaderLocation: number };\ntype VertexBuffer<V, A> = V & {\n  slot: number;\n  attributes: VertexAttrib<A>[];\n};\ntype VertexState<V, A> = VertexBuffer<V, A>[];\n\ntype VertexLayoutState<V, A> = VertexState<\n  { stepMode: GPUVertexStepMode; arrayStride: number } & V,\n  { format: GPUVertexFormat; offset: number } & A\n>;\n\nfunction mapBufferAttribs<V, A1, A2>(\n  buffer: VertexBuffer<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexBuffer<V, A2> {\n  const newAttributes: VertexAttrib<A2>[] = [];\n  for (const a of buffer.attributes) {\n    newAttributes.push({\n      shaderLocation: a.shaderLocation,\n      ...f(buffer, a),\n    });\n  }\n\n  return { ...buffer, attributes: newAttributes };\n}\n\nfunction mapStateAttribs<V, A1, A2>(\n  buffers: VertexState<V, A1>,\n  f: (v: V, a: VertexAttrib<A1>) => A2\n): VertexState<V, A2> {\n  return buffers.map(b => mapBufferAttribs(b, f));\n}\n\nfunction makeRgb10a2(rgba: Array<number>): number {\n  const [r, g, b, a] = rgba;\n  assert((r & 0x3ff) === r);\n  assert((g & 0x3ff) === g);\n  assert((b & 0x3ff) === b);\n  assert((a & 0x3) === a);\n  return r | (g << 10) | (b << 20) | (a << 30);\n}\n\nfunction normalizeRgb10a2(rgba: number, index: number): number {\n  const normalizationFactor = index % 4 === 3 ? 3 : 1023;\n  return rgba / normalizationFactor;\n}\n\ntype TestData = {\n  shaderBaseType: string;\n  floatTolerance?: number;\n  // The number of vertex components in the vertexData (expectedData might contain more because\n  // it is padded to 4 components).\n  testComponentCount: number;\n  // The data that will be in the uniform buffer and used to check the vertex inputs.\n  expectedData: ArrayBuffer;\n  // The data that will be in the vertex buffer.\n  vertexData: ArrayBuffer;\n};\n\nclass VertexStateTest extends GPUTest {\n  // Generate for VS + FS (entrypoints vsMain / fsMain) that for each attribute will check that its\n  // value corresponds to what's expected (as provided by a uniform buffer per attribute) and then\n  // renders each vertex at position (vertexIndex, instanceindex) with either 1 (success) or\n  // a negative number corresponding to the check number (in case you need to debug a failure).\n  makeTestWGSL(\n    buffers: VertexState<\n      { stepMode: GPUVertexStepMode },\n      {\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): string {\n    let vsInputs = '';\n    let vsChecks = '';\n    let providedDataDefs = '';\n\n    for (const b of buffers) {\n      for (const a of b.attributes) {\n        const format = kVertexFormatInfo[a.format];\n        const shaderComponentCount = a.shaderComponentCount ?? format.componentCount;\n        const i = a.shaderLocation;\n\n        // shaderType is either a scalar type like f32 or a vecN<scalarType>\n        let shaderType = a.shaderBaseType;\n        if (shaderComponentCount !== 1) {\n          shaderType = `vec${shaderComponentCount}<${shaderType}>`;\n        }\n\n        let maxCount = `${vertexCount}`;\n        let indexBuiltin = `input.vertexIndex`;\n        if (b.stepMode === 'instance') {\n          maxCount = `${instanceCount}`;\n          indexBuiltin = `input.instanceIndex`;\n        }\n\n        vsInputs += `  @location(${i}) attrib${i} : ${shaderType},\\n`;\n        providedDataDefs += `  data${i}: array<vec4<${a.shaderBaseType}>, ${maxCount}>,\\n`;\n\n        // Generate the all the checks for the attributes.\n        for (let component = 0; component < shaderComponentCount; component++) {\n          // Components are filled with (0, 0, 0, 1) if they aren't provided data from the pipeline.\n          if (component >= format.componentCount) {\n            const expected = component === 3 ? '1' : '0';\n            vsChecks += `  check(input.attrib${i}[${component}] == ${a.shaderBaseType}(${expected}));\\n`;\n            continue;\n          }\n\n          // Check each component individually, with special handling of tolerance for floats.\n          const attribComponent =\n            shaderComponentCount === 1 ? `input.attrib${i}` : `input.attrib${i}[${component}]`;\n          const providedData = `providedData.data${i}[${indexBuiltin}][${component}]`;\n          if (format.type === 'uint' || format.type === 'sint') {\n            vsChecks += `  check(${attribComponent} == ${providedData});\\n`;\n          } else {\n            vsChecks += `  check(floatsSimilar(${attribComponent}, ${providedData}, f32(${\n              a.floatTolerance ?? 0\n            })));\\n`;\n          }\n        }\n      }\n    }\n\n    return `\nstruct Inputs {\n${vsInputs}\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n};\n\nstruct ProvidedData {\n${providedDataDefs}\n};\n\n@group(0) @binding(0) var<uniform> providedData: ProvidedData;\n\nvar<private> vsResult : i32 = 1;\nvar<private> checkIndex : i32 = 0;\nfn check(success : bool) {\n  if (!success) {\n    vsResult = -checkIndex;\n  }\n  checkIndex = checkIndex + 1;\n}\n\nfn floatsSimilar(a : f32, b : f32, tolerance : f32) -> bool {\n  // Note: -0.0 and 0.0 have different bit patterns, but compare as equal.\n  return abs(a - b) < tolerance;\n}\n\nfn doTest(input : Inputs) {\n${vsChecks}\n}\n\nstruct VSOutputs {\n  @location(0) @interpolate(flat, either) result : i32,\n  @builtin(position) position : vec4<f32>,\n};\n\n@vertex fn vsMain(input : Inputs) -> VSOutputs {\n  doTest(input);\n\n  // Place that point at pixel (vertexIndex, instanceIndex) in a framebuffer of size\n  // (vertexCount , instanceCount).\n  var output : VSOutputs;\n  output.position = vec4<f32>(\n    ((f32(input.vertexIndex) + 0.5) / ${vertexCount}.0 * 2.0) - 1.0,\n    ((f32(input.instanceIndex) + 0.5) / ${instanceCount}.0 * 2.0) - 1.0,\n    0.0, 1.0\n  );\n  output.result = vsResult;\n  return output;\n}\n\n@fragment fn fsMain(@location(0) @interpolate(flat, either) result : i32)\n  -> @location(0) i32 {\n  return result;\n}\n    `;\n  }\n\n  makeTestPipeline(\n    buffers: VertexState<\n      { stepMode: GPUVertexStepMode; arrayStride: number },\n      {\n        offset: number;\n        format: GPUVertexFormat;\n        shaderBaseType: string;\n        shaderComponentCount?: number;\n        floatTolerance?: number;\n      }\n    >,\n    vertexCount: number,\n    instanceCount: number\n  ): GPURenderPipeline {\n    const module = this.device.createShaderModule({\n      code: this.makeTestWGSL(buffers, vertexCount, instanceCount),\n    });\n\n    const bufferLayouts: GPUVertexBufferLayout[] = [];\n    for (const b of buffers) {\n      bufferLayouts[b.slot] = b;\n    }\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vsMain',\n        buffers: bufferLayouts,\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n      fragment: {\n        module,\n        entryPoint: 'fsMain',\n        targets: [\n          {\n            format: 'r32sint',\n          },\n        ],\n      },\n    });\n  }\n\n  // Runs the render pass drawing points in a vertexCount*instanceCount rectangle, then check each\n  // of produced a value of 1 which means that the tests in the shader passed.\n  submitRenderPass(\n    pipeline: GPURenderPipeline,\n    buffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}>,\n    expectedData: GPUBindGroup,\n    vertexCount: number,\n    instanceCount: number\n  ) {\n    const testTexture = this.createTextureTracked({\n      format: 'r32sint',\n      size: [vertexCount, instanceCount],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: testTexture.createView(),\n          clearValue: [0, 0, 0, 0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, expectedData);\n    for (const buffer of buffers) {\n      pass.setVertexBuffer(buffer.slot, buffer.buffer, buffer.vbOffset ?? 0);\n    }\n    pass.draw(vertexCount, instanceCount);\n    pass.end();\n\n    this.device.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(testTexture, 'r32sint', {\n      size: [vertexCount, instanceCount, 1],\n      exp: { R: 1 },\n    });\n  }\n\n  // Generate TestData for the format with interesting test values.\n  // MAINTENANCE_TODO cache the result on the fixture?\n  // Note that the test data always starts with an interesting value, so that using the first\n  // test value in a test is still meaningful.\n  generateTestData(format: GPUVertexFormat): TestData {\n    const formatInfo = kVertexFormatInfo[format];\n    const bitSize =\n      formatInfo.bytesPerComponent === 'packed' ? 0 : formatInfo.bytesPerComponent * 8;\n\n    switch (formatInfo.type) {\n      case 'float': {\n        // -0.0 and +0.0 have different bit patterns, but compare as equal.\n        const data = [42.42, 0.0, -0.0, 1.0, -1.0, 1000, -18.7, 25.17];\n        const expectedData = new Float32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data.map(float32ToFloat16Bits)).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n          floatTolerance: 0.05,\n        };\n      }\n\n      case 'sint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1), // min value\n        ];\n        const expectedData = new Int32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Int16Array(data).buffer\n            : new Int8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'i32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'uint': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const expectedData = new Uint32Array(data).buffer;\n        const vertexData =\n          bitSize === 32\n            ? expectedData\n            : bitSize === 16\n            ? new Uint16Array(data).buffer\n            : new Uint8Array(data).buffer;\n\n        return {\n          shaderBaseType: 'u32',\n          testComponentCount: data.length,\n          expectedData,\n          vertexData,\n        };\n      }\n\n      case 'snorm': {\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2,bitSize - 2),\n          Math.pow(2,bitSize - 1) - 1, // max value\n          -Math.pow(2,bitSize - 2),\n          -Math.pow(2,bitSize - 1), // min value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Int16Array(data).buffer\n            : bitSize === 8\n            ? new Int8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, true)))\n            .buffer,\n          vertexData,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, true),\n        };\n      }\n\n      case 'unorm': {\n        if (formatInfo.bytesPerComponent === 'packed') {\n          assert(bitSize === 0);\n\n          switch (format) {\n            case 'unorm10-10-10-2': {\n              /* prettier-ignore */\n              const data = [\n              [   0,    0,    0, 0],\n              [1023, 1023, 1023, 3],\n              [ 243,  567,  765, 2],\n            ];\n              const vertexData = new Uint32Array(data.map(makeRgb10a2)).buffer;\n              const expectedData = new Float32Array(data.flat().map(normalizeRgb10a2)).buffer;\n\n              return {\n                shaderBaseType: 'f32',\n                testComponentCount: data.flat().length,\n                expectedData,\n                vertexData,\n                floatTolerance: 0.1 / 1023,\n              };\n            }\n\n            case 'unorm8x4-bgra': {\n              const data = [42, 0, 1, 2, 3, 4, 128, 255];\n              const vertexData = new Uint8Array(data).buffer;\n              const expectedData = new Float32Array(\n                data.map(v => normalizedIntegerAsFloat(v, 8, false))\n              );\n\n              for (let i = 0; i + 2 < expectedData.length; i += 4) {\n                const r = expectedData[i + 0];\n                const b = expectedData[i + 2];\n                expectedData[i + 0] = b;\n                expectedData[i + 2] = r;\n              }\n\n              return {\n                shaderBaseType: 'f32',\n                testComponentCount: data.length,\n                expectedData: expectedData.buffer,\n                vertexData,\n                floatTolerance: 0.1 / 255,\n              };\n            }\n          }\n        }\n\n        /* prettier-ignore */\n        const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1, // max value\n        ];\n        const vertexData =\n          bitSize === 16\n            ? new Uint16Array(data).buffer\n            : bitSize === 8\n            ? new Uint8Array(data).buffer\n            : unreachable();\n\n        return {\n          shaderBaseType: 'f32',\n          testComponentCount: data.length,\n          expectedData: new Float32Array(data.map(v => normalizedIntegerAsFloat(v, bitSize, false)))\n            .buffer,\n          vertexData,\n          floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, false),\n        };\n      }\n    }\n  }\n\n  // The TestData generated for a format might not contain enough data for all the vertices we are\n  // going to draw, so we expand them by adding additional copies of the vertexData as needed.\n  // expectedData is a bit different because it also needs to be unpacked to have `componentCount`\n  // components every 4 components (because the shader uses vec4 for the expected data).\n  expandTestData(data: TestData, maxCount: number, componentCount: number): TestData {\n    const vertexComponentSize = data.vertexData.byteLength / data.testComponentCount;\n    const expectedComponentSize = data.expectedData.byteLength / data.testComponentCount;\n\n    const expandedVertexData = new Uint8Array(maxCount * componentCount * vertexComponentSize);\n    const expandedExpectedData = new Uint8Array(4 * maxCount * expectedComponentSize);\n\n    for (let index = 0; index < maxCount; index++) {\n      for (let component = 0; component < componentCount; component++) {\n        // If only we had some builtin JS memcpy function between ArrayBuffers...\n        const targetVertexOffset = (index * componentCount + component) * vertexComponentSize;\n        const sourceVertexOffset = targetVertexOffset % data.vertexData.byteLength;\n        memcpy(\n          { src: data.vertexData, start: sourceVertexOffset, length: vertexComponentSize },\n          { dst: expandedVertexData, start: targetVertexOffset }\n        );\n\n        const targetExpectedOffset = (index * 4 + component) * expectedComponentSize;\n        const sourceExpectedOffset =\n          ((index * componentCount + component) * expectedComponentSize) %\n          data.expectedData.byteLength;\n        memcpy(\n          { src: data.expectedData, start: sourceExpectedOffset, length: expectedComponentSize },\n          { dst: expandedExpectedData, start: targetExpectedOffset }\n        );\n      }\n    }\n\n    return {\n      shaderBaseType: data.shaderBaseType,\n      testComponentCount: maxCount * componentCount,\n      floatTolerance: data.floatTolerance,\n      expectedData: expandedExpectedData.slice(0, maxCount * 4 * 4),\n      vertexData: expandedVertexData.buffer,\n    };\n  }\n\n  // Copies `size` bytes from `source` to `target` starting at `offset` each `targetStride`.\n  // (the data in `source` is assumed packed)\n  interleaveVertexDataInto(\n    target: ArrayBuffer,\n    src: ArrayBuffer,\n    { targetStride, offset, size }: { targetStride: number; offset: number; size: number }\n  ) {\n    const dst = new Uint8Array(target);\n    for (\n      let srcStart = 0, dstStart = offset;\n      srcStart < src.byteLength;\n      srcStart += size, dstStart += targetStride\n    ) {\n      memcpy({ src, start: srcStart, length: size }, { dst, start: dstStart });\n    }\n  }\n\n  createTestAndPipelineData<V, A>(\n    state: VertexLayoutState<V, A>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexLayoutState<V, A & TestData> {\n    // Gather the test data and some additional test state for attribs.\n    return mapStateAttribs(state, (buffer, attrib) => {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n      const formatInfo = kVertexFormatInfo[attrib.format];\n\n      let testData = this.generateTestData(attrib.format);\n      testData = this.expandTestData(testData, maxCount, formatInfo.componentCount);\n\n      return {\n        ...testData,\n        ...attrib,\n      };\n    });\n  }\n\n  createExpectedBG(state: VertexState<{}, TestData>, pipeline: GPURenderPipeline): GPUBindGroup {\n    // Create the bindgroup for the expected test data\n\n    // Concat expectedData into one buffer\n    let numBytes = 0;\n    const arrayBuffers = [];\n    for (const buffer of state) {\n      for (const attrib of buffer.attributes) {\n        numBytes += attrib.expectedData.byteLength;\n        arrayBuffers.push(attrib.expectedData);\n      }\n    }\n\n    const allExpectedData = new Uint8Array(numBytes);\n    let offset = 0;\n    for (const arrayBuffer of arrayBuffers) {\n      allExpectedData.set(new Uint8Array(arrayBuffer), offset);\n      offset += arrayBuffer.byteLength;\n    }\n    const expectedDataBuffer = this.makeBufferWithContents(allExpectedData, GPUBufferUsage.UNIFORM);\n\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: expectedDataBuffer } }],\n    });\n  }\n\n  createVertexBuffers(\n    state: VertexLayoutState<{ vbOffset?: number }, TestData>,\n    vertexCount: number,\n    instanceCount: number\n  ): VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> {\n    // Create the vertex buffers\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset?: number }, {}> = [];\n\n    for (const buffer of state) {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n\n      // Fill the vertex data with garbage so that we don't get `0` (which could be a test value)\n      // if the vertex shader loads the vertex data incorrectly.\n      const vertexData = new ArrayBuffer(\n        align(buffer.arrayStride * maxCount + (buffer.vbOffset ?? 0), 4)\n      );\n      new Uint8Array(vertexData).fill(0xc4);\n\n      for (const attrib of buffer.attributes) {\n        const formatInfo = kVertexFormatInfo[attrib.format];\n        this.interleaveVertexDataInto(vertexData, attrib.vertexData, {\n          targetStride: buffer.arrayStride,\n          offset: (buffer.vbOffset ?? 0) + attrib.offset,\n          size: formatInfo.byteSize,\n        });\n      }\n\n      vertexBuffers.push({\n        slot: buffer.slot,\n        buffer: this.makeBufferWithContents(new Uint8Array(vertexData), GPUBufferUsage.VERTEX),\n        vbOffset: buffer.vbOffset,\n        attributes: [],\n      });\n    }\n\n    return vertexBuffers;\n  }\n\n  runTest(\n    buffers: VertexLayoutState<{ vbOffset?: number }, { shaderComponentCount?: number }>,\n    // Default to using 20 vertices and 20 instances so that we cover each of the test data at least\n    // once (at the time of writing the largest testData has 16 values).\n    vertexCount: number = 20,\n    instanceCount: number = 20\n  ) {\n    const testData = this.createTestAndPipelineData(buffers, vertexCount, instanceCount);\n    const pipeline = this.makeTestPipeline(testData, vertexCount, instanceCount);\n    const expectedDataBG = this.createExpectedBG(testData, pipeline);\n    const vertexBuffers = this.createVertexBuffers(testData, vertexCount, instanceCount);\n    this.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, vertexCount, instanceCount);\n  }\n}\n\nexport const g = makeTestGroup(MaxLimitsTestMixin(VertexStateTest));\n\ng.test('vertex_format_to_shader_format_conversion')\n  .desc(\n    `Test that the raw data passed in vertex buffers is correctly converted to the input type in the shader. Test for:\n  - all formats\n  - 1 to 4 components in the shader's input type (unused components are filled with 0 and except the 4th with 1)\n  - various locations\n  - various slots`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .combine('shaderComponentCount', [1, 2, 3, 4])\n      .beginSubcases()\n      .combine('slotVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n      .combine('shaderLocationVariant', [\n        { mult: 0, add: 0 },\n        { mult: 0, add: 1 },\n        { mult: 1, add: -1 },\n      ])\n  )\n  .fn(t => {\n    const { format, shaderComponentCount, slotVariant, shaderLocationVariant } = t.params;\n    const slot = t.makeLimitVariant('maxVertexBuffers', slotVariant);\n    const shaderLocation = t.makeLimitVariant('maxVertexAttributes', shaderLocationVariant);\n    t.runTest([\n      {\n        slot,\n        arrayStride: 16,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation,\n            format,\n            offset: 0,\n            shaderComponentCount,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('setVertexBuffer_offset_and_attribute_offset')\n  .desc(\n    `Test that the vertex buffer offset and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various setVertexBuffer offsets\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbOffset', [0, 4, 400, 1004])\n      .combine('arrayStride', [128])\n      .expand('offset', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.byteSize;\n        return new Set([\n          0,\n          4,\n          8,\n          formatSize,\n          formatSize * 2,\n          p.arrayStride / 2,\n          p.arrayStride - formatSize - 4,\n          p.arrayStride - formatSize - 8,\n          p.arrayStride - formatSize - formatSize,\n          p.arrayStride - formatSize - formatSize * 2,\n          p.arrayStride - formatSize,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, vbOffset, arrayStride, offset } = t.params;\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        vbOffset,\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('non_zero_array_stride_and_attribute_offset')\n  .desc(\n    `Test that the array stride and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various array strides\n  - various attribute offsets in a fixed arrayStride`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .expand('arrayStrideVariant', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.byteSize;\n\n        return [\n          { mult: 0, add: align(formatSize, 4) },\n          { mult: 0, add: align(formatSize, 4) + 4 },\n          { mult: 1, add: 0 },\n        ];\n      })\n      .expand('offsetVariant', function* (p) {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.byteSize;\n        yield { mult: 0, add: 0 };\n        yield { mult: 0, add: 4 };\n        if (formatSize !== 4) yield { mult: 0, add: formatSize };\n        yield { mult: 0.5, add: 0 };\n        yield { mult: 1, add: -formatSize * 2 };\n        if (formatSize !== 4) yield { mult: 1, add: -formatSize - 4 };\n        yield { mult: 1, add: -formatSize };\n      })\n  )\n  .fn(t => {\n    const { format, arrayStrideVariant, offsetVariant } = t.params;\n    const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.byteSize;\n    const offset = clamp(makeValueTestVariant(arrayStride, offsetVariant), {\n      min: 0,\n      max: arrayStride - formatSize,\n    });\n\n    t.runTest([\n      {\n        slot: 0,\n        arrayStride,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: 0,\n            format,\n            offset,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('buffers_with_varying_step_mode')\n  .desc(\n    `Test buffers with varying step modes in the same vertex state.\n  - Various combination of step modes`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('stepModes', [\n        ['instance'],\n        ['vertex', 'vertex', 'instance'],\n        ['instance', 'vertex', 'instance'],\n        ['vertex', 'instance', 'vertex', 'vertex'],\n      ])\n  )\n  .fn(t => {\n    const { stepModes } = t.params;\n    const state = (stepModes as GPUVertexStepMode[]).map((stepMode, i) => ({\n      slot: i,\n      arrayStride: 4,\n      stepMode,\n      attributes: [\n        {\n          shaderLocation: i,\n          format: 'float32' as const,\n          offset: 0,\n        },\n      ],\n    }));\n    t.runTest(state);\n  });\n\ng.test('vertex_buffer_used_multiple_times_overlapped')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer overlapping.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCountVariant', [\n        { mult: 0, add: 2 },\n        { mult: 0, add: 3 },\n        { mult: 1, add: 0 },\n      ])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCountVariant, additionalVBOffset } = t.params;\n    const vbCount = t.makeLimitVariant('maxVertexBuffers', vbCountVariant);\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.byteSize;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a1, a2, a3, ..., a<baseDataVertexCount>\n    // We also create the expected data for the vertex fetching from that buffer so we can modify it\n    // below.\n    const baseDataVertexCount = kVertexCount + vbCount - 1;\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: [{ shaderLocation: 0, format, offset: 0 }],\n        },\n      ],\n      baseDataVertexCount,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, baseDataVertexCount, kInstanceCount)[0]\n      .buffer;\n\n    // We are going to bind the vertex buffer multiple times, each time at a different offset that's\n    // a multiple of the data size. So what should be fetched by the vertex shader is:\n    //    - attrib0: a0, a1, ..., a19\n    //    - attrib1: a1, a2, ..., a20\n    //    - attrib2: a2, a3, ..., a21\n    //    etc.\n    // We re-create the test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) selecting what parts of the expectedData each attribute will see in the expectedData for\n    //      the full vertex buffer.\n    const baseTestData = baseData[0].attributes[0];\n    assert(baseTestData.testComponentCount === formatInfo.componentCount * baseDataVertexCount);\n    const expectedDataBytesPerVertex = baseTestData.expectedData.byteLength / baseDataVertexCount;\n\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        buffer: vertexBuffer,\n        slot: i,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n\n      testData.push({\n        slot: i,\n        arrayStride: alignedFormatByteSize,\n        stepMode: 'vertex',\n        attributes: [\n          {\n            shaderLocation: i,\n            format,\n            offset: 0,\n\n            shaderBaseType: baseTestData.shaderBaseType,\n            floatTolerance: baseTestData.floatTolerance,\n            // Select vertices [i, i + kVertexCount]\n            testComponentCount: kVertexCount * formatInfo.componentCount,\n            expectedData: baseTestData.expectedData.slice(\n              expectedDataBytesPerVertex * i,\n              expectedDataBytesPerVertex * (kVertexCount + i)\n            ),\n            vertexData: new ArrayBuffer(0),\n          },\n        ],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('vertex_buffer_used_multiple_times_interleaved')\n  .desc(\n    `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer interleaved.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('vbCountVariant', [\n        { mult: 0, add: 2 },\n        { mult: 0, add: 3 },\n        { mult: 1, add: 0 },\n      ])\n      .combine('additionalVBOffset', [0, 4, 120])\n  )\n  .fn(t => {\n    const { format, vbCountVariant, additionalVBOffset } = t.params;\n    const vbCount = t.makeLimitVariant('maxVertexBuffers', vbCountVariant);\n    const kVertexCount = 20;\n    const kInstanceCount = 1;\n    const formatInfo = kVertexFormatInfo[format];\n    const formatByteSize = formatInfo.byteSize;\n    // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n    const alignedFormatByteSize = align(formatByteSize, 4);\n\n    // Create data for a single vertex buffer with many attributes, that will be split between\n    // many vertex buffers set at different offsets.\n\n    // In this test we want to test using the same vertex buffer for multiple different attributes.\n    // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n    //    a0, a0, a0, a1, a1, a1, ...\n    // To do that we create a single vertex buffer with `vbCount` attributes that all have the same\n    // format.\n    const attribs: GPUVertexAttribute[] = [];\n    for (let i = 0; i < vbCount; i++) {\n      attribs.push({ format, offset: i * alignedFormatByteSize, shaderLocation: i });\n    }\n    const baseData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: alignedFormatByteSize * vbCount,\n          stepMode: 'vertex',\n          vbOffset: additionalVBOffset,\n          attributes: attribs,\n        },\n      ],\n      kVertexCount,\n      kInstanceCount\n    );\n    const vertexBuffer = t.createVertexBuffers(baseData, kVertexCount, kInstanceCount)[0].buffer;\n\n    // Then we recreate test data by:\n    //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n    //      different offsets.\n    //   2) have multiple vertex buffer, each with one attributes that will expect a0, a1, ...\n    const testData: VertexLayoutState<{}, TestData> = [];\n    const vertexBuffers: VertexState<{ buffer: GPUBuffer; vbOffset: number }, {}> = [];\n    for (let i = 0; i < vbCount; i++) {\n      vertexBuffers.push({\n        slot: i,\n        buffer: vertexBuffer,\n        vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n        attributes: [],\n      });\n      testData.push({\n        ...baseData[0],\n        slot: i,\n        attributes: [{ ...baseData[0].attributes[i], offset: 0 }],\n      });\n    }\n\n    // Run the test with the modified test data.\n    const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n    const expectedDataBG = t.createExpectedBG(testData, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n  });\n\ng.test('max_buffers_and_attribs')\n  .desc(\n    `Test a vertex state that loads as many attributes and buffers as possible.\n  - For each format.\n  `\n  )\n  .params(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n    // In compat mode, @builtin(vertex_index) and @builtin(instance_index) each take an attribute\n    const maxVertexBuffers = t.device.limits.maxVertexBuffers;\n    const deviceMaxVertexAttributes = t.device.limits.maxVertexAttributes;\n    const maxVertexAttributes = deviceMaxVertexAttributes - (t.isCompatibility ? 2 : 0);\n    const attributesPerBuffer = Math.ceil(maxVertexAttributes / maxVertexBuffers);\n    let attributesEmitted = 0;\n\n    const state: VertexLayoutState<{}, {}> = [];\n    for (let i = 0; i < maxVertexBuffers; i++) {\n      const attributes: GPUVertexAttribute[] = [];\n      for (let j = 0; j < attributesPerBuffer && attributesEmitted < maxVertexAttributes; j++) {\n        attributes.push({ format, offset: 0, shaderLocation: attributesEmitted });\n        attributesEmitted++;\n      }\n      state.push({\n        slot: i,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      });\n    }\n    t.runTest(state);\n  });\n\ng.test('array_stride_zero')\n  .desc(\n    `Test that arrayStride 0 correctly uses the same data for all vertex/instances, while another test vertex buffer with arrayStride != 0 gets different data.\n  - Test for all formats\n  - Test for both step modes`\n  )\n  .params(u =>\n    u //\n      .combine('format', kVertexFormats)\n      .beginSubcases()\n      .combine('stepMode', ['vertex', 'instance'] as const)\n      .expand('offsetVariant', p => {\n        const formatInfo = kVertexFormatInfo[p.format];\n        const formatSize = formatInfo.byteSize;\n        return filterUniqueValueTestVariants([\n          { mult: 0, add: 0 },\n          { mult: 0, add: 4 },\n          { mult: 0, add: 8 },\n          { mult: 0, add: formatSize },\n          { mult: 0, add: formatSize * 2 },\n          { mult: 0.5, add: 0 },\n          { mult: 1, add: -formatSize - 4 },\n          { mult: 1, add: -formatSize - 8 },\n          { mult: 1, add: -formatSize },\n          { mult: 1, add: -formatSize * 2 },\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, stepMode, offsetVariant } = t.params;\n    const offset = t.makeLimitVariant('maxVertexBufferArrayStride', offsetVariant);\n    const kCount = 10;\n\n    // Create the stride 0 part of the test, first by faking a single vertex being drawn and\n    // then expanding the data to cover kCount vertex / instances\n    const stride0TestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 0,\n          arrayStride: 2048,\n          stepMode,\n          vbOffset: offset, // used to push data in the vertex buffer\n          attributes: [{ format, offset: 0, shaderLocation: 0 }],\n        },\n      ],\n      1,\n      1\n    )[0];\n    const stride0VertexBuffer = t.createVertexBuffers([stride0TestData], kCount, kCount)[0];\n\n    // Expand the stride0 test data to have kCount values for expectedData.\n    const originalData = stride0TestData.attributes[0].expectedData;\n    const expandedData = new ArrayBuffer(kCount * originalData.byteLength);\n    for (let i = 0; i < kCount; i++) {\n      new Uint8Array(expandedData, originalData.byteLength * i).set(new Uint8Array(originalData));\n    }\n\n    // Fixup stride0TestData to use arrayStride 0.\n    stride0TestData.attributes[0].offset = offset;\n    stride0TestData.attributes[0].expectedData = expandedData;\n    stride0TestData.attributes[0].testComponentCount *= kCount;\n    stride0TestData.arrayStride = 0;\n    stride0VertexBuffer.vbOffset = 0;\n\n    // Create the part of the state that will be varying for each vertex / instance\n    const varyingTestData = t.createTestAndPipelineData(\n      [\n        {\n          slot: 1,\n          arrayStride: 32,\n          stepMode,\n          attributes: [{ format, offset: 0, shaderLocation: 1 }],\n        },\n      ],\n      kCount,\n      kCount\n    )[0];\n    const varyingVertexBuffer = t.createVertexBuffers([varyingTestData], kCount, kCount)[0];\n\n    // Run the test with the merged test state.\n    const state = [stride0TestData, varyingTestData];\n    const vertexBuffers = [stride0VertexBuffer, varyingVertexBuffer];\n\n    const pipeline = t.makeTestPipeline(state, kCount, kCount);\n    const expectedDataBG = t.createExpectedBG(state, pipeline);\n    t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kCount, kCount);\n  });\n\ng.test('discontiguous_location_and_attribs')\n  .desc('Test that using far away slots / shaderLocations works as expected')\n  .fn(t => {\n    t.runTest([\n      {\n        slot: t.device.limits.maxVertexBuffers - 1,\n        arrayStride: 4,\n        stepMode: 'vertex',\n        attributes: [\n          { format: 'uint8x2', offset: 2, shaderLocation: 0 },\n          { format: 'uint8x2', offset: 0, shaderLocation: 8 },\n        ],\n      },\n      {\n        slot: 1,\n        arrayStride: 16,\n        stepMode: 'instance',\n        vbOffset: 1000,\n        attributes: [\n          {\n            format: 'uint32x4',\n            offset: 0,\n            shaderLocation: t.device.limits.maxVertexAttributes - 1,\n          },\n        ],\n      },\n    ]);\n  });\n\ng.test('overlapping_attributes')\n  .desc(\n    `Test that overlapping attributes in the same vertex buffer works\n   - Test for all formats`\n  )\n  .params(u => u.combine('format', kVertexFormats))\n  .fn(t => {\n    const { format } = t.params;\n\n    // In compat mode, @builtin(vertex_index) and @builtin(instance_index) each take an attribute\n    const maxVertexAttributes = t.device.limits.maxVertexAttributes - (t.isCompatibility ? 2 : 0);\n    const attributes: GPUVertexAttribute[] = [];\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      attributes.push({ format, offset: 0, shaderLocation: i });\n    }\n\n    t.runTest([\n      {\n        slot: 0,\n        stepMode: 'vertex',\n        arrayStride: 32,\n        attributes,\n      },\n    ]);\n  });\n"],"mappings":"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"}