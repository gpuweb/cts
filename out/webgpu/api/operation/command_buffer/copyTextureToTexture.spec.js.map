{"version":3,"file":"copyTextureToTexture.spec.js","names":["description","makeTestGroup","assert","memcpy","unreachable","kTextureFormatInfo","kRegularTextureFormats","kCompressedTextureFormats","depthStencilFormatAspectSize","kBufferSizeAlignment","kDepthStencilFormats","kMinDynamicBufferOffsetAlignment","kTextureDimensions","textureDimensionAndFormatCompatible","GPUTest","makeBufferWithContents","checkElementsEqual","checkElementsEqualEither","align","physicalMipSize","DataArrayGenerator","kBytesPerRowAlignment","dataBytesForCopyOrFail","dataGenerator","F","GetInitialDataPerMipLevel","dimension","textureSize","format","mipLevel","textureSizeAtLevel","bytesPerBlock","blockWidthInTexel","blockWidth","blockHeightInTexel","blockHeight","blocksPerSubresource","width","height","byteSize","depthOrArrayLayers","generateView","GetInitialStencilDataPerMipLevel","aspectBytesPerBlock","DoCopyTextureToTextureTest","srcTextureSize","dstTextureSize","srcFormat","dstFormat","copyBoxOffsets","srcCopyLevel","dstCopyLevel","mipLevelCount","srcTextureDesc","size","usage","GPUTextureUsage","COPY_SRC","COPY_DST","srcTexture","device","createTexture","trackForCleanup","dstTextureDesc","dstTexture","initialSrcData","srcTextureSizeAtLevel","srcBlocksPerRow","srcBlockRowsPerImage","queue","writeTexture","texture","bytesPerRow","rowsPerImage","dstTextureSizeAtLevel","minWidth","Math","min","minHeight","minDepth","appliedSrcOffset","x","srcOffset","y","z","appliedDstOffset","dstOffset","appliedCopyWidth","max","copyExtent","appliedCopyHeight","appliedCopyDepth","encoder","createCommandEncoder","copyTextureToTexture","origin","dstBlocksPerRow","dstBlockRowsPerImage","bytesPerDstAlignedBlockRow","dstBufferSize","dstBufferDesc","GPUBufferUsage","dstBuffer","createBuffer","copyTextureToBuffer","buffer","submit","finish","expectedUint8DataWithPadding","Uint8Array","expectedUint8Data","appliedCopyBlocksPerRow","appliedCopyBlockRowsPerImage","srcCopyOffsetInBlocks","dstCopyOffsetInBlocks","srcOffsetZ","dstOffsetZ","dstOffsetYInBlocks","expectedDataWithPaddingOffset","srcOffsetYInBlocks","expectedDataOffset","bytesInRow","src","start","length","dst","alternateExpectedData","includes","slice","i","expectGPUBufferValuesPassCheck","vals","srcByteOffset","type","typedLength","InitializeStencilAspect","sourceTexture","initialStencilData","srcCopyBaseArrayLayer","copySize","aspect","VerifyStencilAspect","destinationTexture","dstCopyBaseArrayLayer","outputBufferSize","layout","method","outputBuffer","expectedStencilData","initialOffsetPerLayer","expectedOffsetPerLayer","initialOffsetPerRow","expectedOffsetPerRow","expectGPUBufferValuesEqual","GetRenderPipelineForT2TCopyWithDepthTests","bindGroupLayout","hasColorAttachment","depthStencil","renderPipelineDescriptor","createPipelineLayout","bindGroupLayouts","vertex","module","createShaderModule","code","entryPoint","fragment","targets","createRenderPipeline","GetBindGroupLayoutForT2TCopyWithDepthTests","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","minBindingSize","hasDynamicOffset","GetBindGroupForT2TCopyWithDepthTests","totalCopyArrayLayers","uniformBufferSize","uniformBufferData","Float32Array","uniformBuffer","UNIFORM","createBindGroup","resource","InitializeDepthAspect","depthFormat","renderPipeline","depthWriteEnabled","depthCompare","bindGroup","hasStencil","stencil","srcCopyLayer","renderPass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","baseArrayLayer","arrayLayerCount","baseMipLevel","depthClearValue","depthLoadOp","depthStoreOp","stencilLoadOp","undefined","stencilStoreOp","setBindGroup","setPipeline","draw","end","VerifyDepthAspect","outputColorTexture","RENDER_ATTACHMENT","dstCopyLayer","clearValue","r","g","b","a","loadOp","storeOp","expectSingleColor","exp","R","G","B","A","kCopyBoxOffsetsForWholeDepth","kCopyBoxOffsetsFor2DArrayTextures","test","desc","params","u","combine","filter","srcBaseFormat","baseFormat","dstBaseFormat","beginSubcases","expandWithParams","p","param","unless","fn","t","beforeAllSubcases","selectDeviceOrSkipTestCase","feature","textureSizeInBlocks","srcBlockWidth","srcBlockHeight","dstBlockWidth","dstBlockHeight","paramsSubcasesOnly","combineWithParams","copyBoxOffset","selectDeviceForTextureFormatOrSkipTestCase","depth","kColorFormat","kSampleCount","TEXTURE_BINDING","sampleCount","renderPipelineForInit","multisample","count","initEncoder","renderPassForInit","copyEncoder","renderPipelineForValidation","getBindGroupLayout","expectedOutputTexture","validationEncoder","renderPassForValidation","kDepthFormat","vertexState","encoderForInit","renderPipelineForVerify","multisampledColorTexture","colorTextureAsResolveTarget","encoderForVerify","renderPassForVerify","resolveTarget"],"sources":["../../../../../src/webgpu/api/operation/command_buffer/copyTextureToTexture.spec.ts"],"sourcesContent":["export const description = `copyTextureToTexture operation tests`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, memcpy, unreachable } from '../../../../common/util/util.js';\nimport {\n  kTextureFormatInfo,\n  kRegularTextureFormats,\n  SizedTextureFormat,\n  kCompressedTextureFormats,\n  depthStencilFormatAspectSize,\n  DepthStencilFormat,\n  kBufferSizeAlignment,\n  kDepthStencilFormats,\n  kMinDynamicBufferOffsetAlignment,\n  kTextureDimensions,\n  textureDimensionAndFormatCompatible,\n} from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { makeBufferWithContents } from '../../../util/buffer.js';\nimport { checkElementsEqual, checkElementsEqualEither } from '../../../util/check_contents.js';\nimport { align } from '../../../util/math.js';\nimport { physicalMipSize } from '../../../util/texture/base.js';\nimport { DataArrayGenerator } from '../../../util/texture/data_generation.js';\nimport { kBytesPerRowAlignment, dataBytesForCopyOrFail } from '../../../util/texture/layout.js';\n\nconst dataGenerator = new DataArrayGenerator();\n\nclass F extends GPUTest {\n  GetInitialDataPerMipLevel(\n    dimension: GPUTextureDimension,\n    textureSize: Required<GPUExtent3DDict>,\n    format: SizedTextureFormat,\n    mipLevel: number\n  ): Uint8Array {\n    const textureSizeAtLevel = physicalMipSize(textureSize, format, dimension, mipLevel);\n    const bytesPerBlock = kTextureFormatInfo[format].bytesPerBlock;\n    const blockWidthInTexel = kTextureFormatInfo[format].blockWidth;\n    const blockHeightInTexel = kTextureFormatInfo[format].blockHeight;\n    const blocksPerSubresource =\n      (textureSizeAtLevel.width / blockWidthInTexel) *\n      (textureSizeAtLevel.height / blockHeightInTexel);\n\n    const byteSize = bytesPerBlock * blocksPerSubresource * textureSizeAtLevel.depthOrArrayLayers;\n    return dataGenerator.generateView(byteSize);\n  }\n\n  GetInitialStencilDataPerMipLevel(\n    textureSize: Required<GPUExtent3DDict>,\n    format: DepthStencilFormat,\n    mipLevel: number\n  ): Uint8Array {\n    const textureSizeAtLevel = physicalMipSize(textureSize, format, '2d', mipLevel);\n    const aspectBytesPerBlock = depthStencilFormatAspectSize(format, 'stencil-only');\n    const byteSize =\n      aspectBytesPerBlock *\n      textureSizeAtLevel.width *\n      textureSizeAtLevel.height *\n      textureSizeAtLevel.depthOrArrayLayers;\n    return dataGenerator.generateView(byteSize);\n  }\n\n  DoCopyTextureToTextureTest(\n    dimension: GPUTextureDimension,\n    srcTextureSize: Required<GPUExtent3DDict>,\n    dstTextureSize: Required<GPUExtent3DDict>,\n    srcFormat: SizedTextureFormat,\n    dstFormat: SizedTextureFormat,\n    copyBoxOffsets: {\n      srcOffset: { x: number; y: number; z: number };\n      dstOffset: { x: number; y: number; z: number };\n      copyExtent: Required<GPUExtent3DDict>;\n    },\n    srcCopyLevel: number,\n    dstCopyLevel: number\n  ): void {\n    const mipLevelCount = dimension === '1d' ? 1 : 4;\n\n    // Create srcTexture and dstTexture\n    const srcTextureDesc: GPUTextureDescriptor = {\n      dimension,\n      size: srcTextureSize,\n      format: srcFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      mipLevelCount,\n    };\n    const srcTexture = this.device.createTexture(srcTextureDesc);\n    this.trackForCleanup(srcTexture);\n    const dstTextureDesc: GPUTextureDescriptor = {\n      dimension,\n      size: dstTextureSize,\n      format: dstFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      mipLevelCount,\n    };\n    const dstTexture = this.device.createTexture(dstTextureDesc);\n    this.trackForCleanup(dstTexture);\n\n    // Fill the whole subresource of srcTexture at srcCopyLevel with initialSrcData.\n    const initialSrcData = this.GetInitialDataPerMipLevel(\n      dimension,\n      srcTextureSize,\n      srcFormat,\n      srcCopyLevel\n    );\n    const srcTextureSizeAtLevel = physicalMipSize(\n      srcTextureSize,\n      srcFormat,\n      dimension,\n      srcCopyLevel\n    );\n    const bytesPerBlock = kTextureFormatInfo[srcFormat].bytesPerBlock;\n    const blockWidth = kTextureFormatInfo[srcFormat].blockWidth;\n    const blockHeight = kTextureFormatInfo[srcFormat].blockHeight;\n    const srcBlocksPerRow = srcTextureSizeAtLevel.width / blockWidth;\n    const srcBlockRowsPerImage = srcTextureSizeAtLevel.height / blockHeight;\n    this.device.queue.writeTexture(\n      { texture: srcTexture, mipLevel: srcCopyLevel },\n      initialSrcData,\n      {\n        bytesPerRow: srcBlocksPerRow * bytesPerBlock,\n        rowsPerImage: srcBlockRowsPerImage,\n      },\n      srcTextureSizeAtLevel\n    );\n\n    // Copy the region specified by copyBoxOffsets from srcTexture to dstTexture.\n    const dstTextureSizeAtLevel = physicalMipSize(\n      dstTextureSize,\n      dstFormat,\n      dimension,\n      dstCopyLevel\n    );\n    const minWidth = Math.min(srcTextureSizeAtLevel.width, dstTextureSizeAtLevel.width);\n    const minHeight = Math.min(srcTextureSizeAtLevel.height, dstTextureSizeAtLevel.height);\n    const minDepth = Math.min(\n      srcTextureSizeAtLevel.depthOrArrayLayers,\n      dstTextureSizeAtLevel.depthOrArrayLayers\n    );\n\n    const appliedSrcOffset = {\n      x: Math.min(copyBoxOffsets.srcOffset.x * blockWidth, minWidth),\n      y: Math.min(copyBoxOffsets.srcOffset.y * blockHeight, minHeight),\n      z: Math.min(copyBoxOffsets.srcOffset.z, minDepth),\n    };\n    const appliedDstOffset = {\n      x: Math.min(copyBoxOffsets.dstOffset.x * blockWidth, minWidth),\n      y: Math.min(copyBoxOffsets.dstOffset.y * blockHeight, minHeight),\n      z: Math.min(copyBoxOffsets.dstOffset.z, minDepth),\n    };\n\n    const appliedCopyWidth = Math.max(\n      minWidth +\n        copyBoxOffsets.copyExtent.width * blockWidth -\n        Math.max(appliedSrcOffset.x, appliedDstOffset.x),\n      0\n    );\n    const appliedCopyHeight = Math.max(\n      minHeight +\n        copyBoxOffsets.copyExtent.height * blockHeight -\n        Math.max(appliedSrcOffset.y, appliedDstOffset.y),\n      0\n    );\n    assert(appliedCopyWidth % blockWidth === 0 && appliedCopyHeight % blockHeight === 0);\n\n    const appliedCopyDepth = Math.max(\n      0,\n      minDepth +\n        copyBoxOffsets.copyExtent.depthOrArrayLayers -\n        Math.max(appliedSrcOffset.z, appliedDstOffset.z)\n    );\n    assert(appliedCopyDepth >= 0);\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n      { texture: srcTexture, mipLevel: srcCopyLevel, origin: appliedSrcOffset },\n      { texture: dstTexture, mipLevel: dstCopyLevel, origin: appliedDstOffset },\n      { width: appliedCopyWidth, height: appliedCopyHeight, depthOrArrayLayers: appliedCopyDepth }\n    );\n\n    // Copy the whole content of dstTexture at dstCopyLevel to dstBuffer.\n    const dstBlocksPerRow = dstTextureSizeAtLevel.width / blockWidth;\n    const dstBlockRowsPerImage = dstTextureSizeAtLevel.height / blockHeight;\n    const bytesPerDstAlignedBlockRow = align(dstBlocksPerRow * bytesPerBlock, 256);\n    const dstBufferSize =\n      (dstBlockRowsPerImage * dstTextureSizeAtLevel.depthOrArrayLayers - 1) *\n        bytesPerDstAlignedBlockRow +\n      align(dstBlocksPerRow * bytesPerBlock, 4);\n    const dstBufferDesc: GPUBufferDescriptor = {\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    };\n    const dstBuffer = this.device.createBuffer(dstBufferDesc);\n    this.trackForCleanup(dstBuffer);\n\n    encoder.copyTextureToBuffer(\n      { texture: dstTexture, mipLevel: dstCopyLevel },\n      {\n        buffer: dstBuffer,\n        bytesPerRow: bytesPerDstAlignedBlockRow,\n        rowsPerImage: dstBlockRowsPerImage,\n      },\n      dstTextureSizeAtLevel\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    // Fill expectedUint8DataWithPadding with the expected data of dstTexture. The other values in\n    // expectedUint8DataWithPadding are kept 0 to check if the texels untouched by the copy are 0\n    // (their previous values).\n    const expectedUint8DataWithPadding = new Uint8Array(dstBufferSize);\n    const expectedUint8Data = new Uint8Array(initialSrcData);\n\n    const appliedCopyBlocksPerRow = appliedCopyWidth / blockWidth;\n    const appliedCopyBlockRowsPerImage = appliedCopyHeight / blockHeight;\n    const srcCopyOffsetInBlocks = {\n      x: appliedSrcOffset.x / blockWidth,\n      y: appliedSrcOffset.y / blockHeight,\n      z: appliedSrcOffset.z,\n    };\n    const dstCopyOffsetInBlocks = {\n      x: appliedDstOffset.x / blockWidth,\n      y: appliedDstOffset.y / blockHeight,\n      z: appliedDstOffset.z,\n    };\n\n    for (let z = 0; z < appliedCopyDepth; ++z) {\n      const srcOffsetZ = srcCopyOffsetInBlocks.z + z;\n      const dstOffsetZ = dstCopyOffsetInBlocks.z + z;\n      for (let y = 0; y < appliedCopyBlockRowsPerImage; ++y) {\n        const dstOffsetYInBlocks = dstCopyOffsetInBlocks.y + y;\n        const expectedDataWithPaddingOffset =\n          bytesPerDstAlignedBlockRow * (dstBlockRowsPerImage * dstOffsetZ + dstOffsetYInBlocks) +\n          dstCopyOffsetInBlocks.x * bytesPerBlock;\n\n        const srcOffsetYInBlocks = srcCopyOffsetInBlocks.y + y;\n        const expectedDataOffset =\n          bytesPerBlock *\n            srcBlocksPerRow *\n            (srcBlockRowsPerImage * srcOffsetZ + srcOffsetYInBlocks) +\n          srcCopyOffsetInBlocks.x * bytesPerBlock;\n\n        const bytesInRow = appliedCopyBlocksPerRow * bytesPerBlock;\n        memcpy(\n          { src: expectedUint8Data, start: expectedDataOffset, length: bytesInRow },\n          { dst: expectedUint8DataWithPadding, start: expectedDataWithPaddingOffset }\n        );\n      }\n    }\n\n    let alternateExpectedData = expectedUint8DataWithPadding;\n    // For 8-byte snorm formats, allow an alternative encoding of -1.\n    // MAINTENANCE_TODO: Use textureContentIsOKByT2B with TexelView.\n    if (srcFormat.includes('snorm')) {\n      switch (srcFormat) {\n        case 'r8snorm':\n        case 'rg8snorm':\n        case 'rgba8snorm':\n          alternateExpectedData = alternateExpectedData.slice();\n          for (let i = 0; i < alternateExpectedData.length; ++i) {\n            if (alternateExpectedData[i] === 128) {\n              alternateExpectedData[i] = 129;\n            } else if (alternateExpectedData[i] === 129) {\n              alternateExpectedData[i] = 128;\n            }\n          }\n          break;\n        case 'bc4-r-snorm':\n        case 'bc5-rg-snorm':\n        case 'eac-r11snorm':\n        case 'eac-rg11snorm':\n          break;\n        default:\n          unreachable();\n      }\n    }\n\n    // Verify the content of the whole subresource of dstTexture at dstCopyLevel (in dstBuffer) is expected.\n    this.expectGPUBufferValuesPassCheck(\n      dstBuffer,\n      alternateExpectedData === expectedUint8DataWithPadding\n        ? vals => checkElementsEqual(vals, expectedUint8DataWithPadding)\n        : vals =>\n            checkElementsEqualEither(vals, [expectedUint8DataWithPadding, alternateExpectedData]),\n      {\n        srcByteOffset: 0,\n        type: Uint8Array,\n        typedLength: expectedUint8DataWithPadding.length,\n      }\n    );\n  }\n\n  InitializeStencilAspect(\n    sourceTexture: GPUTexture,\n    initialStencilData: Uint8Array,\n    srcCopyLevel: number,\n    srcCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    this.queue.writeTexture(\n      {\n        texture: sourceTexture,\n        mipLevel: srcCopyLevel,\n        aspect: 'stencil-only',\n        origin: { x: 0, y: 0, z: srcCopyBaseArrayLayer },\n      },\n      initialStencilData,\n      { bytesPerRow: copySize[0], rowsPerImage: copySize[1] },\n      copySize\n    );\n  }\n\n  VerifyStencilAspect(\n    destinationTexture: GPUTexture,\n    initialStencilData: Uint8Array,\n    dstCopyLevel: number,\n    dstCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    const bytesPerRow = align(copySize[0], kBytesPerRowAlignment);\n    const rowsPerImage = copySize[1];\n    const outputBufferSize = align(\n      dataBytesForCopyOrFail({\n        layout: { bytesPerRow, rowsPerImage },\n        format: 'stencil8',\n        copySize,\n        method: 'CopyT2B',\n      }),\n      kBufferSizeAlignment\n    );\n    const outputBuffer = this.device.createBuffer({\n      size: outputBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(outputBuffer);\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      {\n        texture: destinationTexture,\n        aspect: 'stencil-only',\n        mipLevel: dstCopyLevel,\n        origin: { x: 0, y: 0, z: dstCopyBaseArrayLayer },\n      },\n      { buffer: outputBuffer, bytesPerRow, rowsPerImage },\n      copySize\n    );\n    this.queue.submit([encoder.finish()]);\n\n    const expectedStencilData = new Uint8Array(outputBufferSize);\n    for (let z = 0; z < copySize[2]; ++z) {\n      const initialOffsetPerLayer = z * copySize[0] * copySize[1];\n      const expectedOffsetPerLayer = z * bytesPerRow * rowsPerImage;\n      for (let y = 0; y < copySize[1]; ++y) {\n        const initialOffsetPerRow = initialOffsetPerLayer + y * copySize[0];\n        const expectedOffsetPerRow = expectedOffsetPerLayer + y * bytesPerRow;\n        memcpy(\n          { src: initialStencilData, start: initialOffsetPerRow, length: copySize[0] },\n          { dst: expectedStencilData, start: expectedOffsetPerRow }\n        );\n      }\n    }\n    this.expectGPUBufferValuesEqual(outputBuffer, expectedStencilData);\n  }\n\n  GetRenderPipelineForT2TCopyWithDepthTests(\n    bindGroupLayout: GPUBindGroupLayout,\n    hasColorAttachment: boolean,\n    depthStencil: GPUDepthStencilState\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: this.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            struct Params {\n              copyLayer: f32\n            };\n            @group(0) @binding(0) var<uniform> param: Params;\n            @vertex\n            fn main(@builtin(vertex_index) VertexIndex : u32)-> @builtin(position) vec4<f32> {\n              var depthValue = 0.5 + 0.2 * sin(param.copyLayer);\n              var pos : array<vec3<f32>, 6> = array<vec3<f32>, 6>(\n                  vec3<f32>(-1.0,  1.0, depthValue),\n                  vec3<f32>(-1.0, -1.0, 0.0),\n                  vec3<f32>( 1.0,  1.0, 1.0),\n                  vec3<f32>(-1.0, -1.0, 0.0),\n                  vec3<f32>( 1.0,  1.0, 1.0),\n                  vec3<f32>( 1.0, -1.0, depthValue));\n              return vec4<f32>(pos[VertexIndex], 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      depthStencil,\n    };\n    if (hasColorAttachment) {\n      renderPipelineDescriptor.fragment = {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment\n            fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      };\n    }\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  GetBindGroupLayoutForT2TCopyWithDepthTests(): GPUBindGroupLayout {\n    return this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX,\n          buffer: {\n            type: 'uniform',\n            minBindingSize: 4,\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n  }\n\n  GetBindGroupForT2TCopyWithDepthTests(\n    bindGroupLayout: GPUBindGroupLayout,\n    totalCopyArrayLayers: number\n  ): GPUBindGroup {\n    // Prepare the uniform buffer that contains all the copy layers to generate different depth\n    // values for different copy layers.\n    assert(totalCopyArrayLayers > 0);\n    const uniformBufferSize = kMinDynamicBufferOffsetAlignment * (totalCopyArrayLayers - 1) + 4;\n    const uniformBufferData = new Float32Array(uniformBufferSize / 4);\n    for (let i = 1; i < totalCopyArrayLayers; ++i) {\n      uniformBufferData[(kMinDynamicBufferOffsetAlignment / 4) * i] = i;\n    }\n    const uniformBuffer = makeBufferWithContents(\n      this.device,\n      uniformBufferData,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n    );\n    return this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: 4,\n          },\n        },\n      ],\n    });\n  }\n\n  /** Initialize the depth aspect of sourceTexture with draw calls */\n  InitializeDepthAspect(\n    sourceTexture: GPUTexture,\n    depthFormat: GPUTextureFormat,\n    srcCopyLevel: number,\n    srcCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    // Prepare a renderPipeline with depthCompareFunction == 'always' and depthWriteEnabled == true\n    // for the initializations of the depth attachment.\n    const bindGroupLayout = this.GetBindGroupLayoutForT2TCopyWithDepthTests();\n    const renderPipeline = this.GetRenderPipelineForT2TCopyWithDepthTests(bindGroupLayout, false, {\n      format: depthFormat,\n      depthWriteEnabled: true,\n      depthCompare: 'always',\n    });\n    const bindGroup = this.GetBindGroupForT2TCopyWithDepthTests(bindGroupLayout, copySize[2]);\n\n    const hasStencil = kTextureFormatInfo[sourceTexture.format].stencil;\n    const encoder = this.device.createCommandEncoder();\n    for (let srcCopyLayer = 0; srcCopyLayer < copySize[2]; ++srcCopyLayer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: sourceTexture.createView({\n            baseArrayLayer: srcCopyLayer + srcCopyBaseArrayLayer,\n            arrayLayerCount: 1,\n            baseMipLevel: srcCopyLevel,\n            mipLevelCount: 1,\n          }),\n          depthClearValue: 0.0,\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          stencilLoadOp: hasStencil ? 'load' : undefined,\n          stencilStoreOp: hasStencil ? 'store' : undefined,\n        },\n      });\n      renderPass.setBindGroup(0, bindGroup, [srcCopyLayer * kMinDynamicBufferOffsetAlignment]);\n      renderPass.setPipeline(renderPipeline);\n      renderPass.draw(6);\n      renderPass.end();\n    }\n    this.queue.submit([encoder.finish()]);\n  }\n\n  VerifyDepthAspect(\n    destinationTexture: GPUTexture,\n    depthFormat: GPUTextureFormat,\n    dstCopyLevel: number,\n    dstCopyBaseArrayLayer: number,\n    copySize: [number, number, number]\n  ): void {\n    // Prepare a renderPipeline with depthCompareFunction == 'equal' and depthWriteEnabled == false\n    // for the comparison of the depth attachment.\n    const bindGroupLayout = this.GetBindGroupLayoutForT2TCopyWithDepthTests();\n    const renderPipeline = this.GetRenderPipelineForT2TCopyWithDepthTests(bindGroupLayout, true, {\n      format: depthFormat,\n      depthWriteEnabled: false,\n      depthCompare: 'equal',\n    });\n    const bindGroup = this.GetBindGroupForT2TCopyWithDepthTests(bindGroupLayout, copySize[2]);\n\n    const outputColorTexture = this.trackForCleanup(\n      this.device.createTexture({\n        format: 'rgba8unorm',\n        size: copySize,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n      })\n    );\n    const hasStencil = kTextureFormatInfo[destinationTexture.format].stencil;\n    const encoder = this.device.createCommandEncoder();\n    for (let dstCopyLayer = 0; dstCopyLayer < copySize[2]; ++dstCopyLayer) {\n      // If the depth value is not expected, the color of outputColorTexture will remain Red after\n      // the render pass.\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: outputColorTexture.createView({\n              baseArrayLayer: dstCopyLayer,\n              arrayLayerCount: 1,\n            }),\n            clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n        depthStencilAttachment: {\n          view: destinationTexture.createView({\n            baseArrayLayer: dstCopyLayer + dstCopyBaseArrayLayer,\n            arrayLayerCount: 1,\n            baseMipLevel: dstCopyLevel,\n            mipLevelCount: 1,\n          }),\n          depthLoadOp: 'load',\n          depthStoreOp: 'store',\n          stencilLoadOp: hasStencil ? 'load' : undefined,\n          stencilStoreOp: hasStencil ? 'store' : undefined,\n        },\n      });\n      renderPass.setBindGroup(0, bindGroup, [dstCopyLayer * kMinDynamicBufferOffsetAlignment]);\n      renderPass.setPipeline(renderPipeline);\n      renderPass.draw(6);\n      renderPass.end();\n    }\n    this.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(outputColorTexture, 'rgba8unorm', {\n      size: copySize,\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  }\n}\n\nconst kCopyBoxOffsetsForWholeDepth = [\n  // From (0, 0) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, 0) of src to (blockWidth, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 1, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, 0) of src to (0, blockHeight) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 1, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (blockWidth, 0) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 1, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, blockHeight) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 1, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (blockWidth, 0) of src to (0, 0) of dst, and the copy extent will not cover the last\n  // texel block column of both source and destination texture.\n  {\n    srcOffset: { x: 1, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: -1, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, blockHeight) of src to (0, 0) of dst, and the copy extent will not cover the last\n  // texel block row of both source and destination texture.\n  {\n    srcOffset: { x: 0, y: 1, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: -1, depthOrArrayLayers: 0 },\n  },\n] as const;\n\nconst kCopyBoxOffsetsFor2DArrayTextures = [\n  // Copy the whole array slices from the source texture to the destination texture.\n  // The copy extent will cover the whole subresource of either source or the\n  // destination texture\n  ...kCopyBoxOffsetsForWholeDepth,\n\n  // Copy 1 texture slice from the 1st slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -2 },\n  },\n  // Copy 1 texture slice from the 2nd slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -3 },\n  },\n  // Copy 1 texture slice from the 1st slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n  // Copy 1 texture slice from the 2nd slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n  // Copy 2 texture slices from the 1st slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -3 },\n  },\n  // Copy 3 texture slices from the 2nd slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n] as const;\n\nexport const g = makeTestGroup(F);\n\ng.test('color_textures,non_compressed,non_array')\n  .desc(\n    `\n  Validate the correctness of the copy by filling the srcTexture with testable data and any\n  non-compressed color format supported by WebGPU, doing CopyTextureToTexture() copy, and verifying\n  the content of the whole dstTexture.\n\n  Copy {1 texel block, part of, the whole} srcTexture to the dstTexture {with, without} a non-zero\n  valid srcOffset that\n  - covers the whole dstTexture subresource\n  - covers the corners of the dstTexture\n  - doesn't cover any texels that are on the edge of the dstTexture\n  - covers the mipmap level > 0\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kRegularTextureFormats)\n      .combine('dstFormat', kRegularTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = kTextureFormatInfo[srcFormat].baseFormat;\n        const dstBaseFormat = kTextureFormatInfo[dstFormat].baseFormat;\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', kTextureDimensions)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureDimensionAndFormatCompatible(dimension, srcFormat) &&\n          textureDimensionAndFormatCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .expandWithParams(p => {\n        const params = [\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 31, height: 33, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 31, height: 33, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 64, height: 64, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 63, height: 61, depthOrArrayLayers: 1 },\n          },\n        ];\n        if (p.dimension === '1d') {\n          for (const param of params) {\n            param.srcTextureSize.height = 1;\n            param.dstTextureSize.height = 1;\n          }\n        }\n\n        return params;\n      })\n      .combine('copyBoxOffsets', kCopyBoxOffsetsForWholeDepth)\n      .unless(\n        p =>\n          p.dimension === '1d' &&\n          (p.copyBoxOffsets.copyExtent.height !== 0 ||\n            p.copyBoxOffsets.srcOffset.y !== 0 ||\n            p.copyBoxOffsets.dstOffset.y !== 0)\n      )\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n      .unless(p => p.dimension === '1d' && (p.srcCopyLevel !== 0 || p.dstCopyLevel !== 0))\n  )\n  .fn(t => {\n    const {\n      dimension,\n      srcTextureSize,\n      dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n\n    t.DoCopyTextureToTextureTest(\n      dimension,\n      srcTextureSize,\n      dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,compressed,non_array')\n  .desc(\n    `\n  Validate the correctness of the copy by filling the srcTexture with testable data and any\n  compressed color format supported by WebGPU, doing CopyTextureToTexture() copy, and verifying\n  the content of the whole dstTexture.\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kCompressedTextureFormats)\n      .combine('dstFormat', kCompressedTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = kTextureFormatInfo[srcFormat].baseFormat;\n        const dstBaseFormat = kTextureFormatInfo[dstFormat].baseFormat;\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', kTextureDimensions)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureDimensionAndFormatCompatible(dimension, srcFormat) &&\n          textureDimensionAndFormatCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .combine('textureSizeInBlocks', [\n        // The heights and widths in blocks are all power of 2\n        { src: { width: 16, height: 8 }, dst: { width: 16, height: 8 } },\n        // The virtual width of the source texture at mipmap level 2 (15) is not a multiple of 4 blocks\n        { src: { width: 15, height: 8 }, dst: { width: 16, height: 8 } },\n        // The virtual width of the destination texture at mipmap level 2 (15) is not a multiple\n        // of 4 blocks\n        { src: { width: 16, height: 8 }, dst: { width: 15, height: 8 } },\n        // The virtual height of the source texture at mipmap level 2 (13) is not a multiple of 4 blocks\n        { src: { width: 16, height: 13 }, dst: { width: 16, height: 8 } },\n        // The virtual height of the destination texture at mipmap level 2 (13) is not a\n        // multiple of 4 blocks\n        { src: { width: 16, height: 8 }, dst: { width: 16, height: 13 } },\n        // None of the widths or heights in blocks are power of 2\n        { src: { width: 15, height: 13 }, dst: { width: 15, height: 13 } },\n      ])\n      .combine('copyBoxOffsets', kCopyBoxOffsetsForWholeDepth)\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n  )\n  .beforeAllSubcases(t => {\n    const { srcFormat, dstFormat } = t.params;\n    t.selectDeviceOrSkipTestCase([\n      kTextureFormatInfo[srcFormat].feature,\n      kTextureFormatInfo[dstFormat].feature,\n    ]);\n  })\n  .fn(t => {\n    const {\n      dimension,\n      textureSizeInBlocks,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n    const srcBlockWidth = kTextureFormatInfo[srcFormat].blockWidth;\n    const srcBlockHeight = kTextureFormatInfo[srcFormat].blockHeight;\n    const dstBlockWidth = kTextureFormatInfo[dstFormat].blockWidth;\n    const dstBlockHeight = kTextureFormatInfo[dstFormat].blockHeight;\n\n    t.DoCopyTextureToTextureTest(\n      dimension,\n      {\n        width: textureSizeInBlocks.src.width * srcBlockWidth,\n        height: textureSizeInBlocks.src.height * srcBlockHeight,\n        depthOrArrayLayers: 1,\n      },\n      {\n        width: textureSizeInBlocks.dst.width * dstBlockWidth,\n        height: textureSizeInBlocks.dst.height * dstBlockHeight,\n        depthOrArrayLayers: 1,\n      },\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,non_compressed,array')\n  .desc(\n    `\n  Validate the correctness of the texture-to-texture copy on 2D array textures by filling the\n  srcTexture with testable data and any non-compressed color format supported by WebGPU, doing\n  CopyTextureToTexture() copy, and verifying the content of the whole dstTexture.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kRegularTextureFormats)\n      .combine('dstFormat', kRegularTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = kTextureFormatInfo[srcFormat].baseFormat;\n        const dstBaseFormat = kTextureFormatInfo[dstFormat].baseFormat;\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', ['2d', '3d'] as const)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureDimensionAndFormatCompatible(dimension, srcFormat) &&\n          textureDimensionAndFormatCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .combine('textureSize', [\n        {\n          srcTextureSize: { width: 64, height: 32, depthOrArrayLayers: 5 },\n          dstTextureSize: { width: 64, height: 32, depthOrArrayLayers: 5 },\n        },\n        {\n          srcTextureSize: { width: 31, height: 33, depthOrArrayLayers: 5 },\n          dstTextureSize: { width: 31, height: 33, depthOrArrayLayers: 5 },\n        },\n        {\n          srcTextureSize: { width: 31, height: 32, depthOrArrayLayers: 33 },\n          dstTextureSize: { width: 31, height: 32, depthOrArrayLayers: 33 },\n        },\n      ])\n\n      .combine('copyBoxOffsets', kCopyBoxOffsetsFor2DArrayTextures)\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n  )\n  .fn(t => {\n    const {\n      dimension,\n      textureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n\n    t.DoCopyTextureToTextureTest(\n      dimension,\n      textureSize.srcTextureSize,\n      textureSize.dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,compressed,array')\n  .desc(\n    `\n  Validate the correctness of the texture-to-texture copy on 2D array textures by filling the\n  srcTexture with testable data and any compressed color format supported by WebGPU, doing\n  CopyTextureToTexture() copy, and verifying the content of the whole dstTexture.\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kCompressedTextureFormats)\n      .combine('dstFormat', kCompressedTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = kTextureFormatInfo[srcFormat].baseFormat;\n        const dstBaseFormat = kTextureFormatInfo[dstFormat].baseFormat;\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', ['2d', '3d'] as const)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureDimensionAndFormatCompatible(dimension, srcFormat) &&\n          textureDimensionAndFormatCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .combine('textureSizeInBlocks', [\n        // The heights and widths in blocks are all power of 2\n        { src: { width: 2, height: 2 }, dst: { width: 2, height: 2 } },\n        // None of the widths or heights in blocks are power of 2\n        { src: { width: 15, height: 13 }, dst: { width: 15, height: 13 } },\n      ])\n      .combine('copyBoxOffsets', kCopyBoxOffsetsFor2DArrayTextures)\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n  )\n  .beforeAllSubcases(t => {\n    const { srcFormat, dstFormat } = t.params;\n\n    t.selectDeviceOrSkipTestCase([\n      kTextureFormatInfo[srcFormat].feature,\n      kTextureFormatInfo[dstFormat].feature,\n    ]);\n  })\n  .fn(t => {\n    const {\n      dimension,\n      textureSizeInBlocks,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n    const srcBlockWidth = kTextureFormatInfo[srcFormat].blockWidth;\n    const srcBlockHeight = kTextureFormatInfo[srcFormat].blockHeight;\n    const dstBlockWidth = kTextureFormatInfo[dstFormat].blockWidth;\n    const dstBlockHeight = kTextureFormatInfo[dstFormat].blockHeight;\n\n    t.DoCopyTextureToTextureTest(\n      dimension,\n      {\n        width: textureSizeInBlocks.src.width * srcBlockWidth,\n        height: textureSizeInBlocks.src.height * srcBlockHeight,\n        depthOrArrayLayers: 5,\n      },\n      {\n        width: textureSizeInBlocks.dst.width * dstBlockWidth,\n        height: textureSizeInBlocks.dst.height * dstBlockHeight,\n        depthOrArrayLayers: 5,\n      },\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('zero_sized')\n  .desc(\n    `\n  Validate the correctness of zero-sized copies (should be no-ops).\n\n  - For each texture dimension.\n  - Copies that are zero-sized in only one dimension {x, y, z}, each touching the {lower, upper} end\n  of that dimension.\n  `\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combineWithParams([\n        { dimension: '1d', textureSize: { width: 32, height: 1, depthOrArrayLayers: 1 } },\n        { dimension: '2d', textureSize: { width: 32, height: 32, depthOrArrayLayers: 5 } },\n        { dimension: '3d', textureSize: { width: 32, height: 32, depthOrArrayLayers: 5 } },\n      ] as const)\n      .combine('copyBoxOffset', [\n        // copyExtent.width === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.width === 0 && srcOffset.x === textureWidth\n        {\n          srcOffset: { x: 64, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.width === 0 && dstOffset.x === textureWidth\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 64, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0 && srcOffset.y === textureHeight\n        {\n          srcOffset: { x: 0, y: 32, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0 && dstOffset.y === textureHeight\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 32, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.depthOrArrayLayers === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: -5 },\n        },\n        // copyExtent.depthOrArrayLayers === 0 && srcOffset.z === textureDepth\n        {\n          srcOffset: { x: 0, y: 0, z: 5 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.depthOrArrayLayers === 0 && dstOffset.z === textureDepth\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 5 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n        },\n      ])\n      .unless(\n        p =>\n          p.dimension === '1d' &&\n          (p.copyBoxOffset.copyExtent.height !== 0 ||\n            p.copyBoxOffset.srcOffset.y !== 0 ||\n            p.copyBoxOffset.dstOffset.y !== 0)\n      )\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n      .unless(p => p.dimension === '1d' && (p.srcCopyLevel !== 0 || p.dstCopyLevel !== 0))\n  )\n  .fn(t => {\n    const { dimension, textureSize, copyBoxOffset, srcCopyLevel, dstCopyLevel } = t.params;\n\n    const srcFormat = 'rgba8unorm';\n    const dstFormat = 'rgba8unorm';\n\n    t.DoCopyTextureToTextureTest(\n      dimension,\n      textureSize,\n      textureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffset,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('copy_depth_stencil')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with depth and stencil aspect.\n\n  For all the texture formats with stencil aspect:\n  - Initialize the stencil aspect of the source texture with writeTexture().\n  - Copy the stencil aspect from the source texture into the destination texture\n  - Copy the stencil aspect of the destination texture into another staging buffer and check its\n    content\n  - Test the copies from / into zero / non-zero array layer / mipmap levels\n  - Test copying multiple array layers\n\n  For all the texture formats with depth aspect:\n  - Initialize the depth aspect of the source texture with a draw call\n  - Copy the depth aspect from the source texture into the destination texture\n  - Validate the content in the destination texture with the depth comparison function 'equal'\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .beginSubcases()\n      .combine('srcTextureSize', [\n        { width: 32, height: 16, depthOrArrayLayers: 1 },\n        { width: 32, height: 16, depthOrArrayLayers: 4 },\n        { width: 24, height: 48, depthOrArrayLayers: 5 },\n      ])\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n      .combine('srcCopyBaseArrayLayer', [0, 1])\n      .combine('dstCopyBaseArrayLayer', [0, 1])\n      .filter(t => {\n        return (\n          t.srcTextureSize.depthOrArrayLayers > t.srcCopyBaseArrayLayer &&\n          t.srcTextureSize.depthOrArrayLayers > t.dstCopyBaseArrayLayer\n        );\n      })\n  )\n  .beforeAllSubcases(t => {\n    const { format } = t.params;\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  })\n  .fn(t => {\n    const {\n      format,\n      srcTextureSize,\n      srcCopyLevel,\n      dstCopyLevel,\n      srcCopyBaseArrayLayer,\n      dstCopyBaseArrayLayer,\n    } = t.params;\n\n    const copySize: [number, number, number] = [\n      srcTextureSize.width >> srcCopyLevel,\n      srcTextureSize.height >> srcCopyLevel,\n      srcTextureSize.depthOrArrayLayers - Math.max(srcCopyBaseArrayLayer, dstCopyBaseArrayLayer),\n    ];\n    const sourceTexture = t.trackForCleanup(\n      t.device.createTexture({\n        format,\n        size: srcTextureSize,\n        usage:\n          GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: srcCopyLevel + 1,\n      })\n    );\n    const destinationTexture = t.trackForCleanup(\n      t.device.createTexture({\n        format,\n        size: [\n          copySize[0] << dstCopyLevel,\n          copySize[1] << dstCopyLevel,\n          srcTextureSize.depthOrArrayLayers,\n        ] as const,\n        usage:\n          GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: dstCopyLevel + 1,\n      })\n    );\n\n    let initialStencilData: undefined | Uint8Array = undefined;\n    if (kTextureFormatInfo[format].stencil) {\n      initialStencilData = t.GetInitialStencilDataPerMipLevel(srcTextureSize, format, srcCopyLevel);\n      t.InitializeStencilAspect(\n        sourceTexture,\n        initialStencilData,\n        srcCopyLevel,\n        srcCopyBaseArrayLayer,\n        copySize\n      );\n    }\n    if (kTextureFormatInfo[format].depth) {\n      t.InitializeDepthAspect(sourceTexture, format, srcCopyLevel, srcCopyBaseArrayLayer, copySize);\n    }\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n        mipLevel: srcCopyLevel,\n        origin: { x: 0, y: 0, z: srcCopyBaseArrayLayer },\n      },\n      {\n        texture: destinationTexture,\n        mipLevel: dstCopyLevel,\n        origin: { x: 0, y: 0, z: dstCopyBaseArrayLayer },\n      },\n      copySize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    if (kTextureFormatInfo[format].stencil) {\n      assert(initialStencilData !== undefined);\n      t.VerifyStencilAspect(\n        destinationTexture,\n        initialStencilData,\n        dstCopyLevel,\n        dstCopyBaseArrayLayer,\n        copySize\n      );\n    }\n    if (kTextureFormatInfo[format].depth) {\n      t.VerifyDepthAspect(\n        destinationTexture,\n        format,\n        dstCopyLevel,\n        dstCopyBaseArrayLayer,\n        copySize\n      );\n    }\n  });\n\ng.test('copy_multisampled_color')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with multisampled color formats.\n\n  - Initialize the source texture with a triangle in a render pass.\n  - Copy from the source texture into the destination texture with CopyTextureToTexture().\n  - Compare every sub-pixel of source texture and destination texture in another render pass:\n    - If they are different, then output RED; otherwise output GREEN\n  - Verify the pixels in the output texture are all GREEN.\n  - Note that in current WebGPU SPEC the mipmap level count and array layer count of a multisampled\n    texture can only be 1.\n  `\n  )\n  .fn(t => {\n    const textureSize = [32, 16, 1] as const;\n    const kColorFormat = 'rgba8unorm';\n    const kSampleCount = 4;\n\n    const sourceTexture = t.device.createTexture({\n      format: kColorFormat,\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    t.trackForCleanup(sourceTexture);\n    const destinationTexture = t.device.createTexture({\n      format: kColorFormat,\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    t.trackForCleanup(destinationTexture);\n\n    // Initialize sourceTexture with a draw call.\n    const renderPipelineForInit = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex\n            fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n              var pos = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0),\n                  vec2<f32>( 1.0, -1.0)\n              );\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            @fragment\n            fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.3, 0.5, 0.8, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n    const initEncoder = t.device.createCommandEncoder();\n    const renderPassForInit = initEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: sourceTexture.createView(),\n          clearValue: [1.0, 0.0, 0.0, 1.0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPassForInit.setPipeline(renderPipelineForInit);\n    renderPassForInit.draw(3);\n    renderPassForInit.end();\n    t.queue.submit([initEncoder.finish()]);\n\n    // Do the texture-to-texture copy\n    const copyEncoder = t.device.createCommandEncoder();\n    copyEncoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n      },\n      {\n        texture: destinationTexture,\n      },\n      textureSize\n    );\n    t.queue.submit([copyEncoder.finish()]);\n\n    // Verify if all the sub-pixel values at the same location of sourceTexture and\n    // destinationTexture are equal.\n    const renderPipelineForValidation = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n            var pos = array<vec2<f32>, 6>(\n              vec2<f32>(-1.0,  1.0),\n              vec2<f32>(-1.0, -1.0),\n              vec2<f32>( 1.0,  1.0),\n              vec2<f32>(-1.0, -1.0),\n              vec2<f32>( 1.0,  1.0),\n              vec2<f32>( 1.0, -1.0));\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var sourceTexture : texture_multisampled_2d<f32>;\n          @group(0) @binding(1) var destinationTexture : texture_multisampled_2d<f32>;\n          @fragment\n          fn main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {\n            var coord_in_vec2 = vec2<i32>(i32(coord_in.x), i32(coord_in.y));\n            for (var sampleIndex = 0; sampleIndex < ${kSampleCount};\n              sampleIndex = sampleIndex + 1) {\n              var sourceSubPixel : vec4<f32> =\n                textureLoad(sourceTexture, coord_in_vec2, sampleIndex);\n              var destinationSubPixel : vec4<f32> =\n                textureLoad(destinationTexture, coord_in_vec2, sampleIndex);\n              if (!all(sourceSubPixel == destinationSubPixel)) {\n                return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n              }\n            }\n            return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n    });\n    const bindGroup = t.device.createBindGroup({\n      layout: renderPipelineForValidation.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sourceTexture.createView(),\n        },\n        {\n          binding: 1,\n          resource: destinationTexture.createView(),\n        },\n      ],\n    });\n    const expectedOutputTexture = t.device.createTexture({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    t.trackForCleanup(expectedOutputTexture);\n    const validationEncoder = t.device.createCommandEncoder();\n    const renderPassForValidation = validationEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: expectedOutputTexture.createView(),\n          clearValue: [1.0, 0.0, 0.0, 1.0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPassForValidation.setPipeline(renderPipelineForValidation);\n    renderPassForValidation.setBindGroup(0, bindGroup);\n    renderPassForValidation.draw(6);\n    renderPassForValidation.end();\n    t.queue.submit([validationEncoder.finish()]);\n\n    t.expectSingleColor(expectedOutputTexture, 'rgba8unorm', {\n      size: [textureSize[0], textureSize[1], textureSize[2]],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  });\n\ng.test('copy_multisampled_depth')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with multisampled depth formats.\n\n  - Initialize the source texture with a triangle in a render pass.\n  - Copy from the source texture into the destination texture with CopyTextureToTexture().\n  - Validate the content in the destination texture with the depth comparison function 'equal'.\n  - Note that in current WebGPU SPEC the mipmap level count and array layer count of a multisampled\n    texture can only be 1.\n  `\n  )\n  .fn(t => {\n    const textureSize = [32, 16, 1] as const;\n    const kDepthFormat = 'depth24plus';\n    const kSampleCount = 4;\n\n    const sourceTexture = t.device.createTexture({\n      format: kDepthFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    t.trackForCleanup(sourceTexture);\n    const destinationTexture = t.device.createTexture({\n      format: kDepthFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    t.trackForCleanup(destinationTexture);\n\n    const vertexState: GPUVertexState = {\n      module: t.device.createShaderModule({\n        code: `\n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32)-> @builtin(position) vec4<f32> {\n            var pos : array<vec3<f32>, 6> = array<vec3<f32>, 6>(\n                vec3<f32>(-1.0,  1.0, 0.5),\n                vec3<f32>(-1.0, -1.0, 0.0),\n                vec3<f32>( 1.0,  1.0, 1.0),\n                vec3<f32>(-1.0, -1.0, 0.0),\n                vec3<f32>( 1.0,  1.0, 1.0),\n                vec3<f32>( 1.0, -1.0, 0.5));\n            return vec4<f32>(pos[VertexIndex], 1.0);\n          }`,\n      }),\n      entryPoint: 'main',\n    };\n\n    // Initialize the depth aspect of source texture with a draw call\n    const renderPipelineForInit = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: vertexState,\n      depthStencil: {\n        format: kDepthFormat,\n        depthCompare: 'always',\n        depthWriteEnabled: true,\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n\n    const encoderForInit = t.device.createCommandEncoder();\n    const renderPassForInit = encoderForInit.beginRenderPass({\n      colorAttachments: [],\n      depthStencilAttachment: {\n        view: sourceTexture.createView(),\n        depthClearValue: 0.0,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n      },\n    });\n    renderPassForInit.setPipeline(renderPipelineForInit);\n    renderPassForInit.draw(6);\n    renderPassForInit.end();\n    t.queue.submit([encoderForInit.finish()]);\n\n    // Do the texture-to-texture copy\n    const copyEncoder = t.device.createCommandEncoder();\n    copyEncoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n      },\n      {\n        texture: destinationTexture,\n      },\n      textureSize\n    );\n    t.queue.submit([copyEncoder.finish()]);\n\n    // Verify the depth values in destinationTexture are what we expected with\n    // depthCompareFunction == 'equal' and depthWriteEnabled == false in the render pipeline\n    const kColorFormat = 'rgba8unorm';\n    const renderPipelineForVerify = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: vertexState,\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @fragment\n          fn main() -> @location(0) vec4<f32> {\n            return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n      depthStencil: {\n        format: kDepthFormat,\n        depthCompare: 'equal',\n        depthWriteEnabled: false,\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n    const multisampledColorTexture = t.device.createTexture({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    t.trackForCleanup(multisampledColorTexture);\n    const colorTextureAsResolveTarget = t.device.createTexture({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    t.trackForCleanup(colorTextureAsResolveTarget);\n\n    const encoderForVerify = t.device.createCommandEncoder();\n    const renderPassForVerify = encoderForVerify.beginRenderPass({\n      colorAttachments: [\n        {\n          view: multisampledColorTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'discard',\n          resolveTarget: colorTextureAsResolveTarget.createView(),\n        },\n      ],\n      depthStencilAttachment: {\n        view: destinationTexture.createView(),\n        depthLoadOp: 'load',\n        depthStoreOp: 'store',\n      },\n    });\n    renderPassForVerify.setPipeline(renderPipelineForVerify);\n    renderPassForVerify.draw(6);\n    renderPassForVerify.end();\n    t.queue.submit([encoderForVerify.finish()]);\n\n    t.expectSingleColor(colorTextureAsResolveTarget, kColorFormat, {\n      size: [textureSize[0], textureSize[1], textureSize[2]],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  });\n"],"mappings":"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"}