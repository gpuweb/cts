{"version":3,"file":"copyTextureToTexture.spec.js","names":["description","makeTestGroup","assert","ErrorWithExtra","memcpy","kBufferSizeAlignment","kMinDynamicBufferOffsetAlignment","kTextureDimensions","depthStencilFormatAspectSize","getBaseFormatForTextureFormat","getBlockInfoForColorTextureFormat","isCompressedTextureFormat","isDepthTextureFormat","isRegularTextureFormat","isStencilTextureFormat","kCompressedTextureFormats","kDepthStencilFormats","kRegularTextureFormats","textureFormatAndDimensionPossiblyCompatible","textureFormatsAreViewCompatible","AllFeaturesMaxLimitsGPUTest","ttu","checkElementsEqual","align","physicalMipSize","DataArrayGenerator","kBytesPerRowAlignment","dataBytesForCopyOrFail","TexelView","findFailedPixels","reifyExtent3D","dataGenerator","applyTextureBindingViewDimensionForTest","descriptor","size","textureBindingViewDimension","undefined","dimension","width","height","depthOrArrayLayers","F","getInitialDataPerMipLevel","textureSize","format","mipLevel","textureSizeAtLevel","bytesPerBlock","blockWidth","blockHeight","blocksPerSubresource","byteSize","generateView","getInitialStencilDataPerMipLevel","aspectBytesPerBlock","doCopyTextureToTextureTest","srcTextureSize","dstTextureSize","srcFormat","dstFormat","copyBoxOffsets","srcCopyLevel","dstCopyLevel","skipIfTextureFormatNotSupported","skipIfCopyTextureToTextureNotSupportedForFormat","skipIfTextureFormatAndDimensionNotCompatible","extraTextureUsageFlags","isCompatibility","GPUTextureUsage","TEXTURE_BINDING","mipLevelCount","srcTextureDesc","usage","COPY_SRC","COPY_DST","srcTexture","createTextureTracked","dstTextureDesc","dstTexture","initialSrcData","srcTextureSizeAtLevel","srcBlocksPerRow","srcBlockRowsPerImage","device","queue","writeTexture","texture","bytesPerRow","rowsPerImage","dstTextureSizeAtLevel","minWidth","Math","min","minHeight","minDepth","appliedSrcOffset","x","srcOffset","y","z","appliedDstOffset","dstOffset","appliedCopyWidth","max","copyExtent","appliedCopyHeight","appliedCopyDepth","appliedSize","encoder","createCommandEncoder","copyTextureToTexture","origin","submit","finish","dstBlocksPerRow","dstBlockRowsPerImage","bytesPerDstAlignedBlockRow","dstBufferSize","expectedTexture","expectedData","Uint8Array","updateLinearTextureDataSubBox","src","dataLayout","offset","data","dest","expectTexturesToMatchByRendering","dstBufferDesc","GPUBufferUsage","dstBuffer","createBufferTracked","copyTextureToBuffer","buffer","expectedUint8DataWithPadding","expectedUint8Data","appliedCopyBlocksPerRow","appliedCopyBlockRowsPerImage","srcCopyOffsetInBlocks","dstCopyOffsetInBlocks","bytesInRow","srcOffsetZ","dstOffsetZ","dstOffsetYInBlocks","expectedDataWithPaddingOffset","srcOffsetYInBlocks","expectedDataOffset","start","length","dst","expectGPUBufferValuesPassCheck","vals","srcByteOffset","type","typedLength","regularDstFormat","checkByTextureFormat","actual","zero","actTexelView","fromTextureDataByReference","subrectOrigin","subrectSize","expTexelView","failedPixelsMessage","maxFractionalDiff","msg","initializeStencilAspect","sourceTexture","initialStencilData","srcCopyBaseArrayLayer","copySize","aspect","verifyStencilAspect","destinationTexture","dstCopyBaseArrayLayer","outputBufferSize","layout","method","outputBuffer","expectedStencilData","initialOffsetPerLayer","expectedOffsetPerLayer","initialOffsetPerRow","expectedOffsetPerRow","expectGPUBufferValuesEqual","getRenderPipelineForT2TCopyWithDepthTests","bindGroupLayout","hasColorAttachment","depthStencil","renderPipelineDescriptor","createPipelineLayout","bindGroupLayouts","vertex","module","createShaderModule","code","entryPoint","fragment","targets","createRenderPipeline","getBindGroupLayoutForT2TCopyWithDepthTests","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","minBindingSize","hasDynamicOffset","getBindGroupForT2TCopyWithDepthTests","totalCopyArrayLayers","uniformBufferSize","uniformBufferData","Float32Array","i","uniformBuffer","makeBufferWithContents","UNIFORM","createBindGroup","resource","initializeDepthAspect","depthFormat","renderPipeline","depthWriteEnabled","depthCompare","bindGroup","hasStencil","srcCopyLayer","renderPass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","baseArrayLayer","arrayLayerCount","baseMipLevel","depthClearValue","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","setBindGroup","setPipeline","draw","end","verifyDepthAspect","outputColorTexture","RENDER_ATTACHMENT","dstCopyLayer","clearValue","r","g","b","a","loadOp","storeOp","expectSingleColor","exp","R","G","B","A","kCopyBoxOffsetsForWholeDepth","kCopyBoxOffsetsFor2DArrayTextures","test","desc","params","u","combine","filter","srcBaseFormat","dstBaseFormat","beginSubcases","expandWithParams","p","param","unless","fn","t","textureSizeInBlocks","srcBlockWidth","srcBlockHeight","dstBlockWidth","dstBlockHeight","paramsSubcasesOnly","combineWithParams","copyBoxOffset","skipIf","kColorFormat","kSampleCount","sampleCount","renderPipelineForInit","multisample","count","initEncoder","renderPassForInit","copyEncoder","renderPipelineForValidation","getBindGroupLayout","expectedOutputTexture","validationEncoder","renderPassForValidation","vertexState","encoderForInit","renderPipelineForVerify","multisampledColorTexture","colorTextureAsResolveTarget","encoderForVerify","renderPassForVerify","resolveTarget","unimplemented"],"sources":["../../../../../src/webgpu/api/operation/command_buffer/copyTextureToTexture.spec.ts"],"sourcesContent":["export const description = `copyTextureToTexture operation tests`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, ErrorWithExtra, memcpy } from '../../../../common/util/util.js';\nimport {\n  kBufferSizeAlignment,\n  kMinDynamicBufferOffsetAlignment,\n  kTextureDimensions,\n} from '../../../capability_info.js';\nimport {\n  ColorTextureFormat,\n  DepthStencilFormat,\n  depthStencilFormatAspectSize,\n  getBaseFormatForTextureFormat,\n  getBlockInfoForColorTextureFormat,\n  isCompressedTextureFormat,\n  isDepthTextureFormat,\n  isRegularTextureFormat,\n  isStencilTextureFormat,\n  kCompressedTextureFormats,\n  kDepthStencilFormats,\n  kRegularTextureFormats,\n  RegularTextureFormat,\n  textureFormatAndDimensionPossiblyCompatible,\n  textureFormatsAreViewCompatible,\n} from '../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport * as ttu from '../../../texture_test_utils.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\nimport { align } from '../../../util/math.js';\nimport { physicalMipSize } from '../../../util/texture/base.js';\nimport { DataArrayGenerator } from '../../../util/texture/data_generation.js';\nimport { kBytesPerRowAlignment, dataBytesForCopyOrFail } from '../../../util/texture/layout.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\nimport { findFailedPixels } from '../../../util/texture/texture_ok.js';\nimport { reifyExtent3D } from '../../../util/unions.js';\n\nconst dataGenerator = new DataArrayGenerator();\n\n// If a texture could be textureBindingViewDimension: 'cube' then set it to 'cube'\nfunction applyTextureBindingViewDimensionForTest(descriptor: GPUTextureDescriptor) {\n  const size = reifyExtent3D(descriptor.size);\n  if (\n    descriptor.textureBindingViewDimension === undefined &&\n    descriptor.dimension === '2d' &&\n    size.width === size.height &&\n    size.depthOrArrayLayers === 6\n  ) {\n    descriptor.textureBindingViewDimension = 'cube';\n  }\n  return descriptor;\n}\n\nclass F extends AllFeaturesMaxLimitsGPUTest {\n  getInitialDataPerMipLevel(\n    dimension: GPUTextureDimension,\n    textureSize: Required<GPUExtent3DDict>,\n    format: ColorTextureFormat,\n    mipLevel: number\n  ): Uint8Array {\n    const textureSizeAtLevel = physicalMipSize(textureSize, format, dimension, mipLevel);\n    const { bytesPerBlock, blockWidth, blockHeight } = getBlockInfoForColorTextureFormat(format);\n    const blocksPerSubresource =\n      (textureSizeAtLevel.width / blockWidth) * (textureSizeAtLevel.height / blockHeight);\n\n    const byteSize = bytesPerBlock * blocksPerSubresource * textureSizeAtLevel.depthOrArrayLayers;\n    return dataGenerator.generateView(byteSize);\n  }\n\n  getInitialStencilDataPerMipLevel(\n    textureSize: Required<GPUExtent3DDict>,\n    format: DepthStencilFormat,\n    mipLevel: number\n  ): Uint8Array {\n    const textureSizeAtLevel = physicalMipSize(textureSize, format, '2d', mipLevel);\n    const aspectBytesPerBlock = depthStencilFormatAspectSize(format, 'stencil-only');\n    const byteSize =\n      aspectBytesPerBlock *\n      textureSizeAtLevel.width *\n      textureSizeAtLevel.height *\n      textureSizeAtLevel.depthOrArrayLayers;\n    return dataGenerator.generateView(byteSize);\n  }\n\n  doCopyTextureToTextureTest(\n    dimension: GPUTextureDimension,\n    srcTextureSize: Required<GPUExtent3DDict>,\n    dstTextureSize: Required<GPUExtent3DDict>,\n    srcFormat: ColorTextureFormat,\n    dstFormat: ColorTextureFormat,\n    copyBoxOffsets: {\n      srcOffset: { x: number; y: number; z: number };\n      dstOffset: { x: number; y: number; z: number };\n      copyExtent: Required<GPUExtent3DDict>;\n    },\n    srcCopyLevel: number,\n    dstCopyLevel: number\n  ): void {\n    this.skipIfTextureFormatNotSupported(srcFormat, dstFormat);\n    this.skipIfCopyTextureToTextureNotSupportedForFormat(srcFormat, dstFormat);\n    this.skipIfTextureFormatAndDimensionNotCompatible(srcFormat, dimension);\n    this.skipIfTextureFormatAndDimensionNotCompatible(dstFormat, dimension);\n\n    // If we're in compatibility mode and it's a compressed texture\n    // then we need to render the texture to test the results of the copy.\n    const extraTextureUsageFlags =\n      isCompressedTextureFormat(dstFormat) && this.isCompatibility\n        ? GPUTextureUsage.TEXTURE_BINDING\n        : 0;\n    const mipLevelCount = dimension === '1d' ? 1 : 4;\n\n    // Create srcTexture and dstTexture\n    const srcTextureDesc: GPUTextureDescriptor = applyTextureBindingViewDimensionForTest({\n      dimension,\n      size: srcTextureSize,\n      format: srcFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      mipLevelCount,\n    });\n    const srcTexture = this.createTextureTracked(srcTextureDesc);\n    const dstTextureDesc: GPUTextureDescriptor = applyTextureBindingViewDimensionForTest({\n      dimension,\n      size: dstTextureSize,\n      format: dstFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | extraTextureUsageFlags,\n      mipLevelCount,\n    });\n    const dstTexture = this.createTextureTracked(dstTextureDesc);\n\n    // Fill the whole subresource of srcTexture at srcCopyLevel with initialSrcData.\n    const initialSrcData = this.getInitialDataPerMipLevel(\n      dimension,\n      srcTextureSize,\n      srcFormat,\n      srcCopyLevel\n    );\n    const srcTextureSizeAtLevel = physicalMipSize(\n      srcTextureSize,\n      srcFormat,\n      dimension,\n      srcCopyLevel\n    );\n    const { bytesPerBlock, blockWidth, blockHeight } = getBlockInfoForColorTextureFormat(srcFormat);\n    const srcBlocksPerRow = srcTextureSizeAtLevel.width / blockWidth;\n    const srcBlockRowsPerImage = srcTextureSizeAtLevel.height / blockHeight;\n    this.device.queue.writeTexture(\n      { texture: srcTexture, mipLevel: srcCopyLevel },\n      initialSrcData,\n      {\n        bytesPerRow: srcBlocksPerRow * bytesPerBlock,\n        rowsPerImage: srcBlockRowsPerImage,\n      },\n      srcTextureSizeAtLevel\n    );\n\n    // Copy the region specified by copyBoxOffsets from srcTexture to dstTexture.\n    const dstTextureSizeAtLevel = physicalMipSize(\n      dstTextureSize,\n      dstFormat,\n      dimension,\n      dstCopyLevel\n    );\n    const minWidth = Math.min(srcTextureSizeAtLevel.width, dstTextureSizeAtLevel.width);\n    const minHeight = Math.min(srcTextureSizeAtLevel.height, dstTextureSizeAtLevel.height);\n    const minDepth = Math.min(\n      srcTextureSizeAtLevel.depthOrArrayLayers,\n      dstTextureSizeAtLevel.depthOrArrayLayers\n    );\n\n    const appliedSrcOffset = {\n      x: Math.min(copyBoxOffsets.srcOffset.x * blockWidth, minWidth),\n      y: Math.min(copyBoxOffsets.srcOffset.y * blockHeight, minHeight),\n      z: Math.min(copyBoxOffsets.srcOffset.z, minDepth),\n    };\n    const appliedDstOffset = {\n      x: Math.min(copyBoxOffsets.dstOffset.x * blockWidth, minWidth),\n      y: Math.min(copyBoxOffsets.dstOffset.y * blockHeight, minHeight),\n      z: Math.min(copyBoxOffsets.dstOffset.z, minDepth),\n    };\n\n    const appliedCopyWidth = Math.max(\n      minWidth +\n        copyBoxOffsets.copyExtent.width * blockWidth -\n        Math.max(appliedSrcOffset.x, appliedDstOffset.x),\n      0\n    );\n    const appliedCopyHeight = Math.max(\n      minHeight +\n        copyBoxOffsets.copyExtent.height * blockHeight -\n        Math.max(appliedSrcOffset.y, appliedDstOffset.y),\n      0\n    );\n    assert(appliedCopyWidth % blockWidth === 0 && appliedCopyHeight % blockHeight === 0);\n\n    const appliedCopyDepth = Math.max(\n      0,\n      minDepth +\n        copyBoxOffsets.copyExtent.depthOrArrayLayers -\n        Math.max(appliedSrcOffset.z, appliedDstOffset.z)\n    );\n    assert(appliedCopyDepth >= 0);\n\n    const appliedSize = {\n      width: appliedCopyWidth,\n      height: appliedCopyHeight,\n      depthOrArrayLayers: appliedCopyDepth,\n    };\n\n    {\n      const encoder = this.device.createCommandEncoder();\n      encoder.copyTextureToTexture(\n        { texture: srcTexture, mipLevel: srcCopyLevel, origin: appliedSrcOffset },\n        { texture: dstTexture, mipLevel: dstCopyLevel, origin: appliedDstOffset },\n        appliedSize\n      );\n      this.device.queue.submit([encoder.finish()]);\n    }\n\n    const dstBlocksPerRow = dstTextureSizeAtLevel.width / blockWidth;\n    const dstBlockRowsPerImage = dstTextureSizeAtLevel.height / blockHeight;\n    const bytesPerDstAlignedBlockRow = align(dstBlocksPerRow * bytesPerBlock, 256);\n    const dstBufferSize =\n      (dstBlockRowsPerImage * dstTextureSizeAtLevel.depthOrArrayLayers - 1) *\n        bytesPerDstAlignedBlockRow +\n      align(dstBlocksPerRow * bytesPerBlock, 4);\n\n    if (isCompressedTextureFormat(dstTexture.format) && this.isCompatibility) {\n      assert(textureFormatsAreViewCompatible(this.device, srcFormat, dstFormat));\n      // compare by rendering. We need the expected texture to match\n      // the dstTexture so we'll create a texture where we supply\n      // all of the data in JavaScript.\n      const expectedTexture = this.createTextureTracked({\n        size: [dstTexture.width, dstTexture.height, dstTexture.depthOrArrayLayers],\n        mipLevelCount: dstTexture.mipLevelCount,\n        format: dstTexture.format,\n        usage: dstTexture.usage,\n      });\n      const expectedData = new Uint8Array(dstBufferSize);\n\n      // Execute the equivalent of `copyTextureToTexture`, copying\n      // from `initialSrcData` to `expectedData`.\n      ttu.updateLinearTextureDataSubBox(this, dstFormat, appliedSize, {\n        src: {\n          dataLayout: {\n            bytesPerRow: srcBlocksPerRow * bytesPerBlock,\n            rowsPerImage: srcBlockRowsPerImage,\n            offset: 0,\n          },\n          origin: appliedSrcOffset,\n          data: initialSrcData,\n        },\n        dest: {\n          dataLayout: {\n            bytesPerRow: dstBlocksPerRow * bytesPerBlock,\n            rowsPerImage: dstBlockRowsPerImage,\n            offset: 0,\n          },\n          origin: appliedDstOffset,\n          data: expectedData,\n        },\n      });\n\n      // Upload `expectedData` to `expectedTexture`. If `copyTextureToTexture`\n      // worked then the contents of `dstTexture` should match `expectedTexture`\n      this.queue.writeTexture(\n        { texture: expectedTexture, mipLevel: dstCopyLevel },\n        expectedData,\n        {\n          bytesPerRow: dstBlocksPerRow * bytesPerBlock,\n          rowsPerImage: dstBlockRowsPerImage,\n        },\n        dstTextureSizeAtLevel\n      );\n\n      ttu.expectTexturesToMatchByRendering(\n        this,\n        dstTexture,\n        expectedTexture,\n        dstCopyLevel,\n        appliedDstOffset,\n        appliedSize\n      );\n      return;\n    }\n\n    // Copy the whole content of dstTexture at dstCopyLevel to dstBuffer.\n    const dstBufferDesc: GPUBufferDescriptor = {\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    };\n    const dstBuffer = this.createBufferTracked(dstBufferDesc);\n\n    {\n      const encoder = this.device.createCommandEncoder();\n      encoder.copyTextureToBuffer(\n        { texture: dstTexture, mipLevel: dstCopyLevel },\n        {\n          buffer: dstBuffer,\n          bytesPerRow: bytesPerDstAlignedBlockRow,\n          rowsPerImage: dstBlockRowsPerImage,\n        },\n        dstTextureSizeAtLevel\n      );\n      this.device.queue.submit([encoder.finish()]);\n    }\n\n    // Fill expectedUint8DataWithPadding with the expected data of dstTexture. The other values in\n    // expectedUint8DataWithPadding are kept 0 to check if the texels untouched by the copy are 0\n    // (their previous values).\n    const expectedUint8DataWithPadding = new Uint8Array(dstBufferSize);\n    const expectedUint8Data = new Uint8Array(initialSrcData);\n\n    const appliedCopyBlocksPerRow = appliedCopyWidth / blockWidth;\n    const appliedCopyBlockRowsPerImage = appliedCopyHeight / blockHeight;\n    const srcCopyOffsetInBlocks = {\n      x: appliedSrcOffset.x / blockWidth,\n      y: appliedSrcOffset.y / blockHeight,\n      z: appliedSrcOffset.z,\n    };\n    const dstCopyOffsetInBlocks = {\n      x: appliedDstOffset.x / blockWidth,\n      y: appliedDstOffset.y / blockHeight,\n      z: appliedDstOffset.z,\n    };\n    const bytesInRow = appliedCopyBlocksPerRow * bytesPerBlock;\n\n    for (let z = 0; z < appliedCopyDepth; ++z) {\n      const srcOffsetZ = srcCopyOffsetInBlocks.z + z;\n      const dstOffsetZ = dstCopyOffsetInBlocks.z + z;\n      for (let y = 0; y < appliedCopyBlockRowsPerImage; ++y) {\n        const dstOffsetYInBlocks = dstCopyOffsetInBlocks.y + y;\n        const expectedDataWithPaddingOffset =\n          bytesPerDstAlignedBlockRow * (dstBlockRowsPerImage * dstOffsetZ + dstOffsetYInBlocks) +\n          dstCopyOffsetInBlocks.x * bytesPerBlock;\n\n        const srcOffsetYInBlocks = srcCopyOffsetInBlocks.y + y;\n        const expectedDataOffset =\n          bytesPerBlock *\n            srcBlocksPerRow *\n            (srcBlockRowsPerImage * srcOffsetZ + srcOffsetYInBlocks) +\n          srcCopyOffsetInBlocks.x * bytesPerBlock;\n\n        memcpy(\n          { src: expectedUint8Data, start: expectedDataOffset, length: bytesInRow },\n          { dst: expectedUint8DataWithPadding, start: expectedDataWithPaddingOffset }\n        );\n      }\n    }\n\n    if (isCompressedTextureFormat(dstFormat)) {\n      this.expectGPUBufferValuesPassCheck(\n        dstBuffer,\n        vals => checkElementsEqual(vals, expectedUint8DataWithPadding),\n        {\n          srcByteOffset: 0,\n          type: Uint8Array,\n          typedLength: expectedUint8DataWithPadding.length,\n        }\n      );\n      return;\n    }\n\n    assert(isRegularTextureFormat(dstFormat));\n    const regularDstFormat = dstFormat as RegularTextureFormat;\n\n    // Verify the content of the whole subresource of dstTexture at dstCopyLevel (in dstBuffer) is expected.\n    const checkByTextureFormat = (actual: Uint8Array) => {\n      const zero = { x: 0, y: 0, z: 0 };\n\n      const actTexelView = TexelView.fromTextureDataByReference(regularDstFormat, actual, {\n        bytesPerRow: bytesInRow,\n        rowsPerImage: dstBlockRowsPerImage,\n        subrectOrigin: zero,\n        subrectSize: dstTextureSizeAtLevel,\n      });\n      const expTexelView = TexelView.fromTextureDataByReference(\n        regularDstFormat,\n        expectedUint8DataWithPadding,\n        {\n          bytesPerRow: bytesInRow,\n          rowsPerImage: dstBlockRowsPerImage,\n          subrectOrigin: zero,\n          subrectSize: dstTextureSizeAtLevel,\n        }\n      );\n\n      const failedPixelsMessage = findFailedPixels(\n        regularDstFormat,\n        zero,\n        dstTextureSizeAtLevel,\n        { actTexelView, expTexelView },\n        {\n          maxFractionalDiff: 0,\n        }\n      );\n\n      if (failedPixelsMessage !== undefined) {\n        const msg = 'Texture level had unexpected contents:\\n' + failedPixelsMessage;\n        return new ErrorWithExtra(msg, () => ({\n          expTexelView,\n          actTexelView,\n        }));\n      }\n\n      return undefined;\n    };\n\n    this.expectGPUBufferValuesPassCheck(dstBuffer, checkByTextureFormat, {\n      srcByteOffset: 0,\n      type: Uint8Array,\n      typedLength: expectedUint8DataWithPadding.length,\n    });\n  }\n\n  initializeStencilAspect(\n    sourceTexture: GPUTexture,\n    initialStencilData: Uint8Array,\n    srcCopyLevel: number,\n    srcCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    this.queue.writeTexture(\n      {\n        texture: sourceTexture,\n        mipLevel: srcCopyLevel,\n        aspect: 'stencil-only',\n        origin: { x: 0, y: 0, z: srcCopyBaseArrayLayer },\n      },\n      initialStencilData,\n      { bytesPerRow: copySize[0], rowsPerImage: copySize[1] },\n      copySize\n    );\n  }\n\n  verifyStencilAspect(\n    destinationTexture: GPUTexture,\n    initialStencilData: Uint8Array,\n    dstCopyLevel: number,\n    dstCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    const bytesPerRow = align(copySize[0], kBytesPerRowAlignment);\n    const rowsPerImage = copySize[1];\n    const outputBufferSize = align(\n      dataBytesForCopyOrFail({\n        layout: { bytesPerRow, rowsPerImage },\n        format: 'stencil8',\n        copySize,\n        method: 'CopyT2B',\n      }),\n      kBufferSizeAlignment\n    );\n    const outputBuffer = this.createBufferTracked({\n      size: outputBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      {\n        texture: destinationTexture,\n        aspect: 'stencil-only',\n        mipLevel: dstCopyLevel,\n        origin: { x: 0, y: 0, z: dstCopyBaseArrayLayer },\n      },\n      { buffer: outputBuffer, bytesPerRow, rowsPerImage },\n      copySize\n    );\n    this.queue.submit([encoder.finish()]);\n\n    const expectedStencilData = new Uint8Array(outputBufferSize);\n    for (let z = 0; z < copySize[2]; ++z) {\n      const initialOffsetPerLayer = z * copySize[0] * copySize[1];\n      const expectedOffsetPerLayer = z * bytesPerRow * rowsPerImage;\n      for (let y = 0; y < copySize[1]; ++y) {\n        const initialOffsetPerRow = initialOffsetPerLayer + y * copySize[0];\n        const expectedOffsetPerRow = expectedOffsetPerLayer + y * bytesPerRow;\n        memcpy(\n          { src: initialStencilData, start: initialOffsetPerRow, length: copySize[0] },\n          { dst: expectedStencilData, start: expectedOffsetPerRow }\n        );\n      }\n    }\n    this.expectGPUBufferValuesEqual(outputBuffer, expectedStencilData);\n  }\n\n  getRenderPipelineForT2TCopyWithDepthTests(\n    bindGroupLayout: GPUBindGroupLayout,\n    hasColorAttachment: boolean,\n    depthStencil: GPUDepthStencilState\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: this.device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            struct Params {\n              copyLayer: f32\n            };\n            @group(0) @binding(0) var<uniform> param: Params;\n            @vertex\n            fn main(@builtin(vertex_index) VertexIndex : u32)-> @builtin(position) vec4<f32> {\n              var depthValue = 0.5 + 0.2 * sin(param.copyLayer);\n              var pos : array<vec3<f32>, 6> = array<vec3<f32>, 6>(\n                  vec3<f32>(-1.0,  1.0, depthValue),\n                  vec3<f32>(-1.0, -1.0, 0.0),\n                  vec3<f32>( 1.0,  1.0, 1.0),\n                  vec3<f32>(-1.0, -1.0, 0.0),\n                  vec3<f32>( 1.0,  1.0, 1.0),\n                  vec3<f32>( 1.0, -1.0, depthValue));\n              return vec4<f32>(pos[VertexIndex], 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      depthStencil,\n    };\n    if (hasColorAttachment) {\n      renderPipelineDescriptor.fragment = {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment\n            fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      };\n    }\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  getBindGroupLayoutForT2TCopyWithDepthTests(): GPUBindGroupLayout {\n    return this.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX,\n          buffer: {\n            type: 'uniform',\n            minBindingSize: 4,\n            hasDynamicOffset: true,\n          },\n        },\n      ],\n    });\n  }\n\n  getBindGroupForT2TCopyWithDepthTests(\n    bindGroupLayout: GPUBindGroupLayout,\n    totalCopyArrayLayers: number\n  ): GPUBindGroup {\n    // Prepare the uniform buffer that contains all the copy layers to generate different depth\n    // values for different copy layers.\n    assert(totalCopyArrayLayers > 0);\n    const uniformBufferSize = kMinDynamicBufferOffsetAlignment * (totalCopyArrayLayers - 1) + 4;\n    const uniformBufferData = new Float32Array(uniformBufferSize / 4);\n    for (let i = 1; i < totalCopyArrayLayers; ++i) {\n      uniformBufferData[(kMinDynamicBufferOffsetAlignment / 4) * i] = i;\n    }\n    const uniformBuffer = this.makeBufferWithContents(\n      uniformBufferData,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n    );\n    return this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n            size: 4,\n          },\n        },\n      ],\n    });\n  }\n\n  /** Initialize the depth aspect of sourceTexture with draw calls */\n  initializeDepthAspect(\n    sourceTexture: GPUTexture,\n    depthFormat: GPUTextureFormat,\n    srcCopyLevel: number,\n    srcCopyBaseArrayLayer: number,\n    copySize: readonly [number, number, number]\n  ): void {\n    // Prepare a renderPipeline with depthCompareFunction == 'always' and depthWriteEnabled == true\n    // for the initializations of the depth attachment.\n    const bindGroupLayout = this.getBindGroupLayoutForT2TCopyWithDepthTests();\n    const renderPipeline = this.getRenderPipelineForT2TCopyWithDepthTests(bindGroupLayout, false, {\n      format: depthFormat,\n      depthWriteEnabled: true,\n      depthCompare: 'always',\n    });\n    const bindGroup = this.getBindGroupForT2TCopyWithDepthTests(bindGroupLayout, copySize[2]);\n\n    const hasStencil = isStencilTextureFormat(sourceTexture.format);\n    const encoder = this.device.createCommandEncoder();\n    for (let srcCopyLayer = 0; srcCopyLayer < copySize[2]; ++srcCopyLayer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [],\n        depthStencilAttachment: {\n          view: sourceTexture.createView({\n            baseArrayLayer: srcCopyLayer + srcCopyBaseArrayLayer,\n            arrayLayerCount: 1,\n            baseMipLevel: srcCopyLevel,\n            mipLevelCount: 1,\n          }),\n          depthClearValue: 0.0,\n          depthLoadOp: 'clear',\n          depthStoreOp: 'store',\n          stencilLoadOp: hasStencil ? 'load' : undefined,\n          stencilStoreOp: hasStencil ? 'store' : undefined,\n        },\n      });\n      renderPass.setBindGroup(0, bindGroup, [srcCopyLayer * kMinDynamicBufferOffsetAlignment]);\n      renderPass.setPipeline(renderPipeline);\n      renderPass.draw(6);\n      renderPass.end();\n    }\n    this.queue.submit([encoder.finish()]);\n  }\n\n  verifyDepthAspect(\n    destinationTexture: GPUTexture,\n    depthFormat: GPUTextureFormat,\n    dstCopyLevel: number,\n    dstCopyBaseArrayLayer: number,\n    copySize: [number, number, number]\n  ): void {\n    // Prepare a renderPipeline with depthCompareFunction == 'equal' and depthWriteEnabled == false\n    // for the comparison of the depth attachment.\n    const bindGroupLayout = this.getBindGroupLayoutForT2TCopyWithDepthTests();\n    const renderPipeline = this.getRenderPipelineForT2TCopyWithDepthTests(bindGroupLayout, true, {\n      format: depthFormat,\n      depthWriteEnabled: false,\n      depthCompare: 'equal',\n    });\n    const bindGroup = this.getBindGroupForT2TCopyWithDepthTests(bindGroupLayout, copySize[2]);\n\n    const outputColorTexture = this.createTextureTracked({\n      format: 'rgba8unorm',\n      size: copySize,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n    const hasStencil = isStencilTextureFormat(destinationTexture.format);\n    const encoder = this.device.createCommandEncoder();\n    for (let dstCopyLayer = 0; dstCopyLayer < copySize[2]; ++dstCopyLayer) {\n      // If the depth value is not expected, the color of outputColorTexture will remain Red after\n      // the render pass.\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: outputColorTexture.createView({\n              baseArrayLayer: dstCopyLayer,\n              arrayLayerCount: 1,\n            }),\n            clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n        depthStencilAttachment: {\n          view: destinationTexture.createView({\n            baseArrayLayer: dstCopyLayer + dstCopyBaseArrayLayer,\n            arrayLayerCount: 1,\n            baseMipLevel: dstCopyLevel,\n            mipLevelCount: 1,\n          }),\n          depthLoadOp: 'load',\n          depthStoreOp: 'store',\n          stencilLoadOp: hasStencil ? 'load' : undefined,\n          stencilStoreOp: hasStencil ? 'store' : undefined,\n        },\n      });\n      renderPass.setBindGroup(0, bindGroup, [dstCopyLayer * kMinDynamicBufferOffsetAlignment]);\n      renderPass.setPipeline(renderPipeline);\n      renderPass.draw(6);\n      renderPass.end();\n    }\n    this.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(outputColorTexture, 'rgba8unorm', {\n      size: copySize,\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  }\n}\n\nconst kCopyBoxOffsetsForWholeDepth = [\n  // From (0, 0) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, 0) of src to (blockWidth, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 1, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, 0) of src to (0, blockHeight) of dst.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 1, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (blockWidth, 0) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 1, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, blockHeight) of src to (0, 0) of dst.\n  {\n    srcOffset: { x: 0, y: 1, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (blockWidth, 0) of src to (0, 0) of dst, and the copy extent will not cover the last\n  // texel block column of both source and destination texture.\n  {\n    srcOffset: { x: 1, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: -1, height: 0, depthOrArrayLayers: 0 },\n  },\n  // From (0, blockHeight) of src to (0, 0) of dst, and the copy extent will not cover the last\n  // texel block row of both source and destination texture.\n  {\n    srcOffset: { x: 0, y: 1, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: -1, depthOrArrayLayers: 0 },\n  },\n] as const;\n\nconst kCopyBoxOffsetsFor2DArrayTextures = [\n  // Copy the whole array slices from the source texture to the destination texture.\n  // The copy extent will cover the whole subresource of either source or the\n  // destination texture\n  ...kCopyBoxOffsetsForWholeDepth,\n\n  // Copy 1 texture slice from the 1st slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -2 },\n  },\n  // Copy 1 texture slice from the 2nd slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -3 },\n  },\n  // Copy 1 texture slice from the 1st slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n  // Copy 1 texture slice from the 2nd slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n  // Copy 2 texture slices from the 1st slice of the source texture to the 1st slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 0 },\n    dstOffset: { x: 0, y: 0, z: 0 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -3 },\n  },\n  // Copy 3 texture slices from the 2nd slice of the source texture to the 2nd slice of the\n  // destination texture.\n  {\n    srcOffset: { x: 0, y: 0, z: 1 },\n    dstOffset: { x: 0, y: 0, z: 1 },\n    copyExtent: { width: 0, height: 0, depthOrArrayLayers: -1 },\n  },\n] as const;\n\nexport const g = makeTestGroup(F);\n\ng.test('color_textures,non_compressed,non_array')\n  .desc(\n    `\n  Validate the correctness of the copy by filling the srcTexture with testable data and any\n  non-compressed color format supported by WebGPU, doing CopyTextureToTexture() copy, and verifying\n  the content of the whole dstTexture.\n\n  Copy {1 texel block, part of, the whole} srcTexture to the dstTexture {with, without} a non-zero\n  valid srcOffset that\n  - covers the whole dstTexture subresource\n  - covers the corners of the dstTexture\n  - doesn't cover any texels that are on the edge of the dstTexture\n  - covers the mipmap level > 0\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kRegularTextureFormats)\n      .combine('dstFormat', kRegularTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = getBaseFormatForTextureFormat(srcFormat);\n        const dstBaseFormat = getBaseFormatForTextureFormat(dstFormat);\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', kTextureDimensions)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureFormatAndDimensionPossiblyCompatible(dimension, srcFormat) &&\n          textureFormatAndDimensionPossiblyCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .expandWithParams(p => {\n        const params = [\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 31, height: 33, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 31, height: 33, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 64, height: 64, depthOrArrayLayers: 1 },\n          },\n          {\n            srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 1 },\n            dstTextureSize: { width: 63, height: 61, depthOrArrayLayers: 1 },\n          },\n        ];\n        if (p.dimension === '1d') {\n          for (const param of params) {\n            param.srcTextureSize.height = 1;\n            param.dstTextureSize.height = 1;\n          }\n        }\n\n        return params;\n      })\n      .combine('copyBoxOffsets', kCopyBoxOffsetsForWholeDepth)\n      .unless(\n        p =>\n          p.dimension === '1d' &&\n          (p.copyBoxOffsets.copyExtent.height !== 0 ||\n            p.copyBoxOffsets.srcOffset.y !== 0 ||\n            p.copyBoxOffsets.dstOffset.y !== 0)\n      )\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n      .unless(p => p.dimension === '1d' && (p.srcCopyLevel !== 0 || p.dstCopyLevel !== 0))\n  )\n  .fn(t => {\n    const {\n      dimension,\n      srcTextureSize,\n      dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n\n    t.doCopyTextureToTextureTest(\n      dimension,\n      srcTextureSize,\n      dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,compressed,non_array')\n  .desc(\n    `\n  Validate the correctness of the copy by filling the srcTexture with testable data and any\n  compressed color format supported by WebGPU, doing CopyTextureToTexture() copy, and verifying\n  the content of the whole dstTexture.\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kCompressedTextureFormats)\n      .combine('dstFormat', kCompressedTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = getBaseFormatForTextureFormat(srcFormat);\n        const dstBaseFormat = getBaseFormatForTextureFormat(dstFormat);\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', kTextureDimensions)\n      .beginSubcases()\n      .combine('textureSizeInBlocks', [\n        // The heights and widths in blocks are all power of 2\n        { src: { width: 16, height: 8 }, dst: { width: 16, height: 8 } },\n        // The virtual width of the source texture at mipmap level 2 (15) is not a multiple of 4 blocks\n        { src: { width: 15, height: 8 }, dst: { width: 16, height: 8 } },\n        // The virtual width of the destination texture at mipmap level 2 (15) is not a multiple\n        // of 4 blocks\n        { src: { width: 16, height: 8 }, dst: { width: 15, height: 8 } },\n        // The virtual height of the source texture at mipmap level 2 (13) is not a multiple of 4 blocks\n        { src: { width: 16, height: 13 }, dst: { width: 16, height: 8 } },\n        // The virtual height of the destination texture at mipmap level 2 (13) is not a\n        // multiple of 4 blocks\n        { src: { width: 16, height: 8 }, dst: { width: 16, height: 13 } },\n        // None of the widths or heights in blocks are power of 2\n        { src: { width: 15, height: 13 }, dst: { width: 15, height: 13 } },\n      ])\n      .combine('copyBoxOffsets', kCopyBoxOffsetsForWholeDepth)\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n  )\n  .fn(t => {\n    const {\n      dimension,\n      textureSizeInBlocks,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n    t.skipIfTextureFormatAndDimensionNotCompatible(srcFormat, dimension);\n    t.skipIfTextureFormatAndDimensionNotCompatible(dstFormat, dimension);\n    t.skipIfCopyTextureToTextureNotSupportedForFormat(srcFormat, dstFormat);\n    const { blockWidth: srcBlockWidth, blockHeight: srcBlockHeight } =\n      getBlockInfoForColorTextureFormat(srcFormat);\n    const { blockWidth: dstBlockWidth, blockHeight: dstBlockHeight } =\n      getBlockInfoForColorTextureFormat(dstFormat);\n\n    t.doCopyTextureToTextureTest(\n      dimension,\n      {\n        width: textureSizeInBlocks.src.width * srcBlockWidth,\n        height: textureSizeInBlocks.src.height * srcBlockHeight,\n        depthOrArrayLayers: 1,\n      },\n      {\n        width: textureSizeInBlocks.dst.width * dstBlockWidth,\n        height: textureSizeInBlocks.dst.height * dstBlockHeight,\n        depthOrArrayLayers: 1,\n      },\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,non_compressed,array')\n  .desc(\n    `\n  Validate the correctness of the texture-to-texture copy on 2D array textures by filling the\n  srcTexture with testable data and any non-compressed color format supported by WebGPU, doing\n  CopyTextureToTexture() copy, and verifying the content of the whole dstTexture.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kRegularTextureFormats)\n      .combine('dstFormat', kRegularTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = getBaseFormatForTextureFormat(srcFormat);\n        const dstBaseFormat = getBaseFormatForTextureFormat(dstFormat);\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', ['2d', '3d'] as const)\n      .filter(\n        ({ dimension, srcFormat, dstFormat }) =>\n          textureFormatAndDimensionPossiblyCompatible(dimension, srcFormat) &&\n          textureFormatAndDimensionPossiblyCompatible(dimension, dstFormat)\n      )\n      .beginSubcases()\n      .combine('textureSize', [\n        {\n          srcTextureSize: { width: 64, height: 32, depthOrArrayLayers: 5 },\n          dstTextureSize: { width: 64, height: 32, depthOrArrayLayers: 5 },\n        },\n        {\n          srcTextureSize: { width: 31, height: 33, depthOrArrayLayers: 5 },\n          dstTextureSize: { width: 31, height: 33, depthOrArrayLayers: 5 },\n        },\n        {\n          srcTextureSize: { width: 31, height: 32, depthOrArrayLayers: 33 },\n          dstTextureSize: { width: 31, height: 32, depthOrArrayLayers: 33 },\n        },\n        // Maybe used with textureBindingViewDimension: 'cube'\n        {\n          srcTextureSize: { width: 32, height: 32, depthOrArrayLayers: 6 },\n          dstTextureSize: { width: 32, height: 32, depthOrArrayLayers: 6 },\n        },\n      ])\n      .combine('copyBoxOffsets', kCopyBoxOffsetsFor2DArrayTextures)\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n  )\n  .fn(t => {\n    const {\n      dimension,\n      textureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n\n    t.doCopyTextureToTextureTest(\n      dimension,\n      textureSize.srcTextureSize,\n      textureSize.dstTextureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('color_textures,compressed,array')\n  .desc(\n    `\n  Validate the correctness of the texture-to-texture copy on 2D array textures by filling the\n  srcTexture with testable data and any compressed color format supported by WebGPU, doing\n  CopyTextureToTexture() copy, and verifying the content of the whole dstTexture.\n\n  Tests for all pairs of valid source/destination formats, and all texture dimensions.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcFormat', kCompressedTextureFormats)\n      .combine('dstFormat', kCompressedTextureFormats)\n      .filter(({ srcFormat, dstFormat }) => {\n        const srcBaseFormat = getBaseFormatForTextureFormat(srcFormat);\n        const dstBaseFormat = getBaseFormatForTextureFormat(dstFormat);\n        return (\n          srcFormat === dstFormat ||\n          (srcBaseFormat !== undefined &&\n            dstBaseFormat !== undefined &&\n            srcBaseFormat === dstBaseFormat)\n        );\n      })\n      .combine('dimension', ['2d', '3d'] as const)\n      .beginSubcases()\n      .combine('textureSizeInBlocks', [\n        // The heights and widths in blocks are all power of 2\n        { src: { width: 2, height: 2 }, dst: { width: 2, height: 2 } },\n        // None of the widths or heights in blocks are power of 2\n        { src: { width: 15, height: 13 }, dst: { width: 15, height: 13 } },\n      ])\n      .combine('copyBoxOffsets', kCopyBoxOffsetsFor2DArrayTextures)\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n  )\n  .fn(t => {\n    const {\n      dimension,\n      textureSizeInBlocks,\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel,\n    } = t.params;\n    const { blockWidth: srcBlockWidth, blockHeight: srcBlockHeight } =\n      getBlockInfoForColorTextureFormat(srcFormat);\n    const { blockWidth: dstBlockWidth, blockHeight: dstBlockHeight } =\n      getBlockInfoForColorTextureFormat(dstFormat);\n\n    t.doCopyTextureToTextureTest(\n      dimension,\n      {\n        width: textureSizeInBlocks.src.width * srcBlockWidth,\n        height: textureSizeInBlocks.src.height * srcBlockHeight,\n        depthOrArrayLayers: 5,\n      },\n      {\n        width: textureSizeInBlocks.dst.width * dstBlockWidth,\n        height: textureSizeInBlocks.dst.height * dstBlockHeight,\n        depthOrArrayLayers: 5,\n      },\n      srcFormat,\n      dstFormat,\n      copyBoxOffsets,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('zero_sized')\n  .desc(\n    `\n  Validate the correctness of zero-sized copies (should be no-ops).\n\n  - For each texture dimension.\n  - Copies that are zero-sized in only one dimension {x, y, z}, each touching the {lower, upper} end\n  of that dimension.\n  `\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combineWithParams([\n        { dimension: '1d', textureSize: { width: 32, height: 1, depthOrArrayLayers: 1 } },\n        { dimension: '2d', textureSize: { width: 32, height: 32, depthOrArrayLayers: 5 } },\n        { dimension: '3d', textureSize: { width: 32, height: 32, depthOrArrayLayers: 5 } },\n      ] as const)\n      .combine('copyBoxOffset', [\n        // copyExtent.width === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.width === 0 && srcOffset.x === textureWidth\n        {\n          srcOffset: { x: 64, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.width === 0 && dstOffset.x === textureWidth\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 64, y: 0, z: 0 },\n          copyExtent: { width: -64, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0 && srcOffset.y === textureHeight\n        {\n          srcOffset: { x: 0, y: 32, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.height === 0 && dstOffset.y === textureHeight\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 32, z: 0 },\n          copyExtent: { width: 0, height: -32, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.depthOrArrayLayers === 0\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: -5 },\n        },\n        // copyExtent.depthOrArrayLayers === 0 && srcOffset.z === textureDepth\n        {\n          srcOffset: { x: 0, y: 0, z: 5 },\n          dstOffset: { x: 0, y: 0, z: 0 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n        },\n        // copyExtent.depthOrArrayLayers === 0 && dstOffset.z === textureDepth\n        {\n          srcOffset: { x: 0, y: 0, z: 0 },\n          dstOffset: { x: 0, y: 0, z: 5 },\n          copyExtent: { width: 0, height: 0, depthOrArrayLayers: 0 },\n        },\n      ])\n      .unless(\n        p =>\n          p.dimension === '1d' &&\n          (p.copyBoxOffset.copyExtent.height !== 0 ||\n            p.copyBoxOffset.srcOffset.y !== 0 ||\n            p.copyBoxOffset.dstOffset.y !== 0)\n      )\n      .combine('srcCopyLevel', [0, 3])\n      .combine('dstCopyLevel', [0, 3])\n      .unless(p => p.dimension === '1d' && (p.srcCopyLevel !== 0 || p.dstCopyLevel !== 0))\n  )\n  .fn(t => {\n    const { dimension, textureSize, copyBoxOffset, srcCopyLevel, dstCopyLevel } = t.params;\n\n    const srcFormat = 'rgba8unorm';\n    const dstFormat = 'rgba8unorm';\n\n    t.doCopyTextureToTextureTest(\n      dimension,\n      textureSize,\n      textureSize,\n      srcFormat,\n      dstFormat,\n      copyBoxOffset,\n      srcCopyLevel,\n      dstCopyLevel\n    );\n  });\n\ng.test('copy_depth_stencil')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with depth and stencil aspect.\n\n  For all the texture formats with stencil aspect:\n  - Initialize the stencil aspect of the source texture with writeTexture().\n  - Copy the stencil aspect from the source texture into the destination texture\n  - Copy the stencil aspect of the destination texture into another staging buffer and check its\n    content\n  - Test the copies from / into zero / non-zero array layer / mipmap levels\n  - Test copying multiple array layers\n\n  For all the texture formats with depth aspect:\n  - Initialize the depth aspect of the source texture with a draw call\n  - Copy the depth aspect from the source texture into the destination texture\n  - Validate the content in the destination texture with the depth comparison function 'equal'\n  `\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      .beginSubcases()\n      .combine('srcTextureSize', [\n        { width: 32, height: 16, depthOrArrayLayers: 1 },\n        { width: 32, height: 16, depthOrArrayLayers: 4 },\n        { width: 24, height: 48, depthOrArrayLayers: 5 },\n      ])\n      .combine('srcCopyLevel', [0, 2])\n      .combine('dstCopyLevel', [0, 2])\n      .combine('srcCopyBaseArrayLayer', [0, 1])\n      .combine('dstCopyBaseArrayLayer', [0, 1])\n      .filter(t => {\n        return (\n          t.srcTextureSize.depthOrArrayLayers > t.srcCopyBaseArrayLayer &&\n          t.srcTextureSize.depthOrArrayLayers > t.dstCopyBaseArrayLayer\n        );\n      })\n  )\n  .fn(t => {\n    const {\n      format,\n      srcTextureSize,\n      srcCopyLevel,\n      dstCopyLevel,\n      srcCopyBaseArrayLayer,\n      dstCopyBaseArrayLayer,\n    } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n\n    const copySize: [number, number, number] = [\n      srcTextureSize.width >> srcCopyLevel,\n      srcTextureSize.height >> srcCopyLevel,\n      srcTextureSize.depthOrArrayLayers - Math.max(srcCopyBaseArrayLayer, dstCopyBaseArrayLayer),\n    ];\n    const sourceTexture = t.createTextureTracked({\n      format,\n      size: srcTextureSize,\n      usage:\n        GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n      mipLevelCount: srcCopyLevel + 1,\n    });\n    const destinationTexture = t.createTextureTracked({\n      format,\n      size: [\n        copySize[0] << dstCopyLevel,\n        copySize[1] << dstCopyLevel,\n        srcTextureSize.depthOrArrayLayers,\n      ] as const,\n      usage:\n        GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n      mipLevelCount: dstCopyLevel + 1,\n    });\n\n    let initialStencilData: undefined | Uint8Array = undefined;\n    if (isStencilTextureFormat(format)) {\n      initialStencilData = t.getInitialStencilDataPerMipLevel(srcTextureSize, format, srcCopyLevel);\n      t.initializeStencilAspect(\n        sourceTexture,\n        initialStencilData,\n        srcCopyLevel,\n        srcCopyBaseArrayLayer,\n        copySize\n      );\n    }\n    if (isDepthTextureFormat(format)) {\n      t.initializeDepthAspect(sourceTexture, format, srcCopyLevel, srcCopyBaseArrayLayer, copySize);\n    }\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n        mipLevel: srcCopyLevel,\n        origin: { x: 0, y: 0, z: srcCopyBaseArrayLayer },\n      },\n      {\n        texture: destinationTexture,\n        mipLevel: dstCopyLevel,\n        origin: { x: 0, y: 0, z: dstCopyBaseArrayLayer },\n      },\n      copySize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    if (isStencilTextureFormat(format)) {\n      assert(initialStencilData !== undefined);\n      t.verifyStencilAspect(\n        destinationTexture,\n        initialStencilData,\n        dstCopyLevel,\n        dstCopyBaseArrayLayer,\n        copySize\n      );\n    }\n    if (isDepthTextureFormat(format)) {\n      t.verifyDepthAspect(\n        destinationTexture,\n        format,\n        dstCopyLevel,\n        dstCopyBaseArrayLayer,\n        copySize\n      );\n    }\n  });\n\ng.test('copy_multisampled_color')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with multisampled color formats.\n\n  - Initialize the source texture with a triangle in a render pass.\n  - Copy from the source texture into the destination texture with CopyTextureToTexture().\n  - Compare every sub-pixel of source texture and destination texture in another render pass:\n    - If they are different, then output RED; otherwise output GREEN\n  - Verify the pixels in the output texture are all GREEN.\n  - Note that in current WebGPU SPEC the mipmap level count and array layer count of a multisampled\n    texture can only be 1.\n  `\n  )\n  .fn(t => {\n    t.skipIf(t.isCompatibility, 'multisample textures are not copyable in compatibility mode');\n    const textureSize = [32, 16, 1] as const;\n    const kColorFormat = 'rgba8unorm';\n    const kSampleCount = 4;\n\n    const sourceTexture = t.createTextureTracked({\n      format: kColorFormat,\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    const destinationTexture = t.createTextureTracked({\n      format: kColorFormat,\n      size: textureSize,\n      usage:\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n\n    // Initialize sourceTexture with a draw call.\n    const renderPipelineForInit = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            @vertex\n            fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n              var pos = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0),\n                  vec2<f32>( 1.0, -1.0)\n              );\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            @fragment\n            fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.3, 0.5, 0.8, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n    const initEncoder = t.device.createCommandEncoder();\n    const renderPassForInit = initEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: sourceTexture.createView(),\n          clearValue: [1.0, 0.0, 0.0, 1.0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPassForInit.setPipeline(renderPipelineForInit);\n    renderPassForInit.draw(3);\n    renderPassForInit.end();\n    t.queue.submit([initEncoder.finish()]);\n\n    // Do the texture-to-texture copy\n    const copyEncoder = t.device.createCommandEncoder();\n    copyEncoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n      },\n      {\n        texture: destinationTexture,\n      },\n      textureSize\n    );\n    t.queue.submit([copyEncoder.finish()]);\n\n    // Verify if all the sub-pixel values at the same location of sourceTexture and\n    // destinationTexture are equal.\n    const renderPipelineForValidation = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n            var pos = array<vec2<f32>, 6>(\n              vec2<f32>(-1.0,  1.0),\n              vec2<f32>(-1.0, -1.0),\n              vec2<f32>( 1.0,  1.0),\n              vec2<f32>(-1.0, -1.0),\n              vec2<f32>( 1.0,  1.0),\n              vec2<f32>( 1.0, -1.0));\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var sourceTexture : texture_multisampled_2d<f32>;\n          @group(0) @binding(1) var destinationTexture : texture_multisampled_2d<f32>;\n          @fragment\n          fn main(@builtin(position) coord_in: vec4<f32>) -> @location(0) vec4<f32> {\n            var coord_in_vec2 = vec2<i32>(i32(coord_in.x), i32(coord_in.y));\n            for (var sampleIndex = 0; sampleIndex < ${kSampleCount};\n              sampleIndex = sampleIndex + 1) {\n              var sourceSubPixel : vec4<f32> =\n                textureLoad(sourceTexture, coord_in_vec2, sampleIndex);\n              var destinationSubPixel : vec4<f32> =\n                textureLoad(destinationTexture, coord_in_vec2, sampleIndex);\n              if (!all(sourceSubPixel == destinationSubPixel)) {\n                return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n              }\n            }\n            return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n    });\n    const bindGroup = t.device.createBindGroup({\n      layout: renderPipelineForValidation.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sourceTexture.createView(),\n        },\n        {\n          binding: 1,\n          resource: destinationTexture.createView(),\n        },\n      ],\n    });\n    const expectedOutputTexture = t.createTextureTracked({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const validationEncoder = t.device.createCommandEncoder();\n    const renderPassForValidation = validationEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: expectedOutputTexture.createView(),\n          clearValue: [1.0, 0.0, 0.0, 1.0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPassForValidation.setPipeline(renderPipelineForValidation);\n    renderPassForValidation.setBindGroup(0, bindGroup);\n    renderPassForValidation.draw(6);\n    renderPassForValidation.end();\n    t.queue.submit([validationEncoder.finish()]);\n\n    t.expectSingleColor(expectedOutputTexture, 'rgba8unorm', {\n      size: [textureSize[0], textureSize[1], textureSize[2]],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  });\n\ng.test('copy_multisampled_depth')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with multisampled depth formats.\n\n  - Initialize the source texture with a triangle in a render pass.\n  - Copy from the source texture into the destination texture with CopyTextureToTexture().\n  - Validate the content in the destination texture with the depth comparison function 'equal'.\n  - Note that in current WebGPU SPEC the mipmap level count and array layer count of a multisampled\n    texture can only be 1.\n  `\n  )\n  .params(u =>\n    u.combine('format', kDepthStencilFormats).filter(t => isDepthTextureFormat(t.format))\n  )\n  .fn(t => {\n    const { format } = t.params;\n\n    t.skipIf(t.isCompatibility, 'multisample textures are not copyable in compatibility mode');\n    t.skipIfTextureFormatNotSupported(format);\n\n    const textureSize = [32, 16, 1] as const;\n    const kSampleCount = 4;\n\n    const sourceTexture = t.createTextureTracked({\n      format,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    const destinationTexture = t.createTextureTracked({\n      format,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n\n    const vertexState: GPUVertexState = {\n      module: t.device.createShaderModule({\n        code: `\n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32)-> @builtin(position) vec4<f32> {\n            var pos : array<vec3<f32>, 6> = array<vec3<f32>, 6>(\n                vec3<f32>(-1.0,  1.0, 0.5),\n                vec3<f32>(-1.0, -1.0, 0.0),\n                vec3<f32>( 1.0,  1.0, 1.0),\n                vec3<f32>(-1.0, -1.0, 0.0),\n                vec3<f32>( 1.0,  1.0, 1.0),\n                vec3<f32>( 1.0, -1.0, 0.5));\n            return vec4<f32>(pos[VertexIndex], 1.0);\n          }`,\n      }),\n      entryPoint: 'main',\n    };\n\n    // Initialize the depth aspect of source texture with a draw call\n    const renderPipelineForInit = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: vertexState,\n      depthStencil: {\n        format,\n        depthCompare: 'always',\n        depthWriteEnabled: true,\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n\n    const encoderForInit = t.device.createCommandEncoder();\n    const renderPassForInit = encoderForInit.beginRenderPass({\n      colorAttachments: [],\n      depthStencilAttachment: {\n        view: sourceTexture.createView(),\n        depthClearValue: 0.0,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        ...(isStencilTextureFormat(format) && {\n          stencilLoadOp: 'clear',\n          stencilStoreOp: 'store',\n        }),\n      },\n    });\n    renderPassForInit.setPipeline(renderPipelineForInit);\n    renderPassForInit.draw(6);\n    renderPassForInit.end();\n    t.queue.submit([encoderForInit.finish()]);\n\n    // Do the texture-to-texture copy\n    const copyEncoder = t.device.createCommandEncoder();\n    copyEncoder.copyTextureToTexture(\n      {\n        texture: sourceTexture,\n      },\n      {\n        texture: destinationTexture,\n      },\n      textureSize\n    );\n    t.queue.submit([copyEncoder.finish()]);\n\n    // Verify the depth values in destinationTexture are what we expected with\n    // depthCompareFunction == 'equal' and depthWriteEnabled == false in the render pipeline\n    const kColorFormat = 'rgba8unorm';\n    const renderPipelineForVerify = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: vertexState,\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n          @fragment\n          fn main() -> @location(0) vec4<f32> {\n            return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: kColorFormat }],\n      },\n      depthStencil: {\n        format,\n        depthCompare: 'equal',\n        depthWriteEnabled: false,\n      },\n      multisample: {\n        count: kSampleCount,\n      },\n    });\n    const multisampledColorTexture = t.createTextureTracked({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: kSampleCount,\n    });\n    const colorTextureAsResolveTarget = t.createTextureTracked({\n      format: kColorFormat,\n      size: textureSize,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoderForVerify = t.device.createCommandEncoder();\n    const renderPassForVerify = encoderForVerify.beginRenderPass({\n      colorAttachments: [\n        {\n          view: multisampledColorTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'discard',\n          resolveTarget: colorTextureAsResolveTarget.createView(),\n        },\n      ],\n      depthStencilAttachment: {\n        view: destinationTexture.createView(),\n        depthLoadOp: 'load',\n        depthStoreOp: 'store',\n        ...(isStencilTextureFormat(format) && {\n          stencilLoadOp: 'clear',\n          stencilStoreOp: 'store',\n        }),\n      },\n    });\n    renderPassForVerify.setPipeline(renderPipelineForVerify);\n    renderPassForVerify.draw(6);\n    renderPassForVerify.end();\n    t.queue.submit([encoderForVerify.finish()]);\n\n    t.expectSingleColor(colorTextureAsResolveTarget, kColorFormat, {\n      size: [textureSize[0], textureSize[1], textureSize[2]],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n  });\n\ng.test('copy_multisampled_stencil')\n  .desc(\n    `\n  Validate the correctness of copyTextureToTexture() with multisampled stencil formats.\n    `\n  )\n  .unimplemented();\n"],"mappings":"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"}