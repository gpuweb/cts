{"version":3,"sources":["../../../../../../src/webgpu/api/operation/command_buffer/programmable/programmable_state_test.ts"],"names":["unreachable","GPUTest","ProgrammableStateTest","commonBindGroupLayouts","Map","getBindGroupLayout","type","has","set","device","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","get","getBindGroupLayouts","indices","bindGroupLayouts","a","b","out","createBindGroup","layout","resource","setBindGroup","encoder","index","factory","createBindingStatePipeline","encoderType","groups","algorithm","wgsl","createComputePipeline","createPipelineLayout","compute","module","createShaderModule","code","entryPoint","wgslShaders","vertex","fragment","createRenderPipeline","targets","format","primitive","topology","setPipeline","pass","pipeline","GPUComputePassEncoder","GPURenderPassEncoder","GPURenderBundleEncoder","dispatchOrDraw","dispatch","draw"],"mappings":"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","sourcesContent":["import { unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { EncoderType } from '../../../../util/command_buffer_maker.js';\n\ninterface BindGroupIndices {\n  a: number;\n  b: number;\n  out: number;\n}\n\nexport class ProgrammableStateTest extends GPUTest {\n  private commonBindGroupLayouts: Map<string, GPUBindGroupLayout> = new Map();\n\n  getBindGroupLayout(type: GPUBufferBindingType): GPUBindGroupLayout {\n    if (!this.commonBindGroupLayouts.has(type)) {\n      this.commonBindGroupLayouts.set(\n        type,\n        this.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n              buffer: { type },\n            },\n          ],\n        })\n      );\n    }\n    return this.commonBindGroupLayouts.get(type)!;\n  }\n\n  getBindGroupLayouts(indices: BindGroupIndices): GPUBindGroupLayout[] {\n    const bindGroupLayouts: GPUBindGroupLayout[] = [];\n    bindGroupLayouts[indices.a] = this.getBindGroupLayout('read-only-storage');\n    bindGroupLayouts[indices.b] = this.getBindGroupLayout('read-only-storage');\n    bindGroupLayouts[indices.out] = this.getBindGroupLayout('storage');\n    return bindGroupLayouts;\n  }\n\n  createBindGroup(buffer: GPUBuffer, type: GPUBufferBindingType): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.getBindGroupLayout(type),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  setBindGroup(\n    encoder: GPUProgrammablePassEncoder,\n    index: number,\n    factory: (index: number) => GPUBindGroup\n  ) {\n    encoder.setBindGroup(index, factory(index));\n  }\n\n  // Create a compute pipeline that performs an operation on data from two bind groups,\n  // then writes the result to a third bind group.\n  createBindingStatePipeline<T extends EncoderType>(\n    encoderType: T,\n    groups: BindGroupIndices,\n    algorithm: string = 'a.value - b.value'\n  ): GPUComputePipeline | GPURenderPipeline {\n    switch (encoderType) {\n      case 'compute pass': {\n        const wgsl = `struct Data {\n            value : i32\n          };\n\n          @group(${groups.a}) @binding(0) var<storage> a : Data;\n          @group(${groups.b}) @binding(0) var<storage> b : Data;\n          @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n          @stage(compute) @workgroup_size(1) fn main() {\n            out.value = ${algorithm};\n            return;\n          }\n        `;\n\n        return this.device.createComputePipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: this.getBindGroupLayouts(groups),\n          }),\n          compute: {\n            module: this.device.createShaderModule({\n              code: wgsl,\n            }),\n            entryPoint: 'main',\n          },\n        });\n      }\n      case 'render pass':\n      case 'render bundle': {\n        const wgslShaders = {\n          vertex: `\n            @stage(vertex) fn vert_main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n            }\n          `,\n\n          fragment: `\n            struct Data {\n              value : i32\n            };\n\n            @group(${groups.a}) @binding(0) var<storage> a : Data;\n            @group(${groups.b}) @binding(0) var<storage> b : Data;\n            @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n            @stage(fragment) fn frag_main() -> @location(0) vec4<f32> {\n              out.value = ${algorithm};\n              return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }\n          `,\n        };\n\n        return this.device.createRenderPipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: this.getBindGroupLayouts(groups),\n          }),\n          vertex: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.vertex,\n            }),\n            entryPoint: 'vert_main',\n          },\n          fragment: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.fragment,\n            }),\n            entryPoint: 'frag_main',\n            targets: [{ format: 'rgba8unorm' }],\n          },\n          primitive: { topology: 'point-list' },\n        });\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  setPipeline(pass: GPUProgrammablePassEncoder, pipeline: GPUComputePipeline | GPURenderPipeline) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.setPipeline(pipeline as GPUComputePipeline);\n    } else if (pass instanceof GPURenderPassEncoder || pass instanceof GPURenderBundleEncoder) {\n      pass.setPipeline(pipeline as GPURenderPipeline);\n    }\n  }\n\n  dispatchOrDraw(pass: GPUProgrammablePassEncoder) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.dispatch(1);\n    } else if (pass instanceof GPURenderPassEncoder) {\n      pass.draw(1);\n    } else if (pass instanceof GPURenderBundleEncoder) {\n      pass.draw(1);\n    }\n  }\n}\n"],"file":"programmable_state_test.js"}