{"version":3,"file":"programmable_state_test.js","names":["unreachable","GPUTest","ProgrammableStateTest","commonBindGroupLayouts","Map","skipIfNeedsStorageBuffersInFragmentStageAndHaveNone","type","encoderType","isCompatibility","needsStorageBuffersInFragmentStage","skipIf","device","limits","maxStorageBuffersInFragmentStage","getBindGroupLayout","visibility","id","has","set","createBindGroupLayout","entries","binding","buffer","get","getVisibilityForEncoderType","GPUShaderStage","COMPUTE","FRAGMENT","getBindGroupLayouts","indices","bindGroupLayouts","inputType","a","b","out","createBindGroup","layout","resource","setBindGroup","encoder","index","factory","createBindingStatePipeline","groups","algorithm","wgsl","createComputePipeline","createPipelineLayout","compute","module","createShaderModule","code","entryPoint","wgslShaders","vertex","fragment","createRenderPipeline","targets","format","primitive","topology","createEncoderForStateTest","params","renderTarget","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoderAndFinish","createEncoder","attachmentInfo","colorFormats","createView","validateFinishAndSubmit","shouldBeValid","submitShouldSucceedIfValid","createCommandEncoder","copyTextureToBuffer","texture","queue","submit","finish","setPipeline","pass","pipeline","GPUComputePassEncoder","GPURenderPassEncoder","GPURenderBundleEncoder","dispatchOrDraw","dispatchWorkgroups","draw"],"sources":["../../../../../../src/webgpu/api/operation/command_buffer/programmable/programmable_state_test.ts"],"sourcesContent":["import { unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest, GPUTestBase } from '../../../../gpu_test.js';\nimport { EncoderType } from '../../../../util/command_buffer_maker.js';\n\ninterface BindGroupIndices {\n  a: number;\n  b: number;\n  out: number;\n}\n\ntype CreateEncoderType = ReturnType<\n  typeof GPUTestBase.prototype.createEncoder<'compute pass' | 'render pass' | 'render bundle'>\n>['encoder'];\n\nexport class ProgrammableStateTest extends GPUTest {\n  private commonBindGroupLayouts: Map<string, GPUBindGroupLayout> = new Map();\n\n  skipIfNeedsStorageBuffersInFragmentStageAndHaveNone(\n    type: GPUBufferBindingType,\n    encoderType: EncoderType\n  ) {\n    if (!this.isCompatibility) {\n      return;\n    }\n\n    const needsStorageBuffersInFragmentStage =\n      type === 'storage' && (encoderType === 'render bundle' || encoderType === 'render pass');\n\n    this.skipIf(\n      needsStorageBuffersInFragmentStage &&\n        !(this.device.limits.maxStorageBuffersInFragmentStage! >= 3),\n      `maxStorageBuffersInFragmentStage(${this.device.limits.maxStorageBuffersInFragmentStage}) < 3`\n    );\n  }\n\n  getBindGroupLayout(\n    type: GPUBufferBindingType,\n    visibility: GPUShaderStageFlags\n  ): GPUBindGroupLayout {\n    const id = `${type}:${visibility}`;\n    if (!this.commonBindGroupLayouts.has(id)) {\n      this.commonBindGroupLayouts.set(\n        id,\n        this.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility,\n              buffer: { type },\n            },\n          ],\n        })\n      );\n    }\n    return this.commonBindGroupLayouts.get(id)!;\n  }\n\n  getVisibilityForEncoderType(encoderType: EncoderType) {\n    return encoderType === 'compute pass' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT;\n  }\n\n  getBindGroupLayouts(\n    indices: BindGroupIndices,\n    type: GPUBufferBindingType,\n    encoderType: EncoderType\n  ): GPUBindGroupLayout[] {\n    const bindGroupLayouts: GPUBindGroupLayout[] = [];\n    const inputType = type === 'storage' ? 'read-only-storage' : 'uniform';\n    const visibility = this.getVisibilityForEncoderType(encoderType);\n    bindGroupLayouts[indices.a] = this.getBindGroupLayout(inputType, visibility);\n    bindGroupLayouts[indices.b] = this.getBindGroupLayout(inputType, visibility);\n    if (type === 'storage' || encoderType === 'compute pass') {\n      bindGroupLayouts[indices.out] = this.getBindGroupLayout('storage', visibility);\n    }\n    return bindGroupLayouts;\n  }\n\n  createBindGroup(\n    buffer: GPUBuffer,\n    type: GPUBufferBindingType,\n    encoderType: EncoderType\n  ): GPUBindGroup {\n    const visibility = this.getVisibilityForEncoderType(encoderType);\n    return this.device.createBindGroup({\n      layout: this.getBindGroupLayout(type, visibility),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  setBindGroup(\n    encoder: GPUBindingCommandsMixin,\n    index: number,\n    factory: (index: number) => GPUBindGroup\n  ) {\n    encoder.setBindGroup(index, factory(index));\n  }\n\n  // Create a compute pipeline that performs an operation on data from two bind groups,\n  // then writes the result to a third bind group.\n  createBindingStatePipeline<T extends EncoderType>(\n    encoderType: T,\n    groups: BindGroupIndices,\n    type: GPUBufferBindingType,\n    algorithm: string = 'a.value - b.value'\n  ): GPUComputePipeline | GPURenderPipeline {\n    switch (encoderType) {\n      case 'compute pass': {\n        const wgsl = `struct Data {\n            value : i32\n          };\n\n          @group(${groups.a}) @binding(0) var<${type}> a : Data;\n          @group(${groups.b}) @binding(0) var<${type}> b : Data;\n          @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n          @compute @workgroup_size(1) fn main() {\n            out.value = ${algorithm};\n            return;\n          }\n        `;\n\n        return this.device.createComputePipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: this.getBindGroupLayouts(groups, type, encoderType),\n          }),\n          compute: {\n            module: this.device.createShaderModule({\n              code: wgsl,\n            }),\n            entryPoint: 'main',\n          },\n        });\n      }\n      case 'render pass':\n      case 'render bundle': {\n        const wgslShaders = {\n          vertex: `\n            @vertex fn vert_main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0, 0, 0, 1);\n            }\n          `,\n\n          fragment: `\n            struct Data {\n              value : i32\n            };\n\n            @group(${groups.a}) @binding(0) var<${type}> a : Data;\n            @group(${groups.b}) @binding(0) var<${type}> b : Data;\n            @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n            @fragment fn frag_main_storage() -> @location(0) vec4<i32> {\n              out.value = ${algorithm};\n              return vec4<i32>(1, 0, 0, 1);\n            }\n            @fragment fn frag_main_uniform() -> @location(0) vec4<i32> {\n              return vec4<i32>(${algorithm});\n            }\n          `,\n        };\n\n        return this.device.createRenderPipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: this.getBindGroupLayouts(groups, type, encoderType),\n          }),\n          vertex: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.vertex,\n            }),\n            entryPoint: 'vert_main',\n          },\n          fragment: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.fragment,\n            }),\n            entryPoint: type === 'uniform' ? 'frag_main_uniform' : 'frag_main_storage',\n            targets: [{ format: 'r32sint' }],\n          },\n          primitive: { topology: 'point-list' },\n        });\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  createEncoderForStateTest(\n    type: GPUBufferBindingType,\n    out: GPUBuffer,\n    ...params: Parameters<typeof GPUTestBase.prototype.createEncoder>\n  ): {\n    encoder: CreateEncoderType;\n    validateFinishAndSubmit: (shouldBeValid: boolean, submitShouldSucceedIfValid: boolean) => void;\n  } {\n    const encoderType = params[0];\n    const renderTarget = this.createTextureTracked({\n      size: [1, 1],\n      format: 'r32sint',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    // Note: This nightmare of gibberish is trying the result of 2 hours of\n    // trying to get typescript to accept the code. Originally the code was\n    // effectively just\n    //\n    //  const { encoder, validateFinishAndSubmit } = this.createEncoder(...);\n    //  const fn = (b0, b1) => { validateFinishAndSubmit(b1, b1); if (...) { ... copyT2B ... } }\n    //  return { encoder: e__, validateFinishAndSubmit: fn };\n    //\n    // But TS didn't like it. I couldn't figure out why.\n    const encoderAndFinish = this.createEncoder(encoderType, {\n      attachmentInfo: { colorFormats: ['r32sint'] },\n      targets: [renderTarget.createView()],\n    });\n\n    const validateFinishAndSubmit = (\n      shouldBeValid: boolean,\n      submitShouldSucceedIfValid: boolean\n    ) => {\n      encoderAndFinish.validateFinishAndSubmit(shouldBeValid, submitShouldSucceedIfValid);\n\n      if (\n        type === 'uniform' &&\n        (encoderType === 'render pass' || encoderType === 'render bundle')\n      ) {\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyTextureToBuffer({ texture: renderTarget }, { buffer: out }, [1, 1]);\n        this.device.queue.submit([encoder.finish()]);\n      }\n    };\n\n    return {\n      encoder: encoderAndFinish.encoder as CreateEncoderType,\n      validateFinishAndSubmit,\n    };\n  }\n\n  setPipeline(pass: GPUBindingCommandsMixin, pipeline: GPUComputePipeline | GPURenderPipeline) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.setPipeline(pipeline as GPUComputePipeline);\n    } else if (pass instanceof GPURenderPassEncoder || pass instanceof GPURenderBundleEncoder) {\n      pass.setPipeline(pipeline as GPURenderPipeline);\n    }\n  }\n\n  dispatchOrDraw(pass: GPUBindingCommandsMixin) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.dispatchWorkgroups(1);\n    } else if (pass instanceof GPURenderPassEncoder) {\n      pass.draw(1);\n    } else if (pass instanceof GPURenderBundleEncoder) {\n      pass.draw(1);\n    }\n  }\n}\n"],"mappings":"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"}