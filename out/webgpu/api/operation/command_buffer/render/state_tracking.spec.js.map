{"version":3,"sources":["../../../../../../src/webgpu/api/operation/command_buffer/render/state_tracking.spec.ts"],"names":["description","makeTestGroup","GPUTest","VertexAndIndexStateTrackingTest","GetRenderPipelineForTest","arrayStride","device","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","attributes","format","offset","shaderLocation","fragment","targets","primitive","topology","kVertexAttributeSize","g","test","desc","fn","t","indexBuffer","makeBufferWithContents","Uint16Array","GPUBufferUsage","INDEX","kVertexAttributesCount","vertexBuffer","createBuffer","usage","VERTEX","size","mappedAtCreation","trackForCleanup","vertexAttributes","getMappedRange","kPositions","kColors","Uint8Array","i","length","baseOffset","vertexPosition","Float32Array","vertexColor","set","lastOffset","lastVertexPosition","lastVertexColor","unmap","renderPipeline","outputTexture","createTexture","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","setVertexBuffer","setIndexBuffer","drawIndexed","end","queue","submit","finish","expectedColor","expectSinglePixelIn2DTexture","x","y","exp","draw","renderPipeline1","renderPipeline2","kPointsCount","kAttributeStride","positionBuffer","colorBuffer","fragmentState","kExpectedColors","subarray"],"mappings":"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","sourcesContent":["export const description = `\nEnsure state is set correctly. Tries to stress state caching (setting different states multiple\ntimes in different orders) for setIndexBuffer and setVertexBuffer.\nEquivalent tests for setBindGroup and setPipeline are in programmable/state_tracking.spec.ts.\nEquivalent tests for viewport/scissor/blend/reference are in render/dynamic_state.spec.ts\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../gpu_test.js';\n\nclass VertexAndIndexStateTrackingTest extends GPUTest {\n  GetRenderPipelineForTest(arrayStride: number): GPURenderPipeline {\n    return this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n        struct Inputs {\n          @location(0) vertexPosition : f32,\n          @location(1) vertexColor : vec4<f32>,\n        };\n        struct Outputs {\n          @builtin(position) position : vec4<f32>,\n          @location(0) color : vec4<f32>,\n        };\n        @stage(vertex)\n        fn main(input : Inputs)-> Outputs {\n          var outputs : Outputs;\n          outputs.position =\n            vec4<f32>(input.vertexPosition, 0.5, 0.0, 1.0);\n          outputs.color = input.vertexColor;\n          return outputs;\n        }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride,\n            attributes: [\n              {\n                format: 'float32',\n                offset: 0,\n                shaderLocation: 0,\n              },\n              {\n                format: 'unorm8x4',\n                offset: 4,\n                shaderLocation: 1,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        struct Input {\n          @location(0) color : vec4<f32>\n        };\n        @stage(fragment)\n        fn main(input : Input) -> @location(0) vec4<f32> {\n          return input.color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    });\n  }\n\n  kVertexAttributeSize = 8;\n}\n\nexport const g = makeTestGroup(VertexAndIndexStateTrackingTest);\n\ng.test('set_index_buffer_without_changing_buffer')\n  .desc(\n    `\n  Test that setting index buffer states (index format, offset, size) multiple times in different\n  orders still keeps the correctness of each draw call.\n`\n  )\n  .fn(async t => {\n    // Initialize the index buffer with 5 uint16 indices (0, 1, 2, 3, 4).\n    const indexBuffer = t.makeBufferWithContents(\n      new Uint16Array([0, 1, 2, 3, 4]),\n      GPUBufferUsage.INDEX\n    );\n\n    // Initialize the vertex buffer with required vertex attributes (position: f32, color: f32x4)\n    // Note that the maximum index in the test is 0x10000.\n    const kVertexAttributesCount = 0x10000 + 1;\n    const vertexBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.VERTEX,\n      size: t.kVertexAttributeSize * kVertexAttributesCount,\n      mappedAtCreation: true,\n    });\n    t.trackForCleanup(vertexBuffer);\n    const vertexAttributes = vertexBuffer.getMappedRange();\n    const kPositions = [-0.8, -0.4, 0.0, 0.4, 0.8, -0.4];\n    const kColors = [\n      new Uint8Array([255, 0, 0, 255]),\n      new Uint8Array([255, 255, 255, 255]),\n      new Uint8Array([0, 0, 255, 255]),\n      new Uint8Array([255, 0, 255, 255]),\n      new Uint8Array([0, 255, 255, 255]),\n      new Uint8Array([0, 255, 0, 255]),\n    ];\n    // Set vertex attributes at index {0..4} in Uint16.\n    // Note that the vertex attribute at index 1 will not be used.\n    for (let i = 0; i < kPositions.length - 1; ++i) {\n      const baseOffset = t.kVertexAttributeSize * i;\n      const vertexPosition = new Float32Array(vertexAttributes, baseOffset, 1);\n      vertexPosition[0] = kPositions[i];\n      const vertexColor = new Uint8Array(vertexAttributes, baseOffset + 4, 4);\n      vertexColor.set(kColors[i]);\n    }\n    // Set vertex attributes at index 0x10000.\n    const lastOffset = t.kVertexAttributeSize * (kVertexAttributesCount - 1);\n    const lastVertexPosition = new Float32Array(vertexAttributes, lastOffset, 1);\n    lastVertexPosition[0] = kPositions[kPositions.length - 1];\n    const lastVertexColor = new Uint8Array(vertexAttributes, lastOffset + 4, 4);\n    lastVertexColor.set(kColors[kColors.length - 1]);\n\n    vertexBuffer.unmap();\n\n    const renderPipeline = t.GetRenderPipelineForTest(t.kVertexAttributeSize);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPositions.length - 1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: [0, 0, 0, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setVertexBuffer(0, vertexBuffer);\n\n    // 1st draw: indexFormat = 'uint32', offset = 0, size = 4 (index value: 0x10000)\n    renderPass.setIndexBuffer(indexBuffer, 'uint32', 0, 4);\n    renderPass.drawIndexed(1);\n\n    // 2nd draw: indexFormat = 'uint16', offset = 0, size = 4 (index value: 0)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 0, 4);\n    renderPass.drawIndexed(1);\n\n    // 3rd draw: indexFormat = 'uint16', offset = 4, size = 2 (index value: 2)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 0, 2);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 4, 2);\n    renderPass.drawIndexed(1);\n\n    // 4th draw: indexformat = 'uint16', offset = 6, size = 4 (index values: 3, 4)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 6, 2);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 6, 4);\n    renderPass.drawIndexed(2);\n\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    for (let i = 0; i < kPositions.length - 1; ++i) {\n      const expectedColor = i === 1 ? kColors[kPositions.length - 1] : kColors[i];\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: expectedColor }\n      );\n    }\n  });\n\ng.test('set_vertex_buffer_without_changing_buffer')\n  .desc(\n    `\n  Test that setting vertex buffer states (offset, size) multiple times in different orders still\n  keeps the correctness of each draw call.\n  - Tries several different sequences of setVertexBuffer+draw commands, each of which draws vertices\n    in all 4 output pixels, and check they were drawn correctly.\n`\n  )\n  .fn(async t => {\n    const kPositions = [-0.875, -0.625, -0.375, -0.125, 0.125, 0.375, 0.625, 0.875];\n    const kColors = [\n      new Uint8Array([255, 0, 0, 255]),\n      new Uint8Array([0, 255, 0, 255]),\n      new Uint8Array([0, 0, 255, 255]),\n      new Uint8Array([51, 0, 0, 255]),\n      new Uint8Array([0, 51, 0, 255]),\n      new Uint8Array([0, 0, 51, 255]),\n      new Uint8Array([255, 0, 255, 255]),\n      new Uint8Array([255, 255, 0, 255]),\n    ];\n\n    // Initialize the vertex buffer with required vertex attributes (position: f32, color: f32x4)\n    const kVertexAttributesCount = 8;\n    const vertexBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.VERTEX,\n      size: t.kVertexAttributeSize * kVertexAttributesCount,\n      mappedAtCreation: true,\n    });\n    t.trackForCleanup(vertexBuffer);\n    const vertexAttributes = vertexBuffer.getMappedRange();\n    for (let i = 0; i < kPositions.length; ++i) {\n      const baseOffset = t.kVertexAttributeSize * i;\n      const vertexPosition = new Float32Array(vertexAttributes, baseOffset, 1);\n      vertexPosition[0] = kPositions[i];\n      const vertexColor = new Uint8Array(vertexAttributes, baseOffset + 4, 4);\n      vertexColor.set(kColors[i]);\n    }\n\n    vertexBuffer.unmap();\n\n    const renderPipeline = t.GetRenderPipelineForTest(t.kVertexAttributeSize);\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPositions.length, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: [0, 0, 0, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n\n    // Change 'size' in setVertexBuffer()\n    renderPass.setVertexBuffer(0, vertexBuffer, 0, t.kVertexAttributeSize);\n    renderPass.setVertexBuffer(0, vertexBuffer, 0, t.kVertexAttributeSize * 2);\n    renderPass.draw(2);\n\n    // Change 'offset' in setVertexBuffer()\n    renderPass.setVertexBuffer(\n      0,\n      vertexBuffer,\n      t.kVertexAttributeSize * 2,\n      t.kVertexAttributeSize * 2\n    );\n    renderPass.draw(2);\n\n    // Change 'size' again in setVertexBuffer()\n    renderPass.setVertexBuffer(\n      0,\n      vertexBuffer,\n      t.kVertexAttributeSize * 4,\n      t.kVertexAttributeSize * 2\n    );\n    renderPass.setVertexBuffer(\n      0,\n      vertexBuffer,\n      t.kVertexAttributeSize * 4,\n      t.kVertexAttributeSize * 4\n    );\n    renderPass.draw(4);\n\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    for (let i = 0; i < kPositions.length; ++i) {\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: kColors[i] }\n      );\n    }\n  });\n\ng.test('change_pipeline_before_and_after_vertex_buffer')\n  .desc(\n    `\n  Test that changing the pipeline {before,after} the vertex buffers still keeps the correctness of\n  each draw call (In D3D12, the vertex buffer stride is part of SetVertexBuffer instead of the\n  pipeline.)\n`\n  )\n  .fn(async t => {\n    const kPositions = [-0.8, -0.4, 0.0, 0.4, 0.8, 0.9];\n    const kColors = [\n      new Uint8Array([255, 0, 0, 255]),\n      new Uint8Array([255, 255, 255, 255]),\n      new Uint8Array([0, 255, 0, 255]),\n      new Uint8Array([0, 0, 255, 255]),\n      new Uint8Array([255, 0, 255, 255]),\n      new Uint8Array([0, 255, 255, 255]),\n    ];\n\n    // Initialize the vertex buffer with required vertex attributes (position: f32, color: f32x4)\n    const vertexBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.VERTEX,\n      size: t.kVertexAttributeSize * kPositions.length,\n      mappedAtCreation: true,\n    });\n    t.trackForCleanup(vertexBuffer);\n    // Note that kPositions[1], kColors[1], kPositions[5] and kColors[5] are not used.\n    const vertexAttributes = vertexBuffer.getMappedRange();\n    for (let i = 0; i < kPositions.length; ++i) {\n      const baseOffset = t.kVertexAttributeSize * i;\n      const vertexPosition = new Float32Array(vertexAttributes, baseOffset, 1);\n      vertexPosition[0] = kPositions[i];\n      const vertexColor = new Uint8Array(vertexAttributes, baseOffset + 4, 4);\n      vertexColor.set(kColors[i]);\n    }\n    vertexBuffer.unmap();\n\n    // Create two render pipelines with different vertex attribute strides\n    const renderPipeline1 = t.GetRenderPipelineForTest(t.kVertexAttributeSize);\n    const renderPipeline2 = t.GetRenderPipelineForTest(t.kVertexAttributeSize * 2);\n\n    const kPointsCount = kPositions.length - 1;\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPointsCount, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: [0, 0, 0, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    // Update render pipeline before setVertexBuffer. The applied vertex attribute stride should be\n    // 2 * kVertexAttributeSize.\n    renderPass.setPipeline(renderPipeline1);\n    renderPass.setPipeline(renderPipeline2);\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    renderPass.draw(2);\n\n    // Update render pipeline after setVertexBuffer. The applied vertex attribute stride should be\n    // kVertexAttributeSize.\n    renderPass.setVertexBuffer(0, vertexBuffer, 3 * t.kVertexAttributeSize);\n    renderPass.setPipeline(renderPipeline1);\n    renderPass.draw(2);\n\n    renderPass.end();\n\n    t.queue.submit([encoder.finish()]);\n\n    for (let i = 0; i < kPointsCount; ++i) {\n      const expectedColor = i === 1 ? new Uint8Array([0, 0, 0, 255]) : kColors[i];\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: expectedColor }\n      );\n    }\n  });\n\ng.test('set_vertex_buffer_but_not_used_in_draw')\n  .desc(\n    `\n  Test that drawing after having set vertex buffer slots not used by the pipeline works correctly.\n  - In the test there are 2 draw calls in the render pass. The first draw call uses 2 vertex buffers\n    (position and color), and the second draw call only uses 1 vertex buffer (for color, the vertex\n    position is defined as constant values in the vertex shader). The test verifies if both of these\n    two draw calls work correctly.\n  `\n  )\n  .fn(async t => {\n    const kPositions = new Float32Array([-0.75, -0.25]);\n    const kColors = new Uint8Array([255, 0, 0, 255, 0, 255, 0, 255]);\n\n    // Initialize the vertex buffers with required vertex attributes (position: f32, color: f32x4)\n    const kAttributeStride = 4;\n    const positionBuffer = t.makeBufferWithContents(kPositions, GPUBufferUsage.VERTEX);\n    const colorBuffer = t.makeBufferWithContents(kColors, GPUBufferUsage.VERTEX);\n\n    const fragmentState: GPUFragmentState = {\n      module: t.device.createShaderModule({\n        code: `\n      struct Input {\n        @location(0) color : vec4<f32>\n      };\n      @stage(fragment)\n      fn main(input : Input) -> @location(0) vec4<f32> {\n        return input.color;\n      }`,\n      }),\n      entryPoint: 'main',\n      targets: [{ format: 'rgba8unorm' }],\n    };\n\n    // Create renderPipeline1 that uses both positionBuffer and colorBuffer.\n    const renderPipeline1 = t.device.createRenderPipeline({\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n        struct Inputs {\n          @location(0) vertexColor : vec4<f32>,\n          @location(1) vertexPosition : f32,\n        };\n        struct Outputs {\n          @builtin(position) position : vec4<f32>,\n          @location(0) color : vec4<f32>,\n        };\n        @stage(vertex)\n        fn main(input : Inputs)-> Outputs {\n          var outputs : Outputs;\n          outputs.position =\n            vec4<f32>(input.vertexPosition, 0.5, 0.0, 1.0);\n          outputs.color = input.vertexColor;\n          return outputs;\n        }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: kAttributeStride,\n            attributes: [\n              {\n                format: 'unorm8x4',\n                offset: 0,\n                shaderLocation: 0,\n              },\n            ],\n          },\n          {\n            arrayStride: kAttributeStride,\n            attributes: [\n              {\n                format: 'float32',\n                offset: 0,\n                shaderLocation: 1,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: fragmentState,\n      primitive: {\n        topology: 'point-list',\n      },\n    });\n\n    const renderPipeline2 = t.device.createRenderPipeline({\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n        struct Inputs {\n          @builtin(vertex_index) vertexIndex : u32,\n          @location(0) vertexColor : vec4<f32>,\n        };\n        struct Outputs {\n          @builtin(position) position : vec4<f32>,\n          @location(0) color : vec4<f32>,\n        };\n        @stage(vertex)\n        fn main(input : Inputs)-> Outputs {\n          var kPositions = array<f32, 2> (0.25, 0.75);\n          var outputs : Outputs;\n          outputs.position =\n              vec4(kPositions[input.vertexIndex], 0.5, 0.0, 1.0);\n          outputs.color = input.vertexColor;\n          return outputs;\n        }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: kAttributeStride,\n            attributes: [\n              {\n                format: 'unorm8x4',\n                offset: 0,\n                shaderLocation: 0,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: fragmentState,\n      primitive: {\n        topology: 'point-list',\n      },\n    });\n\n    const kPointsCount = 4;\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPointsCount, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: [0, 0, 0, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    renderPass.setVertexBuffer(0, colorBuffer);\n    renderPass.setVertexBuffer(1, positionBuffer);\n    renderPass.setPipeline(renderPipeline1);\n    renderPass.draw(2);\n\n    renderPass.setPipeline(renderPipeline2);\n    renderPass.draw(2);\n\n    renderPass.end();\n\n    t.queue.submit([encoder.finish()]);\n\n    const kExpectedColors = [\n      kColors.subarray(0, 4),\n      kColors.subarray(4),\n      kColors.subarray(0, 4),\n      kColors.subarray(4),\n    ];\n\n    for (let i = 0; i < kPointsCount; ++i) {\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: kExpectedColors[i] }\n      );\n    }\n  });\n\ng.test('set_index_buffer_before_non_indexed_draw')\n  .desc(\n    `\n  Test that setting / not setting the index buffer does not impact a non-indexed draw.\n  `\n  )\n  .fn(async t => {\n    const kPositions = [-0.75, -0.25, 0.25, 0.75];\n    const kColors = [\n      new Uint8Array([255, 0, 0, 255]),\n      new Uint8Array([0, 255, 0, 255]),\n      new Uint8Array([0, 0, 255, 255]),\n      new Uint8Array([255, 0, 255, 255]),\n    ];\n\n    // Initialize the vertex buffer with required vertex attributes (position: f32, color: f32x4)\n    const vertexBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.VERTEX,\n      size: t.kVertexAttributeSize * kPositions.length,\n      mappedAtCreation: true,\n    });\n    t.trackForCleanup(vertexBuffer);\n    const vertexAttributes = vertexBuffer.getMappedRange();\n    for (let i = 0; i < kPositions.length; ++i) {\n      const baseOffset = t.kVertexAttributeSize * i;\n      const vertexPosition = new Float32Array(vertexAttributes, baseOffset, 1);\n      vertexPosition[0] = kPositions[i];\n      const vertexColor = new Uint8Array(vertexAttributes, baseOffset + 4, 4);\n      vertexColor.set(kColors[i]);\n    }\n    vertexBuffer.unmap();\n\n    // Initialize the index buffer with 2 uint16 indices (2, 3).\n    const indexBuffer = t.makeBufferWithContents(new Uint16Array([2, 3]), GPUBufferUsage.INDEX);\n\n    const renderPipeline = t.GetRenderPipelineForTest(t.kVertexAttributeSize);\n\n    const kPointsCount = 4;\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPointsCount, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: [0, 0, 0, 1],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    // The first draw call is an indexed one (the third and fourth color are involved)\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16');\n    renderPass.setPipeline(renderPipeline);\n    renderPass.drawIndexed(2);\n\n    // The second draw call is a non-indexed one (the first and second color are involved)\n    renderPass.draw(2);\n\n    renderPass.end();\n\n    t.queue.submit([encoder.finish()]);\n\n    for (let i = 0; i < kPointsCount; ++i) {\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: kColors[i] }\n      );\n    }\n  });\n"],"file":"state_tracking.spec.js"}