{"version":3,"file":"clearBuffer.spec.js","names":["description","makeTestGroup","AllFeaturesMaxLimitsGPUTest","g","test","desc","paramsSubcasesOnly","u","combine","undefined","expand","p","offset","size","fn","t","bufferSize","params","bufferData","Uint8Array","i","buffer","makeBufferWithContents","GPUBufferUsage","COPY_DST","COPY_SRC","encoder","device","createCommandEncoder","clearBuffer","queue","submit","finish","expectOffset","expectSize","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/command_buffer/clearBuffer.spec.ts"],"sourcesContent":["export const description = `\nAPI operations tests for clearBuffer.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('clear')\n  .desc(\n    `Validate the correctness of the clear by filling the srcBuffer with testable data, doing\n  clearBuffer(), and verifying the content of the whole srcBuffer with MapRead:\n  Clear {4 bytes, part of, the whole} buffer {with, without} a non-zero valid offset that\n  - covers the whole buffer\n  - covers the beginning of the buffer\n  - covers the end of the buffer\n  - covers neither the beginning nor the end of the buffer`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('offset', [0, 4, 8, 16, undefined])\n      .combine('size', [0, 4, 8, 16, undefined])\n      .expand('bufferSize', p => [\n        (p.offset ?? 0) + (p.size ?? 16),\n        (p.offset ?? 0) + (p.size ?? 16) + 8,\n      ])\n  )\n  .fn(t => {\n    const { offset, size, bufferSize } = t.params;\n\n    const bufferData = new Uint8Array(bufferSize);\n    for (let i = 0; i < bufferSize; ++i) {\n      bufferData[i] = i + 1;\n    }\n\n    const buffer = t.makeBufferWithContents(\n      bufferData,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n    );\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.clearBuffer(buffer, offset, size);\n    t.device.queue.submit([encoder.finish()]);\n\n    const expectOffset = offset ?? 0;\n    const expectSize = size ?? bufferSize - expectOffset;\n\n    for (let i = 0; i < expectSize; ++i) {\n      bufferData[expectOffset + i] = 0;\n    }\n\n    t.expectGPUBufferValuesEqual(buffer, bufferData);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SAASC,2BAA2B,QAAQ,sBAAsB;;AAElE,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,2BAA2B,CAAC;;AAE3DC,CAAC,CAACC,IAAI,CAAC,OAAO,CAAC;AACZC,IAAI;EACF;AACL;AACA;AACA;AACA;AACA;AACA;AACE,CAAC;AACAC,kBAAkB,CAAC,CAAAC,CAAC;AACnBA,CAAC,CAAC;AAAA,CACCC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAEC,SAAS,CAAC,CAAC;AAC3CD,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAEC,SAAS,CAAC,CAAC;AACzCC,MAAM,CAAC,YAAY,EAAE,CAAAC,CAAC,KAAI;AACzB,CAACA,CAAC,CAACC,MAAM,IAAI,CAAC,KAAKD,CAAC,CAACE,IAAI,IAAI,EAAE,CAAC;AAChC,CAACF,CAAC,CAACC,MAAM,IAAI,CAAC,KAAKD,CAAC,CAACE,IAAI,IAAI,EAAE,CAAC,GAAG,CAAC;AACrC;AACL,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM,EAAEH,MAAM,EAAEC,IAAI,EAAEG,UAAU,CAAC,CAAC,GAAGD,CAAC,CAACE,MAAM;;EAE7C,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAACH,UAAU,CAAC;EAC7C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,UAAU,EAAE,EAAEI,CAAC,EAAE;IACnCF,UAAU,CAACE,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC;EACvB;;EAEA,MAAMC,MAAM,GAAGN,CAAC,CAACO,sBAAsB;IACrCJ,UAAU;IACVK,cAAc,CAACC,QAAQ,GAAGD,cAAc,CAACE;EAC3C,CAAC;;EAED,MAAMC,OAAO,GAAGX,CAAC,CAACY,MAAM,CAACC,oBAAoB,CAAC,CAAC;EAC/CF,OAAO,CAACG,WAAW,CAACR,MAAM,EAAET,MAAM,EAAEC,IAAI,CAAC;EACzCE,CAAC,CAACY,MAAM,CAACG,KAAK,CAACC,MAAM,CAAC,CAACL,OAAO,CAACM,MAAM,CAAC,CAAC,CAAC,CAAC;;EAEzC,MAAMC,YAAY,GAAGrB,MAAM,IAAI,CAAC;EAChC,MAAMsB,UAAU,GAAGrB,IAAI,IAAIG,UAAU,GAAGiB,YAAY;;EAEpD,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,UAAU,EAAE,EAAEd,CAAC,EAAE;IACnCF,UAAU,CAACe,YAAY,GAAGb,CAAC,CAAC,GAAG,CAAC;EAClC;;EAEAL,CAAC,CAACoB,0BAA0B,CAACd,MAAM,EAAEH,UAAU,CAAC;AAClD,CAAC,CAAC"}