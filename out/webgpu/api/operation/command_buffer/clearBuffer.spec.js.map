{"version":3,"sources":["../../../../../src/webgpu/api/operation/command_buffer/clearBuffer.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","test","desc","paramsSubcasesOnly","u","combine","undefined","expand","p","offset","size","fn","t","bufferSize","params","bufferData","Uint8Array","i","buffer","makeBufferWithContents","GPUBufferUsage","COPY_DST","COPY_SRC","encoder","device","createCommandEncoder","clearBuffer","queue","submit","finish","expectOffset","expectSize","expectGPUBufferValuesEqual"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAFO,CAIP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,OAAT,QAAwB,sBAAxB;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,OAAD,CAAvB;;AAEPC,CAAC,CAACC,IAAF,CAAO,OAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA;AACA,2DARA;;AAUGC,kBAVH,CAUsB,CAAAC,CAAC;AACnBA,CAAC,CAAC;AAAD,CACEC,OADH,CACW,QADX,EACqB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAcC,SAAd,CADrB;AAEGD,OAFH,CAEW,MAFX,EAEmB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAcC,SAAd,CAFnB;AAGGC,MAHH,CAGU,YAHV,EAGwB,CAAAC,CAAC,KAAI;AACzB,CAACA,CAAC,CAACC,MAAF,IAAY,CAAb,KAAmBD,CAAC,CAACE,IAAF,IAAU,EAA7B,CADyB;AAEzB,CAACF,CAAC,CAACC,MAAF,IAAY,CAAb,KAAmBD,CAAC,CAACE,IAAF,IAAU,EAA7B,IAAmC,CAFV,CAH7B,CAXJ;;;AAmBGC,EAnBH,CAmBM,OAAMC,CAAN,KAAW;AACb,QAAM,EAAEH,MAAF,EAAUC,IAAV,EAAgBG,UAAhB,KAA+BD,CAAC,CAACE,MAAvC;;AAEA,QAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAeH,UAAf,CAAnB;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,UAApB,EAAgC,EAAEI,CAAlC,EAAqC;AACnCF,IAAAA,UAAU,CAACE,CAAD,CAAV,GAAgBA,CAAC,GAAG,CAApB;AACD;;AAED,QAAMC,MAAM,GAAGN,CAAC,CAACO,sBAAF;AACbJ,EAAAA,UADa;AAEbK,EAAAA,cAAc,CAACC,QAAf,GAA0BD,cAAc,CAACE,QAF5B,CAAf;;;AAKA,QAAMC,OAAO,GAAGX,CAAC,CAACY,MAAF,CAASC,oBAAT,EAAhB;AACAF,EAAAA,OAAO,CAACG,WAAR,CAAoBR,MAApB,EAA4BT,MAA5B,EAAoCC,IAApC;AACAE,EAAAA,CAAC,CAACY,MAAF,CAASG,KAAT,CAAeC,MAAf,CAAsB,CAACL,OAAO,CAACM,MAAR,EAAD,CAAtB;;AAEA,QAAMC,YAAY,GAAGrB,MAAM,IAAI,CAA/B;AACA,QAAMsB,UAAU,GAAGrB,IAAI,IAAIG,UAAU,GAAGiB,YAAxC;;AAEA,OAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,UAApB,EAAgC,EAAEd,CAAlC,EAAqC;AACnCF,IAAAA,UAAU,CAACe,YAAY,GAAGb,CAAhB,CAAV,GAA+B,CAA/B;AACD;;AAEDL,EAAAA,CAAC,CAACoB,0BAAF,CAA6Bd,MAA7B,EAAqCH,UAArC;AACD,CA5CH","sourcesContent":["export const description = `\nAPI operations tests for clearBuffer.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('clear')\n  .desc(\n    `Validate the correctness of the clear by filling the srcBuffer with testable data, doing\n  clearBuffer(), and verifying the content of the whole srcBuffer with MapRead:\n  Clear {4 bytes, part of, the whole} buffer {with, without} a non-zero valid offset that\n  - covers the whole buffer\n  - covers the beginning of the buffer\n  - covers the end of the buffer\n  - covers neither the beginning nor the end of the buffer`\n  )\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('offset', [0, 4, 8, 16, undefined])\n      .combine('size', [0, 4, 8, 16, undefined])\n      .expand('bufferSize', p => [\n        (p.offset ?? 0) + (p.size ?? 16),\n        (p.offset ?? 0) + (p.size ?? 16) + 8,\n      ])\n  )\n  .fn(async t => {\n    const { offset, size, bufferSize } = t.params;\n\n    const bufferData = new Uint8Array(bufferSize);\n    for (let i = 0; i < bufferSize; ++i) {\n      bufferData[i] = i + 1;\n    }\n\n    const buffer = t.makeBufferWithContents(\n      bufferData,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n    );\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.clearBuffer(buffer, offset, size);\n    t.device.queue.submit([encoder.finish()]);\n\n    const expectOffset = offset ?? 0;\n    const expectSize = size ?? bufferSize - expectOffset;\n\n    for (let i = 0; i < expectSize; ++i) {\n      bufferData[expectOffset + i] = 0;\n    }\n\n    t.expectGPUBufferValuesEqual(buffer, bufferData);\n  });\n"],"file":"clearBuffer.spec.js"}