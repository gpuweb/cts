{"version":3,"file":"buffer_sync_test.js","names":["assert","unreachable","GPUTest","checkElementsEqualEither","kAllWriteOps","kAllReadOps","kOpInfo","contexts","storage","checkOpsValidForContext","ops","context","valid","includes","checkImpl","op1","op2","readOpUsesStorageBufferInFragmentShader","readOp","writeOpUsesStorageBufferInFragmentShader","writeOp","kDummyVertexShader","BufferSyncTest","tmpValueBuffers","undefined","tmpValueTextures","skipIfNoSupportForStorageBuffersInFragmentStage","isCompatibility","skipIf","device","limits","maxStorageBuffersInFragmentStage","skipIfReadOpsOrWriteOpsUsesStorageBufferInFragmentStageAndNoSupportStorageBuffersInFragmentShaders","readOps","Array","isArray","writeOps","readOpsUseStorageBuffersInFragmentStage","reduce","uses","op","writeOpsUseStorageBuffersInFragmentStage","usesStorageBuffersInFragmentStage","createIntermediateBuffersAndTexturesForWriteOp","slot","value","createBufferWithValue","createTextureWithValue","createBuffersForReadOp","srcValue","opValue","vertexBuffer","createBufferWithValues","indexBuffer","srcBuffer","dstBuffer","createBufferTracked","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","VERTEX","INDEX","INDIRECT","UNIFORM","initValue","buffer","mappedAtCreation","getMappedRange","fill","unmap","queue","onSubmittedWorkDone","initValues","length","bufferView","set","data","texture","createTextureTracked","width","height","depthOrArrayLayers","format","GPUTextureUsage","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","wgslCompute","createComputePipeline","compute","module","createShaderModule","code","entryPoint","createTrivialRenderPipeline","wgslShaders","createRenderPipeline","vertex","fragment","targets","primitive","topology","createStorageWriteRenderPipeline","beginSimpleRenderPass","encoder","view","RENDER_ATTACHMENT","createView","beginRenderPass","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","encodeWriteAsStorageBufferInRenderPass","renderer","bindGroup","setBindGroup","setPipeline","draw","encodeWriteAsStorageBufferInComputePass","pass","dispatchWorkgroups","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","helper","operation","writeOpSlot","ensureContext","renderPassEncoder","renderBundleEncoder","computePassEncoder","commandEncoder","createStorageReadComputePipeline","createBindGroupSrcDstBuffer","createVertexReadRenderPipeline","buffers","arrayStride","attributes","shaderLocation","createUniformReadRenderPipeline","createStorageReadRenderPipeline","encodeReadAsStorageBufferInComputePass","encodeReadAsIndirectBufferInComputePass","dispatchWorkgroupsIndirect","encodeReadAsVertexBufferInRenderPass","setVertexBuffer","encodeReadAsIndexBufferInRenderPass","setIndexBuffer","drawIndexed","encodeReadAsIndirectBufferInRenderPass","drawIndirect","encodeReadAsIndexedIndirectBufferInRenderPass","drawIndexedIndirect","encodeReadAsUniformBufferInRenderPass","encodeReadAsStorageBufferInRenderPass","encodeReadByB2BCopy","encodeReadByB2TCopy","copyBufferToTexture","encodeReadOp","computePass","verifyData","expectedValue","bufferData","expectGPUBufferValuesEqual","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectGPUBufferValuesPassCheck","type","typedLength"],"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"sourcesContent":["import { assert, unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { checkElementsEqualEither } from '../../../../util/check_contents.js';\nimport { OperationContext, OperationContextHelper } from '../operation_context_helper.js';\n\nexport const kAllWriteOps = ['storage', 'b2b-copy', 't2b-copy', 'write-buffer'] as const;\n\nexport const kAllReadOps = [\n  'input-vertex',\n  'input-index',\n  'input-indirect',\n  'input-indirect-index',\n  'input-indirect-dispatch',\n\n  'constant-uniform',\n\n  'storage-read',\n\n  'b2b-copy',\n  'b2t-copy',\n] as const;\n\nexport type ReadOp = (typeof kAllReadOps)[number];\nexport type WriteOp = (typeof kAllWriteOps)[number];\n\nexport type Op = ReadOp | WriteOp;\n\ninterface OpInfo {\n  readonly contexts: OperationContext[];\n}\n\nconst kOpInfo: {\n  readonly [k in Op]: OpInfo;\n} = {\n  'write-buffer': {\n    contexts: ['queue'],\n  },\n  'b2t-copy': {\n    contexts: ['command-encoder'],\n  },\n  'b2b-copy': {\n    contexts: ['command-encoder'],\n  },\n  't2b-copy': {\n    contexts: ['command-encoder'],\n  },\n  storage: {\n    contexts: ['compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'storage-read': {\n    contexts: ['compute-pass-encoder', 'render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-vertex': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-index': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect-index': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n  'input-indirect-dispatch': {\n    contexts: ['compute-pass-encoder'],\n  },\n  'constant-uniform': {\n    contexts: ['render-pass-encoder', 'render-bundle-encoder'],\n  },\n};\n\nexport function checkOpsValidForContext(\n  ops: [Op, Op],\n  context: [OperationContext, OperationContext]\n) {\n  const valid =\n    kOpInfo[ops[0]].contexts.includes(context[0]) && kOpInfo[ops[1]].contexts.includes(context[1]);\n  if (!valid) return false;\n\n  if (\n    context[0] === 'render-bundle-encoder' ||\n    context[0] === 'render-pass-encoder' ||\n    context[1] === 'render-bundle-encoder' ||\n    context[1] === 'render-pass-encoder'\n  ) {\n    // In a render pass, it is invalid to use a resource as both writable and another usage.\n    // Also, for storage+storage usage, the application is opting into racy behavior.\n    // The storage+storage case is also skipped as the results cannot be reliably tested.\n    const checkImpl = (op1: Op, op2: Op) => {\n      switch (op1) {\n        case 'storage':\n          switch (op2) {\n            case 'storage':\n            case 'storage-read':\n            case 'input-vertex':\n            case 'input-index':\n            case 'input-indirect':\n            case 'input-indirect-index':\n            case 'constant-uniform':\n              // Write+other, or racy.\n              return false;\n            case 'b2t-copy':\n            case 't2b-copy':\n            case 'b2b-copy':\n            case 'write-buffer':\n              // These don't occur in a render pass.\n              return true;\n          }\n          break;\n        case 'input-vertex':\n        case 'input-index':\n        case 'input-indirect':\n        case 'input-indirect-index':\n        case 'constant-uniform':\n        case 'b2t-copy':\n        case 't2b-copy':\n        case 'b2b-copy':\n        case 'write-buffer':\n          // These are not write usages, or don't occur in a render pass.\n          break;\n      }\n      return true;\n    };\n    return checkImpl(ops[0], ops[1]) && checkImpl(ops[1], ops[0]);\n  }\n  return true;\n}\n\nfunction readOpUsesStorageBufferInFragmentShader(readOp: ReadOp) {\n  return (\n    readOp === 'storage-read' ||\n    readOp === 'input-vertex' ||\n    readOp === 'input-index' ||\n    readOp === 'input-indirect' ||\n    readOp === 'input-indirect-index' ||\n    readOp === 'constant-uniform'\n  );\n}\n\nfunction writeOpUsesStorageBufferInFragmentShader(writeOp: WriteOp) {\n  return writeOp === 'storage' || writeOp === 'write-buffer';\n}\n\nconst kDummyVertexShader = `\n@vertex fn vert_main() -> @builtin(position) vec4<f32> {\n  return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n}\n`;\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Vertex and index buffers used in read render pass\n  vertexBuffer?: GPUBuffer;\n  indexBuffer?: GPUBuffer;\n\n  // Temp buffer and texture with values for buffer/texture copy write op\n  // There can be at most 2 write op\n  tmpValueBuffers: (GPUBuffer | undefined)[] = [undefined, undefined];\n  tmpValueTextures: (GPUTexture | undefined)[] = [undefined, undefined];\n\n  skipIfNoSupportForStorageBuffersInFragmentStage() {\n    if (this.isCompatibility) {\n      this.skipIf(\n        !(this.device.limits.maxStorageBuffersInFragmentStage! >= 2),\n        `maxStorageBuffersInFragmentStage(${this.device.limits.maxStorageBuffersInFragmentStage}) < 2`\n      );\n    }\n  }\n\n  skipIfReadOpsOrWriteOpsUsesStorageBufferInFragmentStageAndNoSupportStorageBuffersInFragmentShaders(\n    readOp: ReadOp | readonly ReadOp[],\n    writeOp: WriteOp | readonly WriteOp[]\n  ) {\n    if (this.isCompatibility) {\n      const readOps = Array.isArray(readOp) ? readOp : [readOp];\n      const writeOps = Array.isArray(writeOp) ? writeOp : [writeOp];\n      const readOpsUseStorageBuffersInFragmentStage = readOps.reduce(\n        (uses, op) => uses || readOpUsesStorageBufferInFragmentShader(op),\n        false\n      );\n      const writeOpsUseStorageBuffersInFragmentStage = writeOps.reduce(\n        (uses, op) => uses || writeOpUsesStorageBufferInFragmentShader(op),\n        false\n      );\n      const usesStorageBuffersInFragmentStage =\n        readOpsUseStorageBuffersInFragmentStage || writeOpsUseStorageBuffersInFragmentStage;\n      this.skipIf(\n        usesStorageBuffersInFragmentStage &&\n          !(this.device.limits.maxStorageBuffersInFragmentStage! >= 2),\n        `maxStorageBuffersInFragmentStage(${this.device.limits.maxStorageBuffersInFragmentStage}) < 2`\n      );\n    }\n  }\n\n  // These intermediate buffers/textures are created before any read/write op\n  // to avoid extra memory synchronization between ops introduced by await on buffer/texture creations.\n  // Create extra buffers/textures needed by write operation\n  async createIntermediateBuffersAndTexturesForWriteOp(\n    writeOp: WriteOp,\n    slot: number,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'b2b-copy':\n        this.tmpValueBuffers[slot] = await this.createBufferWithValue(value);\n        break;\n      case 't2b-copy':\n        this.tmpValueTextures[slot] = await this.createTextureWithValue(value);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Create extra buffers/textures needed by read operation\n  async createBuffersForReadOp(readOp: ReadOp, srcValue: number, opValue: number) {\n    // This helps create values that will be written into dst buffer by the readop\n    switch (readOp) {\n      case 'input-index':\n        // The index buffer will be the src buffer of the read op.\n        // The src value for readOp will be 0\n        // If the index buffer value is 0, the src value is written into the dst buffer.\n        // If the index buffer value is 1, the op value is written into the dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([srcValue, opValue]);\n        break;\n      case 'input-indirect':\n        // The indirect buffer for the draw cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the op value in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        break;\n      case 'input-indirect-index':\n        // The indirect buffer for draw indexed cmd will be the src buffer of the read op.\n        // If the first value in the indirect buffer is 1, then the opValue in vertex buffer will be written into dst buffer.\n        // If the first value in indirect buffer is 0, then nothing will be write into dst buffer.\n        this.vertexBuffer = await this.createBufferWithValues([opValue]);\n        this.indexBuffer = await this.createBufferWithValues([0]);\n        break;\n      default:\n        break;\n    }\n\n    let srcBuffer: GPUBuffer;\n    switch (readOp) {\n      case 'input-indirect':\n        // vertexCount = {0, 1}\n        // instanceCount = 1\n        // firstVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0]);\n        break;\n      case 'input-indirect-index':\n        // indexCount = {0, 1}\n        // instanceCount = 1\n        // firstIndex = 0\n        // baseVertex = 0\n        // firstInstance = 0\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 0, 0, 0]);\n        break;\n      case 'input-indirect-dispatch':\n        // workgroupCountX = {0, 1}\n        // workgroupCountY = 1\n        // workgroupCountZ = 1\n        srcBuffer = await this.createBufferWithValues([srcValue, 1, 1]);\n        break;\n      default:\n        srcBuffer = await this.createBufferWithValue(srcValue);\n        break;\n    }\n\n    const dstBuffer = this.createBufferTracked({\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n\n    return { srcBuffer, dstBuffer };\n  }\n\n  // Create a buffer with 1 uint32 element, and initialize it to a specified value.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a buffer, and initialize it to the specified values.\n  async createBufferWithValues(initValues: number[]): Promise<GPUBuffer> {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: Uint32Array.BYTES_PER_ELEMENT * initValues.length,\n      usage:\n        GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT |\n        GPUBufferUsage.UNIFORM,\n    });\n    const bufferView = new Uint32Array(buffer.getMappedRange());\n    bufferView.set(initValues);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a 1x1 texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const data = new Uint32Array(1).fill(initValue);\n    const texture = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    this.device.queue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: 256, rowsPerImage: 1 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    await this.queue.onSubmittedWorkDone();\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @compute @workgroup_size(1) fn main() {\n        data.a = ${value}u;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createTrivialRenderPipeline(wgslShaders: { vertex: string; fragment: string }) {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = ${value}u;\n        return vec4<f32>();  // result does't matter\n      }\n    `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    }).createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view,\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via BufferToBuffer copy.\n  encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpBuffer = this.tmpValueBuffers[slot];\n    assert(tmpBuffer !== undefined);\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, slot: number) {\n    const tmpTexture = this.tmpValueTextures[slot];\n    assert(tmpTexture !== undefined);\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const data = new Uint32Array(1).fill(value);\n    this.device.queue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  encodeWriteOp(\n    helper: OperationContextHelper,\n    operation: WriteOp,\n    context: OperationContext,\n    buffer: GPUBuffer,\n    writeOpSlot: number,\n    value: number\n  ) {\n    helper.ensureContext(context);\n\n    switch (operation) {\n      case 'write-buffer':\n        this.writeByWriteBuffer(buffer, value);\n        break;\n      case 'storage':\n        switch (context) {\n          case 'render-pass-encoder':\n            assert(helper.renderPassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderPassEncoder, buffer, value);\n            break;\n          case 'render-bundle-encoder':\n            assert(helper.renderBundleEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInRenderPass(helper.renderBundleEncoder, buffer, value);\n            break;\n          case 'compute-pass-encoder':\n            assert(helper.computePassEncoder !== undefined);\n            this.encodeWriteAsStorageBufferInComputePass(helper.computePassEncoder, buffer, value);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByB2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      case 't2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeWriteByT2BCopy(helper.commandEncoder, buffer, writeOpSlot);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  // Create a compute pipeline: read from src buffer and write it into the storage buffer.\n  createStorageReadComputePipeline(): GPUComputePipeline {\n    const wgslCompute = `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read> srcData : Data;\n      @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n      @compute @workgroup_size(1) fn main() {\n        dstData.a = srcData.a;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  createBindGroupSrcDstBuffer(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n  }\n\n  // Create a render pipeline: read from vertex/index buffer and write it into the storage dst buffer at fragment stage.\n  createVertexReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      struct VertexOutput {\n        @builtin(position) position : vec4<f32>,\n        @location(0) @interpolate(flat, either) data : u32,\n      };\n\n      @vertex fn vert_main(@location(0) input: u32) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4<f32>(0.5, 0.5, 0.0, 1.0);\n        output.data = input;\n        return output;\n      }\n      `,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main(@location(0) @interpolate(flat, either) input : u32) -> @location(0) vec4<f32> {\n        data.a = input;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n        buffers: [\n          {\n            arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: 0,\n                format: 'uint32',\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Create a render pipeline: read from uniform buffer and write it into the storage dst buffer at fragment stage.\n  createUniformReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n      struct Data {\n        a : u32\n      };\n\n      @group(0) @binding(0) var<uniform> constant: Data;\n      @group(0) @binding(1) var<storage, read_write> data : Data;\n\n      @fragment fn frag_main() -> @location(0) vec4<f32> {\n        data.a = constant.a;\n        return vec4<f32>();  // result does't matter\n      }\n      `,\n    };\n\n    return this.createTrivialRenderPipeline(wgslShaders);\n  }\n\n  // Create a render pipeline: read from storage src buffer and write it into the storage dst buffer at fragment stage.\n  createStorageReadRenderPipeline(): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: kDummyVertexShader,\n      fragment: `\n        struct Data {\n          a : u32\n        };\n\n        @group(0) @binding(0) var<storage, read> srcData : Data;\n        @group(0) @binding(1) var<storage, read_write> dstData : Data;\n\n        @fragment fn frag_main() -> @location(0) vec4<f32> {\n          dstData.a = srcData.a;\n          return vec4<f32>();  // result does't matter\n        }\n      `,\n    };\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeReadAsStorageBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadComputePipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n  }\n\n  // Write buffer via dispatchWorkgroupsIndirect call in compute pass.\n  encodeReadAsIndirectBufferInComputePass(\n    pass: GPUComputePassEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, dstBuffer);\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroupsIndirect(srcBuffer, 0);\n  }\n\n  // Read as vertex input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsVertexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, srcBuffer);\n    renderer.draw(1);\n  }\n\n  // Read as index input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(srcBuffer, 'uint32');\n    renderer.drawIndexed(1);\n  }\n\n  // Read as indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.drawIndirect(srcBuffer, 0);\n  }\n\n  // Read as indexed indirect input and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsIndexedIndirectBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer,\n    vertexBuffer: GPUBuffer,\n    indexBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createVertexReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer: dstBuffer } }],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.setVertexBuffer(0, vertexBuffer);\n    renderer.setIndexBuffer(indexBuffer, 'uint32');\n    renderer.drawIndexedIndirect(srcBuffer, 0);\n  }\n\n  // Read as uniform buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsUniformBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createUniformReadRenderPipeline();\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: srcBuffer } },\n        { binding: 1, resource: { buffer: dstBuffer } },\n      ],\n    });\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1);\n  }\n\n  // Read as storage buffer and write buffer via draw call in render pass. Use bundle if needed.\n  encodeReadAsStorageBufferInRenderPass(\n    renderer: GPURenderPassEncoder | GPURenderBundleEncoder,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    const pipeline = this.createStorageReadRenderPipeline();\n    const bindGroup = this.createBindGroupSrcDstBuffer(pipeline, srcBuffer, dstBuffer);\n\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n  }\n\n  // Read and write via BufferToBuffer copy.\n  encodeReadByB2BCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    // The b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, Uint32Array.BYTES_PER_ELEMENT);\n  }\n\n  // Read and Write texture via BufferToTexture copy.\n  encodeReadByB2TCopy(encoder: GPUCommandEncoder, srcBuffer: GPUBuffer, dstBuffer: GPUBuffer) {\n    const tmpTexture = this.createTextureTracked({\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    // The b2t copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToTexture(\n      { buffer: srcBuffer, bytesPerRow: 256 },\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n    // The t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: dstBuffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  encodeReadOp(\n    helper: OperationContextHelper,\n    operation: ReadOp,\n    context: OperationContext,\n    srcBuffer: GPUBuffer,\n    dstBuffer: GPUBuffer\n  ) {\n    helper.ensureContext(context);\n\n    const renderer =\n      context === 'render-bundle-encoder' ? helper.renderBundleEncoder : helper.renderPassEncoder;\n    const computePass = context === 'compute-pass-encoder' ? helper.computePassEncoder : undefined;\n\n    switch (operation) {\n      case 'input-vertex':\n        // The srcBuffer is used as vertexBuffer.\n        // draw writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        this.encodeReadAsVertexBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'input-index':\n        // The srcBuffer is used as indexBuffer.\n        // With this vertexBuffer, drawIndexed writes the same value in srcBuffer[0] to dstBuffer[0].\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndexBufferInRenderPass(renderer, srcBuffer, dstBuffer, this.vertexBuffer);\n        break;\n      case 'input-indirect':\n        // The srcBuffer is used as indirectBuffer for drawIndirect.\n        // srcBuffer[0] = 0 or 1 (vertexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        this.encodeReadAsIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer\n        );\n        break;\n      case 'input-indirect-index':\n        // The srcBuffer is used as indirectBuffer for drawIndexedIndirect.\n        // srcBuffer[0] = 0 or 1 (indexCount), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(renderer !== undefined);\n        assert(this.vertexBuffer !== undefined);\n        assert(this.indexBuffer !== undefined);\n        this.encodeReadAsIndexedIndirectBufferInRenderPass(\n          renderer,\n          srcBuffer,\n          dstBuffer,\n          this.vertexBuffer,\n          this.indexBuffer\n        );\n        break;\n      case 'input-indirect-dispatch':\n        // The srcBuffer is used as indirectBuffer for dispatch.\n        // srcBuffer[0] = 0 or 1 (workgroupCountX), which will decide the value written into dstBuffer to be either 0 or 1.\n        assert(computePass !== undefined);\n        this.encodeReadAsIndirectBufferInComputePass(computePass, srcBuffer, dstBuffer, 1);\n        break;\n      case 'constant-uniform':\n        // The srcBuffer is used as uniform buffer.\n        assert(renderer !== undefined);\n        this.encodeReadAsUniformBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n        break;\n      case 'storage-read':\n        switch (context) {\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder':\n            assert(renderer !== undefined);\n            this.encodeReadAsStorageBufferInRenderPass(renderer, srcBuffer, dstBuffer);\n            break;\n          case 'compute-pass-encoder':\n            assert(computePass !== undefined);\n            this.encodeReadAsStorageBufferInComputePass(computePass, srcBuffer, dstBuffer);\n            break;\n          default:\n            unreachable();\n        }\n        break;\n      case 'b2b-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2BCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      case 'b2t-copy':\n        assert(helper.commandEncoder !== undefined);\n        this.encodeReadByB2TCopy(helper.commandEncoder, srcBuffer, dstBuffer);\n        break;\n      default:\n        unreachable();\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    // This is not hot in profiles; optimize if this gets used more heavily.\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectGPUBufferValuesPassCheck(\n      buffer,\n      a => checkElementsEqualEither(a, [bufferData1, bufferData2]),\n      { type: Uint32Array, typedLength: 1 }\n    );\n  }\n}\n"],"mappings":"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"}