{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/buffer/buffer_sync_test.ts"],"names":["assert","GPUTest","checkElementsEqualEither","kSize","kAllWriteOps","BufferSyncTest","createBufferWithValue","initValue","buffer","device","createBuffer","mappedAtCreation","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","Uint32Array","getMappedRange","fill","unmap","queue","onSubmittedWorkDone","createTextureWithValue","data","texture","createTexture","width","height","depthOrArrayLayers","format","GPUTextureUsage","writeTexture","mipLevel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createStorageWriteComputePipeline","value","wgslCompute","createComputePipeline","compute","module","createShaderModule","code","entryPoint","createStorageWriteRenderPipeline","wgslShaders","vertex","fragment","createRenderPipeline","targets","primitive","topology","beginSimpleRenderPass","encoder","view","RENDER_ATTACHMENT","createView","beginRenderPass","colorAttachments","loadValue","r","g","b","a","storeOp","encodeWriteAsStorageBufferInRenderPass","inBundle","bindGroup","pass","renderer","createRenderBundleEncoder","colorFormats","setBindGroup","setPipeline","draw","executeBundles","finish","endPass","encodeWriteAsStorageBufferInComputePass","beginComputePass","dispatch","encodeWriteByB2BCopy","tmpBuffer","copyBufferToBuffer","encodeWriteByT2BCopy","tmpTexture","copyTextureToBuffer","writeByWriteBuffer","writeBuffer","encodeWriteOp","writeOp","createCommandBufferWithWriteOp","createCommandEncoder","submitWriteOp","submit","verifyData","expectedValue","bufferData","expectGPUBufferValuesEqual","verifyDataTwoValidValues","expectedValue1","expectedValue2","bufferData1","bufferData2","expectGPUBufferValuesPassCheck","type","typedLength"],"mappings":"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","sourcesContent":["import { assert } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { checkElementsEqualEither } from '../../../../util/check_contents.js';\n\nconst kSize = 4;\n\nexport const kAllWriteOps = ['render', 'render-via-bundle', 'compute', 'b2b-copy', 't2b-copy'];\n\n// Note: If it would be useful to have any of these helpers be separate from the fixture,\n// they can be refactored into standalone functions.\nexport class BufferSyncTest extends GPUTest {\n  // Create a buffer, and initialize it to a specified value for all elements.\n  async createBufferWithValue(initValue: number): Promise<GPUBuffer> {\n    const buffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: kSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n    new Uint32Array(buffer.getMappedRange()).fill(initValue);\n    buffer.unmap();\n    await this.queue.onSubmittedWorkDone();\n    return buffer;\n  }\n\n  // Create a texture, and initialize it to a specified value for all elements.\n  async createTextureWithValue(initValue: number): Promise<GPUTexture> {\n    const data = new Uint32Array(kSize / 4).fill(initValue);\n    const texture = this.device.createTexture({\n      size: { width: kSize / 4, height: 1, depthOrArrayLayers: 1 },\n      format: 'r32uint',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    this.device.queue.writeTexture(\n      { texture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      data,\n      { offset: 0, bytesPerRow: kSize, rowsPerImage: 1 },\n      { width: kSize / 4, height: 1, depthOrArrayLayers: 1 }\n    );\n    await this.queue.onSubmittedWorkDone();\n    return texture;\n  }\n\n  createBindGroup(\n    pipeline: GPURenderPipeline | GPUComputePipeline,\n    buffer: GPUBuffer\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  // Create a compute pipeline and write given data into storage buffer.\n  createStorageWriteComputePipeline(value: number): GPUComputePipeline {\n    const wgslCompute = `\n      [[block]] struct Data {\n        a : i32;\n      };\n\n      [[group(0), binding(0)]] var<storage, read_write> data : Data;\n      [[stage(compute), workgroup_size(1)]] fn main() {\n        data.a = ${value};\n        return;\n      }\n    `;\n\n    return this.device.createComputePipeline({\n      compute: {\n        module: this.device.createShaderModule({\n          code: wgslCompute,\n        }),\n        entryPoint: 'main',\n      },\n    });\n  }\n\n  // Create a render pipeline and write given data into storage buffer at fragment stage.\n  createStorageWriteRenderPipeline(value: number): GPURenderPipeline {\n    const wgslShaders = {\n      vertex: `\n      [[stage(vertex)]] fn vert_main() -> [[builtin(position)]] vec4<f32> {\n        return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n      }\n    `,\n\n      fragment: `\n      [[block]] struct Data {\n        a : i32;\n      };\n\n      [[group(0), binding(0)]] var<storage, read_write> data : Data;\n      [[stage(fragment)]] fn frag_main() -> [[location(0)]] vec4<f32> {\n        data.a = ${value};\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n    `,\n    };\n\n    return this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.vertex,\n        }),\n        entryPoint: 'vert_main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: wgslShaders.fragment,\n        }),\n        entryPoint: 'frag_main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const view = this.device\n      .createTexture({\n        size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n      .createView();\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view,\n          loadValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  // Write buffer via draw call in render pass. Use bundle if needed.\n  encodeWriteAsStorageBufferInRenderPass(\n    encoder: GPUCommandEncoder,\n    buffer: GPUBuffer,\n    value: number,\n    inBundle: boolean\n  ) {\n    const pipeline = this.createStorageWriteRenderPipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n\n    const pass = this.beginSimpleRenderPass(encoder);\n    const renderer = inBundle\n      ? this.device.createRenderBundleEncoder({ colorFormats: ['rgba8unorm'] })\n      : pass;\n    renderer.setBindGroup(0, bindGroup);\n    renderer.setPipeline(pipeline);\n    renderer.draw(1, 1, 0, 0);\n\n    if (inBundle) pass.executeBundles([(renderer as GPURenderBundleEncoder).finish()]);\n    pass.endPass();\n  }\n\n  // Write buffer via dispatch call in compute pass.\n  encodeWriteAsStorageBufferInComputePass(\n    encoder: GPUCommandEncoder,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    const pipeline = this.createStorageWriteComputePipeline(value);\n    const bindGroup = this.createBindGroup(pipeline, buffer);\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(1);\n    pass.endPass();\n  }\n\n  /** Write buffer via BufferToBuffer copy. */\n  async encodeWriteByB2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, value: number) {\n    const tmpBuffer = await this.createBufferWithValue(value);\n\n    // The write operation via b2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyBufferToBuffer(tmpBuffer, 0, buffer, 0, kSize);\n  }\n\n  // Write buffer via TextureToBuffer copy.\n  async encodeWriteByT2BCopy(encoder: GPUCommandEncoder, buffer: GPUBuffer, value: number) {\n    const tmpTexture = await this.createTextureWithValue(value);\n\n    // The write operation via t2b copy is just encoded into command encoder, it doesn't write immediately.\n    encoder.copyTextureToBuffer(\n      { texture: tmpTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer, bytesPerRow: 256 },\n      { width: 1, height: 1, depthOrArrayLayers: 1 }\n    );\n  }\n\n  // Write buffer via writeBuffer API on queue\n  writeByWriteBuffer(buffer: GPUBuffer, value: number) {\n    const data = new Uint32Array(kSize / 4).fill(value);\n    this.device.queue.writeBuffer(buffer, 0, data);\n  }\n\n  // Issue write operation via render pass, compute pass, copy, etc.\n  async encodeWriteOp(\n    encoder: GPUCommandEncoder,\n    writeOp: string,\n    buffer: GPUBuffer,\n    value: number\n  ) {\n    switch (writeOp) {\n      case 'render':\n        this.encodeWriteAsStorageBufferInRenderPass(encoder, buffer, value, false);\n        break;\n      case 'render-via-bundle':\n        this.encodeWriteAsStorageBufferInRenderPass(encoder, buffer, value, true);\n        break;\n      case 'compute':\n        this.encodeWriteAsStorageBufferInComputePass(encoder, buffer, value);\n        break;\n      case 'b2b-copy':\n        await this.encodeWriteByB2BCopy(encoder, buffer, value);\n        break;\n      case 't2b-copy':\n        await this.encodeWriteByT2BCopy(encoder, buffer, value);\n        break;\n      default:\n        assert(false);\n    }\n  }\n\n  async createCommandBufferWithWriteOp(\n    writeOp: string,\n    buffer: GPUBuffer,\n    value: number\n  ): Promise<GPUCommandBuffer> {\n    const encoder = this.device.createCommandEncoder();\n    await this.encodeWriteOp(encoder, writeOp, buffer, value);\n    return encoder.finish();\n  }\n\n  async submitWriteOp(writeOp: string, buffer: GPUBuffer, value: number) {\n    if (writeOp === 'write-buffer') {\n      this.writeByWriteBuffer(buffer, value);\n    } else {\n      const encoder = this.device.createCommandEncoder();\n      await this.encodeWriteOp(encoder, writeOp, buffer, value);\n      this.device.queue.submit([encoder.finish()]);\n    }\n  }\n\n  verifyData(buffer: GPUBuffer, expectedValue: number) {\n    const bufferData = new Uint32Array(1);\n    bufferData[0] = expectedValue;\n    this.expectGPUBufferValuesEqual(buffer, bufferData);\n  }\n\n  verifyDataTwoValidValues(buffer: GPUBuffer, expectedValue1: number, expectedValue2: number) {\n    const bufferData1 = new Uint32Array(1);\n    bufferData1[0] = expectedValue1;\n    const bufferData2 = new Uint32Array(1);\n    bufferData2[0] = expectedValue2;\n    this.expectGPUBufferValuesPassCheck(\n      buffer,\n      a => checkElementsEqualEither(a, [bufferData1, bufferData2]),\n      { type: Uint32Array, typedLength: 1 }\n    );\n  }\n}\n"],"file":"buffer_sync_test.js"}