{"version":3,"file":"buffer.spec.js","names":["makeTestGroup","unreachable","GPUConst","AllFeaturesMaxLimitsGPUTest","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mappable","expectGPUBufferValuesEqual","method","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","layout","compute","module","entryPoint","outputTexture","createTextureTracked","format","size","usage","GPUTextureUsage","STORAGE_BINDING","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatchWorkgroups","end","queue","submit","finish","CheckBufferAndOutputTexture","CreateRenderPipelineForTest","vertexShaderModule","testVertexBuffer","renderPipelineDescriptor","vertex","fragment","createShaderModule","code","targets","primitive","topology","buffers","arrayStride","attributes","shaderLocation","createRenderPipeline","RecordInitializeTextureColor","texture","color","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","bufferSize","outputTextureSize","outputTextureColor","R","G","B","A","expectSingleColor","exp","expectedBufferData","Uint8Array","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","appliedOffset","createBufferTracked","copySize","writeData","i","writeBuffer","mapAsync","readData","getMappedRange","expect","unmap","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","QUERY_RESOLVE","dstBuffer","querySet","createQuerySetTracked","type","count","resolveQuerySet","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","baseArrayLayer","baseMipLevel","r","b","a","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","STORAGE","renderPipeline","vertexBuffer","VERTEX","setVertexBuffer","draw","indexBuffer","INDEX","setIndexBuffer","drawIndexed","test_indexed_draw","kDrawIndirectParametersSize","kDrawIndexedIndirectParametersSize","indirectBuffer","INDIRECT","undefined","drawIndexedIndirect","drawIndirect","kDispatchIndirectParametersSize","dispatchWorkgroupsIndirect"],"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { PerTexelComponent } from '../../../util/texture/texel_data.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends AllFeaturesMaxLimitsGPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): void {\n    const mappable = bufferUsage & GPUBufferUsage.MAP_READ;\n    this.expectGPUBufferValuesEqual(buffer, expectedData, 0, { method: mappable ? 'map' : 'copy' });\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING,\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchWorkgroups(1);\n    computePass.end();\n    this.queue.submit([encoder.finish()]);\n\n    this.CheckBufferAndOutputTexture(buffer, boundBufferSize + bufferOffset, outputTexture);\n  }\n\n  CreateRenderPipelineForTest(\n    vertexShaderModule: GPUShaderModule,\n    testVertexBuffer: boolean\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      layout: 'auto',\n      vertex: {\n        module: vertexShaderModule,\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        @fragment\n        fn main(@location(0) i_color : vec4<f32>) -> @location(0) vec4<f32> {\n            return i_color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    };\n    if (testVertexBuffer) {\n      renderPipelineDescriptor.vertex.buffers = [\n        {\n          arrayStride: 16,\n          attributes: [{ format: 'float32x4', offset: 0, shaderLocation: 0 }],\n        },\n      ];\n    }\n\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  RecordInitializeTextureColor(\n    encoder: GPUCommandEncoder,\n    texture: GPUTexture,\n    color: GPUColor\n  ): void {\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView(),\n          clearValue: color,\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.end();\n  }\n\n  CheckBufferAndOutputTexture(\n    buffer: GPUBuffer,\n    bufferSize: number,\n    outputTexture: GPUTexture,\n    outputTextureSize: [number, number, number] = [1, 1, 1],\n    outputTextureColor: PerTexelComponent<number> = { R: 0.0, G: 1.0, B: 0.0, A: 1.0 }\n  ): void {\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: outputTextureSize,\n      exp: outputTextureColor,\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    this.expectGPUBufferValuesEqual(buffer, expectedBufferData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const textureSize: [number, number, number] = [8, 8, 1];\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.createTextureTracked({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', textureSize);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.createBufferTracked({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(srcBuffer, srcBufferSize, dstTexture, textureSize, {\n      R: 0.0,\n      G: 0.0,\n      B: 0.0,\n      A: 0.0,\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.createQuerySetTracked({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.createTextureTracked({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.createBufferTracked({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            clearValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.end();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination buffer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.createBufferTracked({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  struct UBO {\n    value : vec4<u32>\n  };\n  @group(0) @binding(0) var<uniform> ubo : UBO;\n  @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  @compute @workgroup_size(1) fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.createBufferTracked({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n      value : vec4<u32>\n    };\n    @group(0) @binding(0) var<storage, read> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.createBufferTracked({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    struct SSBO {\n      value : vec4<u32>\n    };\n    @group(0) @binding(0) var<storage, read_write> ssbo : SSBO;\n    @group(0) @binding(1) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(1) fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('vertex_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a vertex buffer just after the creation of that\n  GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n      struct VertexOut {\n        @location(0) color : vec4<f32>,\n        @builtin(position) position : vec4<f32>,\n      };\n\n      @vertex fn main(@location(0) pos : vec4<f32>) -> VertexOut {\n        var output : VertexOut;\n        if (all(pos == vec4<f32>(0.0, 0.0, 0.0, 0.0))) {\n          output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        } else {\n          output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n        output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        return output;\n      }`,\n      }),\n      true\n    );\n\n    const bufferSize = 16 + bufferOffset;\n    const vertexBuffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer, bufferOffset);\n    renderPass.setPipeline(renderPipeline);\n    renderPass.draw(1);\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(vertexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('index_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as an index buffer just after the creation of that\nGPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>,\n      @builtin(position) position : vec4<f32>,\n    };\n\n    @vertex\n    fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOut {\n      var output : VertexOut;\n      if (VertexIndex == 0u) {\n        output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      } else {\n        output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    // The size of GPUBuffer must be at least 4.\n    const bufferSize = 4 + bufferOffset;\n    const indexBuffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', bufferOffset, 4);\n    renderPass.drawIndexed(1);\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(indexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_draw_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for drawIndirect() or\ndrawIndexedIndirect() just after the creation of that GPUBuffer, all the contents in that GPUBuffer\nhave been initialized to 0.`\n  )\n  .params(u =>\n    u.combine('test_indexed_draw', [true, false]).beginSubcases().combine('bufferOffset', [0, 16])\n  )\n  .fn(t => {\n    const { test_indexed_draw, bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      @location(0) color : vec4<f32>,\n      @builtin(position) position : vec4<f32>,\n    };\n\n    @vertex fn main() -> VertexOut {\n      var output : VertexOut;\n      output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    const kDrawIndirectParametersSize = 16;\n    const kDrawIndexedIndirectParametersSize = 20;\n    const bufferSize =\n      Math.max(kDrawIndirectParametersSize, kDrawIndexedIndirectParametersSize) + bufferOffset;\n    const indirectBuffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n\n    let indexBuffer = undefined;\n    if (test_indexed_draw) {\n      indexBuffer = t.createBufferTracked({\n        size: 4,\n        usage: GPUBufferUsage.INDEX,\n      });\n      renderPass.setIndexBuffer(indexBuffer, 'uint16');\n      renderPass.drawIndexedIndirect(indirectBuffer, bufferOffset);\n    } else {\n      renderPass.drawIndirect(indirectBuffer, bufferOffset);\n    }\n\n    renderPass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the render pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_dispatch_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for dispatchWorkgroupsIndirect() just\n    after the creation of that GPUBuffer, all the contents in that GPUBuffer have been initialized\n    to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(t => {\n    const { bufferOffset } = t.params;\n\n    const computePipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n        @group(0) @binding(0) var outImage : texture_storage_2d<rgba8unorm, write>;\n\n        @compute @workgroup_size(1) fn main() {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }`,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const kDispatchIndirectParametersSize = 12;\n    const bufferSize = kDispatchIndirectParametersSize + bufferOffset;\n    const indirectBuffer = t.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        GPUTextureUsage.RENDER_ATTACHMENT |\n        GPUTextureUsage.STORAGE_BINDING,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    // The indirect buffer should be lazily cleared to 0, so we actually don't execute the compute\n    // shader and the output texture should keep its original color (green).\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchWorkgroupsIndirect(indirectBuffer, bufferOffset);\n    computePass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the compute pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n"],"mappings":"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"}