{"version":3,"file":"command_buffer_maker.js","names":["kRenderEncodeTypes","kProgrammableEncoderTypes","kEncoderTypes","CommandBufferMaker","constructor","t","encoder","finish","validateFinish","shouldSucceed","expectGPUError","validateFinishAndSubmit","shouldBeValid","submitShouldSucceedIfValid","commandBuffer","expectValidationError","queue","submit","validateFinishAndSubmitGivenState","resourceState"],"sources":["../../../src/webgpu/util/command_buffer_maker.ts"],"sourcesContent":["import { ResourceState, GPUTestBase } from '../gpu_test.js';\n\nexport const kRenderEncodeTypes = ['render pass', 'render bundle'] as const;\nexport type RenderEncodeType = (typeof kRenderEncodeTypes)[number];\nexport const kProgrammableEncoderTypes = ['compute pass', ...kRenderEncodeTypes] as const;\nexport type ProgrammableEncoderType = (typeof kProgrammableEncoderTypes)[number];\nexport const kEncoderTypes = ['non-pass', ...kProgrammableEncoderTypes] as const;\nexport type EncoderType = (typeof kEncoderTypes)[number];\n\n// Look up the type of the encoder based on `T`. If `T` is a union, this will be too!\ntype EncoderByEncoderType<T extends EncoderType> = {\n  'non-pass': GPUCommandEncoder;\n  'compute pass': GPUComputePassEncoder;\n  'render pass': GPURenderPassEncoder;\n  'render bundle': GPURenderBundleEncoder;\n}[T];\n\n/** See {@link webgpu/api/validation/validation_test.ValidationTest.createEncoder |\n * GPUTest.createEncoder()}. */\nexport class CommandBufferMaker<T extends EncoderType> {\n  /** `GPU___Encoder` for recording commands into. */\n  // Look up the type of the encoder based on `T`. If `T` is a union, this will be too!\n  readonly encoder: EncoderByEncoderType<T>;\n\n  /**\n   * Finish any passes, finish and record any bundles, and finish/return the command buffer. Any\n   * errors are ignored and the GPUCommandBuffer (which may be an error buffer) is returned.\n   */\n  readonly finish: () => GPUCommandBuffer;\n\n  /**\n   * Finish any passes, finish and record any bundles, and finish/return the command buffer.\n   * Checks for validation errors in (only) the appropriate finish call.\n   */\n  readonly validateFinish: (shouldSucceed: boolean) => GPUCommandBuffer;\n\n  /**\n   * Finish the command buffer and submit it. Checks for validation errors in either the submit or\n   * the appropriate finish call, depending on the state of a resource used in the encoding.\n   */\n  readonly validateFinishAndSubmit: (\n    shouldBeValid: boolean,\n    submitShouldSucceedIfValid: boolean\n  ) => void;\n\n  /**\n   * `validateFinishAndSubmit()` based on the state of a resource in the command encoder.\n   * - `finish()` should fail if the resource is 'invalid'.\n   * - Only `submit()` should fail if the resource is 'destroyed'.\n   */\n  readonly validateFinishAndSubmitGivenState: (resourceState: ResourceState) => void;\n\n  constructor(\n    t: GPUTestBase,\n    encoder: EncoderByEncoderType<EncoderType>,\n    finish: () => GPUCommandBuffer\n  ) {\n    // TypeScript introduces an intersection type here where we don't want one.\n    this.encoder = encoder as EncoderByEncoderType<T>;\n    this.finish = finish;\n\n    // Define extra methods like this, otherwise they get unbound when destructured, e.g.:\n    //   const { encoder, validateFinishAndSubmit } = t.createEncoder(type);\n    // Alternatively, do not destructure, and call member functions, e.g.:\n    //   const encoder = t.createEncoder(type);\n    //   encoder.validateFinish(true);\n    this.validateFinish = (shouldSucceed: boolean) => {\n      return t.expectGPUError('validation', this.finish, !shouldSucceed);\n    };\n\n    this.validateFinishAndSubmit = (\n      shouldBeValid: boolean,\n      submitShouldSucceedIfValid: boolean\n    ) => {\n      const commandBuffer = this.validateFinish(shouldBeValid);\n      if (shouldBeValid) {\n        t.expectValidationError(() => t.queue.submit([commandBuffer]), !submitShouldSucceedIfValid);\n      }\n    };\n\n    this.validateFinishAndSubmitGivenState = (resourceState: ResourceState) => {\n      this.validateFinishAndSubmit(resourceState !== 'invalid', resourceState !== 'destroyed');\n    };\n  }\n}\n"],"mappings":";;GAEA,OAAO,MAAMA,kBAAkB,GAAG,CAAC,aAAa,EAAE,eAAe,CAAU;;AAE3E,OAAO,MAAMC,yBAAyB,GAAG,CAAC,cAAc,EAAE,GAAGD,kBAAkB,CAAU;;AAEzF,OAAO,MAAME,aAAa,GAAG,CAAC,UAAU,EAAE,GAAGD,yBAAyB,CAAU;;;AAGhF;;;;;;;;AAQA;AACA;AACA,OAAO,MAAME,kBAAkB,CAAwB;EACrD;EACA;;;EAGA;AACF;AACA;AACA;;;EAGE;AACF;AACA;AACA;;;EAGE;AACF;AACA;AACA;;;;;;EAME;AACF;AACA;AACA;AACA;;;EAGEC,WAAWA;EACTC,CAAc;EACdC,OAA0C;EAC1CC,MAA8B;EAC9B;IACA;IACA,IAAI,CAACD,OAAO,GAAGA,OAAkC;IACjD,IAAI,CAACC,MAAM,GAAGA,MAAM;;IAEpB;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,cAAc,GAAG,CAACC,aAAsB,KAAK;MAChD,OAAOJ,CAAC,CAACK,cAAc,CAAC,YAAY,EAAE,IAAI,CAACH,MAAM,EAAE,CAACE,aAAa,CAAC;IACpE,CAAC;;IAED,IAAI,CAACE,uBAAuB,GAAG;IAC7BC,aAAsB;IACtBC,0BAAmC;IAChC;MACH,MAAMC,aAAa,GAAG,IAAI,CAACN,cAAc,CAACI,aAAa,CAAC;MACxD,IAAIA,aAAa,EAAE;QACjBP,CAAC,CAACU,qBAAqB,CAAC,MAAMV,CAAC,CAACW,KAAK,CAACC,MAAM,CAAC,CAACH,aAAa,CAAC,CAAC,EAAE,CAACD,0BAA0B,CAAC;MAC7F;IACF,CAAC;;IAED,IAAI,CAACK,iCAAiC,GAAG,CAACC,aAA4B,KAAK;MACzE,IAAI,CAACR,uBAAuB,CAACQ,aAAa,KAAK,SAAS,EAAEA,aAAa,KAAK,WAAW,CAAC;IAC1F,CAAC;EACH;AACF"}