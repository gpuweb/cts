{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","unreachable","Float16Array","kValue","reinterpretF32AsU32","reinterpretU32AsF32","cartesianProduct","correctlyRoundedF16","correctlyRoundedF32","flushSubnormalNumberF32","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","oneULP","F32Interval","constructor","bounds","begin","end","length","Number","isNaN","isPoint","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","i","toF32Interval","containsZeroOrSubnormals","f32","subnormal","negative","min","positive","max","isFinite","span","intervals","forEach","Math","toString","any","_any","undefined","serializeF32Interval","deserializeF32Interval","data","Array","kNegPiToPiInterval","pi","whole","kGreaterThanZeroInterval","isF32Vector","v","toF32Vector","f","map","kZeroVector","kAnyVector","spanF32Vector","vectors","vector_length","every","e","_","idx","multiplyVectorByScalar","c","x","multiplicationInterval","addFlushedIfNeededF32","values","some","concat","addFlushedIfNeededF16","limitPointToIntervalDomain","domain","impl","limitBinaryToIntervalDomain","y","d","roundAndFlushPointToInterval","op","inputs","results","Set","roundAndFlushBinaryToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","roundAndFlushVectorToInterval","x_rounded","x_flushed","roundAndFlushVectorPairToInterval","y_rounded","y_flushed","roundAndFlushVectorToVector","interval_vectors","roundAndFlushVectorPairToVector","runPointToIntervalOp","extrema","result","b","runBinaryToIntervalOp","outputs","runTernaryToIntervalOp","runVectorToIntervalOp","runVectorPairToIntervalOp","runVectorToVectorOp","runPointToIntervalOpComponentWise","runVectorPairToVectorOp","runBinaryToIntervalOpComponentWise","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","AbsoluteErrorIntervalOp","error_range","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","ulpInterval","AbsIntervalOp","absInterval","AcosIntervalOp","sqrtInterval","subtractionInterval","atan2Interval","acosInterval","acoshIntervals","acoshAlternativeInterval","acoshPrimaryInterval","AcoshAlternativeIntervalOp","inner_value","additionInterval","sqrt_value","logInterval","AcoshPrimaryIntervalOp","AdditionIntervalOp","AsinIntervalOp","asinInterval","AsinhIntervalOp","asinhInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","atan_yx","divisionInterval","AtanhIntervalOp","numerator","denominator","log_interval","atanhInterval","CeilIntervalOp","ceil","ceilInterval","ClampMedianIntervalOp","sort","a","clampIntervals","clampMinMaxInterval","clampMedianInterval","ClampMinMaxIntervalOp","low","high","CosIntervalOp","cos","cosInterval","CoshIntervalOp","minus_n","negationInterval","expInterval","coshInterval","CrossIntervalOp","r0","r1","r2","crossInterval","DegreesIntervalOp","degreesInterval","DistanceIntervalScalarOp","lengthInterval","DistanceIntervalVectorOp","SubtractionIntervalOp","distanceInterval","DivisionIntervalOp","DotIntervalOp","multiplications","MultiplicationIntervalOp","reduce","previous","current","dotInterval","ExpIntervalOp","exp","Exp2IntervalOp","pow","exp2Interval","faceForwardIntervals","x_vec","positive_x","negative_x","NegationIntervalOp","dot_interval","push","FloorIntervalOp","floor","floorInterval","FmaIntervalOp","fmaInterval","FractIntervalOp","less_than_one","fractInterval","InverseSqrtIntervalOp","sqrt","inverseSqrtInterval","LdexpIntervalOp","e1","e2","ldexpInterval","LengthIntervalScalarOp","LengthIntervalVectorOp","LogIntervalOp","log","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","maxInterval","MinIntervalOp","minInterval","MixImpreciseIntervalOp","t","mixIntervals","mixImpreciseInterval","mixPreciseInterval","MixPreciseIntervalOp","s","MultiplicationInnerOp","NormalizeIntervalOp","normalizeInterval","PowIntervalOp","powInterval","QuantizeToF16IntervalOp","rounded","flushed","quantizeToF16Interval","RadiansIntervalOp","radiansInterval","ReflectIntervalOp","rhs","reflectInterval","refractInterval","r","r_squared","dot","dot_squared","one_minus_dot_squared","k","dot_times_r","k_sqrt","RemainderIntervalOp","truncInterval","remainderInterval","RoundIntervalOp","diff_before","diff_after","roundInterval","saturateInterval","SignIntervalOp","signInterval","SinIntervalOp","sin","sinInterval","SinhIntervalOp","sinhInterval","SmoothStepOp","smoothStepInterval","SqrtIntervalOp","StepIntervalOp","edge","stepInterval","TanIntervalOp","tanInterval","TanhIntervalOp","tanhInterval","TruncIntervalOp","trunc","unpackData","ArrayBuffer","unpackDataU32","Uint32Array","unpackDataU16","Uint16Array","unpackDataU8","Uint8Array","unpackDataI16","Int16Array","unpackDataI8","Int8Array","unpackDataF16","unpack2x16floatInterval","u32","Unpack2x16snormIntervalOp","unpack2x16snormInterval","Unpack2x16unormIntervalOp","unpack2x16unormInterval","Unpack4x8snormIntervalOp","unpack4x8snormInterval","Unpack4x8unormIntervalOp","unpack4x8unormInterval"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kValue } from './constants.js';\nimport { reinterpretF32AsU32, reinterpretU32AsF32 } from './conversion.js';\nimport {\n  cartesianProduct,\n  correctlyRoundedF16,\n  correctlyRoundedF32,\n  flushSubnormalNumberF32,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  oneULP,\n} from './math.js';\n\n/**\n * Representation of bounds for an interval as an array with either one or two\n * elements. Single element indicates that the interval is a single point. For\n * two elements, the first is the lower bound of the interval and the second is\n * the upper bound.\n */\nexport type IntervalBounds = [number] | [number, number];\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _any: F32Interval;\n\n  /** Constructor\n   *\n   * @param bounds either a pair of numbers indicating the beginning then the\n   *               end of the interval, or a single element array indicating the\n   *               interval is a point\n   */\n  public constructor(...bounds: IntervalBounds) {\n    const [begin, end] = bounds.length === 2 ? bounds : [bounds[0], bounds[0]];\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns begin and end if non-point interval, otherwise just begin */\n  public bounds(): IntervalBounds {\n    return this.isPoint() ? [this.begin] : [this.begin, this.end];\n  }\n\n  /** @returns if a point or interval is completely contained by this interval */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the any interval indicates that accuracy is not defined for this\n      // test, so the test is just checking that this input doesn't cause the\n      // implementation to misbehave, so NaN is accepted.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toF32Interval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if any values in the interval may be flushed to zero, this\n   *           includes any subnormals and zero itself.\n   */\n  public containsZeroOrSubnormals(): boolean {\n    return !(\n      this.end < kValue.f32.subnormal.negative.min || this.begin > kValue.f32.subnormal.positive.max\n    );\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains f32 finite values */\n  public isFinite(): boolean {\n    return isFiniteF32(this.begin) && isFiniteF32(this.end);\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.bounds()}]`;\n  }\n\n  /** @returns a singleton for interval of all possible values\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static any(): F32Interval {\n    if (this._any === undefined) {\n      this._any = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._any;\n  }\n}\n\n/**\n * SerializedF32Interval holds the serialized form of a F32Interval.\n * This form can be safely encoded to JSON.\n */\nexport type SerializedF32Interval = { begin: number; end: number } | 'any';\n\n/** serializeF32Interval() converts a F32Interval to a SerializedF32Interval */\nexport function serializeF32Interval(i: F32Interval): SerializedF32Interval {\n  return i === F32Interval.any()\n    ? 'any'\n    : { begin: reinterpretF32AsU32(i.begin), end: reinterpretF32AsU32(i.end) };\n}\n\n/** serializeF32Interval() converts a SerializedF32Interval to a F32Interval */\nexport function deserializeF32Interval(data: SerializedF32Interval): F32Interval {\n  return data === 'any'\n    ? F32Interval.any()\n    : new F32Interval(reinterpretU32AsF32(data.begin), reinterpretU32AsF32(data.end));\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toF32Interval(n: number | IntervalBounds | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n\n  if (n instanceof Array) {\n    return new F32Interval(...n);\n  }\n\n  return new F32Interval(n, n);\n}\n\n/** F32Interval of [-, ] */\nconst kNegPiToPiInterval = new F32Interval(\n  kValue.f32.negative.pi.whole,\n  kValue.f32.positive.pi.whole\n);\n\n/** F32Interval of values greater than 0 and less than or equal to f32 max */\nconst kGreaterThanZeroInterval = new F32Interval(\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.positive.max\n);\n\n/** Representation of a vec2/3/4 of floating point intervals as an array of F32Intervals */\ntype F32Vector =\n  | [F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval, F32Interval];\n\n/** Coerce F32Interval[] to F32Vector if possible */\nfunction isF32Vector(v: number[] | IntervalBounds[] | F32Interval[] | F32Vector): v is F32Vector {\n  if (v[0] instanceof F32Interval) {\n    return v.length === 2 || v.length === 3 || v.length === 4;\n  }\n  return false;\n}\n\n/** @returns an F32Vector representation of an array fo F32Intervals if possible */\nexport function toF32Vector(v: number[] | IntervalBounds[] | F32Interval[] | F32Vector): F32Vector {\n  if (isF32Vector(v)) {\n    return v;\n  }\n\n  const f = v.map(toF32Interval);\n  if (isF32Vector(f)) {\n    return f;\n  }\n  unreachable(`Cannot convert [${v}] to F32Vector`);\n}\n\n/** F32Vector with all zero elements */\nconst kZeroVector = {\n  2: toF32Vector([0, 0]),\n  3: toF32Vector([0, 0, 0]),\n  4: toF32Vector([0, 0, 0, 0]),\n};\n\n/** F32Vector with all F32Interval.any() elements */\nconst kAnyVector = {\n  2: toF32Vector([F32Interval.any(), F32Interval.any()]),\n  3: toF32Vector([F32Interval.any(), F32Interval.any(), F32Interval.any()]),\n  4: toF32Vector([F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()]),\n};\n\n/**\n * @returns a F32Vector where each element is the span for corresponding\n *          elements at the same index in the input vectors\n */\nfunction spanF32Vector(...vectors: F32Vector[]): F32Vector {\n  const vector_length = vectors[0].length;\n  assert(\n    vectors.every(e => e.length === vector_length),\n    `Vector span is not defined for vectors of differing lengths`\n  );\n\n  // The outer map is doing the walk across a single F32Vector to get the indices to use.\n  // The inner map is doing the walk across the of the vector array, collecting the value of each vector at the\n  // index, then spanning them down to a single F32Interval.\n  // The toF32Vector coerces things at the end to be a F32Vector, because the outer .map() will actually return a\n  // F32Interval[]\n  return toF32Vector(\n    vectors[0].map((_, idx) => {\n      return F32Interval.span(...vectors.map(v => v[idx]));\n    })\n  );\n}\n\n/**\n * @retuns the vector result of multiplying the given vector by the given scalar\n */\nfunction multiplyVectorByScalar(v: number[], c: number | F32Interval): F32Vector {\n  return toF32Vector(v.map(x => multiplicationInterval(x, c)));\n}\n\n/**\n * @returns the input plus zero if any of the entries are f32 subnormal,\n * otherwise returns the input.\n */\nfunction addFlushedIfNeededF32(values: number[]): number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF32(v)) ? values.concat(0) : values;\n}\n\n/**\n * @returns the input plus zero if any of the entries are f16 subnormal,\n * otherwise returns the input\n */\nfunction addFlushedIfNeededF16(values: number[]): number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF16(v)) ? values.concat(0) : values;\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\nexport interface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: PointToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by runPointToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * Restrict the inputs to an PointToInterval operation\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain interval to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a PointToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitPointToIntervalDomain(domain: F32Interval, impl: PointToInterval): PointToInterval {\n  return (n: number): F32Interval => {\n    return domain.contains(n) ? impl(n) : F32Interval.any();\n  };\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: BinaryToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runBinaryToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/** Domain for a BinaryToInterval implementation */\ninterface BinaryToIntervalDomain {\n  x: F32Interval;\n  // y is an array to support handling domains composed of discrete intervals\n  y: F32Interval[];\n}\n\n/**\n * Restrict the inputs to a BinaryToInterval\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain set of intervals to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a BinaryToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitBinaryToIntervalDomain(\n  domain: BinaryToIntervalDomain,\n  impl: BinaryToInterval\n): BinaryToInterval {\n  return (x: number, y: number): F32Interval => {\n    if (!domain.x.contains(x)) {\n      return F32Interval.any();\n    }\n\n    if (!domain.y.some(d => d.contains(y))) {\n      return F32Interval.any();\n    }\n\n    return impl(x, y);\n  };\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: TernaryToInterval;\n}\n\n// Currently PointToVector is not integrated with the rest of the floating point\n// framework, because the only builtins that use it are actually\n// u32 -> [f32, f32, f32, f32] functions, so the whole rounding and interval\n// process doesn't get applied to the inputs.\n// They do use the framework internally by invoking divisionInterval on segments\n// of the input.\n/**\n * A function that converts a point to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToVector {\n  (n: number): F32Vector;\n}\n\n/**\n * A function that converts a vector to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToInterval {\n  (x: number[]): F32Interval;\n}\n\n/** Operation used to implement a VectorToInterval */\ninterface VectorToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vector x */\n  impl: VectorToInterval;\n}\n\n/**\n * A function that converts a pair of vectors to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToInterval {\n  (x: number[], y: number[]): F32Interval;\n}\n\n/** Operation used to implement a VectorPairToInterval */\ninterface VectorPairToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vectors (x, y) */\n  impl: VectorPairToInterval;\n}\n\n/**\n * A function that converts a vector to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToVector {\n  (x: number[]): F32Vector;\n}\n\n/** Operation used to implement a VectorToVector */\ninterface VectorToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vector x */\n  impl: VectorToVector;\n}\n\n/**\n * A function that converts a pair of vectors to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToVector {\n  (x: number[], y: number[]): F32Vector;\n}\n\n/** Operation used to implement a VectorPairToVector */\ninterface VectorPairToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vectors (x, y) */\n  impl: VectorPairToVector;\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = addFlushedIfNeededF32(values);\n  const results = new Set<F32Interval>(inputs.map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = addFlushedIfNeededF32(x_values);\n  const y_inputs = addFlushedIfNeededF32(y_values);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = addFlushedIfNeededF32(x_values);\n  const y_inputs = addFlushedIfNeededF32(y_values);\n  const z_inputs = addFlushedIfNeededF32(z_values);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a vector to an acceptance interval using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushVectorToInterval(x: number[], op: VectorToIntervalOp): F32Interval {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    intervals.add(op.impl(inner_x));\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a pair of vectors to an acceptance interval using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushVectorPairToInterval(\n  x: number[],\n  y: number[],\n  op: VectorPairToIntervalOp\n): F32Interval {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n  assert(\n    y.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const y_rounded: number[][] = y.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const y_flushed: number[][] = y_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n  const y_inputs = cartesianProduct<number>(...y_flushed);\n\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a vector to a vector of acceptance intervals using a specific\n * function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a vector of spans for each outputs of op.impl\n */\nfunction roundAndFlushVectorToVector(x: number[], op: VectorToVectorOp): F32Vector {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n\n  const interval_vectors = new Set<F32Vector>();\n  x_inputs.forEach(inner_x => {\n    interval_vectors.add(op.impl(inner_x));\n  });\n\n  return spanF32Vector(...interval_vectors);\n}\n\n/**\n * Converts a pair of vectors to a vector of acceptance intervals using a\n * specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param x second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a vector of spans for each output of op.impl\n */\nfunction roundAndFlushVectorPairToVector(\n  x: number[],\n  y: number[],\n  op: VectorPairToVectorOp\n): F32Vector {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n  assert(\n    y.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const y_rounded: number[][] = y.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const y_flushed: number[][] = y_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n  const y_inputs = cartesianProduct<number>(...y_flushed);\n\n  const interval_vectors = new Set<F32Vector>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      interval_vectors.add(op.impl(inner_x, inner_y));\n    });\n  });\n\n  return spanF32Vector(...interval_vectors);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointToIntervalOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (!x.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n\n  const result = F32Interval.span(...x.bounds().map(b => roundAndFlushPointToInterval(b, op)));\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runBinaryToIntervalOp(\n  x: F32Interval,\n  y: F32Interval,\n  op: BinaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      outputs.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runTernaryToIntervalOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n    return F32Interval.any();\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      z.bounds().forEach(inner_z => {\n        outputs.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a vector function over given intervals\n *\n * @param x input domain intervals vector\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runVectorToIntervalOp(x: F32Vector, op: VectorToIntervalOp): F32Interval {\n  if (x.some(e => !e.isFinite())) {\n    return F32Interval.any();\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    outputs.add(roundAndFlushVectorToInterval(inner_x, op));\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a vector pair function over given intervals\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runVectorPairToIntervalOp(\n  x: F32Vector,\n  y: F32Vector,\n  op: VectorPairToIntervalOp\n): F32Interval {\n  if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n    return F32Interval.any();\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n  const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushVectorPairToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the vector of acceptance intervals for a pair of vector function over\n * given intervals\n *\n * @param x input domain intervals vector\n * @param x input domain intervals vector\n * @param op operation defining the function being run\n * @returns a vector of spans over all of the outputs of op.impl\n */\nfunction runVectorToVectorOp(x: F32Vector, op: VectorToVectorOp): F32Vector {\n  if (x.some(e => !e.isFinite())) {\n    return kAnyVector[x.length];\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n  const outputs = new Set<F32Vector>();\n  x_values.forEach(inner_x => {\n    outputs.add(roundAndFlushVectorToVector(inner_x, op));\n  });\n\n  const result = spanF32Vector(...outputs);\n  return result.every(e => e.isFinite()) ? result : toF32Vector(x.map(_ => F32Interval.any()));\n}\n\n/**\n * Calculate the vector of acceptance intervals by running a scalar operation\n * component-wise over a vector.\n *\n * This is used for situations where a component-wise operation, like vector\n * negation, is needed as part of a inherited accuracy, but the top-level\n * operation test don't require an explicit vector definition of the function,\n * due to the generated vectorize tests being sufficient.\n *\n * @param x input domain intervals vector\n * @param op scalar operation to be run component-wise\n * @returns a vector of intervals with the outputs of op.impl\n */\nfunction runPointToIntervalOpComponentWise(x: F32Vector, op: PointToIntervalOp): F32Vector {\n  return toF32Vector(\n    x.map(i => {\n      return runPointToIntervalOp(i, op);\n    })\n  );\n}\n\n/** Calculate the vector of acceptance intervals for a vector function over\n * given intervals\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op operation defining the function being run\n * @returns a vector of spans over all of the outputs of op.impl\n */\nfunction runVectorPairToVectorOp(x: F32Vector, y: F32Vector, op: VectorPairToVectorOp): F32Vector {\n  if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n    return kAnyVector[x.length];\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n  const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n  const outputs = new Set<F32Vector>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushVectorPairToVector(inner_x, inner_y, op));\n    });\n  });\n\n  const result = spanF32Vector(...outputs);\n  return result.every(e => e.isFinite()) ? result : toF32Vector(x.map(_ => F32Interval.any()));\n}\n\n/**\n * Calculate the vector of acceptance intervals by running a scalar operation\n * component-wise over a pair vectors.\n *\n * This is used for situations where a component-wise operation, like vector\n * subtraction, is needed as part of a inherited accuracy, but the top-level\n * operation test don't require an explicit vector definition of the function,\n * due to the generated vectorize tests being sufficient.\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op scalar operation to be run component-wise\n * @returns a vector of intervals with the outputs of op.impl\n */\nfunction runBinaryToIntervalOpComponentWise(\n  x: F32Vector,\n  y: F32Vector,\n  op: BinaryToIntervalOp\n): F32Vector {\n  assert(\n    x.length === y.length,\n    `runBinaryToIntervalOpComponentWise requires vectors of the same length`\n  );\n  return toF32Vector(\n    x.map((i, idx) => {\n      return runBinaryToIntervalOp(i, y[idx], op);\n    })\n  );\n}\n\n/** Defines a PointToIntervalOp for an interval of the correctly rounded values around the point */\nconst CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    assert(!Number.isNaN(n), `absolute not defined for NaN`);\n    return toF32Interval(n);\n  },\n};\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CorrectlyRoundedIntervalOp);\n}\n\n/** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\nfunction AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isFiniteF32(error_range)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n      return new F32Interval(n - error_range, n + error_range);\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  error_range = Math.abs(error_range);\n  return runPointToIntervalOp(toF32Interval(n), AbsoluteErrorIntervalOp(error_range));\n}\n\n/** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\nfunction ULPIntervalOp(numULP: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isFiniteF32(numULP)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n      const ulp = oneULP(n);\n      const begin = n - numULP * ulp;\n      const end = n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumberF32(begin)),\n        Math.max(end, flushSubnormalNumberF32(end))\n      );\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return runPointToIntervalOp(toF32Interval(n), ULPIntervalOp(numULP));\n}\n\nconst AbsIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    return correctlyRoundedInterval(Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AbsIntervalOp);\n}\n\nconst AcosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(toF32Interval([-1.0, 1.0]), (n: number) => {\n    // acos(n) = atan2(sqrt(1.0 - n * n), n)\n    const y = sqrtInterval(subtractionInterval(1, multiplicationInterval(n, n)));\n    return atan2Interval(y, n);\n  }),\n};\n\n/** Calculate an acceptance interval for acos(n) */\nexport function acosInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AcosIntervalOp);\n}\n\n/** All acceptance interval functions for acosh(x) */\nexport const acoshIntervals: PointToInterval[] = [acoshAlternativeInterval, acoshPrimaryInterval];\n\nconst AcoshAlternativeIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt((x + 1.0f) * (x - 1.0)))\n    const inner_value = multiplicationInterval(\n      additionInterval(x, 1.0),\n      subtractionInterval(x, 1.0)\n    );\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt((x + 1.0f) * (x - 1.0))) */\nexport function acoshAlternativeInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), AcoshAlternativeIntervalOp);\n}\n\nconst AcoshPrimaryIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt(x * x - 1.0))\n    const inner_value = subtractionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt(x * x - 1.0)) */\nexport function acoshPrimaryInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), AcoshPrimaryIntervalOp);\n}\n\nconst AdditionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x + y);\n  },\n};\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), AdditionIntervalOp);\n}\n\nconst AsinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(toF32Interval([-1.0, 1.0]), (n: number) => {\n    // asin(n) = atan2(n, sqrt(1.0 - n * n))\n    const x = sqrtInterval(subtractionInterval(1, multiplicationInterval(n, n)));\n    return atan2Interval(n, x);\n  }),\n};\n\n/** Calculate an acceptance interval for asin(n) */\nexport function asinInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AsinIntervalOp);\n}\n\nconst AsinhIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // asinh(x) = log(x + sqrt(x * x + 1.0))\n    const inner_value = additionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of asinh(x) */\nexport function asinhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AsinhIntervalOp);\n}\n\nconst AtanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.atan(n), 4096);\n  },\n};\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AtanIntervalOp);\n}\n\nconst Atan2IntervalOp: BinaryToIntervalOp = {\n  impl: (y: number, x: number): F32Interval => {\n    // y/x is not defined meaningfully here\n    if (x === 0) {\n      return F32Interval.any();\n    }\n\n    // atan2's accuracy is only defined if y is normal\n    if (isSubnormalNumberF32(y)) {\n      return F32Interval.any();\n    }\n\n    const atan_yx = atanInterval(divisionInterval(y, x));\n    // x > 0, atan(y/x)\n    if (x > 0) {\n      return atan_yx;\n    }\n\n    // x < 0, y > 0, atan(y/x) + \n    if (y > 0) {\n      return additionInterval(atan_yx, kValue.f32.positive.pi.whole);\n    }\n\n    // x < 0, y < 0, atan(y/x) - \n    return subtractionInterval(atan_yx, kValue.f32.positive.pi.whole);\n  },\n  extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n    // There is discontinuity + undefined behaviour at y/x = 0 that will dominate the accuracy\n    if (y.contains(0)) {\n      if (x.contains(0)) {\n        return [toF32Interval(0), toF32Interval(0)];\n      }\n      return [toF32Interval(0), x];\n    }\n    return [y, x];\n  },\n};\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(y), toF32Interval(x), Atan2IntervalOp);\n}\n\nconst AtanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    // atanh(x) = log((1.0 + x) / (1.0 - x)) * 0.5\n    const numerator = additionInterval(1.0, n);\n    const denominator = subtractionInterval(1.0, n);\n    const log_interval = logInterval(divisionInterval(numerator, denominator));\n    return multiplicationInterval(log_interval, 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of atanh(x) */\nexport function atanhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AtanhIntervalOp);\n}\n\nconst CeilIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.ceil(n));\n  },\n};\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CeilIntervalOp);\n}\n\nconst ClampMedianIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return correctlyRoundedInterval(\n      // Default sort is string sort, so have to implement numeric comparison.\n      // Cannot use the b-a one liner, because that assumes no infinities.\n      [x, y, z].sort((a, b) => {\n        if (a < b) {\n          return -1;\n        }\n        if (a > b) {\n          return 1;\n        }\n        return 0;\n      })[1]\n    );\n  },\n};\n\n/** All acceptance interval functions for clamp(x, y, z) */\nexport const clampIntervals: TernaryToInterval[] = [clampMinMaxInterval, clampMedianInterval];\n\n/** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\nexport function clampMedianInterval(\n  x: number | F32Interval,\n  y: number | F32Interval,\n  z: number | F32Interval\n): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    ClampMedianIntervalOp\n  );\n}\n\nconst ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, low: number, high: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(Math.max(x, low), high));\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\nexport function clampMinMaxInterval(\n  x: number | F32Interval,\n  low: number | F32Interval,\n  high: number | F32Interval\n): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(low),\n    toF32Interval(high),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst CosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.cos(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CosIntervalOp);\n}\n\nconst CoshIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // cosh(x) = (exp(x) + exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(additionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of cosh(x) */\nexport function coshInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CoshIntervalOp);\n}\n\nconst CrossIntervalOp: VectorPairToVectorOp = {\n  impl: (x: number[], y: number[]): F32Vector => {\n    assert(x.length === 3, `CrossIntervalOp received x with ${x.length} instead of 3`);\n    assert(y.length === 3, `CrossIntervalOp received y with ${y.length} instead of 3`);\n\n    // cross(x, y) = r, where\n    //   r[0] = x[1] * y[2] - x[2] * y[1]\n    //   r[1] = x[2] * y[0] - x[0] * y[2]\n    //   r[2] = x[0] * y[1] - x[1] * y[0]\n\n    const r0 = subtractionInterval(\n      multiplicationInterval(x[1], y[2]),\n      multiplicationInterval(x[2], y[1])\n    );\n    const r1 = subtractionInterval(\n      multiplicationInterval(x[2], y[0]),\n      multiplicationInterval(x[0], y[2])\n    );\n    const r2 = subtractionInterval(\n      multiplicationInterval(x[0], y[1]),\n      multiplicationInterval(x[1], y[0])\n    );\n    return [r0, r1, r2];\n  },\n};\n\nexport function crossInterval(x: number[], y: number[]): F32Vector {\n  assert(x.length === 3, `Cross is only defined for vec3`);\n  assert(y.length === 3, `Cross is only defined for vec3`);\n  return runVectorPairToVectorOp(toF32Vector(x), toF32Vector(y), CrossIntervalOp);\n}\n\nconst DegreesIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 57.295779513082322865);\n  },\n};\n\n/** Calculate an acceptance interval of degrees(x) */\nexport function degreesInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), DegreesIntervalOp);\n}\n\nconst DistanceIntervalScalarOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return lengthInterval(subtractionInterval(x, y));\n  },\n};\n\nconst DistanceIntervalVectorOp: VectorPairToIntervalOp = {\n  impl: (x: number[], y: number[]): F32Interval => {\n    return lengthInterval(\n      runBinaryToIntervalOpComponentWise(toF32Vector(x), toF32Vector(y), SubtractionIntervalOp)\n    );\n  },\n};\n\n/** Calculate an acceptance interval of distance(x, y) */\nexport function distanceInterval(x: number | number[], y: number | number[]): F32Interval {\n  if (x instanceof Array && y instanceof Array) {\n    assert(\n      x.length === y.length,\n      `distanceInterval requires both params to have the same number of elements`\n    );\n    return runVectorPairToIntervalOp(toF32Vector(x), toF32Vector(y), DistanceIntervalVectorOp);\n  } else if (!(x instanceof Array) && !(y instanceof Array)) {\n    return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), DistanceIntervalScalarOp);\n  }\n  unreachable(\n    `distanceInterval requires both params to both the same type, either scalars or vectors`\n  );\n}\n\nconst DivisionIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-(2 ** 126), -(2 ** -126)), new F32Interval(2 ** -126, 2 ** 126)],\n    },\n    (x: number, y: number): F32Interval => {\n      if (y === 0) {\n        return F32Interval.any();\n      }\n      return ulpInterval(x / y, 2.5);\n    }\n  ),\n  extrema: (x: F32Interval, y: F32Interval): [F32Interval, F32Interval] => {\n    // division has a discontinuity at y = 0.\n    if (y.contains(0)) {\n      y = toF32Interval(0);\n    }\n    return [x, y];\n  },\n};\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), DivisionIntervalOp);\n}\n\nconst DotIntervalOp: VectorPairToIntervalOp = {\n  impl: (x: number[], y: number[]): F32Interval => {\n    // dot(x, y) = sum of x[i] * y[i]\n    const multiplications = runBinaryToIntervalOpComponentWise(\n      toF32Vector(x),\n      toF32Vector(y),\n      MultiplicationIntervalOp\n    );\n    return multiplications.reduce((previous, current) => additionInterval(previous, current));\n  },\n};\n\nexport function dotInterval(x: number[], y: number[]): F32Interval {\n  assert(x.length === y.length, `dot not defined for vectors with different lengths`);\n  return runVectorPairToIntervalOp(toF32Vector(x), toF32Vector(y), DotIntervalOp);\n}\n\nconst ExpIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.exp(n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), ExpIntervalOp);\n}\n\nconst Exp2IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.pow(2, n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), Exp2IntervalOp);\n}\n\n/**\n * Calculate the acceptance intervals for faceForward(x, y, z)\n *\n * faceForward(x, y, z) = select(-x, x, dot(z, y) < 0.0)\n *\n * This builtin selects from two discrete results (delta rounding/flushing), so\n * the majority of the framework code is not appropriate, since the framework\n * attempts to span results.\n *\n * Thus a bespoke implementation is used instead of\n * defining a Op and running that through the framework.\n */\nexport function faceForwardIntervals(x: number[], y: number[], z: number[]): F32Vector[] {\n  const x_vec = toF32Vector(x);\n  // Running vector through runPointToIntervalOpComponentWise to make sure that flushing/rounding is handled, since\n  // toF32Vector does not perform those operations.\n  const positive_x = runPointToIntervalOpComponentWise(x_vec, { impl: toF32Interval });\n  const negative_x = runPointToIntervalOpComponentWise(x_vec, NegationIntervalOp);\n\n  const dot_interval = dotInterval(z, y);\n  const results = new Array<F32Vector>();\n\n  // Because the result of dot can be an interval, it might span across 0, thus it is possible that both -x and x are\n  // valid responses.\n  if (dot_interval.begin < 0 || dot_interval.end < 0) {\n    results.push(positive_x);\n  }\n\n  if (dot_interval.begin >= 0 || dot_interval.end >= 0) {\n    results.push(negative_x);\n  }\n\n  assert(\n    results.length > 0,\n    `faceForwardInterval selected neither positive x or negative x for the result, this shouldn't be possible`\n  );\n  return results;\n}\n\nconst FloorIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.floor(n));\n  },\n};\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), FloorIntervalOp);\n}\n\nconst FmaIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return additionInterval(multiplicationInterval(x, y), z);\n  },\n};\n\n/** Calculate an acceptance interval for fma(x, y, z) */\nexport function fmaInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    FmaIntervalOp\n  );\n}\n\nconst FractIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // fract(x) = x - floor(x) is defined in the spec.\n    // For people coming from a non-graphics background this will cause some unintuitive results. For example,\n    // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n    // This is how other shading languages operate and allows for a desirable wrap around in graphics programming.\n    const result = subtractionInterval(n, floorInterval(n));\n    if (result.contains(1)) {\n      // Very small negative numbers can lead to catastrophic cancellation, thus calculating a fract of 1.0, which is\n      // technically not a fractional part, so some implementations clamp the result to next nearest number.\n      return F32Interval.span(result, toF32Interval(kValue.f32.positive.less_than_one));\n    }\n    return result;\n  },\n};\n\n/** Calculate an acceptance interval of fract(x) */\nexport function fractInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), FractIntervalOp);\n}\n\nconst InverseSqrtIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      return ulpInterval(1 / Math.sqrt(n), 2);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of inverseSqrt(x) */\nexport function inverseSqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), InverseSqrtIntervalOp);\n}\n\nconst LdexpIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    // Implementing SPIR-V's more restrictive domain until\n    // https://github.com/gpuweb/gpuweb/issues/3134 is resolved\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-126, 128)],\n    },\n    (e1: number, e2: number): F32Interval => {\n      // Though the spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, the\n      // accuracy is listed as correctly rounded to the true value, so the\n      // inheritance framework does not need to be invoked to determine bounds.\n      // Instead the value at a higher precision is calculated and passed to\n      // correctlyRoundedInterval.\n      const result = e1 * 2 ** e2;\n      if (Number.isNaN(result)) {\n        // Overflowed TS's number type, so definitely out of bounds for f32\n        return F32Interval.any();\n      }\n      return correctlyRoundedInterval(result);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of ldexp(e1, e2) */\nexport function ldexpInterval(e1: number, e2: number): F32Interval {\n  return roundAndFlushBinaryToInterval(e1, e2, LdexpIntervalOp);\n}\n\nconst LengthIntervalScalarOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return sqrtInterval(multiplicationInterval(n, n));\n  },\n};\n\nconst LengthIntervalVectorOp: VectorToIntervalOp = {\n  impl: (n: number[]): F32Interval => {\n    return sqrtInterval(dotInterval(n, n));\n  },\n};\n\n/** Calculate an acceptance interval of length(x) */\nexport function lengthInterval(n: number | F32Interval | number[] | F32Vector): F32Interval {\n  if (n instanceof Array) {\n    return runVectorToIntervalOp(toF32Vector(n), LengthIntervalVectorOp);\n  } else {\n    return runPointToIntervalOp(toF32Interval(n), LengthIntervalScalarOp);\n  }\n}\n\nconst LogIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), LogIntervalOp);\n}\n\nconst Log2IntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log2(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log2(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), Log2IntervalOp);\n}\n\nconst MaxIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.max(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MaxIntervalOp);\n}\n\nconst MinIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MinIntervalOp);\n}\n\nconst MixImpreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x + (y - x) * z =\n    //  x + t, where t = (y - x) * z\n    const t = multiplicationInterval(subtractionInterval(y, x), z);\n    return additionInterval(x, t);\n  },\n};\n\n/** All acceptance interval functions for mix(x, y, z) */\nexport const mixIntervals: TernaryToInterval[] = [mixImpreciseInterval, mixPreciseInterval];\n\n/** Calculate an acceptance interval of mix(x, y, z) using x + (y - x) * z */\nexport function mixImpreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    MixImpreciseIntervalOp\n  );\n}\n\nconst MixPreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x * (1.0 - z) + y * z =\n    //   t + s, where t = x * (1.0 - z), s = y * z\n    const t = multiplicationInterval(x, subtractionInterval(1.0, z));\n    const s = multiplicationInterval(y, z);\n    return additionInterval(t, s);\n  },\n};\n\n/** Calculate an acceptance interval of mix(x, y, z) using x * (1.0 - z) + y * z */\nexport function mixPreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    MixPreciseIntervalOp\n  );\n}\n\nconst MultiplicationInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x * y);\n  },\n};\n\nconst MultiplicationIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, MultiplicationInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MultiplicationIntervalOp);\n}\n\nconst NegationIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(-n);\n  },\n};\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), NegationIntervalOp);\n}\n\nconst NormalizeIntervalOp: VectorToVectorOp = {\n  impl: (n: number[]): F32Vector => {\n    const length = lengthInterval(n);\n    return toF32Vector(n.map(e => divisionInterval(e, length)));\n  },\n};\n\n/** Calculate an acceptance interval of normalize(x) */\nexport function normalizeInterval(n: number[]): F32Vector {\n  return runVectorToVectorOp(toF32Vector(n), NormalizeIntervalOp);\n}\n\nconst PowIntervalOp: BinaryToIntervalOp = {\n  // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n  // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n  // enforce this, so there is no need to wrap the impl call here.\n  impl: (x: number, y: number): F32Interval => {\n    return exp2Interval(multiplicationInterval(y, log2Interval(x)));\n  },\n};\n\n/** Calculate an acceptance interval of pow(x, y) */\nexport function powInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), PowIntervalOp);\n}\n\n// Once a full implementation of F16Interval exists, the correctlyRounded for\n// that can potentially be used instead of having a bespoke operation\n// implementation.\nconst QuantizeToF16IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    const rounded = correctlyRoundedF16(n);\n    const flushed = addFlushedIfNeededF16(rounded);\n    return F32Interval.span(...flushed.map(toF32Interval));\n  },\n};\n\n/** Calculate an acceptance interval of quanitizeToF16(x) */\nexport function quantizeToF16Interval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), QuantizeToF16IntervalOp);\n}\n\nconst RadiansIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 0.017453292519943295474);\n  },\n};\n\n/** Calculate an acceptance interval of radians(x) */\nexport function radiansInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), RadiansIntervalOp);\n}\n\nconst ReflectIntervalOp: VectorPairToVectorOp = {\n  impl: (x: number[], y: number[]): F32Vector => {\n    assert(\n      x.length === y.length,\n      `ReflectIntervalOp received x (${x}) and y (${y}) with different numbers of elements`\n    );\n\n    // reflect(x, y) = x - 2.0 * dot(x, y) * y\n    //               = x - t * y, t = 2.0 * dot(x, y)\n    // x = incident vector\n    // y = normal of reflecting surface\n    const t = multiplicationInterval(2.0, dotInterval(x, y));\n    const rhs = multiplyVectorByScalar(y, t);\n    return runBinaryToIntervalOpComponentWise(toF32Vector(x), rhs, SubtractionIntervalOp);\n  },\n};\n\n/** Calculate an acceptance interval of reflect(x, y) */\nexport function reflectInterval(x: number[], y: number[]): F32Vector {\n  assert(\n    x.length === y.length,\n    `reflect is only defined for vectors with the same number of elements`\n  );\n  return runVectorPairToVectorOp(toF32Vector(x), toF32Vector(y), ReflectIntervalOp);\n}\n\n/**\n * Calculate acceptance interval vectors of reflect(i, s, r)\n *\n * refract is a singular function in the sense that it is the only builtin that\n * takes in (F32Vector, F32Vector, F32) and returns F32Vector and is basically\n * defined in terms of other functions.\n *\n * Instead of implementing all of the framework code to integrate it with its\n * own operation type/etc, it instead has a bespoke implementation that is a\n * composition of other builtin functions that use the framework.\n */\nexport function refractInterval(i: number[], s: number[], r: number): F32Vector {\n  assert(\n    i.length === s.length,\n    `refract is only defined for vectors with the same number of elements`\n  );\n\n  const r_squared = multiplicationInterval(r, r);\n  const dot = dotInterval(s, i);\n  const dot_squared = multiplicationInterval(dot, dot);\n  const one_minus_dot_squared = subtractionInterval(1, dot_squared);\n  const k = subtractionInterval(1.0, multiplicationInterval(r_squared, one_minus_dot_squared));\n\n  if (k.containsZeroOrSubnormals()) {\n    // There is a discontinuity at k == 0, due to sqrt(k) being calculated, so exiting early\n    return kAnyVector[toF32Vector(i).length];\n  }\n\n  if (k.end < 0.0) {\n    // if k is negative, then the zero vector is the valid response\n    return kZeroVector[toF32Vector(i).length];\n  }\n\n  const dot_times_r = multiplicationInterval(dot, r);\n  const k_sqrt = sqrtInterval(k);\n  const t = additionInterval(dot_times_r, k_sqrt); // t = r * dot(i, s) + sqrt(k)\n\n  const result = runBinaryToIntervalOpComponentWise(\n    multiplyVectorByScalar(i, r),\n    multiplyVectorByScalar(s, t),\n    SubtractionIntervalOp\n  ); // (i * r) - (s * t)\n  return result;\n}\n\nconst RemainderIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    // x % y = x - y * trunc(x/y)\n    return subtractionInterval(x, multiplicationInterval(y, truncInterval(divisionInterval(x, y))));\n  },\n};\n\n/** Calculate an acceptance interval for x % y */\nexport function remainderInterval(x: number, y: number): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), RemainderIntervalOp);\n}\n\nconst RoundIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    const k = Math.floor(n);\n    const diff_before = n - k;\n    const diff_after = k + 1 - n;\n    if (diff_before < diff_after) {\n      return correctlyRoundedInterval(k);\n    } else if (diff_before > diff_after) {\n      return correctlyRoundedInterval(k + 1);\n    }\n\n    // n is in the middle of two integers.\n    // The tie breaking rule is 'k if k is even, k + 1 if k is odd'\n    if (k % 2 === 0) {\n      return correctlyRoundedInterval(k);\n    }\n    return correctlyRoundedInterval(k + 1);\n  },\n};\n\n/** Calculate an acceptance interval of round(x) */\nexport function roundInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), RoundIntervalOp);\n}\n\n/**\n * Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0)\n *\n * The definition of saturate is such that both possible implementations of\n * clamp will return the same value, so arbitrarily picking the minmax version\n * to use.\n */\nexport function saturateInterval(n: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(n),\n    toF32Interval(0.0),\n    toF32Interval(1.0),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst SignIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    if (n > 0.0) {\n      return correctlyRoundedInterval(1.0);\n    }\n    if (n < 0.0) {\n      return correctlyRoundedInterval(-1.0);\n    }\n\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function signInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SignIntervalOp);\n}\n\nconst SinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.sin(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SinIntervalOp);\n}\n\nconst SinhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // sinh(x) = (exp(x) - exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(subtractionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of sinh(x) */\nexport function sinhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SinhIntervalOp);\n}\n\nconst SmoothStepOp: TernaryToIntervalOp = {\n  impl: (low: number, high: number, x: number): F32Interval => {\n    // For clamp(foo, 0.0, 1.0) the different implementations of clamp provide\n    // the same value, so arbitrarily picking the minmax version to use.\n    // t = clamp((x - low) / (high - low), 0.0, 1.0)\n    // prettier-ignore\n    const t = clampMedianInterval(\n      divisionInterval(\n        subtractionInterval(x, low),\n        subtractionInterval(high, low)),\n      0.0,\n      1.0);\n    // Inherited from t * t * (3.0 - 2.0 * t)\n    // prettier-ignore\n    return multiplicationInterval(\n      t,\n      multiplicationInterval(t,\n        subtractionInterval(3.0,\n          multiplicationInterval(2.0, t))));\n  },\n};\n\n/** Calculate an acceptance interval of smoothStep(low, high, x) */\nexport function smoothStepInterval(low: number, high: number, x: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(low),\n    toF32Interval(high),\n    toF32Interval(x),\n    SmoothStepOp\n  );\n}\n\nconst SqrtIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(1.0, inverseSqrtInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of sqrt(x) */\nexport function sqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SqrtIntervalOp);\n}\n\nconst StepIntervalOp: BinaryToIntervalOp = {\n  impl: (edge: number, x: number): F32Interval => {\n    if (edge <= x) {\n      return correctlyRoundedInterval(1.0);\n    }\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance 'interval' for step(edge, x)\n *\n * step only returns two possible values, so its interval requires special\n * interpretation in CTS tests.\n * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-, +].\n * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n * indicate either 0.0 or 1.0 are acceptable answers.\n * [-, +] is treated as the any interval, since an undefined or infinite value was passed in.\n */\nexport function stepInterval(edge: number, x: number): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(edge), toF32Interval(x), StepIntervalOp);\n}\n\nconst SubtractionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x - y);\n  },\n};\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), SubtractionIntervalOp);\n}\n\nconst TanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinInterval(n), cosInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tan(x) */\nexport function tanInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TanIntervalOp);\n}\n\nconst TanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinhInterval(n), coshInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tanh(x) */\nexport function tanhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TanhIntervalOp);\n}\n\nconst TruncIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.trunc(n));\n  },\n};\n\n/** Calculate an acceptance interval of trunc(x) */\nexport function truncInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TruncIntervalOp);\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when converting between numeric formats\n *\n * unpackData* is shared between all of the unpack*Interval functions, so to avoid re-entrancy problems, they should\n * not call each other or themselves directly or indirectly.\n */\nconst unpackData = new ArrayBuffer(4);\nconst unpackDataU32 = new Uint32Array(unpackData);\nconst unpackDataU16 = new Uint16Array(unpackData);\nconst unpackDataU8 = new Uint8Array(unpackData);\nconst unpackDataI16 = new Int16Array(unpackData);\nconst unpackDataI8 = new Int8Array(unpackData);\nconst unpackDataF16 = new Float16Array(unpackData);\n\n/** Calculate an acceptance interval vector for unpack2x16float(x) */\nexport function unpack2x16floatInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16floatInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  if (unpackDataF16.some(f => !isFiniteF16(f))) {\n    return [F32Interval.any(), F32Interval.any()];\n  }\n\n  const result: F32Vector = [\n    quantizeToF16Interval(unpackDataF16[0]),\n    quantizeToF16Interval(unpackDataF16[1]),\n  ];\n\n  if (result.some(r => !r.isFinite())) {\n    return [F32Interval.any(), F32Interval.any()];\n  }\n  return result;\n}\n\nconst Unpack2x16snormIntervalOp = (n: number): F32Interval => {\n  return maxInterval(divisionInterval(n, 32767), -1);\n};\n\n/** Calculate an acceptance interval vector for unpack2x16snorm(x) */\nexport function unpack2x16snormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16snormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [Unpack2x16snormIntervalOp(unpackDataI16[0]), Unpack2x16snormIntervalOp(unpackDataI16[1])];\n}\n\nconst Unpack2x16unormIntervalOp = (n: number): F32Interval => {\n  return divisionInterval(n, 65535);\n};\n\n/** Calculate an acceptance interval vector for unpack2x16unorm(x) */\nexport function unpack2x16unormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16unormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [Unpack2x16unormIntervalOp(unpackDataU16[0]), Unpack2x16unormIntervalOp(unpackDataU16[1])];\n}\n\nconst Unpack4x8snormIntervalOp = (n: number): F32Interval => {\n  return maxInterval(divisionInterval(n, 127), -1);\n};\n\n/** Calculate an acceptance interval vector for unpack4x8snorm(x) */\nexport function unpack4x8snormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack4x8snormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [\n    Unpack4x8snormIntervalOp(unpackDataI8[0]),\n    Unpack4x8snormIntervalOp(unpackDataI8[1]),\n    Unpack4x8snormIntervalOp(unpackDataI8[2]),\n    Unpack4x8snormIntervalOp(unpackDataI8[3]),\n  ];\n}\n\nconst Unpack4x8unormIntervalOp = (n: number): F32Interval => {\n  return divisionInterval(n, 255);\n};\n\n/** Calculate an acceptance interval vector for unpack4x8unorm(x) */\nexport function unpack4x8unormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack4x8unormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [\n    Unpack4x8unormIntervalOp(unpackDataU8[0]),\n    Unpack4x8unormIntervalOp(unpackDataU8[1]),\n    Unpack4x8unormIntervalOp(unpackDataU8[2]),\n    Unpack4x8unormIntervalOp(unpackDataU8[3]),\n  ];\n}\n"],"file":"f32_interval.js"}