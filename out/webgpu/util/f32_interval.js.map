{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","kValue","correctlyRoundedF32","flushSubnormalNumber","isF32Finite","isSubnormalNumber","oneULP","F32Interval","constructor","begin","end","Number","isNaN","NEGATIVE_INFINITY","f32","negative","min","POSITIVE_INFINITY","positive","max","contains","n","i","toInterval","isPoint","span","intervals","length","forEach","Math","toString","infinite","_infinite","undefined","roundAndFlushPointToInterval","op","values","inputs","Set","map","results","impl","roundAndFlushBinaryToInterval","x","y","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","runPointOp","extrema","runBinaryOp","runTernaryOp","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","AbsoluteErrorIntervalOp","error_range","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","ulpInterval","AbsIntervalOp","absInterval","AdditionInnerOp","sign","AdditionIntervalOp","additionInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","pi","whole","atan2","atan2Interval","CeilIntervalOp","ceil","ceilInterval","ClampMedianIntervalOp","sort","a","b","clampMedianInterval","ClampMinMaxIntervalOp","low","high","clampMinMaxInterval","CosIntervalOp","cos","cosInterval","DivisionIntervalOp","divisionInterval","Y","lower_bound","upper_bound","ExpIntervalOp","exp","expInterval","Exp2IntervalOp","pow","exp2Interval","FloorIntervalOp","floor","floorInterval","FractIntervalOp","result","subtractionInterval","less_than_one","fractInterval","InverseSqrtIntervalOp","sqrt","inverseSqrtInterval","LogIntervalOp","log","logInterval","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","maxInterval","MinIntervalOp","minInterval","MultiplicationInnerOp","appropriate_infinity","MultiplicationIntervalOp","multiplicationInterval","NegationIntervalOp","negationInterval","SinIntervalOp","sin","sinInterval","SubtractionInnerOp","SubtractionIntervalOp","TanIntervalOp","tanInterval"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kValue } from './constants.js';\nimport {\n  correctlyRoundedF32,\n  flushSubnormalNumber,\n  isF32Finite,\n  isSubnormalNumber,\n  oneULP,\n} from './math.js';\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _infinite: F32Interval;\n\n  /** Constructor\n   *\n   * Bounds that are out of range for F32 are converted to appropriate edge or\n   * infinity values, so that all values above/below the f32 range are lumped\n   * together.\n   *\n   * @param begin number indicating the lower bound of the interval\n   * @param end number indicating the upper bound of the interval\n   */\n  public constructor(begin: number, end: number) {\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `begin (${begin}) must be equal or before end (${end})`);\n\n    if (begin === Number.NEGATIVE_INFINITY || begin < kValue.f32.negative.min) {\n      this.begin = Number.NEGATIVE_INFINITY;\n    } else if (begin === Number.POSITIVE_INFINITY || begin > kValue.f32.positive.max) {\n      this.begin = kValue.f32.positive.max;\n    } else {\n      this.begin = begin;\n    }\n\n    if (end === Number.POSITIVE_INFINITY || end > kValue.f32.positive.max) {\n      this.end = Number.POSITIVE_INFINITY;\n    } else if (end === Number.NEGATIVE_INFINITY || end < kValue.f32.negative.min) {\n      this.end = kValue.f32.negative.min;\n    } else {\n      this.end = end;\n    }\n  }\n\n  /** @returns if a point or interval is completely contained by this interval\n   *\n   * Due to values that are above/below the f32 range being indistinguishable\n   * from other values out of range in the same way, there some unintuitive\n   * behaviours here, for example:\n   *   [0, greater than max f32].contains(+âˆž) will return true.\n   */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the infinite interval indicates that the accuracy is not defined\n      // for this test, so the test is just checking that this input doesn't\n      // cause the implementation to misbehave, so NaN is acceptable.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toInterval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.begin}, ${this.end}]`;\n  }\n\n  /** @returns a singleton for the infinite interval\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static infinite(): F32Interval {\n    if (this._infinite === undefined) {\n      this._infinite = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._infinite;\n  }\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toInterval(n: number | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n  return new F32Interval(n, n);\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\ninterface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: (x: number) => F32Interval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: (x: number, y: number) => F32Interval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: (x: number, y: number, z: number) => F32Interval;\n  // All current ternary operations that are used in inheritance (clamp*) are\n  // monotonic, so extrema calculation isn't needed. Re-using the Op interface\n  // pattern for symmetry with the other operations\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = new Set<number>([...values, ...values.map(flushSubnormalNumber)]);\n  const results = new Set<F32Interval>([...inputs].map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const z_inputs = new Set<number>([...z_values, ...z_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (x.isPoint()) {\n    return roundAndFlushPointToInterval(x.begin, op);\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n  return F32Interval.span(\n    roundAndFlushPointToInterval(x.begin, op),\n    roundAndFlushPointToInterval(x.end, op)\n  );\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runBinaryOp(x: F32Interval, y: F32Interval, op: BinaryToIntervalOp): F32Interval {\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      results.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runTernaryOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n  const z_values = new Set<number>([z.begin, z.end]);\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      z_values.forEach(inner_z => {\n        results.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\nconst CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    assert(!Number.isNaN(n), `absolute not defined for NaN`);\n    return toInterval(n);\n  },\n};\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return roundAndFlushPointToInterval(n, CorrectlyRoundedIntervalOp);\n}\n\n/** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\nfunction AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n  return {\n    impl: (n: number) => {\n      if (!isF32Finite(n)) {\n        return toInterval(n);\n      }\n\n      assert(!Number.isNaN(n), `absolute not defined for NaN`);\n      return new F32Interval(n - error_range, n + error_range);\n    },\n  };\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  error_range = Math.abs(error_range);\n  return roundAndFlushPointToInterval(n, AbsoluteErrorIntervalOp(error_range));\n}\n\n/** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\nfunction ULPIntervalOp(numULP: number): PointToIntervalOp {\n  return {\n    impl: (n: number) => {\n      if (!isF32Finite(n)) {\n        assert(!Number.isNaN(n), `ULP not defined for NaN`);\n        return toInterval(n);\n      }\n\n      const ulp = oneULP(n);\n      const begin = n - numULP * ulp;\n      const end = n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumber(begin)),\n        Math.max(end, flushSubnormalNumber(end))\n      );\n    },\n  };\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return roundAndFlushPointToInterval(n, ULPIntervalOp(numULP));\n}\n\nconst AbsIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), AbsIntervalOp);\n}\n\nconst AdditionInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    if (!isF32Finite(x) && isF32Finite(y)) {\n      return correctlyRoundedInterval(x);\n    }\n\n    if (isF32Finite(x) && !isF32Finite(y)) {\n      return correctlyRoundedInterval(y);\n    }\n\n    if (!isF32Finite(x) && !isF32Finite(y)) {\n      if (Math.sign(x) === Math.sign(y)) {\n        return correctlyRoundedInterval(x);\n      } else {\n        return F32Interval.infinite();\n      }\n    }\n    return correctlyRoundedInterval(x + y);\n  },\n};\n\nconst AdditionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, AdditionInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), AdditionIntervalOp);\n}\n\nconst AtanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.atan(n), 4096);\n  },\n};\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), AtanIntervalOp);\n}\n\nconst Atan2IntervalOp: BinaryToIntervalOp = {\n  impl: (y: number, x: number): F32Interval => {\n    const numULP = 4096;\n    if (y === 0) {\n      if (x === 0) {\n        return F32Interval.infinite();\n      } else {\n        return F32Interval.span(\n          ulpInterval(kValue.f32.negative.pi.whole, numULP),\n          ulpInterval(kValue.f32.positive.pi.whole, numULP)\n        );\n      }\n    }\n    return ulpInterval(Math.atan2(y, x), numULP);\n  },\n  extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n    if (y.contains(0)) {\n      if (x.contains(0)) {\n        return [toInterval(0), toInterval(0)];\n      }\n      return [toInterval(0), x];\n    }\n    return [y, x];\n  },\n};\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(y), toInterval(x), Atan2IntervalOp);\n}\n\nconst CeilIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.ceil(n));\n  },\n};\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), CeilIntervalOp);\n}\n\nconst ClampMedianIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return correctlyRoundedInterval(\n      // Default sort is string sort, so have to implement numeric comparison.\n      // Cannot use the b-a one liner, because that assumes no infinities.\n      [x, y, z].sort((a, b) => {\n        if (a < b) {\n          return -1;\n        }\n        if (a > b) {\n          return 1;\n        }\n        return 0;\n      })[1]\n    );\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\nexport function clampMedianInterval(\n  x: number | F32Interval,\n  y: number | F32Interval,\n  z: number | F32Interval\n): F32Interval {\n  return runTernaryOp(toInterval(x), toInterval(y), toInterval(z), ClampMedianIntervalOp);\n}\n\nconst ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, low: number, high: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(Math.max(x, low), high));\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\nexport function clampMinMaxInterval(\n  x: number | F32Interval,\n  low: number | F32Interval,\n  high: number | F32Interval\n): F32Interval {\n  return runTernaryOp(toInterval(x), toInterval(low), toInterval(high), ClampMinMaxIntervalOp);\n}\n\nconst CosIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return kValue.f32.negative.pi.whole <= n && n <= kValue.f32.positive.pi.whole\n      ? absoluteErrorInterval(Math.cos(n), 2 ** -11)\n      : F32Interval.infinite();\n  },\n};\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), CosIntervalOp);\n}\n\nconst DivisionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    assert(\n      !isSubnormalNumber(y),\n      `divisionInterval impl should never receive y === 0 or flush(y) === 0`\n    );\n    return ulpInterval(x / y, 2.5);\n  },\n};\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  {\n    const Y = toInterval(y);\n    const lower_bound = 2 ** -126;\n    const upper_bound = 2 ** 126;\n    // division accuracy is not defined outside of |denominator| on [2 ** -126, 2 ** 126]\n    if (\n      !new F32Interval(-upper_bound, -lower_bound).contains(Y) &&\n      !new F32Interval(lower_bound, upper_bound).contains(Y)\n    ) {\n      return F32Interval.infinite();\n    }\n  }\n\n  return runBinaryOp(toInterval(x), toInterval(y), DivisionIntervalOp);\n}\n\nconst ExpIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    return ulpInterval(Math.exp(x), 3 + 2 * Math.abs(x));\n  },\n};\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), ExpIntervalOp);\n}\n\nconst Exp2IntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    return ulpInterval(Math.pow(2, x), 3 + 2 * Math.abs(x));\n  },\n};\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), Exp2IntervalOp);\n}\n\nconst FloorIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.floor(n));\n  },\n};\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), FloorIntervalOp);\n}\n\nconst FractIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // fract(x) = x - floor(x) is defined in the spec.\n    // For people coming from a non-graphics background this will cause some unintuitive results. For example,\n    // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n    // This is how other shading languages operate and allows for a desirable wrap around in graphics programming.\n    const result = subtractionInterval(n, floorInterval(n));\n    if (result.contains(1)) {\n      // Very small negative numbers can lead to catastrophic cancellation, thus calculating a fract of 1.0, which is\n      // technically not a fractional part, so some implementations clamp the result to next nearest number.\n      return F32Interval.span(result, toInterval(kValue.f32.positive.less_than_one));\n    }\n    return result;\n  },\n};\n\n/** Calculate an acceptance interval of fract(x) */\nexport function fractInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), FractIntervalOp);\n}\n\nconst InverseSqrtIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    if (n <= 0) {\n      // 1 / sqrt(n) for n <= 0 is not meaningfully defined for real f32\n      return F32Interval.infinite();\n    }\n    return ulpInterval(1 / Math.sqrt(n), 2);\n  },\n};\n\n/** Calculate an acceptance interval of inverseSqrt(x) */\nexport function inverseSqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(n), InverseSqrtIntervalOp);\n}\n\nconst LogIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // log is not defined in the real plane for x <= 0\n    if (x <= 0.0) {\n      return F32Interval.infinite();\n    }\n\n    if (x >= 0.5 && x <= 2.0) {\n      return absoluteErrorInterval(Math.log(x), 2 ** -21);\n    }\n    return ulpInterval(Math.log(x), 3);\n  },\n};\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), LogIntervalOp);\n}\n\nconst Log2IntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // log2 is not defined in the real plane for x <= 0\n    if (x <= 0.0) {\n      return F32Interval.infinite();\n    }\n\n    if (x >= 0.5 && x <= 2.0) {\n      return absoluteErrorInterval(Math.log2(x), 2 ** -21);\n    }\n    return ulpInterval(Math.log2(x), 3);\n  },\n};\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), Log2IntervalOp);\n}\n\nconst MaxIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.max(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MaxIntervalOp);\n}\n\nconst MinIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MinIntervalOp);\n}\n\nconst MultiplicationInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    if (x === 0 || y === 0) {\n      return correctlyRoundedInterval(0);\n    }\n\n    const appropriate_infinity =\n      Math.sign(x) === Math.sign(y) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n    if (!isF32Finite(x) || !isF32Finite(y)) {\n      return correctlyRoundedInterval(appropriate_infinity);\n    }\n\n    return correctlyRoundedInterval(x * y);\n  },\n};\n\nconst MultiplicationIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, MultiplicationInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MultiplicationIntervalOp);\n}\n\nconst NegationIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(-n);\n  },\n};\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), NegationIntervalOp);\n}\n\nconst SinIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return kValue.f32.negative.pi.whole <= n && n <= kValue.f32.positive.pi.whole\n      ? absoluteErrorInterval(Math.sin(n), 2 ** -11)\n      : F32Interval.infinite();\n  },\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), SinIntervalOp);\n}\n\nconst SubtractionInnerOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    if (!isF32Finite(x) && isF32Finite(y)) {\n      return correctlyRoundedInterval(x);\n    }\n\n    if (isF32Finite(x) && !isF32Finite(y)) {\n      const result = Math.sign(y) > 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n      return correctlyRoundedInterval(result);\n    }\n\n    if (!isF32Finite(x) && !isF32Finite(y)) {\n      if (Math.sign(x) === -Math.sign(y)) {\n        return correctlyRoundedInterval(x);\n      } else {\n        return F32Interval.infinite();\n      }\n    }\n    return correctlyRoundedInterval(x - y);\n  },\n};\n\nconst SubtractionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, SubtractionInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), SubtractionIntervalOp);\n}\n\nconst TanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinInterval(n), cosInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tan(x) */\nexport function tanInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), TanIntervalOp);\n}\n"],"file":"f32_interval.js"}