{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","kValue","correctlyRoundedF32","flushSubnormalNumber","isF32Finite","oneULP","F32Interval","constructor","bounds","begin","end","Number","isNaN","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","i","toInterval","isPoint","isFinite","span","intervals","length","forEach","Math","min","max","toString","any","_any","undefined","kNegPiToPiInterval","f32","negative","pi","whole","positive","kGreaterThanZeroInterval","subnormal","limitPointToIntervalDomain","domain","impl","limitBinaryToIntervalDomain","x","y","some","d","roundAndFlushPointToInterval","op","values","inputs","Set","map","results","roundAndFlushBinaryToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","runPointOp","extrema","result","runBinaryOp","outputs","runTernaryOp","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","AbsoluteErrorIntervalOp","error_range","_","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","ulpInterval","AbsIntervalOp","absInterval","AdditionIntervalOp","additionInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","atan2","atan2Interval","CeilIntervalOp","ceil","ceilInterval","ClampMedianIntervalOp","sort","a","b","clampMedianInterval","ClampMinMaxIntervalOp","low","high","clampMinMaxInterval","CosIntervalOp","cos","cosInterval","DegreesIntervalOp","multiplicationInterval","degreesInterval","DivisionIntervalOp","divisionInterval","ExpIntervalOp","exp","expInterval","Exp2IntervalOp","pow","exp2Interval","FloorIntervalOp","floor","floorInterval","FractIntervalOp","subtractionInterval","less_than_one","fractInterval","InverseSqrtIntervalOp","sqrt","inverseSqrtInterval","LdexpIntervalOp","e1","e2","ldexpInterval","LogIntervalOp","log","logInterval","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","maxInterval","MinIntervalOp","minInterval","MultiplicationInnerOp","MultiplicationIntervalOp","NegationIntervalOp","negationInterval","PowIntervalOp","powInterval","RadiansIntervalOp","radiansInterval","saturateInterval","SignIntervalOp","signInterval","SinIntervalOp","sin","sinInterval","StepIntervalOp","edge","stepInterval","SubtractionInnerOp","SubtractionIntervalOp","TanIntervalOp","tanInterval"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kValue } from './constants.js';\nimport { correctlyRoundedF32, flushSubnormalNumber, isF32Finite, oneULP } from './math.js';\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _any: F32Interval;\n\n  /** Constructor\n   *\n   * @param bounds a pair of numbers indicating the beginning then the end of the interval\n   */\n  public constructor(...bounds: [number, number]) {\n    const [begin, end] = bounds;\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns if a point or interval is completely contained by this interval\n   *\n   * Due to values that are above/below the f32 range being indistinguishable\n   * from other values out of range in the same way, there some unintuitive\n   * behaviours here, for example:\n   *   [0, greater than max f32].contains(+∞) will return true.\n   */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the undefined interval indicates that the accuracy is not defined\n      // for this test, so the test is just checking that this input doesn't\n      // cause the implementation to misbehave, so NaN is acceptable.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toInterval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains f32 finite values */\n  public isFinite(): boolean {\n    return isF32Finite(this.begin) && isF32Finite(this.end);\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.begin}, ${this.end}]`;\n  }\n\n  /** @returns a singleton for interval of all possible values\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static any(): F32Interval {\n    if (this._any === undefined) {\n      this._any = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._any;\n  }\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toInterval(n: number | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n  return new F32Interval(n, n);\n}\n\n/** F32Interval of [-π, π] */\nconst kNegPiToPiInterval = new F32Interval(\n  kValue.f32.negative.pi.whole,\n  kValue.f32.positive.pi.whole\n);\n\n/** F32Interval of values greater than 0 and less than or equal to f32 max */\nconst kGreaterThanZeroInterval = new F32Interval(\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.positive.max\n);\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\nexport interface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: PointToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by runPointOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * Restrict the inputs to an PointToInterval operation\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain interval to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a PointToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitPointToIntervalDomain(domain: F32Interval, impl: PointToInterval): PointToInterval {\n  return (n: number): F32Interval => {\n    return domain.contains(n) ? impl(n) : F32Interval.any();\n  };\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: BinaryToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runBinaryOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/** Domain for a BinaryToInterval implementation */\ninterface BinaryToIntervalDomain {\n  x: F32Interval;\n  // y is an array to support handling domains composed of discrete intervals\n  y: F32Interval[];\n}\n\n/**\n * Restrict the inputs to an BinaryToInterval\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain set of intervals to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a BinaryToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitBinaryToIntervalDomain(\n  domain: BinaryToIntervalDomain,\n  impl: BinaryToInterval\n): BinaryToInterval {\n  return (x: number, y: number): F32Interval => {\n    if (!domain.x.contains(x)) {\n      return F32Interval.any();\n    }\n\n    if (!domain.y.some(d => d.contains(y))) {\n      return F32Interval.any();\n    }\n\n    return impl(x, y);\n  };\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: TernaryToInterval;\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = new Set<number>([...values, ...values.map(flushSubnormalNumber)]);\n  const results = new Set<F32Interval>([...inputs].map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const z_inputs = new Set<number>([...z_values, ...z_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (!x.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n\n  const result = F32Interval.span(\n    roundAndFlushPointToInterval(x.begin, op),\n    roundAndFlushPointToInterval(x.end, op)\n  );\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runBinaryOp(x: F32Interval, y: F32Interval, op: BinaryToIntervalOp): F32Interval {\n  if (!x.isFinite() || !y.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runTernaryOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n    return F32Interval.any();\n  }\n\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n  const z_values = new Set<number>([z.begin, z.end]);\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      z_values.forEach(inner_z => {\n        outputs.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Defines a PointToIntervalOp for an interval of the correctly rounded values around the point */\nconst CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    assert(!Number.isNaN(n), `absolute not defined for NaN`);\n    return toInterval(n);\n  },\n};\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), CorrectlyRoundedIntervalOp);\n}\n\n/** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\nfunction AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isF32Finite(error_range)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n      return new F32Interval(n - error_range, n + error_range);\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  error_range = Math.abs(error_range);\n  return runPointOp(toInterval(n), AbsoluteErrorIntervalOp(error_range));\n}\n\n/** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\nfunction ULPIntervalOp(numULP: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isF32Finite(numULP)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n      const ulp = oneULP(n);\n      const begin = n - numULP * ulp;\n      const end = n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumber(begin)),\n        Math.max(end, flushSubnormalNumber(end))\n      );\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return runPointOp(toInterval(n), ULPIntervalOp(numULP));\n}\n\nconst AbsIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    return correctlyRoundedInterval(Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), AbsIntervalOp);\n}\n\nconst AdditionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x + y);\n  },\n};\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), AdditionIntervalOp);\n}\n\nconst AtanIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    return ulpInterval(Math.atan(n), 4096);\n  },\n};\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), AtanIntervalOp);\n}\n\nconst Atan2IntervalOp: BinaryToIntervalOp = {\n  impl: (y: number, x: number): F32Interval => {\n    const numULP = 4096;\n    if (y === 0) {\n      if (x === 0) {\n        return F32Interval.any();\n      } else {\n        return F32Interval.span(\n          ulpInterval(kValue.f32.negative.pi.whole, numULP),\n          ulpInterval(kValue.f32.positive.pi.whole, numULP)\n        );\n      }\n    }\n    return ulpInterval(Math.atan2(y, x), numULP);\n  },\n  extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n    if (y.contains(0)) {\n      if (x.contains(0)) {\n        return [toInterval(0), toInterval(0)];\n      }\n      return [toInterval(0), x];\n    }\n    return [y, x];\n  },\n};\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(y), toInterval(x), Atan2IntervalOp);\n}\n\nconst CeilIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.ceil(n));\n  },\n};\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), CeilIntervalOp);\n}\n\nconst ClampMedianIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return correctlyRoundedInterval(\n      // Default sort is string sort, so have to implement numeric comparison.\n      // Cannot use the b-a one liner, because that assumes no infinities.\n      [x, y, z].sort((a, b) => {\n        if (a < b) {\n          return -1;\n        }\n        if (a > b) {\n          return 1;\n        }\n        return 0;\n      })[1]\n    );\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\nexport function clampMedianInterval(\n  x: number | F32Interval,\n  y: number | F32Interval,\n  z: number | F32Interval\n): F32Interval {\n  return runTernaryOp(toInterval(x), toInterval(y), toInterval(z), ClampMedianIntervalOp);\n}\n\nconst ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, low: number, high: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(Math.max(x, low), high));\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\nexport function clampMinMaxInterval(\n  x: number | F32Interval,\n  low: number | F32Interval,\n  high: number | F32Interval\n): F32Interval {\n  return runTernaryOp(toInterval(x), toInterval(low), toInterval(high), ClampMinMaxIntervalOp);\n}\n\nconst CosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.cos(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), CosIntervalOp);\n}\n\nconst DegreesIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 57.295779513082322865);\n  },\n};\n\n/** Calculate an acceptance interval of degrees(x) */\nexport function degreesInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), DegreesIntervalOp);\n}\n\nconst DivisionIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-(2 ** 126), -(2 ** -126)), new F32Interval(2 ** -126, 2 ** 126)],\n    },\n    (x: number, y: number): F32Interval => {\n      if (y === 0) {\n        return F32Interval.any();\n      }\n      return ulpInterval(x / y, 2.5);\n    }\n  ),\n  extrema: (x: F32Interval, y: F32Interval): [F32Interval, F32Interval] => {\n    // division has a discontinuity at y = 0.\n    if (y.contains(0)) {\n      y = toInterval(0);\n    }\n    return [x, y];\n  },\n};\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), DivisionIntervalOp);\n}\n\nconst ExpIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.exp(n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), ExpIntervalOp);\n}\n\nconst Exp2IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.pow(2, n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), Exp2IntervalOp);\n}\n\nconst FloorIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.floor(n));\n  },\n};\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), FloorIntervalOp);\n}\n\nconst FractIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // fract(x) = x - floor(x) is defined in the spec.\n    // For people coming from a non-graphics background this will cause some unintuitive results. For example,\n    // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n    // This is how other shading languages operate and allows for a desirable wrap around in graphics programming.\n    const result = subtractionInterval(n, floorInterval(n));\n    if (result.contains(1)) {\n      // Very small negative numbers can lead to catastrophic cancellation, thus calculating a fract of 1.0, which is\n      // technically not a fractional part, so some implementations clamp the result to next nearest number.\n      return F32Interval.span(result, toInterval(kValue.f32.positive.less_than_one));\n    }\n    return result;\n  },\n};\n\n/** Calculate an acceptance interval of fract(x) */\nexport function fractInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), FractIntervalOp);\n}\n\nconst InverseSqrtIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      return ulpInterval(1 / Math.sqrt(n), 2);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of inverseSqrt(x) */\nexport function inverseSqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(n), InverseSqrtIntervalOp);\n}\n\nconst LdexpIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    // Implementing SPIR-V's more restrictive domain until\n    // https://github.com/gpuweb/gpuweb/issues/3134 is resolved\n    {\n      x: new F32Interval(kValue.f32.negative.min, kValue.f32.positive.max),\n      y: [new F32Interval(-126, 128)],\n    },\n    (e1: number, e2: number): F32Interval => {\n      // Though the spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, the\n      // accuracy is listed as correctly rounded to the true value, so the\n      // inheritance framework does not need to be invoked to determine bounds.\n      // Instead the value at a higher precision is calculated and passed to\n      // correctlyRoundedInterval.\n      const result = e1 * 2 ** e2;\n      if (Number.isNaN(result)) {\n        // Overflowed TS's number type, so definitely out of bounds for f32\n        return F32Interval.any();\n      }\n      return correctlyRoundedInterval(result);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of ldexp(e1, e2) */\nexport function ldexpInterval(e1: number, e2: number): F32Interval {\n  return roundAndFlushBinaryToInterval(e1, e2, LdexpIntervalOp);\n}\n\nconst LogIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), LogIntervalOp);\n}\n\nconst Log2IntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log2(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log2(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  return runPointOp(toInterval(x), Log2IntervalOp);\n}\n\nconst MaxIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.max(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MaxIntervalOp);\n}\n\nconst MinIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(Math.min(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MinIntervalOp);\n}\n\nconst MultiplicationInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x * y);\n  },\n};\n\nconst MultiplicationIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, MultiplicationInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), MultiplicationIntervalOp);\n}\n\nconst NegationIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(-n);\n  },\n};\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), NegationIntervalOp);\n}\n\nconst PowIntervalOp: BinaryToIntervalOp = {\n  // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n  // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n  // enforce this, so there is no need to wrap the impl call here.\n  impl: (x: number, y: number): F32Interval => {\n    return exp2Interval(multiplicationInterval(y, log2Interval(x)));\n  },\n};\n\n/** Calculate an acceptance interval of pow(x, y) */\nexport function powInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), PowIntervalOp);\n}\n\nconst RadiansIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 0.017453292519943295474);\n  },\n};\n\n/** Calculate an acceptance interval of radians(x) */\nexport function radiansInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), RadiansIntervalOp);\n}\n\n/**\n * Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0)\n *\n * The definition of saturate is such that both possible implementations of\n * clamp will return the same value, so arbitrarily picking the minmax version\n * to use.\n */\nexport function saturateInterval(n: number): F32Interval {\n  return runTernaryOp(toInterval(n), toInterval(0.0), toInterval(1.0), ClampMinMaxIntervalOp);\n}\n\nconst SignIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    if (n > 0.0) {\n      return correctlyRoundedInterval(1.0);\n    }\n    if (n < 0.0) {\n      return correctlyRoundedInterval(-1.0);\n    }\n\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function signInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), SignIntervalOp);\n}\n\nconst SinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.sin(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), SinIntervalOp);\n}\n\nconst StepIntervalOp: BinaryToIntervalOp = {\n  impl: (edge: number, x: number): F32Interval => {\n    if (edge <= x) {\n      return correctlyRoundedInterval(1.0);\n    }\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance 'interval' for step(edge, x)\n *\n * step only returns two possible values, so its interval requires special\n * interpretation in CTS tests.\n * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-∞, +∞].\n * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n * indicate either 0.0 or 1.0 are acceptable answers.\n * [-∞, +∞] is treated as the any interval, since an undefined or infinite value was passed in.\n */\nexport function stepInterval(edge: number, x: number): F32Interval {\n  return runBinaryOp(toInterval(edge), toInterval(x), StepIntervalOp);\n}\n\nconst SubtractionInnerOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x - y);\n  },\n};\n\nconst SubtractionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, SubtractionInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryOp(toInterval(x), toInterval(y), SubtractionIntervalOp);\n}\n\nconst TanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinInterval(n), cosInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tan(x) */\nexport function tanInterval(n: number): F32Interval {\n  return runPointOp(toInterval(n), TanIntervalOp);\n}\n"],"file":"f32_interval.js"}