{"version":3,"sources":["../../../src/webgpu/util/copy_to_texture.ts"],"names":["GPUTest","checkElementsEqual","checkElementsBetween","align","kBytesPerRowAlignment","isFp16Format","format","CopyToTextureUtils","checkCopyExternalImageResult","src","expected","width","height","bytesPerPixel","isFp16","exp","Uint8Array","buffer","byteOffset","byteLength","rowPitch","readbackPromise","readGPUBufferRangeTyped","type","typedLength","eventualAsyncExpectation","niceStack","readback","check","checkBufferWithRowPitch","data","undefined","message","rec","expectationFailed","cleanup","actual","bytesPerRow","y","expRow","subarray","checkResult","i","doTestAndCheckResult","imageCopyExternalImage","dstTextureCopyView","copySize","expectedData","device","queue","copyExternalImageToTexture","externalImage","source","dstTexture","texture","testBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","trackForCleanup","encoder","createCommandEncoder","copyTextureToBuffer","mipLevel","origin","x","z","depthOrArrayLayers","submit","finish"],"mappings":"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","sourcesContent":["import { GPUTest } from '../gpu_test.js';\n\nimport { checkElementsEqual, checkElementsBetween } from './check_contents.js';\nimport { align } from './math.js';\nimport { kBytesPerRowAlignment } from './texture/layout.js';\n\nexport function isFp16Format(format: GPUTextureFormat): boolean {\n  switch (format) {\n    case 'r16float':\n    case 'rg16float':\n    case 'rgba16float':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport class CopyToTextureUtils extends GPUTest {\n  // TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkCopyExternalImageResult(\n    src: GPUBuffer,\n    expected: ArrayBufferView,\n    width: number,\n    height: number,\n    bytesPerPixel: number,\n    isFp16: boolean\n  ): void {\n    const exp = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);\n    const rowPitch = align(width * bytesPerPixel, kBytesPerRowAlignment);\n\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      type: Uint8Array,\n      typedLength: rowPitch * height,\n    });\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      const check = this.checkBufferWithRowPitch(\n        readback.data,\n        exp,\n        width,\n        height,\n        rowPitch,\n        bytesPerPixel,\n        isFp16\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.expectationFailed(niceStack);\n      }\n      readback.cleanup();\n    });\n  }\n\n  // TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkBufferWithRowPitch(\n    actual: Uint8Array,\n    exp: Uint8Array,\n    width: number,\n    height: number,\n    rowPitch: number,\n    bytesPerPixel: number,\n    isFp16: boolean\n  ): string | undefined {\n    const bytesPerRow = width * bytesPerPixel;\n    // When dst format is fp16 formats, the expectation and real result always has 1 bit difference in the ending\n    // (e.g. CC vs CD) if there needs some alpha ops (if alpha channel is not 0.0 or 1.0). Suspect it is errors when\n    // doing encoding. We check fp16 dst texture format with 1-bit ULP tolerance.\n    if (isFp16) {\n      for (let y = 0; y < height; ++y) {\n        const expRow = exp.subarray(y * bytesPerRow, bytesPerRow);\n        const checkResult = checkElementsBetween(actual.subarray(y * rowPitch, bytesPerRow), [\n          i => (expRow[i] > 0 ? expRow[i] - 1 : expRow[i]),\n          i => expRow[i] + 1,\n        ]);\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    } else {\n      for (let y = 0; y < height; ++y) {\n        const checkResult = checkElementsEqual(\n          actual.subarray(y * rowPitch, bytesPerRow),\n          exp.subarray(y * bytesPerRow, bytesPerRow)\n        );\n        if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n      }\n    }\n    return undefined;\n  }\n\n  doTestAndCheckResult(\n    imageCopyExternalImage: GPUImageCopyExternalImage,\n    dstTextureCopyView: GPUImageCopyTextureTagged,\n    copySize: GPUExtent3DDict,\n    bytesPerPixel: number,\n    expectedData: Uint8ClampedArray,\n    isFp16: boolean\n  ): void {\n    this.device.queue.copyExternalImageToTexture(\n      imageCopyExternalImage,\n      dstTextureCopyView,\n      copySize\n    );\n\n    const externalImage = imageCopyExternalImage.source;\n    const dstTexture = dstTextureCopyView.texture;\n\n    const bytesPerRow = align(externalImage.width * bytesPerPixel, kBytesPerRowAlignment);\n    const testBuffer = this.device.createBuffer({\n      size: bytesPerRow * externalImage.height,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(testBuffer);\n\n    const encoder = this.device.createCommandEncoder();\n\n    encoder.copyTextureToBuffer(\n      { texture: dstTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: testBuffer, bytesPerRow },\n      { width: externalImage.width, height: externalImage.height, depthOrArrayLayers: 1 }\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    this.checkCopyExternalImageResult(\n      testBuffer,\n      expectedData,\n      externalImage.width,\n      externalImage.height,\n      bytesPerPixel,\n      isFp16\n    );\n  }\n}\n"],"file":"copy_to_texture.js"}