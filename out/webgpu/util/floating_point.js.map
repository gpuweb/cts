{"version":3,"file":"floating_point.js","names":["assert","unreachable","Float16Array","anyOf","kValue","abstractFloat","f16","f32","isFloatType","toMatrix","toVector","u32","calculatePermutations","cartesianProduct","correctlyRoundedF16","correctlyRoundedF32","correctlyRoundedF64","flatten2DArray","flushSubnormalNumberF16","flushSubnormalNumberF32","flushSubnormalNumberF64","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","isSubnormalNumberF64","map2DArray","oneULPF16","oneULPF32","quantizeToF32","quantizeToF16","unflatten2DArray","every2DArray","SerializedFPIntervalKind","serializeFPKind","s","value","writeU8","Abstract","F16","F32","deserializeFPKind","kind","readU8","FPInterval","constructor","bounds","begin","end","length","Number","isNaN","traits","FP","isPoint","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","containsZeroOrSubnormals","constants","negative","subnormal","min","positive","max","isFinite","toString","map","scalarBuilder","serializeFPInterval","i","writeCond","unboundedInterval","if_true","writeF64","writeF32","writeF16","if_false","deserializeFPInterval","readCond","toInterval","readF64","readF32","readF16","addFlushedIfNeededF16","values","some","v","concat","FPTraits","k","Array","toParam","interval","fromParam","p","param","spanIntervals","intervals","every","forEach","Math","isVector","e","f","spanVectors","vectors","vector_length","result","isMatrix","m","c","num_rows","bind","spanMatrices","matrices","ms","num_cols","r","_","j","addFlushedIfNeeded","subnormals","filter","isSubnormal","needs_zero","limitScalarToIntervalDomain","domain","impl","limitScalarPairToIntervalDomain","x","y","d","unimplementedScalarToInterval","name","_x","unimplementedScalarPairToInterval","_y","unimplementedScalarTripleToInterval","_z","unimplementedScalarToVector","unimplementedVectorToInterval","unimplementedVectorPairToInterval","unimplementedVectorToVector","unimplementedVectorPairToVector","unimplementedVectorScalarToVector","unimplementedScalarVectorToVector","unimplementedMatrixToInterval","unimplementedMatrixToMatrix","unimplementedMatrixPairToMatrix","unimplementedMatrixScalarToMatrix","unimplementedScalarMatrixToMatrix","unimplementedMatrixVectorToVector","unimplementedVectorMatrixToVector","unimplementedDistance","unimplementedFaceForward","unimplementedLength","unimplementedModf","unimplementedRefract","_i","_s","_r","unboundedAbsoluteErrorInterval","_n","_error_range","unboundedUlpInterval","_numULP","makeScalarToIntervalCase","ops","quantize","o","undefined","input","expected","generateScalarToIntervalCases","params","reduce","cases","push","makeScalarPairToIntervalCase","param0","param1","generateScalarPairToIntervalCases","param0s","param1s","makeScalarTripleToIntervalCase","param2","generateScalarTripleToIntervalCases","param2s","makeVectorToIntervalCase","generateVectorToIntervalCases","makeVectorPairToIntervalCase","generateVectorPairToIntervalCases","makeVectorToVectorCase","generateVectorToVectorCases","makeScalarVectorToVectorCase","scalar","vector","results","generateScalarVectorToVectorCases","scalars","makeVectorScalarToVectorCase","generateVectorScalarToVectorCases","makeVectorPairToVectorCase","generateVectorPairToVectorCases","makeVectorPairScalarToVectorComponentWiseCase","componentWiseOps","width","el0","index","generateVectorPairScalarToVectorComponentWiseCase","makeMatrixToScalarCase","generateMatrixToScalarCases","makeMatrixToMatrixCase","generateMatrixToMatrixCases","makeMatrixPairToMatrixCase","generateMatrixPairToMatrixCases","makeMatrixScalarToMatrixCase","mat","generateMatrixScalarToMatrixCases","mats","makeScalarMatrixToMatrixCase","generateScalarMatrixToMatrixCases","makeMatrixVectorToVectorCase","vec","generateMatrixVectorToVectorCases","vecs","makeVectorMatrixToVectorCase","generateVectorMatrixToVectorCases","roundAndFlushScalarToInterval","op","correctlyRounded","inputs","Set","roundAndFlushScalarPairToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushScalarTripleToInterval","z","z_values","z_inputs","inner_z","roundAndFlushVectorToInterval","x_rounded","x_flushed","roundAndFlushVectorPairToInterval","y_rounded","y_flushed","roundAndFlushVectorToVector","interval_vectors","roundAndFlushVectorPairToVector","roundAndFlushMatrixToMatrix","m_flat","m_rounded","m_flushed","m_options","m_inputs","interval_matrices","inner_m","runScalarToIntervalOp","extrema","b","runScalarPairToIntervalOp","outputs","runScalarTripleToIntervalOp","runVectorToIntervalOp","runVectorPairToIntervalOp","runVectorToVectorOp","unboundedVector","runScalarToIntervalOpComponentWise","runVectorPairToVectorOp","runScalarPairToIntervalOpVectorComponentWise","idx","runMatrixToMatrixOp","unboundedMatrix","m_values","unflat_m","result_cols","result_rows","runScalarPairToIntervalOpMatrixComponentWise","cols","rows","flat_x","flat_y","AbsoluteErrorIntervalOp","error_range","absoluteErrorIntervalImpl","abs","CorrectlyRoundedIntervalOp","correctlyRoundedIntervalImpl","correctlyRoundedMatrixImpl","correctlyRoundedInterval","ULPIntervalOp","numULP","ulp","oneULP","flushSubnormal","ulpIntervalImpl","AbsIntervalOp","absIntervalImpl","AcosIntervalOp","sqrtInterval","subtractionInterval","multiplicationInterval","approx_abs_error","atan2Interval","absoluteErrorInterval","acos","acosIntervalImpl","AcoshAlternativeIntervalOp","inner_value","additionInterval","sqrt_value","logInterval","acoshAlternativeIntervalImpl","AcoshPrimaryIntervalOp","acoshPrimaryIntervalImpl","AdditionIntervalOp","additionIntervalImpl","additionMatrixMatrixIntervalImpl","AsinIntervalOp","asin","asinIntervalImpl","AsinhIntervalOp","asinhIntervalImpl","AtanIntervalOp","ulp_error","ulpInterval","atan","atanIntervalImpl","Atan2IntervalOpBuilder","domain_x","domain_y","atan_yx","f64","pi","whole","atan2IntervalImpl","AtanhIntervalOp","numerator","denominator","log_interval","divisionInterval","atanhIntervalImpl","CeilIntervalOp","ceil","ceilIntervalImpl","ClampMedianIntervalOp","sort","a","clampMedianIntervalImpl","ClampMinMaxIntervalOp","low","high","minInterval","maxInterval","clampMinMaxIntervalImpl","CosIntervalOp","negPiToPiInterval","abs_error","cos","cosIntervalImpl","CoshIntervalOp","minus_n","negationInterval","expInterval","coshIntervalImpl","CrossIntervalOp","r0","r1","r2","crossIntervalImpl","DegreesIntervalOp","degreesIntervalImpl","minorNxN","col","row","dim","col_indices","keys","row_indices","determinant2x2Interval","determinant3x3Interval","A","B","C","permutations","prev","cur","determinant4x4Interval","D","determinantIntervalImpl","DistanceIntervalScalarOp","lengthInterval","DistanceIntervalVectorOp","SubtractionIntervalOp","distanceIntervalImpl","DivisionIntervalOpBuilder","divisionIntervalImpl","DotIntervalOp","multiplications","MultiplicationIntervalOp","dotIntervalImpl","ExpIntervalOp","exp","expIntervalImpl","Exp2IntervalOp","pow","exp2IntervalImpl","faceForwardIntervalsImpl","x_vec","positive_x","negative_x","NegationIntervalOp","dot_interval","dotInterval","FloorIntervalOp","floor","floorIntervalImpl","FmaIntervalOp","fmaIntervalImpl","FractIntervalOp","floorInterval","less_than_one","fractIntervalImpl","InverseSqrtIntervalOp","greaterThanZeroInterval","sqrt","inverseSqrtIntervalImpl","LdexpIntervalOp","e1","e2","isInteger","bias","ldexpIntervalImpl","LengthIntervalScalarOp","LengthIntervalVectorOp","lengthIntervalImpl","LogIntervalOp","log","logIntervalImpl","Log2IntervalOp","log2","log2IntervalImpl","MaxIntervalOp","maxIntervalImpl","MinIntervalOp","minIntervalImpl","MixImpreciseIntervalOp","t","mixImpreciseIntervalImpl","MixPreciseIntervalOp","mixPreciseIntervalImpl","modfIntervalImpl","fract","MultiplicationInnerOp","multiplicationIntervalImpl","multiplyVectorByScalar","multiplicationMatrixScalarIntervalImpl","multiplicationScalarMatrixIntervalImpl","multiplicationMatrixMatrixIntervalImpl","mat_x","mat_y","x_cols","x_rows","y_cols","y_rows","x_transposed","transposeInterval","multiplicationMatrixVectorIntervalImpl","multiplicationVectorMatrixIntervalImpl","negationIntervalImpl","NormalizeIntervalOp","normalizeIntervalImpl","PowIntervalOp","exp2Interval","log2Interval","powIntervalImpl","RadiansIntervalOp","radiansIntervalImpl","ReflectIntervalOp","rhs","reflectIntervalImpl","refractIntervalImpl","r_squared","dot","dot_squared","one_minus_dot_squared","zeroVector","dot_times_r","k_sqrt","RemainderIntervalOp","truncInterval","remainderIntervalImpl","RoundIntervalOp","diff_before","diff_after","roundIntervalImpl","saturateIntervalImpl","SignIntervalOp","signIntervalImpl","SinIntervalOp","sin","sinIntervalImpl","SinhIntervalOp","sinhIntervalImpl","SmoothStepOp","clampMedianInterval","smoothStepIntervalImpl","SqrtIntervalOp","inverseSqrtInterval","sqrtIntervalImpl","StepIntervalOp","edge","stepIntervalImpl","subtractionIntervalImpl","subtractionMatrixMatrixIntervalImpl","TanIntervalOp","sinInterval","cosInterval","tanIntervalImpl","TanhIntervalOp","sinhInterval","coshInterval","tanhIntervalImpl","TransposeIntervalOp","transposeIntervalImpl","TruncIntervalOp","trunc","truncIntervalImpl","kF32UnboundedInterval","kF32ZeroInterval","F32Traits","_constants","infinity","nearest_max","three_quarters","half","third","quarter","sixth","nearest_min","zeroInterval","correctlyRoundedMatrix","absInterval","acosInterval","acoshAlternativeInterval","acoshPrimaryInterval","acoshIntervals","additionMatrixMatrixInterval","asinInterval","asinhInterval","atanInterval","atanhInterval","ceilInterval","clampMinMaxInterval","clampIntervals","crossInterval","degreesInterval","determinantInterval","distanceInterval","faceForwardIntervals","fmaInterval","fractInterval","ldexpInterval","mixImpreciseInterval","mixPreciseInterval","mixIntervals","modfInterval","multiplicationMatrixMatrixInterval","multiplicationMatrixScalarInterval","multiplicationScalarMatrixInterval","multiplicationMatrixVectorInterval","multiplicationVectorMatrixInterval","normalizeInterval","powInterval","radiansInterval","reflectInterval","refractInterval","remainderInterval","roundInterval","saturateInterval","signInterval","smoothStepInterval","stepInterval","subtractionMatrixMatrixInterval","tanInterval","tanhInterval","makeU32ToVectorCase","generateU32ToIntervalCases","QuantizeToF16IntervalOp","rounded","flushed","quantizeToF16IntervalImpl","quantizeToF16Interval","unpackData","ArrayBuffer","unpackDataU32","Uint32Array","unpackDataU16","Uint16Array","unpackDataU8","Uint8Array","unpackDataI16","Int16Array","unpackDataI8","Int8Array","unpackDataF16","unpack2x16floatIntervalImpl","unpack2x16floatInterval","unpack2x16snormIntervalImpl","unpack2x16snormInterval","unpack2x16unormIntervalImpl","unpack2x16unormInterval","unpack4x8snormIntervalImpl","unpack4x8snormInterval","unpack4x8unormIntervalImpl","unpack4x8unormInterval","kF32Traits","kAbstractUnboundedInterval","kAbstractZeroInterval","FPAbstractTraits","_target","_mode","kF16UnboundedInterval","kF16ZeroInterval","F16Traits","abstract","fpTraitsFor","type","isRepresentable"],"sources":["../../../src/webgpu/util/floating_point.ts"],"sourcesContent":["import { ROArrayArray, ROArrayArrayArray } from '../../common/util/types.js';\nimport { assert, unreachable } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\nimport { Case, IntervalFilter } from '../shader/execution/expression/expression.js';\n\nimport BinaryStream from './binary_stream.js';\nimport { anyOf } from './compare.js';\nimport { kValue } from './constants.js';\nimport {\n  abstractFloat,\n  f16,\n  f32,\n  isFloatType,\n  Scalar,\n  ScalarType,\n  toMatrix,\n  toVector,\n  u32,\n} from './conversion.js';\nimport {\n  calculatePermutations,\n  cartesianProduct,\n  correctlyRoundedF16,\n  correctlyRoundedF32,\n  correctlyRoundedF64,\n  flatten2DArray,\n  FlushMode,\n  flushSubnormalNumberF16,\n  flushSubnormalNumberF32,\n  flushSubnormalNumberF64,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  isSubnormalNumberF64,\n  map2DArray,\n  oneULPF16,\n  oneULPF32,\n  quantizeToF32,\n  quantizeToF16,\n  unflatten2DArray,\n  every2DArray,\n} from './math.js';\n\n/** Indicate the kind of WGSL floating point numbers being operated on */\nexport type FPKind = 'f32' | 'f16' | 'abstract';\n\nenum SerializedFPIntervalKind {\n  Abstract,\n  F32,\n  F16,\n}\n\n/** serializeFPKind() serializes a FPKind to a BinaryStream */\nexport function serializeFPKind(s: BinaryStream, value: FPKind) {\n  switch (value) {\n    case 'abstract':\n      s.writeU8(SerializedFPIntervalKind.Abstract);\n      break;\n    case 'f16':\n      s.writeU8(SerializedFPIntervalKind.F16);\n      break;\n    case 'f32':\n      s.writeU8(SerializedFPIntervalKind.F32);\n      break;\n  }\n}\n\n/** deserializeFPKind() deserializes a FPKind from a BinaryStream */\nexport function deserializeFPKind(s: BinaryStream): FPKind {\n  const kind = s.readU8();\n  switch (kind) {\n    case SerializedFPIntervalKind.Abstract:\n      return 'abstract';\n    case SerializedFPIntervalKind.F16:\n      return 'f16';\n    case SerializedFPIntervalKind.F32:\n      return 'f32';\n    default:\n      unreachable(`invalid deserialized FPKind: ${kind}`);\n  }\n}\n// Containers\n\n/**\n * Representation of bounds for an interval as an array with either one or two\n * elements. Single element indicates that the interval is a single point. For\n * two elements, the first is the lower bound of the interval and the second is\n * the upper bound.\n */\nexport type IntervalBounds = readonly [number] | readonly [number, number];\n\n/** Represents a closed interval of floating point numbers */\nexport class FPInterval {\n  public readonly kind: FPKind;\n  public readonly begin: number;\n  public readonly end: number;\n\n  /**\n   * Constructor\n   *\n   * `FPTraits.toInterval` is the preferred way to create FPIntervals\n   *\n   * @param kind the floating point number type this is an interval for\n   * @param bounds beginning and end of the interval\n   */\n  public constructor(kind: FPKind, ...bounds: IntervalBounds) {\n    this.kind = kind;\n\n    const [begin, end] = bounds.length === 2 ? bounds : [bounds[0], bounds[0]];\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns the floating point traits for this interval */\n  public traits(): FPTraits {\n    return FP[this.kind];\n  }\n\n  /** @returns begin and end if non-point interval, otherwise just begin */\n  public bounds(): IntervalBounds {\n    return this.isPoint() ? [this.begin] : [this.begin, this.end];\n  }\n\n  /** @returns if a point or interval is completely contained by this interval */\n  public contains(n: number | FPInterval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the 'any' interval indicates that accuracy is not defined for this\n      // test, so the test is just checking that this input doesn't cause the\n      // implementation to misbehave, so NaN is accepted.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n\n    if (n instanceof FPInterval) {\n      return this.begin <= n.begin && this.end >= n.end;\n    }\n    return this.begin <= n && this.end >= n;\n  }\n\n  /** @returns if any values in the interval may be flushed to zero, this\n   *           includes any subnormals and zero itself.\n   */\n  public containsZeroOrSubnormals(): boolean {\n    return !(\n      this.end < this.traits().constants().negative.subnormal.min ||\n      this.begin > this.traits().constants().positive.subnormal.max\n    );\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains finite values */\n  public isFinite(): boolean {\n    return this.traits().isFinite(this.begin) && this.traits().isFinite(this.end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `{ '${this.kind}', [${this.bounds().map(this.traits().scalarBuilder)}] }`;\n  }\n}\n\n/** serializeFPInterval() serializes a FPInterval to a BinaryStream */\nexport function serializeFPInterval(s: BinaryStream, i: FPInterval) {\n  serializeFPKind(s, i.kind);\n  const traits = FP[i.kind];\n  s.writeCond(i !== traits.constants().unboundedInterval, {\n    if_true: () => {\n      // Bounded\n      switch (i.kind) {\n        case 'abstract':\n          s.writeF64(i.begin);\n          s.writeF64(i.end);\n          break;\n        case 'f32':\n          s.writeF32(i.begin);\n          s.writeF32(i.end);\n          break;\n        case 'f16':\n          s.writeF16(i.begin);\n          s.writeF16(i.end);\n          break;\n        default:\n          unreachable(`Unable to serialize FPInterval ${i}`);\n          break;\n      }\n    },\n    if_false: () => {\n      // Unbounded\n    },\n  });\n}\n\n/** deserializeFPInterval() deserializes a FPInterval from a BinaryStream */\nexport function deserializeFPInterval(s: BinaryStream): FPInterval {\n  const kind = deserializeFPKind(s);\n  const traits = FP[kind];\n  return s.readCond({\n    if_true: () => {\n      // Bounded\n      switch (kind) {\n        case 'abstract':\n          return traits.toInterval([s.readF64(), s.readF64()]);\n        case 'f32':\n          return traits.toInterval([s.readF32(), s.readF32()]);\n        case 'f16':\n          return traits.toInterval([s.readF16(), s.readF16()]);\n      }\n      unreachable(`Unable to deserialize FPInterval with kind ${kind}`);\n    },\n    if_false: () => {\n      // Unbounded\n      return traits.constants().unboundedInterval;\n    },\n  });\n}\n\n/**\n * Representation of a vec2/3/4 of floating point intervals as an array of\n * FPIntervals.\n */\nexport type FPVector =\n  | [FPInterval, FPInterval]\n  | [FPInterval, FPInterval, FPInterval]\n  | [FPInterval, FPInterval, FPInterval, FPInterval];\n\n/** Shorthand for an Array of Arrays that contains a column-major matrix */\ntype Array2D<T> = ROArrayArray<T>;\n\n/**\n * Representation of a matCxR of floating point intervals as an array of arrays\n * of FPIntervals. This maps onto the WGSL concept of matrix. Internally\n */\nexport type FPMatrix =\n  | readonly [readonly [FPInterval, FPInterval], readonly [FPInterval, FPInterval]]\n  | readonly [\n      readonly [FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval]\n    ]\n  | readonly [\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval],\n      readonly [FPInterval, FPInterval, FPInterval, FPInterval]\n    ];\n\n// Utilities\n\n/** @returns input with an appended 0, if inputs contains non-zero subnormals */\n// When f16 traits is defined, this can be replaced with something like\n// `FP.f16..addFlushIfNeeded`\nfunction addFlushedIfNeededF16(values: readonly number[]): readonly number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF16(v)) ? values.concat(0) : values;\n}\n\n// Operations\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarToInterval {\n  (x: number): FPInterval;\n}\n\n/** Operation used to implement a ScalarToInterval */\ninterface ScalarToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: ScalarToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by this.runScalarToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | FPInterval, not x: number\n   */\n  extrema?: (x: FPInterval) => FPInterval;\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarPairToInterval {\n  (x: number, y: number): FPInterval;\n}\n\n/** Operation used to implement a ScalarPairToInterval */\ninterface ScalarPairToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: ScalarPairToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runScalarPairToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: FPInterval, y: FPInterval) => [FPInterval, FPInterval];\n}\n\n/** Domain for a ScalarPairToInterval implementation */\ninterface ScalarPairToIntervalDomain {\n  // Arrays to support discrete valid domain intervals\n  x: readonly FPInterval[];\n  y: readonly FPInterval[];\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarTripleToInterval {\n  (x: number, y: number, z: number): FPInterval;\n}\n\n/** Operation used to implement a ScalarTripleToInterval */\ninterface ScalarTripleToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: ScalarTripleToInterval;\n}\n\n// Currently ScalarToVector is not integrated with the rest of the floating point\n// framework, because the only builtins that use it are actually\n// u32 -> [f32, f32, f32, f32] functions, so the whole rounding and interval\n// process doesn't get applied to the inputs.\n// They do use the framework internally by invoking divisionInterval on segments\n// of the input.\n/**\n * A function that converts a point to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarToVector {\n  (n: number): FPVector;\n}\n\n/**\n * A function that converts a vector to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToInterval {\n  (x: readonly number[]): FPInterval;\n}\n\n/** Operation used to implement a VectorToInterval */\ninterface VectorToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vector x */\n  impl: VectorToInterval;\n}\n\n/**\n * A function that converts a pair of vectors to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToInterval {\n  (x: readonly number[], y: readonly number[]): FPInterval;\n}\n\n/** Operation used to implement a VectorPairToInterval */\ninterface VectorPairToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vectors (x, y) */\n  impl: VectorPairToInterval;\n}\n\n/**\n * A function that converts a vector to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToVector {\n  (x: readonly number[]): FPVector;\n}\n\n/** Operation used to implement a VectorToVector */\ninterface VectorToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vector x */\n  impl: VectorToVector;\n}\n\n/**\n * A function that converts a pair of vectors to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToVector {\n  (x: readonly number[], y: readonly number[]): FPVector;\n}\n\n/** Operation used to implement a VectorPairToVector */\ninterface VectorPairToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vectors (x, y) */\n  impl: VectorPairToVector;\n}\n\n/**\n * A function that converts a vector and a scalar to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorScalarToVector {\n  (x: readonly number[], y: number): FPVector;\n}\n\n/**\n * A function that converts a scalar and a vector  to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarVectorToVector {\n  (x: number, y: readonly number[]): FPVector;\n}\n\n/**\n * A function that converts a matrix to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToScalar {\n  (m: Array2D<number>): FPInterval;\n}\n\n/** Operation used to implement a MatrixToMatrix */\ninterface MatrixToMatrixOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a matrix of acceptance intervals for a function on matrix x */\n  impl: MatrixToMatrix;\n}\n\n/**\n * A function that converts a matrix to a matrix of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToMatrix {\n  (m: Array2D<number>): FPMatrix;\n}\n\n/**\n * A function that converts a pair of matrices to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixPairToMatrix {\n  (x: Array2D<number>, y: Array2D<number>): FPMatrix;\n}\n\n/**\n * A function that converts a matrix and a scalar to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixScalarToMatrix {\n  (x: Array2D<number>, y: number): FPMatrix;\n}\n\n/**\n * A function that converts a scalar and a matrix to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarMatrixToMatrix {\n  (x: number, y: Array2D<number>): FPMatrix;\n}\n\n/**\n * A function that converts a matrix and a vector to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixVectorToVector {\n  (x: Array2D<number>, y: readonly number[]): FPVector;\n}\n\n/**\n * A function that converts a vector and a matrix to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorMatrixToVector {\n  (x: readonly number[], y: Array2D<number>): FPVector;\n}\n\n// Traits\n\n/**\n * Typed structure containing all the limits/constants defined for each\n * WGSL floating point kind\n */\ninterface FPConstants {\n  positive: {\n    min: number;\n    max: number;\n    infinity: number;\n    nearest_max: number;\n    less_than_one: number;\n    subnormal: {\n      min: number;\n      max: number;\n    };\n    pi: {\n      whole: number;\n      three_quarters: number;\n      half: number;\n      third: number;\n      quarter: number;\n      sixth: number;\n    };\n    e: number;\n  };\n  negative: {\n    min: number;\n    max: number;\n    infinity: number;\n    nearest_min: number;\n    less_than_one: number;\n    subnormal: {\n      min: number;\n      max: number;\n    };\n    pi: {\n      whole: number;\n      three_quarters: number;\n      half: number;\n      third: number;\n      quarter: number;\n      sixth: number;\n    };\n  };\n  unboundedInterval: FPInterval;\n  zeroInterval: FPInterval;\n  negPiToPiInterval: FPInterval;\n  greaterThanZeroInterval: FPInterval;\n  zeroVector: {\n    2: FPVector;\n    3: FPVector;\n    4: FPVector;\n  };\n  unboundedVector: {\n    2: FPVector;\n    3: FPVector;\n    4: FPVector;\n  };\n  unboundedMatrix: {\n    2: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n    3: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n    4: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n  };\n}\n\n/** A representation of an FPInterval for a case param */\nexport type FPIntervalParam = {\n  kind: FPKind;\n  interval: number | IntervalBounds;\n};\n\n/** Abstract base class for all floating-point traits */\nexport abstract class FPTraits {\n  public readonly kind: FPKind;\n  protected constructor(k: FPKind) {\n    this.kind = k;\n  }\n\n  public abstract constants(): FPConstants;\n\n  // Utilities - Implemented\n\n  /** @returns an interval containing the point or the original interval */\n  public toInterval(n: number | IntervalBounds | FPInterval): FPInterval {\n    if (n instanceof FPInterval) {\n      if (n.kind === this.kind) {\n        return n;\n      }\n\n      // Preserve if the original interval was unbounded or bounded\n      if (!n.isFinite()) {\n        return this.constants().unboundedInterval;\n      }\n\n      return new FPInterval(this.kind, ...n.bounds());\n    }\n\n    if (n instanceof Array) {\n      return new FPInterval(this.kind, ...n);\n    }\n\n    return new FPInterval(this.kind, n, n);\n  }\n\n  /**\n   * Makes a param that can be turned into an interval\n   */\n  public toParam(n: number | IntervalBounds): FPIntervalParam {\n    return {\n      kind: this.kind,\n      interval: n,\n    };\n  }\n\n  /**\n   * Converts p into an FPInterval if it is an FPIntervalPAram\n   */\n  public fromParam(\n    p: number | IntervalBounds | FPIntervalParam\n  ): number | IntervalBounds | FPInterval {\n    const param = p as FPIntervalParam;\n    if (param.interval && param.kind) {\n      assert(param.kind === this.kind);\n      return this.toInterval(param.interval);\n    }\n    return p as number | IntervalBounds;\n  }\n\n  /**\n   * @returns an interval with the tightest bounds that includes all provided\n   *          intervals\n   */\n  public spanIntervals(...intervals: readonly FPInterval[]): FPInterval {\n    assert(intervals.length > 0, `span of an empty list of FPIntervals is not allowed`);\n    assert(\n      intervals.every(i => i.kind === this.kind),\n      `span is only defined for intervals with the same kind`\n    );\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return this.toInterval([begin, end]);\n  }\n\n  /** Narrow an array of values to FPVector if possible */\n  public isVector(v: ReadonlyArray<number | IntervalBounds | FPInterval>): v is FPVector {\n    if (v.every(e => e instanceof FPInterval && e.kind === this.kind)) {\n      return v.length === 2 || v.length === 3 || v.length === 4;\n    }\n    return false;\n  }\n\n  /** @returns an FPVector representation of an array of values if possible */\n  public toVector(v: ReadonlyArray<number | IntervalBounds | FPInterval>): FPVector {\n    if (this.isVector(v) && v.every(e => e.kind === this.kind)) {\n      return v;\n    }\n\n    const f = v.map(e => this.toInterval(e));\n    // The return of the map above is a readonly FPInterval[], which needs to be narrowed\n    // to FPVector, since FPVector is defined as fixed length tuples.\n    if (this.isVector(f)) {\n      return f;\n    }\n    unreachable(`Cannot convert [${v}] to FPVector`);\n  }\n\n  /**\n   * @returns a FPVector where each element is the span for corresponding\n   *          elements at the same index in the input vectors\n   */\n  public spanVectors(...vectors: FPVector[]): FPVector {\n    assert(\n      vectors.every(e => this.isVector(e)),\n      'Vector span is not defined for vectors of differing floating point kinds'\n    );\n\n    const vector_length = vectors[0].length;\n    assert(\n      vectors.every(e => e.length === vector_length),\n      `Vector span is not defined for vectors of differing lengths`\n    );\n\n    const result: FPInterval[] = new Array<FPInterval>(vector_length);\n\n    for (let i = 0; i < vector_length; i++) {\n      result[i] = this.spanIntervals(...vectors.map(v => v[i]));\n    }\n    return this.toVector(result);\n  }\n\n  /** Narrow an array of an array of values to FPMatrix if possible */\n  public isMatrix(m: Array2D<number | IntervalBounds | FPInterval> | FPVector[]): m is FPMatrix {\n    if (!m.every(c => c.every(e => e instanceof FPInterval && e.kind === this.kind))) {\n      return false;\n    }\n    // At this point m guaranteed to be a ROArrayArray<FPInterval>, but maybe typed as a\n    // FPVector[].\n    // Coercing the type since FPVector[] is functionally equivalent to\n    // ROArrayArray<FPInterval> for .length and .every, but they are type compatible,\n    // since tuples are not equivalent to arrays, so TS considers c in .every to\n    // be unresolvable below, even though our usage is safe.\n    m = m as ROArrayArray<FPInterval>;\n\n    if (m.length > 4 || m.length < 2) {\n      return false;\n    }\n\n    const num_rows = m[0].length;\n    if (num_rows > 4 || num_rows < 2) {\n      return false;\n    }\n\n    return m.every(c => c.length === num_rows);\n  }\n\n  /** @returns an FPMatrix representation of an array of an array of values if possible */\n  public toMatrix(m: Array2D<number | IntervalBounds | FPInterval> | FPVector[]): FPMatrix {\n    if (\n      this.isMatrix(m) &&\n      every2DArray(m, (e: FPInterval) => {\n        return e.kind === this.kind;\n      })\n    ) {\n      return m;\n    }\n\n    const result = map2DArray(m, this.toInterval.bind(this));\n\n    // The return of the map above is a ROArrayArray<FPInterval>, which needs to be\n    // narrowed to FPMatrix, since FPMatrix is defined as fixed length tuples.\n    if (this.isMatrix(result)) {\n      return result;\n    }\n    unreachable(`Cannot convert ${m} to FPMatrix`);\n  }\n\n  /**\n   * @returns a FPMatrix where each element is the span for corresponding\n   *          elements at the same index in the input matrices\n   */\n  public spanMatrices(...matrices: FPMatrix[]): FPMatrix {\n    // Coercing the type of matrices, since tuples are not generally compatible\n    // with Arrays, but they are functionally equivalent for the usages in this\n    // function.\n    const ms = matrices as Array2D<FPInterval>[];\n    const num_cols = ms[0].length;\n    const num_rows = ms[0][0].length;\n    assert(\n      ms.every(m => m.length === num_cols && m.every(r => r.length === num_rows)),\n      `Matrix span is not defined for Matrices of differing dimensions`\n    );\n\n    const result: FPInterval[][] = [...Array(num_cols)].map(_ => [...Array(num_rows)]);\n    for (let i = 0; i < num_cols; i++) {\n      for (let j = 0; j < num_rows; j++) {\n        result[i][j] = this.spanIntervals(...ms.map(m => m[i][j]));\n      }\n    }\n\n    return this.toMatrix(result);\n  }\n\n  /** @returns input with an appended 0, if inputs contains non-zero subnormals */\n  public addFlushedIfNeeded(values: readonly number[]): readonly number[] {\n    const subnormals = values.filter(this.isSubnormal);\n    const needs_zero = subnormals.length > 0 && subnormals.every(s => s !== 0);\n    return needs_zero ? values.concat(0) : values;\n  }\n\n  /**\n   * Restrict the inputs to an ScalarToInterval operation\n   *\n   * Only used for operations that have tighter domain requirements than 'must\n   * be finite'.\n   *\n   * @param domain interval to restrict inputs to\n   * @param impl operation implementation to run if input is within the required domain\n   * @returns a ScalarToInterval that calls impl if domain contains the input,\n   *          otherwise it returns an unbounded interval */\n  protected limitScalarToIntervalDomain(\n    domain: FPInterval,\n    impl: ScalarToInterval\n  ): ScalarToInterval {\n    return (n: number): FPInterval => {\n      return domain.contains(n) ? impl(n) : this.constants().unboundedInterval;\n    };\n  }\n\n  /**\n   * Restrict the inputs to a ScalarPairToInterval\n   *\n   * Only used for operations that have tighter domain requirements than 'must be\n   * finite'.\n   *\n   * @param domain set of intervals to restrict inputs to\n   * @param impl operation implementation to run if input is within the required domain\n   * @returns a ScalarPairToInterval that calls impl if domain contains the input,\n   *          otherwise it returns an unbounded interval */\n  protected limitScalarPairToIntervalDomain(\n    domain: ScalarPairToIntervalDomain,\n    impl: ScalarPairToInterval\n  ): ScalarPairToInterval {\n    return (x: number, y: number): FPInterval => {\n      if (!domain.x.some(d => d.contains(x)) || !domain.y.some(d => d.contains(y))) {\n        return this.constants().unboundedInterval;\n      }\n\n      return impl(x, y);\n    };\n  }\n\n  /** Stub for scalar to interval generator */\n  protected unimplementedScalarToInterval(name: string, _x: number | FPInterval): FPInterval {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for scalar pair to interval generator */\n  protected unimplementedScalarPairToInterval(\n    name: string,\n    _x: number | FPInterval,\n    _y: number | FPInterval\n  ): FPInterval {\n    unreachable(`'${name}' is yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for scalar triple to interval generator */\n  protected unimplementedScalarTripleToInterval(\n    name: string,\n    _x: number | FPInterval,\n    _y: number | FPInterval,\n    _z: number | FPInterval\n  ): FPInterval {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for scalar to vector generator */\n  protected unimplementedScalarToVector(name: string, _x: number | FPInterval): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector to interval generator */\n  protected unimplementedVectorToInterval(name: string, _x: (number | FPInterval)[]): FPInterval {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector pair to interval generator */\n  protected unimplementedVectorPairToInterval(\n    name: string,\n    _x: readonly (number | FPInterval)[],\n    _y: readonly (number | FPInterval)[]\n  ): FPInterval {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector to vector generator */\n  protected unimplementedVectorToVector(\n    name: string,\n    _x: readonly (number | FPInterval)[]\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector pair to vector generator */\n  protected unimplementedVectorPairToVector(\n    name: string,\n    _x: readonly (number | FPInterval)[],\n    _y: readonly (number | FPInterval)[]\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector-scalar to vector generator */\n  protected unimplementedVectorScalarToVector(\n    name: string,\n    _x: readonly (number | FPInterval)[],\n    _y: number | FPInterval\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for scalar-vector to vector generator */\n  protected unimplementedScalarVectorToVector(\n    name: string,\n    _x: number | FPInterval,\n    _y: (number | FPInterval)[]\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for matrix to interval generator */\n  protected unimplementedMatrixToInterval(name: string, _x: Array2D<number>): FPInterval {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for matrix to matirx generator */\n  protected unimplementedMatrixToMatrix(name: string, _x: Array2D<number>): FPMatrix {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for matrix pair to matrix generator */\n  protected unimplementedMatrixPairToMatrix(\n    name: string,\n    _x: Array2D<number>,\n    _y: Array2D<number>\n  ): FPMatrix {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for matrix-scalar to matrix generator  */\n  protected unimplementedMatrixScalarToMatrix(\n    name: string,\n    _x: Array2D<number>,\n    _y: number | FPInterval\n  ): FPMatrix {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for scalar-matrix to matrix generator  */\n  protected unimplementedScalarMatrixToMatrix(\n    name: string,\n    _x: number | FPInterval,\n    _y: Array2D<number>\n  ): FPMatrix {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for matrix-vector to vector generator  */\n  protected unimplementedMatrixVectorToVector(\n    name: string,\n    _x: Array2D<number>,\n    _y: readonly (number | FPInterval)[]\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for vector-matrix to vector generator  */\n  protected unimplementedVectorMatrixToVector(\n    name: string,\n    _x: readonly (number | FPInterval)[],\n    _y: Array2D<number>\n  ): FPVector {\n    unreachable(`'${name}' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for distance generator */\n  protected unimplementedDistance(\n    _x: number | readonly number[],\n    _y: number | readonly number[]\n  ): FPInterval {\n    unreachable(`'distance' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for faceForward */\n  protected unimplementedFaceForward(\n    _x: readonly number[],\n    _y: readonly number[],\n    _z: readonly number[]\n  ): (FPVector | undefined)[] {\n    unreachable(`'faceForward' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for length generator */\n  protected unimplementedLength(\n    _x: number | FPInterval | readonly number[] | FPVector\n  ): FPInterval {\n    unreachable(`'length' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for modf generator */\n  protected unimplementedModf(_x: number): { fract: FPInterval; whole: FPInterval } {\n    unreachable(`'modf' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Stub for refract generator */\n  protected unimplementedRefract(\n    _i: readonly number[],\n    _s: readonly number[],\n    _r: number\n  ): FPVector {\n    unreachable(`'refract' is not yet implemented for '${this.kind}'`);\n  }\n\n  /** Version of absoluteErrorInterval that always returns the unboundedInterval */\n  protected unboundedAbsoluteErrorInterval(_n: number, _error_range: number): FPInterval {\n    return this.constants().unboundedInterval;\n  }\n\n  /** Version of ulpInterval that always returns the unboundedInterval */\n  protected unboundedUlpInterval(_n: number, _numULP: number): FPInterval {\n    return this.constants().unboundedInterval;\n  }\n\n  // Utilities - Defined by subclass\n  /**\n   * @returns the nearest precise value to the input. Rounding should be IEEE\n   *          'roundTiesToEven'.\n   */\n  public abstract readonly quantize: (n: number) => number;\n  /** @returns all valid roundings of input */\n  public abstract readonly correctlyRounded: (n: number) => readonly number[];\n  /** @returns true if input is considered finite, otherwise false */\n  public abstract readonly isFinite: (n: number) => boolean;\n  /** @returns true if input is considered subnormal, otherwise false */\n  public abstract readonly isSubnormal: (n: number) => boolean;\n  /** @returns 0 if the provided number is subnormal, otherwise returns the proved number */\n  public abstract readonly flushSubnormal: (n: number) => number;\n  /** @returns 1 * ULP: (number) */\n  public abstract readonly oneULP: (target: number, mode?: FlushMode) => number;\n  /** @returns a builder for converting numbers to Scalars */\n  public abstract readonly scalarBuilder: (n: number) => Scalar;\n\n  // Framework - Cases\n\n  /**\n   * @returns a Case for the param and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeScalarToIntervalCase(\n    param: number,\n    filter: IntervalFilter,\n    ...ops: ScalarToInterval[]\n  ): Case | undefined {\n    param = this.quantize(param);\n\n    const intervals = ops.map(o => o(param));\n    if (filter === 'finite' && intervals.some(i => !i.isFinite())) {\n      return undefined;\n    }\n    return { input: [this.scalarBuilder(param)], expected: anyOf(...intervals) };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateScalarToIntervalCases(\n    params: readonly number[],\n    filter: IntervalFilter,\n    ...ops: ScalarToInterval[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeScalarToIntervalCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param0 the first param to pass in\n   * @param param1 the second param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeScalarPairToIntervalCase(\n    param0: number,\n    param1: number,\n    filter: IntervalFilter,\n    ...ops: ScalarPairToInterval[]\n  ): Case | undefined {\n    param0 = this.quantize(param0);\n    param1 = this.quantize(param1);\n\n    const intervals = ops.map(o => o(param0, param1));\n    if (filter === 'finite' && intervals.some(i => !i.isFinite())) {\n      return undefined;\n    }\n    return {\n      input: [this.scalarBuilder(param0), this.scalarBuilder(param1)],\n      expected: anyOf(...intervals),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of inputs to try for the first input\n   * @param param1s array of inputs to try for the second input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateScalarPairToIntervalCases(\n    param0s: readonly number[],\n    param1s: readonly number[],\n    filter: IntervalFilter,\n    ...ops: ScalarPairToInterval[]\n  ): Case[] {\n    return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n      const c = this.makeScalarPairToIntervalCase(e[0], e[1], filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param0 the first param to pass in\n   * @param param1 the second param to pass in\n   * @param param2 the third param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public makeScalarTripleToIntervalCase(\n    param0: number,\n    param1: number,\n    param2: number,\n    filter: IntervalFilter,\n    ...ops: ScalarTripleToInterval[]\n  ): Case | undefined {\n    param0 = this.quantize(param0);\n    param1 = this.quantize(param1);\n    param2 = this.quantize(param2);\n\n    const intervals = ops.map(o => o(param0, param1, param2));\n    if (filter === 'finite' && intervals.some(i => !i.isFinite())) {\n      return undefined;\n    }\n    return {\n      input: [this.scalarBuilder(param0), this.scalarBuilder(param1), this.scalarBuilder(param2)],\n      expected: anyOf(...intervals),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of inputs to try for the first input\n   * @param param1s array of inputs to try for the second input\n   * @param param2s array of inputs to try for the third input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateScalarTripleToIntervalCases(\n    param0s: readonly number[],\n    param1s: readonly number[],\n    param2s: readonly number[],\n    filter: IntervalFilter,\n    ...ops: ScalarTripleToInterval[]\n  ): Case[] {\n    return cartesianProduct(param0s, param1s, param2s).reduce((cases, e) => {\n      const c = this.makeScalarTripleToIntervalCase(e[0], e[1], e[2], filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeVectorToIntervalCase(\n    param: readonly number[],\n    filter: IntervalFilter,\n    ...ops: VectorToInterval[]\n  ): Case | undefined {\n    param = param.map(this.quantize);\n\n    const intervals = ops.map(o => o(param));\n    if (filter === 'finite' && intervals.some(i => !i.isFinite())) {\n      return undefined;\n    }\n    return {\n      input: [toVector(param, this.scalarBuilder)],\n      expected: anyOf(...intervals),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateVectorToIntervalCases(\n    params: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorToInterval[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeVectorToIntervalCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param0 the first param to pass in\n   * @param param1 the second param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeVectorPairToIntervalCase(\n    param0: readonly number[],\n    param1: readonly number[],\n    filter: IntervalFilter,\n    ...ops: VectorPairToInterval[]\n  ): Case | undefined {\n    param0 = param0.map(this.quantize);\n    param1 = param1.map(this.quantize);\n\n    const intervals = ops.map(o => o(param0, param1));\n    if (filter === 'finite' && intervals.some(i => !i.isFinite())) {\n      return undefined;\n    }\n    return {\n      input: [toVector(param0, this.scalarBuilder), toVector(param1, this.scalarBuilder)],\n      expected: anyOf(...intervals),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of inputs to try for the first input\n   * @param param1s array of inputs to try for the second input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateVectorPairToIntervalCases(\n    param0s: ROArrayArray<number>,\n    param1s: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorPairToInterval[]\n  ): Case[] {\n    return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n      const c = this.makeVectorPairToIntervalCase(e[0], e[1], filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the param and vector of intervals generator provided\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals.\n   */\n  private makeVectorToVectorCase(\n    param: readonly number[],\n    filter: IntervalFilter,\n    ...ops: VectorToVector[]\n  ): Case | undefined {\n    param = param.map(this.quantize);\n\n    const vectors = ops.map(o => o(param));\n    if (filter === 'finite' && vectors.some(v => v.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [toVector(param, this.scalarBuilder)],\n      expected: anyOf(...vectors),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals.\n   */\n  public generateVectorToVectorCases(\n    params: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorToVector[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeVectorToVectorCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the interval vector generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param scalar the scalar param to pass in\n   * @param vector the vector param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance intervals\n   */\n  private makeScalarVectorToVectorCase(\n    scalar: number,\n    vector: readonly number[],\n    filter: IntervalFilter,\n    ...ops: ScalarVectorToVector[]\n  ): Case | undefined {\n    scalar = this.quantize(scalar);\n    vector = vector.map(this.quantize);\n\n    const results = ops.map(o => o(scalar, vector));\n    if (filter === 'finite' && results.some(r => r.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [this.scalarBuilder(scalar), toVector(vector, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param scalars array of scalar inputs to try\n   * @param vectors array of vector inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance intervals\n   */\n  public generateScalarVectorToVectorCases(\n    scalars: readonly number[],\n    vectors: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: ScalarVectorToVector[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    scalars.forEach(scalar => {\n      vectors.forEach(vector => {\n        const c = this.makeScalarVectorToVectorCase(scalar, vector, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the params and the interval vector generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param vector the vector param to pass in\n   * @param scalar the scalar param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance intervals\n   */\n  private makeVectorScalarToVectorCase(\n    vector: readonly number[],\n    scalar: number,\n    filter: IntervalFilter,\n    ...ops: VectorScalarToVector[]\n  ): Case | undefined {\n    vector = vector.map(this.quantize);\n    scalar = this.quantize(scalar);\n\n    const results = ops.map(o => o(vector, scalar));\n    if (filter === 'finite' && results.some(r => r.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [toVector(vector, this.scalarBuilder), this.scalarBuilder(scalar)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param vectors array of vector inputs to try\n   * @param scalars array of scalar inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance intervals\n   */\n  public generateVectorScalarToVectorCases(\n    vectors: ROArrayArray<number>,\n    scalars: readonly number[],\n    filter: IntervalFilter,\n    ...ops: VectorScalarToVector[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    vectors.forEach(vector => {\n      scalars.forEach(scalar => {\n        const c = this.makeVectorScalarToVectorCase(vector, scalar, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the param and vector of intervals generator provided\n   * @param param0 the first param to pass in\n   * @param param1 the second param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals.\n   */\n  private makeVectorPairToVectorCase(\n    param0: readonly number[],\n    param1: readonly number[],\n    filter: IntervalFilter,\n    ...ops: VectorPairToVector[]\n  ): Case | undefined {\n    param0 = param0.map(this.quantize);\n    param1 = param1.map(this.quantize);\n    const vectors = ops.map(o => o(param0, param1));\n    if (filter === 'finite' && vectors.some(v => v.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [toVector(param0, this.scalarBuilder), toVector(param1, this.scalarBuilder)],\n      expected: anyOf(...vectors),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of inputs to try for the first input\n   * @param param1s array of inputs to try for the second input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals.\n   */\n  public generateVectorPairToVectorCases(\n    param0s: ROArrayArray<number>,\n    param1s: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorPairToVector[]\n  ): Case[] {\n    return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n      const c = this.makeVectorPairToVectorCase(e[0], e[1], filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and the component-wise interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param0 the first vector param to pass in\n   * @param param1 the second vector param to pass in\n   * @param param2 the scalar param to pass in\n   * @param filter what interval filtering to apply\n   * @param componentWiseOps callbacks that implement generating a component-wise acceptance interval,\n   *                         one component result at a time.\n   */\n  private makeVectorPairScalarToVectorComponentWiseCase(\n    param0: readonly number[],\n    param1: readonly number[],\n    param2: number,\n    filter: IntervalFilter,\n    ...componentWiseOps: ScalarTripleToInterval[]\n  ): Case | undefined {\n    // Width of input vector\n    const width = param0.length;\n    assert(2 <= width && width <= 4, 'input vector width must between 2 and 4');\n    assert(param1.length === width, 'two input vectors must have the same width');\n    param0 = param0.map(this.quantize);\n    param1 = param1.map(this.quantize);\n    param2 = this.quantize(param2);\n\n    // Call the component-wise interval generator and build the expectation FPVector\n    const results = componentWiseOps.map(o => {\n      return param0.map((el0, index) => o(el0, param1[index], param2)) as FPVector;\n    });\n    if (filter === 'finite' && results.some(r => r.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [\n        toVector(param0, this.scalarBuilder),\n        toVector(param1, this.scalarBuilder),\n        this.scalarBuilder(param2),\n      ],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of first vector inputs to try\n   * @param param1s array of second vector inputs to try\n   * @param param2s array of scalar inputs to try\n   * @param filter what interval filtering to apply\n   * @param componentWiseOpscallbacks that implement generating a component-wise acceptance interval\n   */\n  public generateVectorPairScalarToVectorComponentWiseCase(\n    param0s: ROArrayArray<number>,\n    param1s: ROArrayArray<number>,\n    param2s: readonly number[],\n    filter: IntervalFilter,\n    ...componentWiseOps: ScalarTripleToInterval[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    param0s.forEach(param0 => {\n      param1s.forEach(param1 => {\n        param2s.forEach(param2 => {\n          const c = this.makeVectorPairScalarToVectorComponentWiseCase(\n            param0,\n            param1,\n            param2,\n            filter,\n            ...componentWiseOps\n          );\n          if (c !== undefined) {\n            cases.push(c);\n          }\n        });\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the param and an array of interval generators provided\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeMatrixToScalarCase(\n    param: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixToScalar[]\n  ): Case | undefined {\n    param = map2DArray(param, this.quantize);\n\n    const results = ops.map(o => o(param));\n    if (filter === 'finite' && results.some(e => !e.isFinite())) {\n      return undefined;\n    }\n\n    return {\n      input: [toMatrix(param, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateMatrixToScalarCases(\n    params: ROArrayArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixToScalar[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeMatrixToScalarCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the param and an array of interval generators provided\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  private makeMatrixToMatrixCase(\n    param: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixToMatrix[]\n  ): Case | undefined {\n    param = map2DArray(param, this.quantize);\n\n    const results = ops.map(o => o(param));\n    if (filter === 'finite' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n      return undefined;\n    }\n\n    return {\n      input: [toMatrix(param, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  public generateMatrixToMatrixCases(\n    params: ROArrayArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixToMatrix[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeMatrixToMatrixCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and matrix of intervals generator provided\n   * @param param0 the first param to pass in\n   * @param param1 the second param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  private makeMatrixPairToMatrixCase(\n    param0: ROArrayArray<number>,\n    param1: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixPairToMatrix[]\n  ): Case | undefined {\n    param0 = map2DArray(param0, this.quantize);\n    param1 = map2DArray(param1, this.quantize);\n\n    const results = ops.map(o => o(param0, param1));\n    if (filter === 'finite' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n      return undefined;\n    }\n    return {\n      input: [toMatrix(param0, this.scalarBuilder), toMatrix(param1, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param param0s array of inputs to try for the first input\n   * @param param1s array of inputs to try for the second input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  public generateMatrixPairToMatrixCases(\n    param0s: ROArrayArrayArray<number>,\n    param1s: ROArrayArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixPairToMatrix[]\n  ): Case[] {\n    return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n      const c = this.makeMatrixPairToMatrixCase(e[0], e[1], filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  /**\n   * @returns a Case for the params and matrix of intervals generator provided\n   * @param mat the matrix param to pass in\n   * @param scalar the scalar to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  private makeMatrixScalarToMatrixCase(\n    mat: ROArrayArray<number>,\n    scalar: number,\n    filter: IntervalFilter,\n    ...ops: MatrixScalarToMatrix[]\n  ): Case | undefined {\n    mat = map2DArray(mat, this.quantize);\n    scalar = this.quantize(scalar);\n\n    const results = ops.map(o => o(mat, scalar));\n    if (filter === 'finite' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n      return undefined;\n    }\n    return {\n      input: [toMatrix(mat, this.scalarBuilder), this.scalarBuilder(scalar)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param mats array of inputs to try for the matrix input\n   * @param scalars array of inputs to try for the scalar input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  public generateMatrixScalarToMatrixCases(\n    mats: ROArrayArrayArray<number>,\n    scalars: readonly number[],\n    filter: IntervalFilter,\n    ...ops: MatrixScalarToMatrix[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    mats.forEach(mat => {\n      scalars.forEach(scalar => {\n        const c = this.makeMatrixScalarToMatrixCase(mat, scalar, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the params and matrix of intervals generator provided\n   * @param scalar the scalar to pass in\n   * @param mat the matrix param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  private makeScalarMatrixToMatrixCase(\n    scalar: number,\n    mat: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: ScalarMatrixToMatrix[]\n  ): Case | undefined {\n    scalar = this.quantize(scalar);\n    mat = map2DArray(mat, this.quantize);\n\n    const results = ops.map(o => o(scalar, mat));\n    if (filter === 'finite' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n      return undefined;\n    }\n    return {\n      input: [this.scalarBuilder(scalar), toMatrix(mat, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param scalars array of inputs to try for the scalar input\n   * @param mats array of inputs to try for the matrix input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a matrix of acceptance\n   *            intervals\n   */\n  public generateScalarMatrixToMatrixCases(\n    scalars: readonly number[],\n    mats: ROArrayArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: ScalarMatrixToMatrix[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    mats.forEach(mat => {\n      scalars.forEach(scalar => {\n        const c = this.makeScalarMatrixToMatrixCase(scalar, mat, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the params and the vector of intervals generator provided\n   * @param mat the matrix param to pass in\n   * @param vec the vector to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals\n   */\n  private makeMatrixVectorToVectorCase(\n    mat: ROArrayArray<number>,\n    vec: readonly number[],\n    filter: IntervalFilter,\n    ...ops: MatrixVectorToVector[]\n  ): Case | undefined {\n    mat = map2DArray(mat, this.quantize);\n    vec = vec.map(this.quantize);\n\n    const results = ops.map(o => o(mat, vec));\n    if (filter === 'finite' && results.some(v => v.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [toMatrix(mat, this.scalarBuilder), toVector(vec, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param mats array of inputs to try for the matrix input\n   * @param vecs array of inputs to try for the vector input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals\n   */\n  public generateMatrixVectorToVectorCases(\n    mats: ROArrayArrayArray<number>,\n    vecs: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: MatrixVectorToVector[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    mats.forEach(mat => {\n      vecs.forEach(vec => {\n        const c = this.makeMatrixVectorToVectorCase(mat, vec, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  /**\n   * @returns a Case for the params and the vector of intervals generator provided\n   * @param vec the vector to pass in\n   * @param mat the matrix param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals\n   */\n  private makeVectorMatrixToVectorCase(\n    vec: readonly number[],\n    mat: ROArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorMatrixToVector[]\n  ): Case | undefined {\n    vec = vec.map(this.quantize);\n    mat = map2DArray(mat, this.quantize);\n\n    const results = ops.map(o => o(vec, mat));\n    if (filter === 'finite' && results.some(v => v.some(e => !e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: [toVector(vec, this.scalarBuilder), toMatrix(mat, this.scalarBuilder)],\n      expected: anyOf(...results),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param vecs array of inputs to try for the vector input\n   * @param mats array of inputs to try for the matrix input\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating a vector of acceptance\n   *            intervals\n   */\n  public generateVectorMatrixToVectorCases(\n    vecs: ROArrayArray<number>,\n    mats: ROArrayArrayArray<number>,\n    filter: IntervalFilter,\n    ...ops: VectorMatrixToVector[]\n  ): Case[] {\n    // Cannot use cartesianProduct here, due to heterogeneous types\n    const cases: Case[] = [];\n    vecs.forEach(vec => {\n      mats.forEach(mat => {\n        const c = this.makeVectorMatrixToVectorCase(vec, mat, filter, ...ops);\n        if (c !== undefined) {\n          cases.push(c);\n        }\n      });\n    });\n    return cases;\n  }\n\n  // Framework - Intervals\n\n  /**\n   * Converts a point to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * op.extrema is invoked before this point in the call stack.\n   * op.domain is tested before this point in the call stack.\n   *\n   * @param n value to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushScalarToInterval(n: number, op: ScalarToIntervalOp) {\n    assert(!Number.isNaN(n), `flush not defined for NaN`);\n    const values = this.correctlyRounded(n);\n    const inputs = this.addFlushedIfNeeded(values);\n    const results = new Set<FPInterval>(inputs.map(op.impl));\n    return this.spanIntervals(...results);\n  }\n\n  /**\n   * Converts a pair to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x & y are run.\n   * op.extrema is invoked before this point in the call stack.\n   * op.domain is tested before this point in the call stack.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushScalarPairToInterval(\n    x: number,\n    y: number,\n    op: ScalarPairToIntervalOp\n  ): FPInterval {\n    assert(!Number.isNaN(x), `flush not defined for NaN`);\n    assert(!Number.isNaN(y), `flush not defined for NaN`);\n    const x_values = this.correctlyRounded(x);\n    const y_values = this.correctlyRounded(y);\n    const x_inputs = this.addFlushedIfNeeded(x_values);\n    const y_inputs = this.addFlushedIfNeeded(y_values);\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        intervals.add(op.impl(inner_x, inner_y));\n      });\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a triplet to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x, y & z are run.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param z third param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushScalarTripleToInterval(\n    x: number,\n    y: number,\n    z: number,\n    op: ScalarTripleToIntervalOp\n  ): FPInterval {\n    assert(!Number.isNaN(x), `flush not defined for NaN`);\n    assert(!Number.isNaN(y), `flush not defined for NaN`);\n    assert(!Number.isNaN(z), `flush not defined for NaN`);\n    const x_values = this.correctlyRounded(x);\n    const y_values = this.correctlyRounded(y);\n    const z_values = this.correctlyRounded(z);\n    const x_inputs = this.addFlushedIfNeeded(x_values);\n    const y_inputs = this.addFlushedIfNeeded(y_values);\n    const z_inputs = this.addFlushedIfNeeded(z_values);\n    const intervals = new Set<FPInterval>();\n    // prettier-ignore\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        z_inputs.forEach(inner_z => {\n          intervals.add(op.impl(inner_x, inner_y, inner_z));\n        });\n      });\n    });\n\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a vector to an acceptance interval using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushVectorToInterval(x: readonly number[], op: VectorToIntervalOp): FPInterval {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: ROArrayArray<number> = x.map(this.correctlyRounded);\n    const x_flushed: ROArrayArray<number> = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      intervals.add(op.impl(inner_x));\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a pair of vectors to an acceptance interval using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x & y are run.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushVectorPairToInterval(\n    x: readonly number[],\n    y: readonly number[],\n    op: VectorPairToIntervalOp\n  ): FPInterval {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n    assert(\n      y.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: ROArrayArray<number> = x.map(this.correctlyRounded);\n    const y_rounded: ROArrayArray<number> = y.map(this.correctlyRounded);\n    const x_flushed: ROArrayArray<number> = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const y_flushed: ROArrayArray<number> = y_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n    const y_inputs = cartesianProduct<number>(...y_flushed);\n\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        intervals.add(op.impl(inner_x, inner_y));\n      });\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a vector to a vector of acceptance intervals using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a vector of spans for each outputs of op.impl\n   */\n  private roundAndFlushVectorToVector(x: readonly number[], op: VectorToVectorOp): FPVector {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: ROArrayArray<number> = x.map(this.correctlyRounded);\n    const x_flushed: ROArrayArray<number> = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n\n    const interval_vectors = new Set<FPVector>();\n    x_inputs.forEach(inner_x => {\n      interval_vectors.add(op.impl(inner_x));\n    });\n\n    return this.spanVectors(...interval_vectors);\n  }\n\n  /**\n   * Converts a pair of vectors to a vector of acceptance intervals using a\n   * specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a vector of spans for each output of op.impl\n   */\n  private roundAndFlushVectorPairToVector(\n    x: readonly number[],\n    y: readonly number[],\n    op: VectorPairToVectorOp\n  ): FPVector {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n    assert(\n      y.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: ROArrayArray<number> = x.map(this.correctlyRounded);\n    const y_rounded: ROArrayArray<number> = y.map(this.correctlyRounded);\n    const x_flushed: ROArrayArray<number> = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const y_flushed: ROArrayArray<number> = y_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n    const y_inputs = cartesianProduct<number>(...y_flushed);\n\n    const interval_vectors = new Set<FPVector>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        interval_vectors.add(op.impl(inner_x, inner_y));\n      });\n    });\n\n    return this.spanVectors(...interval_vectors);\n  }\n\n  /**\n   * Converts a matrix to a matrix of acceptance intervals using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param m param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a matrix of spans for each outputs of op.impl\n   */\n  private roundAndFlushMatrixToMatrix(m: Array2D<number>, op: MatrixToMatrixOp): FPMatrix {\n    const num_cols = m.length;\n    const num_rows = m[0].length;\n    assert(\n      m.every(c => c.every(r => !Number.isNaN(r))),\n      `flush not defined for NaN`\n    );\n\n    const m_flat = flatten2DArray(m);\n    const m_rounded: ROArrayArray<number> = m_flat.map(this.correctlyRounded);\n    const m_flushed: ROArrayArray<number> = m_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const m_options: ROArrayArray<number> = cartesianProduct<number>(...m_flushed);\n    const m_inputs: ROArrayArrayArray<number> = m_options.map(e =>\n      unflatten2DArray(e, num_cols, num_rows)\n    );\n\n    const interval_matrices = new Set<FPMatrix>();\n    m_inputs.forEach(inner_m => {\n      interval_matrices.add(op.impl(inner_m));\n    });\n\n    return this.spanMatrices(...interval_matrices);\n  }\n\n  /**\n   * Calculate the acceptance interval for a unary function over an interval\n   *\n   * If the interval is actually a point, this just decays to\n   * roundAndFlushScalarToInterval.\n   *\n   * The provided domain interval may be adjusted if the operation defines an\n   * extrema function.\n   *\n   * @param x input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  protected runScalarToIntervalOp(x: FPInterval, op: ScalarToIntervalOp): FPInterval {\n    if (!x.isFinite()) {\n      return this.constants().unboundedInterval;\n    }\n\n    if (op.extrema !== undefined) {\n      x = op.extrema(x);\n    }\n\n    const result = this.spanIntervals(\n      ...x.bounds().map(b => this.roundAndFlushScalarToInterval(b, op))\n    );\n    return result.isFinite() ? result : this.constants().unboundedInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a binary function over an interval\n   *\n   * The provided domain intervals may be adjusted if the operation defines an\n   * extrema function.\n   *\n   * @param x first input domain interval\n   * @param y second input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  protected runScalarPairToIntervalOp(\n    x: FPInterval,\n    y: FPInterval,\n    op: ScalarPairToIntervalOp\n  ): FPInterval {\n    if (!x.isFinite() || !y.isFinite()) {\n      return this.constants().unboundedInterval;\n    }\n\n    if (op.extrema !== undefined) {\n      [x, y] = op.extrema(x, y);\n    }\n\n    const outputs = new Set<FPInterval>();\n    x.bounds().forEach(inner_x => {\n      y.bounds().forEach(inner_y => {\n        outputs.add(this.roundAndFlushScalarPairToInterval(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().unboundedInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a ternary function over an interval\n   *\n   * @param x first input domain interval\n   * @param y second input domain interval\n   * @param z third input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  protected runScalarTripleToIntervalOp(\n    x: FPInterval,\n    y: FPInterval,\n    z: FPInterval,\n    op: ScalarTripleToIntervalOp\n  ): FPInterval {\n    if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n      return this.constants().unboundedInterval;\n    }\n\n    const outputs = new Set<FPInterval>();\n    x.bounds().forEach(inner_x => {\n      y.bounds().forEach(inner_y => {\n        z.bounds().forEach(inner_z => {\n          outputs.add(this.roundAndFlushScalarTripleToInterval(inner_x, inner_y, inner_z, op));\n        });\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().unboundedInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a vector function over given\n   * intervals\n   *\n   * @param x input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  protected runVectorToIntervalOp(x: FPVector, op: VectorToIntervalOp): FPInterval {\n    if (x.some(e => !e.isFinite())) {\n      return this.constants().unboundedInterval;\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n    const outputs = new Set<FPInterval>();\n    x_values.forEach(inner_x => {\n      outputs.add(this.roundAndFlushVectorToInterval(inner_x, op));\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().unboundedInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a vector pair function over given\n   * intervals\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  protected runVectorPairToIntervalOp(\n    x: FPVector,\n    y: FPVector,\n    op: VectorPairToIntervalOp\n  ): FPInterval {\n    if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n      return this.constants().unboundedInterval;\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n    const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n    const outputs = new Set<FPInterval>();\n    x_values.forEach(inner_x => {\n      y_values.forEach(inner_y => {\n        outputs.add(this.roundAndFlushVectorPairToInterval(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().unboundedInterval;\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals for a pair of vector function\n   * over given intervals\n   *\n   * @param x input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a vector of spans over all the outputs of op.impl\n   */\n  protected runVectorToVectorOp(x: FPVector, op: VectorToVectorOp): FPVector {\n    if (x.some(e => !e.isFinite())) {\n      return this.constants().unboundedVector[x.length];\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n    const outputs = new Set<FPVector>();\n    x_values.forEach(inner_x => {\n      outputs.add(this.roundAndFlushVectorToVector(inner_x, op));\n    });\n\n    const result = this.spanVectors(...outputs);\n    return result.every(e => e.isFinite())\n      ? result\n      : this.constants().unboundedVector[result.length];\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals by running a scalar operation\n   * component-wise over a vector.\n   *\n   * This is used for situations where a component-wise operation, like vector\n   * negation, is needed as part of an inherited accuracy, but the top-level\n   * operation test don't require an explicit vector definition of the function,\n   * due to the generated 'vectorize' tests being sufficient.\n   *\n   * @param x input domain intervals vector\n   * @param op scalar operation to be run component-wise\n   * @returns a vector of intervals with the outputs of op.impl\n   */\n  protected runScalarToIntervalOpComponentWise(x: FPVector, op: ScalarToIntervalOp): FPVector {\n    return this.toVector(x.map(e => this.runScalarToIntervalOp(e, op)));\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals for a vector function over\n   * given intervals\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a vector of spans over all the outputs of op.impl\n   */\n  protected runVectorPairToVectorOp(x: FPVector, y: FPVector, op: VectorPairToVectorOp): FPVector {\n    if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n      return this.constants().unboundedVector[x.length];\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n    const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n    const outputs = new Set<FPVector>();\n    x_values.forEach(inner_x => {\n      y_values.forEach(inner_y => {\n        outputs.add(this.roundAndFlushVectorPairToVector(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanVectors(...outputs);\n    return result.every(e => e.isFinite())\n      ? result\n      : this.constants().unboundedVector[result.length];\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals by running a scalar operation\n   * component-wise over a pair of vectors.\n   *\n   * This is used for situations where a component-wise operation, like vector\n   * subtraction, is needed as part of an inherited accuracy, but the top-level\n   * operation test don't require an explicit vector definition of the function,\n   * due to the generated 'vectorize' tests being sufficient.\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op scalar operation to be run component-wise\n   * @returns a vector of intervals with the outputs of op.impl\n   */\n  protected runScalarPairToIntervalOpVectorComponentWise(\n    x: FPVector,\n    y: FPVector,\n    op: ScalarPairToIntervalOp\n  ): FPVector {\n    assert(\n      x.length === y.length,\n      `runScalarPairToIntervalOpVectorComponentWise requires vectors of the same dimensions`\n    );\n\n    return this.toVector(\n      x.map((i, idx) => {\n        return this.runScalarPairToIntervalOp(i, y[idx], op);\n      })\n    );\n  }\n\n  /**\n   * Calculate the matrix of acceptance intervals for a pair of matrix function over\n   * given intervals\n   *\n   * @param m input domain intervals matrix\n   * @param op operation defining the function being run\n   * @returns a matrix of spans over all the outputs of op.impl\n   */\n  protected runMatrixToMatrixOp(m: FPMatrix, op: MatrixToMatrixOp): FPMatrix {\n    const num_cols = m.length;\n    const num_rows = m[0].length;\n    if (m.some(c => c.some(r => !r.isFinite()))) {\n      return this.constants().unboundedMatrix[num_cols][num_rows];\n    }\n\n    const m_flat: readonly FPInterval[] = flatten2DArray(m);\n    const m_values: ROArrayArray<number> = cartesianProduct<number>(...m_flat.map(e => e.bounds()));\n\n    const outputs = new Set<FPMatrix>();\n    m_values.forEach(inner_m => {\n      const unflat_m = unflatten2DArray(inner_m, num_cols, num_rows);\n      outputs.add(this.roundAndFlushMatrixToMatrix(unflat_m, op));\n    });\n\n    const result = this.spanMatrices(...outputs);\n    const result_cols = result.length;\n    const result_rows = result[0].length;\n\n    // FPMatrix has to be coerced to ROArrayArray<FPInterval> to use .every. This should\n    // always be safe, since FPMatrix are defined as fixed length array of\n    // arrays.\n    return (result as ROArrayArray<FPInterval>).every(c => c.every(r => r.isFinite()))\n      ? result\n      : this.constants().unboundedMatrix[result_cols][result_rows];\n  }\n\n  /**\n   * Calculate the Matrix of acceptance intervals by running a scalar operation\n   * component-wise over a pair of matrices.\n   *\n   * An example of this is performing matrix addition.\n   *\n   * @param x first input domain intervals matrix\n   * @param y second input domain intervals matrix\n   * @param op scalar operation to be run component-wise\n   * @returns a matrix of intervals with the outputs of op.impl\n   */\n  protected runScalarPairToIntervalOpMatrixComponentWise(\n    x: FPMatrix,\n    y: FPMatrix,\n    op: ScalarPairToIntervalOp\n  ): FPMatrix {\n    assert(\n      x.length === y.length && x[0].length === y[0].length,\n      `runScalarPairToIntervalOpMatrixComponentWise requires matrices of the same dimensions`\n    );\n\n    const cols = x.length;\n    const rows = x[0].length;\n    const flat_x = flatten2DArray(x);\n    const flat_y = flatten2DArray(y);\n\n    return this.toMatrix(\n      unflatten2DArray(\n        flat_x.map((i, idx) => {\n          return this.runScalarPairToIntervalOp(i, flat_y[idx], op);\n        }),\n        cols,\n        rows\n      )\n    );\n  }\n\n  // API - Fundamental Error Intervals\n\n  /** @returns a ScalarToIntervalOp for [n - error_range, n + error_range] */\n  private AbsoluteErrorIntervalOp(error_range: number): ScalarToIntervalOp {\n    const op: ScalarToIntervalOp = {\n      impl: (_: number) => {\n        return this.constants().unboundedInterval;\n      },\n    };\n\n    assert(\n      error_range >= 0,\n      `absoluteErrorInterval must have non-negative error range, get ${error_range}`\n    );\n\n    if (this.isFinite(error_range)) {\n      op.impl = (n: number) => {\n        assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n        // Return anyInterval if given center n is infinity.\n        if (!this.isFinite(n)) {\n          return this.constants().unboundedInterval;\n        }\n        return this.toInterval([n - error_range, n + error_range]);\n      };\n    }\n\n    return op;\n  }\n\n  protected absoluteErrorIntervalImpl(n: number, error_range: number): FPInterval {\n    error_range = Math.abs(error_range);\n    return this.runScalarToIntervalOp(\n      this.toInterval(n),\n      this.AbsoluteErrorIntervalOp(error_range)\n    );\n  }\n\n  /** @returns an interval of the absolute error around the point */\n  public abstract readonly absoluteErrorInterval: (n: number, error_range: number) => FPInterval;\n\n  /**\n   * Defines a ScalarToIntervalOp for an interval of the correctly rounded values\n   * around the point\n   */\n  private readonly CorrectlyRoundedIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number) => {\n      assert(!Number.isNaN(n), `absolute not defined for NaN`);\n      return this.toInterval(n);\n    },\n  };\n\n  protected correctlyRoundedIntervalImpl(n: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.CorrectlyRoundedIntervalOp);\n  }\n\n  /** @returns an interval of the correctly rounded values around the point */\n  public abstract readonly correctlyRoundedInterval: (n: number | FPInterval) => FPInterval;\n\n  protected correctlyRoundedMatrixImpl(m: Array2D<number>): FPMatrix {\n    return this.toMatrix(map2DArray(m, this.correctlyRoundedInterval));\n  }\n\n  /** @returns a matrix of correctly rounded intervals for the provided matrix */\n  public abstract readonly correctlyRoundedMatrix: (m: Array2D<number>) => FPMatrix;\n\n  /** @returns a ScalarToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\n  private ULPIntervalOp(numULP: number): ScalarToIntervalOp {\n    const op: ScalarToIntervalOp = {\n      impl: (_: number) => {\n        return this.constants().unboundedInterval;\n      },\n    };\n\n    if (this.isFinite(numULP)) {\n      op.impl = (n: number) => {\n        assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n        const ulp = this.oneULP(n);\n        const begin = n - numULP * ulp;\n        const end = n + numULP * ulp;\n\n        return this.toInterval([\n          Math.min(begin, this.flushSubnormal(begin)),\n          Math.max(end, this.flushSubnormal(end)),\n        ]);\n      };\n    }\n\n    return op;\n  }\n\n  protected ulpIntervalImpl(n: number, numULP: number): FPInterval {\n    numULP = Math.abs(numULP);\n    return this.runScalarToIntervalOp(this.toInterval(n), this.ULPIntervalOp(numULP));\n  }\n\n  /** @returns an interval of N * ULP around the point */\n  public abstract readonly ulpInterval: (n: number, numULP: number) => FPInterval;\n\n  // API - Acceptance Intervals\n\n  private readonly AbsIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number) => {\n      return this.correctlyRoundedInterval(Math.abs(n));\n    },\n  };\n\n  protected absIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AbsIntervalOp);\n  }\n\n  /** Calculate an acceptance interval for abs(n) */\n  public abstract readonly absInterval: (n: number) => FPInterval;\n\n  // This op is implemented differently for f32 and f16.\n  private readonly AcosIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(this.toInterval([-1.0, 1.0]), (n: number) => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      // acos(n) = atan2(sqrt(1.0 - n * n), n) or a polynomial approximation with absolute error\n      const y = this.sqrtInterval(this.subtractionInterval(1, this.multiplicationInterval(n, n)));\n      const approx_abs_error = this.kind === 'f32' ? 6.77e-5 : 3.91e-3;\n      return this.spanIntervals(\n        this.atan2Interval(y, n),\n        this.absoluteErrorInterval(Math.acos(n), approx_abs_error)\n      );\n    }),\n  };\n\n  protected acosIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AcosIntervalOp);\n  }\n\n  /** Calculate an acceptance interval for acos(n) */\n  public abstract readonly acosInterval: (n: number) => FPInterval;\n\n  private readonly AcoshAlternativeIntervalOp: ScalarToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // acosh(x) = log(x + sqrt((x + 1.0f) * (x - 1.0)))\n      const inner_value = this.multiplicationInterval(\n        this.additionInterval(x, 1.0),\n        this.subtractionInterval(x, 1.0)\n      );\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  protected acoshAlternativeIntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.AcoshAlternativeIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of acosh(x) using log(x + sqrt((x + 1.0f) * (x - 1.0))) */\n  public abstract readonly acoshAlternativeInterval: (x: number | FPInterval) => FPInterval;\n\n  private readonly AcoshPrimaryIntervalOp: ScalarToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // acosh(x) = log(x + sqrt(x * x - 1.0))\n      const inner_value = this.subtractionInterval(this.multiplicationInterval(x, x), 1.0);\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  protected acoshPrimaryIntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.AcoshPrimaryIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of acosh(x) using log(x + sqrt(x * x - 1.0)) */\n  protected abstract acoshPrimaryInterval: (x: number | FPInterval) => FPInterval;\n\n  /** All acceptance interval functions for acosh(x) */\n  public abstract readonly acoshIntervals: ScalarToInterval[];\n\n  private readonly AdditionIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x + y);\n    },\n  };\n\n  protected additionIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.AdditionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x + y, when x and y are both scalars */\n  public abstract readonly additionInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  protected additionMatrixMatrixIntervalImpl(x: Array2D<number>, y: Array2D<number>): FPMatrix {\n    return this.runScalarPairToIntervalOpMatrixComponentWise(\n      this.toMatrix(x),\n      this.toMatrix(y),\n      this.AdditionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x + y, when x and y are matrices */\n  public abstract readonly additionMatrixMatrixInterval: (\n    x: Array2D<number>,\n    y: Array2D<number>\n  ) => FPMatrix;\n\n  // This op is implemented differently for f32 and f16.\n  private readonly AsinIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(this.toInterval([-1.0, 1.0]), (n: number) => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      // asin(n) = atan2(n, sqrt(1.0 - n * n)) or a polynomial approximation with absolute error\n      const x = this.sqrtInterval(this.subtractionInterval(1, this.multiplicationInterval(n, n)));\n      const approx_abs_error = this.kind === 'f32' ? 6.77e-5 : 3.91e-3;\n      return this.spanIntervals(\n        this.atan2Interval(n, x),\n        this.absoluteErrorInterval(Math.asin(n), approx_abs_error)\n      );\n    }),\n  };\n\n  /** Calculate an acceptance interval for asin(n) */\n  protected asinIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AsinIntervalOp);\n  }\n\n  /** Calculate an acceptance interval for asin(n) */\n  public abstract readonly asinInterval: (n: number) => FPInterval;\n\n  private readonly AsinhIntervalOp: ScalarToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // asinh(x) = log(x + sqrt(x * x + 1.0))\n      const inner_value = this.additionInterval(this.multiplicationInterval(x, x), 1.0);\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  protected asinhIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AsinhIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of asinh(x) */\n  public abstract readonly asinhInterval: (n: number) => FPInterval;\n\n  private readonly AtanIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      const ulp_error = this.kind === 'f32' ? 4096 : 5;\n      return this.ulpInterval(Math.atan(n), ulp_error);\n    },\n  };\n\n  /** Calculate an acceptance interval of atan(x) */\n  protected atanIntervalImpl(n: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AtanIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of atan(x) */\n  public abstract readonly atanInterval: (n: number | FPInterval) => FPInterval;\n\n  // This op is implemented differently for f32 and f16.\n  private Atan2IntervalOpBuilder(): ScalarPairToIntervalOp {\n    assert(this.kind === 'f32' || this.kind === 'f16');\n    const constants = this.constants();\n    // For atan2, the params are labelled (y, x), not (x, y), so domain.x is first parameter (y),\n    // and domain.y is the second parameter (x).\n    // The first param must be finite and normal.\n    const domain_x = [\n      this.toInterval([constants.negative.min, constants.negative.max]),\n      this.toInterval([constants.positive.min, constants.positive.max]),\n    ];\n    // inherited from division\n    const domain_y =\n      this.kind === 'f32'\n        ? [this.toInterval([-(2 ** 126), -(2 ** -126)]), this.toInterval([2 ** -126, 2 ** 126])]\n        : [this.toInterval([-(2 ** 14), -(2 ** -14)]), this.toInterval([2 ** -14, 2 ** 14])];\n    const ulp_error = this.kind === 'f32' ? 4096 : 5;\n    return {\n      impl: this.limitScalarPairToIntervalDomain(\n        {\n          x: domain_x,\n          y: domain_y,\n        },\n        (y: number, x: number): FPInterval => {\n          // Accurate result in f64\n          let atan_yx = Math.atan(y / x);\n          // Offset by +/-pi according to the definition. Use pi value in f64 because we are\n          // handling accurate result.\n          if (x < 0) {\n            // x < 0, y > 0, result is atan(y/x) + \n            if (y > 0) {\n              atan_yx = atan_yx + kValue.f64.positive.pi.whole;\n            } else {\n              // x < 0, y < 0, result is atan(y/x) - \n              atan_yx = atan_yx - kValue.f64.positive.pi.whole;\n            }\n          }\n\n          return this.ulpInterval(atan_yx, ulp_error);\n        }\n      ),\n      extrema: (y: FPInterval, x: FPInterval): [FPInterval, FPInterval] => {\n        // There is discontinuity, which generates an unbounded result, at y/x = 0 that will dominate the accuracy\n        if (y.contains(0)) {\n          if (x.contains(0)) {\n            return [this.toInterval(0), this.toInterval(0)];\n          }\n          return [this.toInterval(0), x];\n        }\n        return [y, x];\n      },\n    };\n  }\n\n  protected atan2IntervalImpl(y: number | FPInterval, x: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(y),\n      this.toInterval(x),\n      this.Atan2IntervalOpBuilder()\n    );\n  }\n\n  /** Calculate an acceptance interval of atan2(y, x) */\n  public abstract readonly atan2Interval: (\n    y: number | FPInterval,\n    x: number | FPInterval\n  ) => FPInterval;\n\n  private readonly AtanhIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number) => {\n      // atanh(x) = log((1.0 + x) / (1.0 - x)) * 0.5\n      const numerator = this.additionInterval(1.0, n);\n      const denominator = this.subtractionInterval(1.0, n);\n      const log_interval = this.logInterval(this.divisionInterval(numerator, denominator));\n      return this.multiplicationInterval(log_interval, 0.5);\n    },\n  };\n\n  protected atanhIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.AtanhIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of atanh(x) */\n  public abstract readonly atanhInterval: (n: number) => FPInterval;\n\n  private readonly CeilIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.ceil(n));\n    },\n  };\n\n  protected ceilIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.CeilIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of ceil(x) */\n  public abstract readonly ceilInterval: (n: number) => FPInterval;\n\n  private readonly ClampMedianIntervalOp: ScalarTripleToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      return this.correctlyRoundedInterval(\n        // Default sort is string sort, so have to implement numeric comparison.\n        // Cannot use the b-a one-liner, because that assumes no infinities.\n        [x, y, z].sort((a, b) => {\n          if (a < b) {\n            return -1;\n          }\n          if (a > b) {\n            return 1;\n          }\n          return 0;\n        })[1]\n      );\n    },\n  };\n\n  protected clampMedianIntervalImpl(\n    x: number | FPInterval,\n    y: number | FPInterval,\n    z: number | FPInterval\n  ): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.ClampMedianIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\n  public abstract readonly clampMedianInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval,\n    z: number | FPInterval\n  ) => FPInterval;\n\n  private readonly ClampMinMaxIntervalOp: ScalarTripleToIntervalOp = {\n    impl: (x: number, low: number, high: number): FPInterval => {\n      return this.minInterval(this.maxInterval(x, low), high);\n    },\n  };\n\n  protected clampMinMaxIntervalImpl(\n    x: number | FPInterval,\n    low: number | FPInterval,\n    high: number | FPInterval\n  ): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(low),\n      this.toInterval(high),\n      this.ClampMinMaxIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\n  public abstract readonly clampMinMaxInterval: (\n    x: number | FPInterval,\n    low: number | FPInterval,\n    high: number | FPInterval\n  ) => FPInterval;\n\n  /** All acceptance interval functions for clamp(x, y, z) */\n  public abstract readonly clampIntervals: ScalarTripleToInterval[];\n\n  private readonly CosIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(\n      this.constants().negPiToPiInterval,\n      (n: number): FPInterval => {\n        assert(this.kind === 'f32' || this.kind === 'f16');\n        const abs_error = this.kind === 'f32' ? 2 ** -11 : 2 ** -7;\n        return this.absoluteErrorInterval(Math.cos(n), abs_error);\n      }\n    ),\n  };\n\n  protected cosIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.CosIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of cos(x) */\n  public abstract readonly cosInterval: (n: number) => FPInterval;\n\n  private readonly CoshIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // cosh(x) = (exp(x) + exp(-x)) * 0.5\n      const minus_n = this.negationInterval(n);\n      return this.multiplicationInterval(\n        this.additionInterval(this.expInterval(n), this.expInterval(minus_n)),\n        0.5\n      );\n    },\n  };\n\n  protected coshIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.CoshIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of cosh(x) */\n  public abstract readonly coshInterval: (n: number) => FPInterval;\n\n  private readonly CrossIntervalOp: VectorPairToVectorOp = {\n    impl: (x: readonly number[], y: readonly number[]): FPVector => {\n      assert(x.length === 3, `CrossIntervalOp received x with ${x.length} instead of 3`);\n      assert(y.length === 3, `CrossIntervalOp received y with ${y.length} instead of 3`);\n\n      // cross(x, y) = r, where\n      //   r[0] = x[1] * y[2] - x[2] * y[1]\n      //   r[1] = x[2] * y[0] - x[0] * y[2]\n      //   r[2] = x[0] * y[1] - x[1] * y[0]\n\n      const r0 = this.subtractionInterval(\n        this.multiplicationInterval(x[1], y[2]),\n        this.multiplicationInterval(x[2], y[1])\n      );\n      const r1 = this.subtractionInterval(\n        this.multiplicationInterval(x[2], y[0]),\n        this.multiplicationInterval(x[0], y[2])\n      );\n      const r2 = this.subtractionInterval(\n        this.multiplicationInterval(x[0], y[1]),\n        this.multiplicationInterval(x[1], y[0])\n      );\n      return [r0, r1, r2];\n    },\n  };\n\n  protected crossIntervalImpl(x: readonly number[], y: readonly number[]): FPVector {\n    assert(x.length === 3, `Cross is only defined for vec3`);\n    assert(y.length === 3, `Cross is only defined for vec3`);\n    return this.runVectorPairToVectorOp(this.toVector(x), this.toVector(y), this.CrossIntervalOp);\n  }\n\n  /** Calculate a vector of acceptance intervals for cross(x, y) */\n  public abstract readonly crossInterval: (x: readonly number[], y: readonly number[]) => FPVector;\n\n  private readonly DegreesIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.multiplicationInterval(n, 57.295779513082322865);\n    },\n  };\n\n  protected degreesIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.DegreesIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of degrees(x) */\n  public abstract readonly degreesInterval: (n: number) => FPInterval;\n\n  /**\n   * Calculate the minor of a NxN matrix.\n   *\n   * The ijth minor of a square matrix, is the N-1xN-1 matrix created by removing\n   * the ith column and jth row from the original matrix.\n   */\n  private minorNxN(m: Array2D<number>, col: number, row: number): Array2D<number> {\n    const dim = m.length;\n    assert(m.length === m[0].length, `minorMatrix is only defined for square matrices`);\n    assert(col >= 0 && col < dim, `col ${col} needs be in [0, # of columns '${dim}')`);\n    assert(row >= 0 && row < dim, `row ${row} needs be in [0, # of rows '${dim}')`);\n\n    const result: number[][] = [...Array(dim - 1)].map(_ => [...Array(dim - 1)]);\n\n    const col_indices: readonly number[] = [...Array(dim).keys()].filter(e => e !== col);\n    const row_indices: readonly number[] = [...Array(dim).keys()].filter(e => e !== row);\n\n    col_indices.forEach((c, i) => {\n      row_indices.forEach((r, j) => {\n        result[i][j] = m[c][r];\n      });\n    });\n    return result;\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 2x2 matrix */\n  private determinant2x2Interval(m: Array2D<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 2,\n      `determinant2x2Interval called on non-2x2 matrix`\n    );\n    return this.subtractionInterval(\n      this.multiplicationInterval(m[0][0], m[1][1]),\n      this.multiplicationInterval(m[0][1], m[1][0])\n    );\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 3x3 matrix */\n  private determinant3x3Interval(m: Array2D<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 3,\n      `determinant3x3Interval called on non-3x3 matrix`\n    );\n\n    // M is a 3x3 matrix\n    // det(M) is A + B + C, where A, B, C are three elements in a row/column times\n    // their own co-factor.\n    // (The co-factor is the determinant of the minor of that position with the\n    // appropriate +/-)\n    // For simplicity sake A, B, C are calculated as the elements of the first\n    // column\n    const A = this.multiplicationInterval(\n      m[0][0],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 0))\n    );\n    const B = this.multiplicationInterval(\n      -m[0][1],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 1))\n    );\n    const C = this.multiplicationInterval(\n      m[0][2],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 2))\n    );\n\n    // Need to calculate permutations, since for fp addition is not associative,\n    // so A + B + C is not guaranteed to equal B + C + A, etc.\n    const permutations: ROArrayArray<FPInterval> = calculatePermutations([A, B, C]);\n    return this.spanIntervals(\n      ...permutations.map(p =>\n        p.reduce((prev: FPInterval, cur: FPInterval) => this.additionInterval(prev, cur))\n      )\n    );\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 4x4 matrix */\n  private determinant4x4Interval(m: Array2D<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 4,\n      `determinant3x3Interval called on non-4x4 matrix`\n    );\n\n    // M is a 4x4 matrix\n    // det(M) is A + B + C + D, where A, B, C, D are four elements in a row/column\n    // times their own co-factor.\n    // (The co-factor is the determinant of the minor of that position with the\n    // appropriate +/-)\n    // For simplicity sake A, B, C, D are calculated as the elements of the\n    // first column\n    const A = this.multiplicationInterval(\n      m[0][0],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 0))\n    );\n    const B = this.multiplicationInterval(\n      -m[0][1],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 1))\n    );\n    const C = this.multiplicationInterval(\n      m[0][2],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 2))\n    );\n    const D = this.multiplicationInterval(\n      -m[0][3],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 3))\n    );\n\n    // Need to calculate permutations, since for fp addition is not associative\n    // so A + B + C + D is not guaranteed to equal B + C + A + D, etc.\n    const permutations: ROArrayArray<FPInterval> = calculatePermutations([A, B, C, D]);\n    return this.spanIntervals(\n      ...permutations.map(p =>\n        p.reduce((prev: FPInterval, cur: FPInterval) => this.additionInterval(prev, cur))\n      )\n    );\n  }\n\n  /**\n   * This code calculates 3x3 and 4x4 determinants using the textbook co-factor\n   * method, using the first column for the co-factor selection.\n   *\n   * For matrices composed of integer elements, e, with |e|^4 < 2**21, this\n   * should be fine.\n   *\n   * For e, where e is subnormal or 4*(e^4) might not be precisely expressible as\n   * a f32 values, this approach breaks down, because the rule of all co-factor\n   * definitions of determinant being equal doesn't hold in these cases.\n   *\n   * The general solution for this is to calculate all the permutations of the\n   * operations in the worked out formula for determinant.\n   * For 3x3 this is tractable, but for 4x4 this works out to ~23! permutations\n   * that need to be calculated.\n   * Thus, CTS testing and the spec definition of accuracy is restricted to the\n   * space that the simple implementation is valid.\n   */\n  protected determinantIntervalImpl(x: Array2D<number>): FPInterval {\n    const dim = x.length;\n    assert(\n      x[0].length === dim && (dim === 2 || dim === 3 || dim === 4),\n      `determinantInterval only defined for 2x2, 3x3 and 4x4 matrices`\n    );\n    switch (dim) {\n      case 2:\n        return this.determinant2x2Interval(x);\n      case 3:\n        return this.determinant3x3Interval(x);\n      case 4:\n        return this.determinant4x4Interval(x);\n    }\n    unreachable(\n      \"determinantInterval called on x, where which has an unexpected dimension of '${dim}'\"\n    );\n  }\n\n  /** Calculate an acceptance interval for determinant(x) */\n  public abstract readonly determinantInterval: (x: Array2D<number>) => FPInterval;\n\n  private readonly DistanceIntervalScalarOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.lengthInterval(this.subtractionInterval(x, y));\n    },\n  };\n\n  private readonly DistanceIntervalVectorOp: VectorPairToIntervalOp = {\n    impl: (x: readonly number[], y: readonly number[]): FPInterval => {\n      return this.lengthInterval(\n        this.runScalarPairToIntervalOpVectorComponentWise(\n          this.toVector(x),\n          this.toVector(y),\n          this.SubtractionIntervalOp\n        )\n      );\n    },\n  };\n\n  protected distanceIntervalImpl(\n    x: number | readonly number[],\n    y: number | readonly number[]\n  ): FPInterval {\n    if (x instanceof Array && y instanceof Array) {\n      assert(\n        x.length === y.length,\n        `distanceInterval requires both params to have the same number of elements`\n      );\n      return this.runVectorPairToIntervalOp(\n        this.toVector(x),\n        this.toVector(y),\n        this.DistanceIntervalVectorOp\n      );\n    } else if (!(x instanceof Array) && !(y instanceof Array)) {\n      return this.runScalarPairToIntervalOp(\n        this.toInterval(x),\n        this.toInterval(y),\n        this.DistanceIntervalScalarOp\n      );\n    }\n    unreachable(\n      `distanceInterval requires both params to both the same type, either scalars or vectors`\n    );\n  }\n\n  /** Calculate an acceptance interval of distance(x, y) */\n  public abstract readonly distanceInterval: (\n    x: number | readonly number[],\n    y: number | readonly number[]\n  ) => FPInterval;\n\n  // This op is implemented differently for f32 and f16.\n  private DivisionIntervalOpBuilder(): ScalarPairToIntervalOp {\n    const constants = this.constants();\n    const domain_x = [this.toInterval([constants.negative.min, constants.positive.max])];\n    const domain_y =\n      this.kind === 'f32' || this.kind === 'abstract'\n        ? [this.toInterval([-(2 ** 126), -(2 ** -126)]), this.toInterval([2 ** -126, 2 ** 126])]\n        : [this.toInterval([-(2 ** 14), -(2 ** -14)]), this.toInterval([2 ** -14, 2 ** 14])];\n    return {\n      impl: this.limitScalarPairToIntervalDomain(\n        {\n          x: domain_x,\n          y: domain_y,\n        },\n        (x: number, y: number): FPInterval => {\n          if (y === 0) {\n            return constants.unboundedInterval;\n          }\n          return this.ulpInterval(x / y, 2.5);\n        }\n      ),\n      extrema: (x: FPInterval, y: FPInterval): [FPInterval, FPInterval] => {\n        // division has a discontinuity at y = 0.\n        if (y.contains(0)) {\n          y = this.toInterval(0);\n        }\n        return [x, y];\n      },\n    };\n  }\n\n  protected divisionIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.DivisionIntervalOpBuilder()\n    );\n  }\n\n  /** Calculate an acceptance interval of x / y */\n  public abstract readonly divisionInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  private readonly DotIntervalOp: VectorPairToIntervalOp = {\n    impl: (x: readonly number[], y: readonly number[]): FPInterval => {\n      // dot(x, y) = sum of x[i] * y[i]\n      const multiplications = this.runScalarPairToIntervalOpVectorComponentWise(\n        this.toVector(x),\n        this.toVector(y),\n        this.MultiplicationIntervalOp\n      );\n\n      // vec2 doesn't require permutations, since a + b = b + a for floats\n      if (multiplications.length === 2) {\n        return this.additionInterval(multiplications[0], multiplications[1]);\n      }\n\n      // The spec does not state the ordering of summation, so all the\n      // permutations are calculated and their results spanned, since addition\n      // of more than two floats is not transitive, i.e. a + b + c is not\n      // guaranteed to equal b + a + c\n      const permutations: ROArrayArray<FPInterval> = calculatePermutations(multiplications);\n      return this.spanIntervals(\n        ...permutations.map(p => p.reduce((prev, cur) => this.additionInterval(prev, cur)))\n      );\n    },\n  };\n\n  protected dotIntervalImpl(\n    x: readonly number[] | readonly FPInterval[],\n    y: readonly number[] | readonly FPInterval[]\n  ): FPInterval {\n    assert(x.length === y.length, `dot not defined for vectors with different lengths`);\n    return this.runVectorPairToIntervalOp(this.toVector(x), this.toVector(y), this.DotIntervalOp);\n  }\n\n  /** Calculated the acceptance interval for dot(x, y) */\n  public abstract readonly dotInterval: (\n    x: readonly number[] | readonly FPInterval[],\n    y: readonly number[] | readonly FPInterval[]\n  ) => FPInterval;\n\n  private readonly ExpIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      const ulp_error = this.kind === 'f32' ? 3 + 2 * Math.abs(n) : 1 + 2 * Math.abs(n);\n      return this.ulpInterval(Math.exp(n), ulp_error);\n    },\n  };\n\n  protected expIntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.ExpIntervalOp);\n  }\n\n  /** Calculate an acceptance interval for exp(x) */\n  public abstract readonly expInterval: (x: number | FPInterval) => FPInterval;\n\n  private readonly Exp2IntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      const ulp_error = this.kind === 'f32' ? 3 + 2 * Math.abs(n) : 1 + 2 * Math.abs(n);\n      return this.ulpInterval(Math.pow(2, n), ulp_error);\n    },\n  };\n\n  protected exp2IntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.Exp2IntervalOp);\n  }\n\n  /** Calculate an acceptance interval for exp2(x) */\n  public abstract readonly exp2Interval: (x: number | FPInterval) => FPInterval;\n\n  /**\n   * faceForward(x, y, z) = select(-x, x, dot(z, y) < 0.0)\n   *\n   * This builtin selects from two discrete results (delta rounding/flushing),\n   * so the majority of the framework code is not appropriate, since the\n   * framework attempts to span results.\n   *\n   * Thus, a bespoke implementation is used instead of\n   * defining an Op and running that through the framework.\n   */\n  protected faceForwardIntervalsImpl(\n    x: readonly number[],\n    y: readonly number[],\n    z: readonly number[]\n  ): (FPVector | undefined)[] {\n    const x_vec = this.toVector(x);\n    // Running vector through this.runScalarToIntervalOpComponentWise to make\n    // sure that flushing/rounding is handled, since toVector does not perform\n    // those operations.\n    const positive_x = this.runScalarToIntervalOpComponentWise(x_vec, {\n      impl: (i: number): FPInterval => {\n        return this.toInterval(i);\n      },\n    });\n    const negative_x = this.runScalarToIntervalOpComponentWise(x_vec, this.NegationIntervalOp);\n\n    const dot_interval = this.dotInterval(z, y);\n\n    const results: (FPVector | undefined)[] = [];\n\n    if (!dot_interval.isFinite()) {\n      // dot calculation went out of bounds\n      // Inserting undefined in the result, so that the test running framework\n      // is aware of this potential OOB.\n      // For const-eval tests, it means that the test case should be skipped,\n      // since the shader will fail to compile.\n      // For non-const-eval the undefined should be stripped out of the possible\n      // results.\n\n      results.push(undefined);\n    }\n\n    // Because the result of dot can be an interval, it might span across 0, thus\n    // it is possible that both -x and x are valid responses.\n    if (dot_interval.begin < 0 || dot_interval.end < 0) {\n      results.push(positive_x);\n    }\n\n    if (dot_interval.begin >= 0 || dot_interval.end >= 0) {\n      results.push(negative_x);\n    }\n\n    assert(\n      results.length > 0 || results.every(r => r === undefined),\n      `faceForwardInterval selected neither positive x or negative x for the result, this shouldn't be possible`\n    );\n    return results;\n  }\n\n  /** Calculate the acceptance intervals for faceForward(x, y, z) */\n  public abstract readonly faceForwardIntervals: (\n    x: readonly number[],\n    y: readonly number[],\n    z: readonly number[]\n  ) => (FPVector | undefined)[];\n\n  private readonly FloorIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.floor(n));\n    },\n  };\n\n  protected floorIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.FloorIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of floor(x) */\n  public abstract readonly floorInterval: (n: number) => FPInterval;\n\n  private readonly FmaIntervalOp: ScalarTripleToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      return this.additionInterval(this.multiplicationInterval(x, y), z);\n    },\n  };\n\n  protected fmaIntervalImpl(x: number, y: number, z: number): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.FmaIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval for fma(x, y, z) */\n  public abstract readonly fmaInterval: (x: number, y: number, z: number) => FPInterval;\n\n  private readonly FractIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // fract(x) = x - floor(x) is defined in the spec.\n      // For people coming from a non-graphics background this will cause some\n      // unintuitive results. For example,\n      // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n      // This is how other shading languages operate and allows for a desirable\n      // wrap around in graphics programming.\n      const result = this.subtractionInterval(n, this.floorInterval(n));\n      assert(\n        // negative.subnormal.min instead of 0, because FTZ can occur\n        // selectively during the calculation\n        this.toInterval([this.constants().negative.subnormal.min, 1.0]).contains(result),\n        `fract(${n}) interval [${result}] unexpectedly extends beyond [~0.0, 1.0]`\n      );\n      if (result.contains(1)) {\n        // Very small negative numbers can lead to catastrophic cancellation,\n        // thus calculating a fract of 1.0, which is technically not a\n        // fractional part, so some implementations clamp the result to next\n        // nearest number.\n        return this.spanIntervals(result, this.toInterval(this.constants().positive.less_than_one));\n      }\n      return result;\n    },\n  };\n\n  protected fractIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.FractIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of fract(x) */\n  public abstract readonly fractInterval: (n: number) => FPInterval;\n\n  private readonly InverseSqrtIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        return this.ulpInterval(1 / Math.sqrt(n), 2);\n      }\n    ),\n  };\n\n  protected inverseSqrtIntervalImpl(n: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.InverseSqrtIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of inverseSqrt(x) */\n  public abstract readonly inverseSqrtInterval: (n: number | FPInterval) => FPInterval;\n\n  private readonly LdexpIntervalOp: ScalarPairToIntervalOp = {\n    impl: (e1: number, e2: number) => {\n      assert(this.kind === 'f32' || this.kind === 'f16');\n      assert(Number.isInteger(e2), 'the second param of ldexp must be an integer');\n      const bias = this.kind === 'f32' ? 127 : 15;\n      // Spec explicitly calls indeterminate value if e2 > bias + 1\n      if (e2 > bias + 1) {\n        return this.constants().unboundedInterval;\n      }\n      // The spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, and the accuracy is correctly\n      // rounded to the true value, so the inheritance framework does not need to be invoked to\n      // determine bounds.\n      // Instead, the value at a higher precision is calculated and passed to\n      // correctlyRoundedInterval.\n      const result = e1 * 2 ** e2;\n      if (!Number.isFinite(result)) {\n        // Overflowed TS's number type, so definitely out of bounds for f32/f16\n        return this.constants().unboundedInterval;\n      }\n      // The result may be zero if e2 + bias <= 0, but we can't simply span the interval to 0.0.\n      // For example, for f32 input e1 = 2**120 and e2 = -130, e2 + bias = -3 <= 0, but\n      // e1 * 2 ** e2 = 2**-10, so the valid result is 2**-10 or 0.0, instead of [0.0, 2**-10].\n      // Always return the correctly-rounded interval, and special examination should be taken when\n      // using the result.\n      return this.correctlyRoundedInterval(result);\n    },\n  };\n\n  protected ldexpIntervalImpl(e1: number, e2: number): FPInterval {\n    // Only round and flush e1, as e2 is of integer type (i32 or abstract integer) and should be\n    // precise.\n    return this.roundAndFlushScalarToInterval(e1, {\n      impl: (e1: number) => this.LdexpIntervalOp.impl(e1, e2),\n    });\n  }\n\n  /**\n   * Calculate an acceptance interval of ldexp(e1, e2), where e2 is integer\n   *\n   * Spec indicate that the result may be zero if e2 + bias <= 0, no matter how large\n   * was e1 * 2 ** e2, i.e. the actual valid result is correctlyRounded(e1 * 2 ** e2) or 0.0, if\n   * e2 + bias <= 0. Such discontinious flush-to-zero behavior is hard to be expressed using\n   * FPInterval, therefore in the situation of e2 + bias <= 0 the returned interval would be just\n   * correctlyRounded(e1 * 2 ** e2), and special examination should be taken when using the result.\n   *\n   */\n  public abstract readonly ldexpInterval: (e1: number, e2: number) => FPInterval;\n\n  private readonly LengthIntervalScalarOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.sqrtInterval(this.multiplicationInterval(n, n));\n    },\n  };\n\n  private readonly LengthIntervalVectorOp: VectorToIntervalOp = {\n    impl: (n: readonly number[]): FPInterval => {\n      return this.sqrtInterval(this.dotInterval(n, n));\n    },\n  };\n\n  protected lengthIntervalImpl(n: number | FPInterval | readonly number[] | FPVector): FPInterval {\n    if (n instanceof Array) {\n      return this.runVectorToIntervalOp(this.toVector(n), this.LengthIntervalVectorOp);\n    } else {\n      return this.runScalarToIntervalOp(this.toInterval(n), this.LengthIntervalScalarOp);\n    }\n  }\n\n  /** Calculate an acceptance interval of length(x) */\n  public abstract readonly lengthInterval: (\n    n: number | FPInterval | readonly number[] | FPVector\n  ) => FPInterval;\n\n  private readonly LogIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        assert(this.kind === 'f32' || this.kind === 'f16');\n        const abs_error = this.kind === 'f32' ? 2 ** -21 : 2 ** -7;\n        if (n >= 0.5 && n <= 2.0) {\n          return this.absoluteErrorInterval(Math.log(n), abs_error);\n        }\n        return this.ulpInterval(Math.log(n), 3);\n      }\n    ),\n  };\n\n  protected logIntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.LogIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of log(x) */\n  public abstract readonly logInterval: (x: number | FPInterval) => FPInterval;\n\n  private readonly Log2IntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        assert(this.kind === 'f32' || this.kind === 'f16');\n        const abs_error = this.kind === 'f32' ? 2 ** -21 : 2 ** -7;\n        if (n >= 0.5 && n <= 2.0) {\n          return this.absoluteErrorInterval(Math.log2(n), abs_error);\n        }\n        return this.ulpInterval(Math.log2(n), 3);\n      }\n    ),\n  };\n\n  protected log2IntervalImpl(x: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(x), this.Log2IntervalOp);\n  }\n\n  /** Calculate an acceptance interval of log2(x) */\n  public abstract readonly log2Interval: (x: number | FPInterval) => FPInterval;\n\n  private readonly MaxIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // If both of the inputs are subnormal, then either of the inputs can be returned\n      if (this.isSubnormal(x) && this.isSubnormal(y)) {\n        return this.correctlyRoundedInterval(\n          this.spanIntervals(this.toInterval(x), this.toInterval(y))\n        );\n      }\n\n      return this.correctlyRoundedInterval(Math.max(x, y));\n    },\n  };\n\n  protected maxIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.MaxIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of max(x, y) */\n  public abstract readonly maxInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  private readonly MinIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // If both of the inputs are subnormal, then either of the inputs can be returned\n      if (this.isSubnormal(x) && this.isSubnormal(y)) {\n        return this.correctlyRoundedInterval(\n          this.spanIntervals(this.toInterval(x), this.toInterval(y))\n        );\n      }\n\n      return this.correctlyRoundedInterval(Math.min(x, y));\n    },\n  };\n\n  protected minIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.MinIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of min(x, y) */\n  public abstract readonly minInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  private readonly MixImpreciseIntervalOp: ScalarTripleToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      // x + (y - x) * z =\n      //  x + t, where t = (y - x) * z\n      const t = this.multiplicationInterval(this.subtractionInterval(y, x), z);\n      return this.additionInterval(x, t);\n    },\n  };\n\n  protected mixImpreciseIntervalImpl(x: number, y: number, z: number): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.MixImpreciseIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of mix(x, y, z) using x + (y - x) * z */\n  public abstract readonly mixImpreciseInterval: (x: number, y: number, z: number) => FPInterval;\n\n  private readonly MixPreciseIntervalOp: ScalarTripleToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      // x * (1.0 - z) + y * z =\n      //   t + s, where t = x * (1.0 - z), s = y * z\n      const t = this.multiplicationInterval(x, this.subtractionInterval(1.0, z));\n      const s = this.multiplicationInterval(y, z);\n      return this.additionInterval(t, s);\n    },\n  };\n\n  protected mixPreciseIntervalImpl(x: number, y: number, z: number): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.MixPreciseIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of mix(x, y, z) using x * (1.0 - z) + y * z */\n  public abstract readonly mixPreciseInterval: (x: number, y: number, z: number) => FPInterval;\n\n  /** All acceptance interval functions for mix(x, y, z) */\n  public abstract readonly mixIntervals: ScalarTripleToInterval[];\n\n  protected modfIntervalImpl(n: number): { fract: FPInterval; whole: FPInterval } {\n    const fract = this.correctlyRoundedInterval(n % 1.0);\n    const whole = this.correctlyRoundedInterval(n - (n % 1.0));\n    return { fract, whole };\n  }\n\n  /** Calculate an acceptance interval of modf(x) */\n  public abstract readonly modfInterval: (n: number) => { fract: FPInterval; whole: FPInterval };\n\n  private readonly MultiplicationInnerOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x * y);\n    },\n  };\n\n  private readonly MultiplicationIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.roundAndFlushScalarPairToInterval(x, y, this.MultiplicationInnerOp);\n    },\n  };\n\n  protected multiplicationIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.MultiplicationIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x * y */\n  public abstract readonly multiplicationInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  /**\n   * @returns the vector result of multiplying the given vector by the given\n   *          scalar\n   */\n  private multiplyVectorByScalar(v: readonly number[], c: number | FPInterval): FPVector {\n    return this.toVector(v.map(x => this.multiplicationInterval(x, c)));\n  }\n\n  protected multiplicationMatrixScalarIntervalImpl(mat: Array2D<number>, scalar: number): FPMatrix {\n    const cols = mat.length;\n    const rows = mat[0].length;\n    return this.toMatrix(\n      unflatten2DArray(\n        flatten2DArray(mat).map(e => this.multiplicationInterval(e, scalar)),\n        cols,\n        rows\n      )\n    );\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a scalar */\n  public abstract readonly multiplicationMatrixScalarInterval: (\n    mat: Array2D<number>,\n    scalar: number\n  ) => FPMatrix;\n\n  protected multiplicationScalarMatrixIntervalImpl(scalar: number, mat: Array2D<number>): FPMatrix {\n    return this.multiplicationMatrixScalarIntervalImpl(mat, scalar);\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a scalar and y is a matrix */\n  public abstract readonly multiplicationScalarMatrixInterval: (\n    scalar: number,\n    mat: Array2D<number>\n  ) => FPMatrix;\n\n  protected multiplicationMatrixMatrixIntervalImpl(\n    mat_x: Array2D<number>,\n    mat_y: Array2D<number>\n  ): FPMatrix {\n    const x_cols = mat_x.length;\n    const x_rows = mat_x[0].length;\n    const y_cols = mat_y.length;\n    const y_rows = mat_y[0].length;\n    assert(x_cols === y_rows, `'mat${x_cols}x${x_rows} * mat${y_cols}x${y_rows}' is not defined`);\n\n    const x_transposed = this.transposeInterval(mat_x);\n\n    const result: FPInterval[][] = [...Array(y_cols)].map(_ => [...Array(x_rows)]);\n    mat_y.forEach((y, i) => {\n      x_transposed.forEach((x, j) => {\n        result[i][j] = this.dotInterval(x, y);\n      });\n    });\n\n    return (result as ROArrayArray<FPInterval>) as FPMatrix;\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a matrix */\n  public abstract readonly multiplicationMatrixMatrixInterval: (\n    mat_x: Array2D<number>,\n    mat_y: Array2D<number>\n  ) => FPMatrix;\n\n  protected multiplicationMatrixVectorIntervalImpl(\n    x: Array2D<number>,\n    y: readonly number[]\n  ): FPVector {\n    const cols = x.length;\n    const rows = x[0].length;\n    assert(y.length === cols, `'mat${cols}x${rows} * vec${y.length}' is not defined`);\n\n    return this.transposeInterval(x).map(e => this.dotInterval(e, y)) as FPVector;\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a vector */\n  public abstract readonly multiplicationMatrixVectorInterval: (\n    x: Array2D<number>,\n    y: readonly number[]\n  ) => FPVector;\n\n  protected multiplicationVectorMatrixIntervalImpl(\n    x: readonly number[],\n    y: Array2D<number>\n  ): FPVector {\n    const cols = y.length;\n    const rows = y[0].length;\n    assert(x.length === rows, `'vec${x.length} * mat${cols}x${rows}' is not defined`);\n\n    return y.map(e => this.dotInterval(x, e)) as FPVector;\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a vector and y is a matrix */\n  public abstract readonly multiplicationVectorMatrixInterval: (\n    x: readonly number[],\n    y: Array2D<number>\n  ) => FPVector;\n\n  private readonly NegationIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(-n);\n    },\n  };\n\n  protected negationIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.NegationIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of -x */\n  public abstract readonly negationInterval: (n: number) => FPInterval;\n\n  private readonly NormalizeIntervalOp: VectorToVectorOp = {\n    impl: (n: readonly number[]): FPVector => {\n      const length = this.lengthInterval(n);\n      return this.toVector(n.map(e => this.divisionInterval(e, length)));\n    },\n  };\n\n  protected normalizeIntervalImpl(n: readonly number[]): FPVector {\n    return this.runVectorToVectorOp(this.toVector(n), this.NormalizeIntervalOp);\n  }\n\n  public abstract readonly normalizeInterval: (n: readonly number[]) => FPVector;\n\n  private readonly PowIntervalOp: ScalarPairToIntervalOp = {\n    // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n    // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n    // enforce this, so there is no need to wrap the impl call here.\n    impl: (x: number, y: number): FPInterval => {\n      return this.exp2Interval(this.multiplicationInterval(y, this.log2Interval(x)));\n    },\n  };\n\n  protected powIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.PowIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of pow(x, y) */\n  public abstract readonly powInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  private readonly RadiansIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.multiplicationInterval(n, 0.017453292519943295474);\n    },\n  };\n\n  protected radiansIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.RadiansIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of radians(x) */\n  public abstract readonly radiansInterval: (n: number) => FPInterval;\n\n  private readonly ReflectIntervalOp: VectorPairToVectorOp = {\n    impl: (x: readonly number[], y: readonly number[]): FPVector => {\n      assert(\n        x.length === y.length,\n        `ReflectIntervalOp received x (${x}) and y (${y}) with different numbers of elements`\n      );\n\n      // reflect(x, y) = x - 2.0 * dot(x, y) * y\n      //               = x - t * y, t = 2.0 * dot(x, y)\n      // x = incident vector\n      // y = normal of reflecting surface\n      const t = this.multiplicationInterval(2.0, this.dotInterval(x, y));\n      const rhs = this.multiplyVectorByScalar(y, t);\n      return this.runScalarPairToIntervalOpVectorComponentWise(\n        this.toVector(x),\n        rhs,\n        this.SubtractionIntervalOp\n      );\n    },\n  };\n\n  protected reflectIntervalImpl(x: readonly number[], y: readonly number[]): FPVector {\n    assert(\n      x.length === y.length,\n      `reflect is only defined for vectors with the same number of elements`\n    );\n    return this.runVectorPairToVectorOp(this.toVector(x), this.toVector(y), this.ReflectIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of reflect(x, y) */\n  public abstract readonly reflectInterval: (\n    x: readonly number[],\n    y: readonly number[]\n  ) => FPVector;\n\n  /**\n   * refract is a singular function in the sense that it is the only builtin that\n   * takes in (FPVector, FPVector, F32/F16) and returns FPVector and is basically\n   * defined in terms of other functions.\n   *\n   * Instead of implementing all the framework code to integrate it with its\n   * own operation type, etc, it instead has a bespoke implementation that is a\n   * composition of other builtin functions that use the framework.\n   */\n  protected refractIntervalImpl(i: readonly number[], s: readonly number[], r: number): FPVector {\n    assert(\n      i.length === s.length,\n      `refract is only defined for vectors with the same number of elements`\n    );\n\n    const r_squared = this.multiplicationInterval(r, r);\n    const dot = this.dotInterval(s, i);\n    const dot_squared = this.multiplicationInterval(dot, dot);\n    const one_minus_dot_squared = this.subtractionInterval(1, dot_squared);\n    const k = this.subtractionInterval(\n      1.0,\n      this.multiplicationInterval(r_squared, one_minus_dot_squared)\n    );\n\n    if (!k.isFinite() || k.containsZeroOrSubnormals()) {\n      // There is a discontinuity at k == 0, due to sqrt(k) being calculated, so exiting early\n      return this.constants().unboundedVector[this.toVector(i).length];\n    }\n\n    if (k.end < 0.0) {\n      // if k is negative, then the zero vector is the valid response\n      return this.constants().zeroVector[this.toVector(i).length];\n    }\n\n    const dot_times_r = this.multiplicationInterval(dot, r);\n    const k_sqrt = this.sqrtInterval(k);\n    const t = this.additionInterval(dot_times_r, k_sqrt); // t = r * dot(i, s) + sqrt(k)\n\n    return this.runScalarPairToIntervalOpVectorComponentWise(\n      this.multiplyVectorByScalar(i, r),\n      this.multiplyVectorByScalar(s, t),\n      this.SubtractionIntervalOp\n    ); // (i * r) - (s * t)\n  }\n\n  /** Calculate acceptance interval vectors of reflect(i, s, r) */\n  public abstract readonly refractInterval: (\n    i: readonly number[],\n    s: readonly number[],\n    r: number\n  ) => FPVector;\n\n  private readonly RemainderIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // x % y = x - y * trunc(x/y)\n      return this.subtractionInterval(\n        x,\n        this.multiplicationInterval(y, this.truncInterval(this.divisionInterval(x, y)))\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval for x % y */\n  protected remainderIntervalImpl(x: number, y: number): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.RemainderIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval for x % y */\n  public abstract readonly remainderInterval: (x: number, y: number) => FPInterval;\n\n  private readonly RoundIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      const k = Math.floor(n);\n      const diff_before = n - k;\n      const diff_after = k + 1 - n;\n      if (diff_before < diff_after) {\n        return this.correctlyRoundedInterval(k);\n      } else if (diff_before > diff_after) {\n        return this.correctlyRoundedInterval(k + 1);\n      }\n\n      // n is in the middle of two integers.\n      // The tie breaking rule is 'k if k is even, k + 1 if k is odd'\n      if (k % 2 === 0) {\n        return this.correctlyRoundedInterval(k);\n      }\n      return this.correctlyRoundedInterval(k + 1);\n    },\n  };\n\n  protected roundIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.RoundIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of round(x) */\n  public abstract readonly roundInterval: (n: number) => FPInterval;\n\n  /**\n   * The definition of saturate does not specify which version of clamp to use.\n   * Using min-max here, since it has wider acceptance intervals, that include\n   * all of median's.\n   */\n  protected saturateIntervalImpl(n: number): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(n),\n      this.toInterval(0.0),\n      this.toInterval(1.0),\n      this.ClampMinMaxIntervalOp\n    );\n  }\n\n  /*** Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0) */\n  public abstract readonly saturateInterval: (n: number) => FPInterval;\n\n  private readonly SignIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      if (n > 0.0) {\n        return this.correctlyRoundedInterval(1.0);\n      }\n      if (n < 0.0) {\n        return this.correctlyRoundedInterval(-1.0);\n      }\n\n      return this.correctlyRoundedInterval(0.0);\n    },\n  };\n\n  protected signIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.SignIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of sign(x) */\n  public abstract readonly signInterval: (n: number) => FPInterval;\n\n  private readonly SinIntervalOp: ScalarToIntervalOp = {\n    impl: this.limitScalarToIntervalDomain(\n      this.constants().negPiToPiInterval,\n      (n: number): FPInterval => {\n        assert(this.kind === 'f32' || this.kind === 'f16');\n        const abs_error = this.kind === 'f32' ? 2 ** -11 : 2 ** -7;\n        return this.absoluteErrorInterval(Math.sin(n), abs_error);\n      }\n    ),\n  };\n\n  protected sinIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.SinIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of sin(x) */\n  public abstract readonly sinInterval: (n: number) => FPInterval;\n\n  private readonly SinhIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // sinh(x) = (exp(x) - exp(-x)) * 0.5\n      const minus_n = this.negationInterval(n);\n      return this.multiplicationInterval(\n        this.subtractionInterval(this.expInterval(n), this.expInterval(minus_n)),\n        0.5\n      );\n    },\n  };\n\n  protected sinhIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.SinhIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of sinh(x) */\n  public abstract readonly sinhInterval: (n: number) => FPInterval;\n\n  private readonly SmoothStepOp: ScalarTripleToIntervalOp = {\n    impl: (low: number, high: number, x: number): FPInterval => {\n      // For clamp(foo, 0.0, 1.0) the different implementations of clamp provide\n      // the same value, so arbitrarily picking the minmax version to use.\n      // t = clamp((x - low) / (high - low), 0.0, 1.0)\n      // prettier-ignore\n      const t = this.clampMedianInterval(\n        this.divisionInterval(\n          this.subtractionInterval(x, low),\n          this.subtractionInterval(high, low)),\n        0.0,\n        1.0);\n      // Inherited from t * t * (3.0 - 2.0 * t)\n      // prettier-ignore\n      return this.multiplicationInterval(\n        t,\n        this.multiplicationInterval(t,\n          this.subtractionInterval(3.0,\n            this.multiplicationInterval(2.0, t))));\n    },\n  };\n\n  protected smoothStepIntervalImpl(low: number, high: number, x: number): FPInterval {\n    return this.runScalarTripleToIntervalOp(\n      this.toInterval(low),\n      this.toInterval(high),\n      this.toInterval(x),\n      this.SmoothStepOp\n    );\n  }\n\n  /** Calculate an acceptance interval of smoothStep(low, high, x) */\n  public abstract readonly smoothStepInterval: (low: number, high: number, x: number) => FPInterval;\n\n  private readonly SqrtIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(1.0, this.inverseSqrtInterval(n));\n    },\n  };\n\n  protected sqrtIntervalImpl(n: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.SqrtIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of sqrt(x) */\n  public abstract readonly sqrtInterval: (n: number | FPInterval) => FPInterval;\n\n  private readonly StepIntervalOp: ScalarPairToIntervalOp = {\n    impl: (edge: number, x: number): FPInterval => {\n      if (edge <= x) {\n        return this.correctlyRoundedInterval(1.0);\n      }\n      return this.correctlyRoundedInterval(0.0);\n    },\n  };\n\n  protected stepIntervalImpl(edge: number, x: number): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(edge),\n      this.toInterval(x),\n      this.StepIntervalOp\n    );\n  }\n\n  /**\n   * Calculate an acceptance 'interval' for step(edge, x)\n   *\n   * step only returns two possible values, so its interval requires special\n   * interpretation in CTS tests.\n   * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-, +].\n   * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n   * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n   * indicate either 0.0 or 1.0 are acceptable answers.\n   * [-, +] is treated as unbounded interval, since an unbounded or\n   * infinite value was passed in.\n   */\n  public abstract readonly stepInterval: (edge: number, x: number) => FPInterval;\n\n  private readonly SubtractionIntervalOp: ScalarPairToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x - y);\n    },\n  };\n\n  protected subtractionIntervalImpl(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runScalarPairToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.SubtractionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x - y */\n  public abstract readonly subtractionInterval: (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ) => FPInterval;\n\n  protected subtractionMatrixMatrixIntervalImpl(x: Array2D<number>, y: Array2D<number>): FPMatrix {\n    return this.runScalarPairToIntervalOpMatrixComponentWise(\n      this.toMatrix(x),\n      this.toMatrix(y),\n      this.SubtractionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x - y, when x and y are matrices */\n  public abstract readonly subtractionMatrixMatrixInterval: (\n    x: Array2D<number>,\n    y: Array2D<number>\n  ) => FPMatrix;\n\n  private readonly TanIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(this.sinInterval(n), this.cosInterval(n));\n    },\n  };\n\n  protected tanIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.TanIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of tan(x) */\n  public abstract readonly tanInterval: (n: number) => FPInterval;\n\n  private readonly TanhIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(this.sinhInterval(n), this.coshInterval(n));\n    },\n  };\n\n  protected tanhIntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.TanhIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of tanh(x) */\n  public abstract readonly tanhInterval: (n: number) => FPInterval;\n\n  private readonly TransposeIntervalOp: MatrixToMatrixOp = {\n    impl: (m: Array2D<number>): FPMatrix => {\n      const num_cols = m.length;\n      const num_rows = m[0].length;\n      const result: FPInterval[][] = [...Array(num_rows)].map(_ => [...Array(num_cols)]);\n\n      for (let i = 0; i < num_cols; i++) {\n        for (let j = 0; j < num_rows; j++) {\n          result[j][i] = this.correctlyRoundedInterval(m[i][j]);\n        }\n      }\n      return this.toMatrix(result);\n    },\n  };\n\n  protected transposeIntervalImpl(m: Array2D<number>): FPMatrix {\n    return this.runMatrixToMatrixOp(this.toMatrix(m), this.TransposeIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of transpose(m) */\n  public abstract readonly transposeInterval: (m: Array2D<number>) => FPMatrix;\n\n  private readonly TruncIntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.trunc(n));\n    },\n  };\n\n  protected truncIntervalImpl(n: number | FPInterval): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.TruncIntervalOp);\n  }\n\n  /** Calculate an acceptance interval of trunc(x) */\n  public abstract readonly truncInterval: (n: number | FPInterval) => FPInterval;\n}\n\n// Pre-defined values that get used multiple times in _constants' initializers. Cannot use FPTraits members, since this\n// executes before they are defined.\nconst kF32UnboundedInterval = new FPInterval(\n  'f32',\n  Number.NEGATIVE_INFINITY,\n  Number.POSITIVE_INFINITY\n);\nconst kF32ZeroInterval = new FPInterval('f32', 0);\n\nclass F32Traits extends FPTraits {\n  private static _constants: FPConstants = {\n    positive: {\n      min: kValue.f32.positive.min,\n      max: kValue.f32.positive.max,\n      infinity: kValue.f32.positive.infinity,\n      nearest_max: kValue.f32.positive.nearest_max,\n      less_than_one: kValue.f32.positive.less_than_one,\n      subnormal: {\n        min: kValue.f32.positive.subnormal.min,\n        max: kValue.f32.positive.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f32.positive.pi.whole,\n        three_quarters: kValue.f32.positive.pi.three_quarters,\n        half: kValue.f32.positive.pi.half,\n        third: kValue.f32.positive.pi.third,\n        quarter: kValue.f32.positive.pi.quarter,\n        sixth: kValue.f32.positive.pi.sixth,\n      },\n      e: kValue.f32.positive.e,\n    },\n    negative: {\n      min: kValue.f32.negative.min,\n      max: kValue.f32.negative.max,\n      infinity: kValue.f32.negative.infinity,\n      nearest_min: kValue.f32.negative.nearest_min,\n      less_than_one: kValue.f32.negative.less_than_one,\n      subnormal: {\n        min: kValue.f32.negative.subnormal.min,\n        max: kValue.f32.negative.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f32.negative.pi.whole,\n        three_quarters: kValue.f32.negative.pi.three_quarters,\n        half: kValue.f32.negative.pi.half,\n        third: kValue.f32.negative.pi.third,\n        quarter: kValue.f32.negative.pi.quarter,\n        sixth: kValue.f32.negative.pi.sixth,\n      },\n    },\n    unboundedInterval: kF32UnboundedInterval,\n    zeroInterval: kF32ZeroInterval,\n    // Have to use the constants.ts values here, because values defined in the\n    // initializer cannot be referenced in the initializer\n    negPiToPiInterval: new FPInterval(\n      'f32',\n      kValue.f32.negative.pi.whole,\n      kValue.f32.positive.pi.whole\n    ),\n    greaterThanZeroInterval: new FPInterval(\n      'f32',\n      kValue.f32.positive.subnormal.min,\n      kValue.f32.positive.max\n    ),\n    zeroVector: {\n      2: [kF32ZeroInterval, kF32ZeroInterval],\n      3: [kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval],\n      4: [kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval],\n    },\n    unboundedVector: {\n      2: [kF32UnboundedInterval, kF32UnboundedInterval],\n      3: [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n      4: [\n        kF32UnboundedInterval,\n        kF32UnboundedInterval,\n        kF32UnboundedInterval,\n        kF32UnboundedInterval,\n      ],\n    },\n    unboundedMatrix: {\n      2: {\n        2: [\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        3: [\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        4: [\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n        ],\n      },\n      3: {\n        2: [\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        3: [\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        4: [\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n        ],\n      },\n      4: {\n        2: [\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        3: [\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n          [kF32UnboundedInterval, kF32UnboundedInterval, kF32UnboundedInterval],\n        ],\n        4: [\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n          [\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n            kF32UnboundedInterval,\n          ],\n        ],\n      },\n    },\n  };\n\n  public constructor() {\n    super('f32');\n  }\n\n  public constants(): FPConstants {\n    return F32Traits._constants;\n  }\n\n  // Utilities - Overrides\n  public readonly quantize = quantizeToF32;\n  public readonly correctlyRounded = correctlyRoundedF32;\n  public readonly isFinite = isFiniteF32;\n  public readonly isSubnormal = isSubnormalNumberF32;\n  public readonly flushSubnormal = flushSubnormalNumberF32;\n  public readonly oneULP = oneULPF32;\n  public readonly scalarBuilder = f32;\n\n  // Framework - Fundamental Error Intervals - Overrides\n  public readonly absoluteErrorInterval = this.absoluteErrorIntervalImpl.bind(this);\n  public readonly correctlyRoundedInterval = this.correctlyRoundedIntervalImpl.bind(this);\n  public readonly correctlyRoundedMatrix = this.correctlyRoundedMatrixImpl.bind(this);\n  public readonly ulpInterval = this.ulpIntervalImpl.bind(this);\n\n  // Framework - API - Overrides\n  public readonly absInterval = this.absIntervalImpl.bind(this);\n  public readonly acosInterval = this.acosIntervalImpl.bind(this);\n  public readonly acoshAlternativeInterval = this.acoshAlternativeIntervalImpl.bind(this);\n  public readonly acoshPrimaryInterval = this.acoshPrimaryIntervalImpl.bind(this);\n  public readonly acoshIntervals = [this.acoshAlternativeInterval, this.acoshPrimaryInterval];\n  public readonly additionInterval = this.additionIntervalImpl.bind(this);\n  public readonly additionMatrixMatrixInterval = this.additionMatrixMatrixIntervalImpl.bind(this);\n  public readonly asinInterval = this.asinIntervalImpl.bind(this);\n  public readonly asinhInterval = this.asinhIntervalImpl.bind(this);\n  public readonly atanInterval = this.atanIntervalImpl.bind(this);\n  public readonly atan2Interval = this.atan2IntervalImpl.bind(this);\n  public readonly atanhInterval = this.atanhIntervalImpl.bind(this);\n  public readonly ceilInterval = this.ceilIntervalImpl.bind(this);\n  public readonly clampMedianInterval = this.clampMedianIntervalImpl.bind(this);\n  public readonly clampMinMaxInterval = this.clampMinMaxIntervalImpl.bind(this);\n  public readonly clampIntervals = [this.clampMedianInterval, this.clampMinMaxInterval];\n  public readonly cosInterval = this.cosIntervalImpl.bind(this);\n  public readonly coshInterval = this.coshIntervalImpl.bind(this);\n  public readonly crossInterval = this.crossIntervalImpl.bind(this);\n  public readonly degreesInterval = this.degreesIntervalImpl.bind(this);\n  public readonly determinantInterval = this.determinantIntervalImpl.bind(this);\n  public readonly distanceInterval = this.distanceIntervalImpl.bind(this);\n  public readonly divisionInterval = this.divisionIntervalImpl.bind(this);\n  public readonly dotInterval = this.dotIntervalImpl.bind(this);\n  public readonly expInterval = this.expIntervalImpl.bind(this);\n  public readonly exp2Interval = this.exp2IntervalImpl.bind(this);\n  public readonly faceForwardIntervals = this.faceForwardIntervalsImpl.bind(this);\n  public readonly floorInterval = this.floorIntervalImpl.bind(this);\n  public readonly fmaInterval = this.fmaIntervalImpl.bind(this);\n  public readonly fractInterval = this.fractIntervalImpl.bind(this);\n  public readonly inverseSqrtInterval = this.inverseSqrtIntervalImpl.bind(this);\n  public readonly ldexpInterval = this.ldexpIntervalImpl.bind(this);\n  public readonly lengthInterval = this.lengthIntervalImpl.bind(this);\n  public readonly logInterval = this.logIntervalImpl.bind(this);\n  public readonly log2Interval = this.log2IntervalImpl.bind(this);\n  public readonly maxInterval = this.maxIntervalImpl.bind(this);\n  public readonly minInterval = this.minIntervalImpl.bind(this);\n  public readonly mixImpreciseInterval = this.mixImpreciseIntervalImpl.bind(this);\n  public readonly mixPreciseInterval = this.mixPreciseIntervalImpl.bind(this);\n  public readonly mixIntervals = [this.mixImpreciseInterval, this.mixPreciseInterval];\n  public readonly modfInterval = this.modfIntervalImpl.bind(this);\n  public readonly multiplicationInterval = this.multiplicationIntervalImpl.bind(this);\n  public readonly multiplicationMatrixMatrixInterval = this.multiplicationMatrixMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationMatrixScalarInterval = this.multiplicationMatrixScalarIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationScalarMatrixInterval = this.multiplicationScalarMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationMatrixVectorInterval = this.multiplicationMatrixVectorIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationVectorMatrixInterval = this.multiplicationVectorMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly negationInterval = this.negationIntervalImpl.bind(this);\n  public readonly normalizeInterval = this.normalizeIntervalImpl.bind(this);\n  public readonly powInterval = this.powIntervalImpl.bind(this);\n  public readonly radiansInterval = this.radiansIntervalImpl.bind(this);\n  public readonly reflectInterval = this.reflectIntervalImpl.bind(this);\n  public readonly refractInterval = this.refractIntervalImpl.bind(this);\n  public readonly remainderInterval = this.remainderIntervalImpl.bind(this);\n  public readonly roundInterval = this.roundIntervalImpl.bind(this);\n  public readonly saturateInterval = this.saturateIntervalImpl.bind(this);\n  public readonly signInterval = this.signIntervalImpl.bind(this);\n  public readonly sinInterval = this.sinIntervalImpl.bind(this);\n  public readonly sinhInterval = this.sinhIntervalImpl.bind(this);\n  public readonly smoothStepInterval = this.smoothStepIntervalImpl.bind(this);\n  public readonly sqrtInterval = this.sqrtIntervalImpl.bind(this);\n  public readonly stepInterval = this.stepIntervalImpl.bind(this);\n  public readonly subtractionInterval = this.subtractionIntervalImpl.bind(this);\n  public readonly subtractionMatrixMatrixInterval = this.subtractionMatrixMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly tanInterval = this.tanIntervalImpl.bind(this);\n  public readonly tanhInterval = this.tanhIntervalImpl.bind(this);\n  public readonly transposeInterval = this.transposeIntervalImpl.bind(this);\n  public readonly truncInterval = this.truncIntervalImpl.bind(this);\n\n  // Framework - Cases\n\n  // U32 -> Interval is used for testing f32 specific unpack* functions\n  /**\n   * @returns a Case for the param and the interval generator provided.\n   * The Case will use an interval comparator for matching results.\n   * @param param the param to pass in\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  private makeU32ToVectorCase(\n    param: number,\n    filter: IntervalFilter,\n    ...ops: ScalarToVector[]\n  ): Case | undefined {\n    param = Math.trunc(param);\n\n    const vectors = ops.map(o => o(param));\n    if (filter === 'finite' && vectors.some(v => !v.every(e => e.isFinite()))) {\n      return undefined;\n    }\n    return {\n      input: u32(param),\n      expected: anyOf(...vectors),\n    };\n  }\n\n  /**\n   * @returns an array of Cases for operations over a range of inputs\n   * @param params array of inputs to try\n   * @param filter what interval filtering to apply\n   * @param ops callbacks that implement generating an acceptance interval\n   */\n  public generateU32ToIntervalCases(\n    params: readonly number[],\n    filter: IntervalFilter,\n    ...ops: ScalarToVector[]\n  ): Case[] {\n    return params.reduce((cases, e) => {\n      const c = this.makeU32ToVectorCase(e, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n      return cases;\n    }, new Array<Case>());\n  }\n\n  // Framework - API\n\n  private readonly QuantizeToF16IntervalOp: ScalarToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      const rounded = correctlyRoundedF16(n);\n      const flushed = addFlushedIfNeededF16(rounded);\n      return this.spanIntervals(...flushed.map(f => this.toInterval(f)));\n    },\n  };\n\n  protected quantizeToF16IntervalImpl(n: number): FPInterval {\n    return this.runScalarToIntervalOp(this.toInterval(n), this.QuantizeToF16IntervalOp);\n  }\n\n  /** Calculate an acceptance interval of quantizeToF16(x) */\n  public readonly quantizeToF16Interval = this.quantizeToF16IntervalImpl.bind(this);\n\n  /**\n   * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n   * converting between numeric formats\n   *\n   * unpackData* is shared between all the unpack*Interval functions, so to\n   * avoid re-entrancy problems, they should not call each other or themselves\n   * directly or indirectly.\n   */\n  private readonly unpackData = new ArrayBuffer(4);\n  private readonly unpackDataU32 = new Uint32Array(this.unpackData);\n  private readonly unpackDataU16 = new Uint16Array(this.unpackData);\n  private readonly unpackDataU8 = new Uint8Array(this.unpackData);\n  private readonly unpackDataI16 = new Int16Array(this.unpackData);\n  private readonly unpackDataI8 = new Int8Array(this.unpackData);\n  private readonly unpackDataF16 = new Float16Array(this.unpackData);\n\n  private unpack2x16floatIntervalImpl(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16floatInterval only accepts values on the bounds of u32'\n    );\n    this.unpackDataU32[0] = n;\n    if (this.unpackDataF16.some(f => !isFiniteF16(f))) {\n      return [this.constants().unboundedInterval, this.constants().unboundedInterval];\n    }\n\n    const result: FPVector = [\n      this.quantizeToF16Interval(this.unpackDataF16[0]),\n      this.quantizeToF16Interval(this.unpackDataF16[1]),\n    ];\n\n    if (result.some(r => !r.isFinite())) {\n      return [this.constants().unboundedInterval, this.constants().unboundedInterval];\n    }\n    return result;\n  }\n\n  /** Calculate an acceptance interval vector for unpack2x16float(x) */\n  public readonly unpack2x16floatInterval = this.unpack2x16floatIntervalImpl.bind(this);\n\n  private unpack2x16snormIntervalImpl(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16snormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.ulpInterval(Math.max(n / 32767, -1), 3);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [op(this.unpackDataI16[0]), op(this.unpackDataI16[1])];\n  }\n\n  /** Calculate an acceptance interval vector for unpack2x16snorm(x) */\n  public readonly unpack2x16snormInterval = this.unpack2x16snormIntervalImpl.bind(this);\n\n  private unpack2x16unormIntervalImpl(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16unormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.ulpInterval(n / 65535, 3);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [op(this.unpackDataU16[0]), op(this.unpackDataU16[1])];\n  }\n\n  /** Calculate an acceptance interval vector for unpack2x16unorm(x) */\n  public readonly unpack2x16unormInterval = this.unpack2x16unormIntervalImpl.bind(this);\n\n  private unpack4x8snormIntervalImpl(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack4x8snormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.ulpInterval(Math.max(n / 127, -1), 3);\n    };\n    this.unpackDataU32[0] = n;\n    return [\n      op(this.unpackDataI8[0]),\n      op(this.unpackDataI8[1]),\n      op(this.unpackDataI8[2]),\n      op(this.unpackDataI8[3]),\n    ];\n  }\n\n  /** Calculate an acceptance interval vector for unpack4x8snorm(x) */\n  public readonly unpack4x8snormInterval = this.unpack4x8snormIntervalImpl.bind(this);\n\n  private unpack4x8unormIntervalImpl(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack4x8unormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.ulpInterval(n / 255, 3);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [\n      op(this.unpackDataU8[0]),\n      op(this.unpackDataU8[1]),\n      op(this.unpackDataU8[2]),\n      op(this.unpackDataU8[3]),\n    ];\n  }\n\n  /** Calculate an acceptance interval vector for unpack4x8unorm(x) */\n  public readonly unpack4x8unormInterval = this.unpack4x8unormIntervalImpl.bind(this);\n}\n\n// Need to separately allocate f32 traits, so they can be referenced by\n// FPAbstractTraits for forwarding.\nconst kF32Traits = new F32Traits();\n\n// Pre-defined values that get used multiple times in _constants' initializers. Cannot use FPTraits members, since this\n// executes before they are defined.\nconst kAbstractUnboundedInterval = new FPInterval(\n  'abstract',\n  Number.NEGATIVE_INFINITY,\n  Number.POSITIVE_INFINITY\n);\nconst kAbstractZeroInterval = new FPInterval('abstract', 0);\n\n// This is implementation is incomplete\nclass FPAbstractTraits extends FPTraits {\n  private static _constants: FPConstants = {\n    positive: {\n      min: kValue.f64.positive.min,\n      max: kValue.f64.positive.max,\n      infinity: kValue.f64.positive.infinity,\n      nearest_max: kValue.f64.positive.nearest_max,\n      less_than_one: kValue.f64.positive.less_than_one,\n      subnormal: {\n        min: kValue.f64.positive.subnormal.min,\n        max: kValue.f64.positive.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f64.positive.pi.whole,\n        three_quarters: kValue.f64.positive.pi.three_quarters,\n        half: kValue.f64.positive.pi.half,\n        third: kValue.f64.positive.pi.third,\n        quarter: kValue.f64.positive.pi.quarter,\n        sixth: kValue.f64.positive.pi.sixth,\n      },\n      e: kValue.f64.positive.e,\n    },\n    negative: {\n      min: kValue.f64.negative.min,\n      max: kValue.f64.negative.max,\n      infinity: kValue.f64.negative.infinity,\n      nearest_min: kValue.f64.negative.nearest_min,\n      less_than_one: kValue.f64.negative.less_than_one,\n      subnormal: {\n        min: kValue.f64.negative.subnormal.min,\n        max: kValue.f64.negative.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f64.negative.pi.whole,\n        three_quarters: kValue.f64.negative.pi.three_quarters,\n        half: kValue.f64.negative.pi.half,\n        third: kValue.f64.negative.pi.third,\n        quarter: kValue.f64.negative.pi.quarter,\n        sixth: kValue.f64.negative.pi.sixth,\n      },\n    },\n    unboundedInterval: kAbstractUnboundedInterval,\n    zeroInterval: kAbstractZeroInterval,\n    // Have to use the constants.ts values here, because values defined in the\n    // initializer cannot be referenced in the initializer\n    negPiToPiInterval: new FPInterval(\n      'abstract',\n      kValue.f64.negative.pi.whole,\n      kValue.f64.positive.pi.whole\n    ),\n    greaterThanZeroInterval: new FPInterval(\n      'abstract',\n      kValue.f64.positive.subnormal.min,\n      kValue.f64.positive.max\n    ),\n    zeroVector: {\n      2: [kAbstractZeroInterval, kAbstractZeroInterval],\n      3: [kAbstractZeroInterval, kAbstractZeroInterval, kAbstractZeroInterval],\n      4: [\n        kAbstractZeroInterval,\n        kAbstractZeroInterval,\n        kAbstractZeroInterval,\n        kAbstractZeroInterval,\n      ],\n    },\n    unboundedVector: {\n      2: [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n      3: [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n      4: [\n        kAbstractUnboundedInterval,\n        kAbstractUnboundedInterval,\n        kAbstractUnboundedInterval,\n        kAbstractUnboundedInterval,\n      ],\n    },\n    unboundedMatrix: {\n      2: {\n        2: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        3: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        4: [\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n        ],\n      },\n      3: {\n        2: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        3: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        4: [\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n        ],\n      },\n      4: {\n        2: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        3: [\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n          [kAbstractUnboundedInterval, kAbstractUnboundedInterval, kAbstractUnboundedInterval],\n        ],\n        4: [\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n          [\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n            kAbstractUnboundedInterval,\n          ],\n        ],\n      },\n    },\n  };\n\n  public constructor() {\n    super('abstract');\n  }\n\n  public constants(): FPConstants {\n    return FPAbstractTraits._constants;\n  }\n\n  // Utilities - Overrides\n  // number is represented as a f64 internally, so all number values are already\n  // quantized to f64\n  public readonly quantize = (n: number) => {\n    return n;\n  };\n  public readonly correctlyRounded = correctlyRoundedF64;\n  public readonly isFinite = Number.isFinite;\n  public readonly isSubnormal = isSubnormalNumberF64;\n  public readonly flushSubnormal = flushSubnormalNumberF64;\n  public readonly oneULP = (_target: number, _mode: FlushMode = 'flush'): number => {\n    unreachable(`'FPAbstractTraits.oneULP should never be called`);\n  };\n  public readonly scalarBuilder = abstractFloat;\n\n  // Framework - Fundamental Error Intervals - Overrides\n  public readonly absoluteErrorInterval = this.unboundedAbsoluteErrorInterval.bind(this);\n  public readonly correctlyRoundedInterval = this.correctlyRoundedIntervalImpl.bind(this);\n  public readonly correctlyRoundedMatrix = this.correctlyRoundedMatrixImpl.bind(this);\n  public readonly ulpInterval = (n: number, numULP: number): FPInterval => {\n    return this.toInterval(kF32Traits.ulpInterval(n, numULP));\n  };\n\n  // Framework - API - Overrides\n  public readonly absInterval = this.absIntervalImpl.bind(this);\n  public readonly acosInterval = this.unimplementedScalarToInterval.bind(this, 'acosInterval');\n  public readonly acoshAlternativeInterval = this.unimplementedScalarToInterval.bind(\n    this,\n    'acoshAlternativeInterval'\n  );\n  public readonly acoshPrimaryInterval = this.unimplementedScalarToInterval.bind(\n    this,\n    'acoshPrimaryInterval'\n  );\n  public readonly acoshIntervals = [this.acoshAlternativeInterval, this.acoshPrimaryInterval];\n  public readonly additionInterval = this.additionIntervalImpl.bind(this);\n  public readonly additionMatrixMatrixInterval = this.additionMatrixMatrixIntervalImpl.bind(this);\n  public readonly asinInterval = this.unimplementedScalarToInterval.bind(this, 'asinInterval');\n  public readonly asinhInterval = this.unimplementedScalarToInterval.bind(this, 'asinhInterval');\n  public readonly atanInterval = this.unimplementedScalarToInterval.bind(this, 'atanInterval');\n  public readonly atan2Interval = this.unimplementedScalarPairToInterval.bind(\n    this,\n    'atan2Interval'\n  );\n  public readonly atanhInterval = this.unimplementedScalarToInterval.bind(this, 'atanhInterval');\n  public readonly ceilInterval = this.unimplementedScalarToInterval.bind(this, 'ceilInterval');\n  public readonly clampMedianInterval = this.clampMedianIntervalImpl.bind(this);\n  public readonly clampMinMaxInterval = this.clampMinMaxIntervalImpl.bind(this);\n  public readonly clampIntervals = [this.clampMedianInterval, this.clampMinMaxInterval];\n  public readonly cosInterval = this.unimplementedScalarToInterval.bind(this, 'cosInterval');\n  public readonly coshInterval = this.unimplementedScalarToInterval.bind(this, 'coshInterval');\n  public readonly crossInterval = this.crossIntervalImpl.bind(this);\n  public readonly degreesInterval = this.degreesIntervalImpl.bind(this);\n  public readonly determinantInterval = this.unimplementedMatrixToInterval.bind(\n    this,\n    'determinantInterval'\n  );\n  public readonly distanceInterval = this.unimplementedDistance.bind(this);\n  public readonly divisionInterval = (\n    x: number | FPInterval,\n    y: number | FPInterval\n  ): FPInterval => {\n    return this.toInterval(kF32Traits.divisionInterval(x, y));\n  };\n  public readonly dotInterval = this.unimplementedVectorPairToInterval.bind(this, 'dotInterval');\n  public readonly expInterval = this.unimplementedScalarToInterval.bind(this, 'expInterval');\n  public readonly exp2Interval = this.unimplementedScalarToInterval.bind(this, 'exp2Interval');\n  public readonly faceForwardIntervals = this.unimplementedFaceForward.bind(this);\n  public readonly floorInterval = this.floorIntervalImpl.bind(this);\n  public readonly fmaInterval = this.fmaIntervalImpl.bind(this);\n  public readonly fractInterval = this.unimplementedScalarToInterval.bind(this, 'fractInterval');\n  public readonly inverseSqrtInterval = this.unimplementedScalarToInterval.bind(\n    this,\n    'inverseSqrtInterval'\n  );\n  public readonly ldexpInterval = this.unimplementedScalarPairToInterval.bind(\n    this,\n    'ldexpInterval'\n  );\n  public readonly lengthInterval = this.unimplementedLength.bind(this);\n  public readonly logInterval = this.unimplementedScalarToInterval.bind(this, 'logInterval');\n  public readonly log2Interval = this.unimplementedScalarToInterval.bind(this, 'log2Interval');\n  public readonly maxInterval = this.maxIntervalImpl.bind(this);\n  public readonly minInterval = this.minIntervalImpl.bind(this);\n  public readonly mixImpreciseInterval = this.unimplementedScalarTripleToInterval.bind(\n    this,\n    'mixImpreciseInterval'\n  );\n  public readonly mixPreciseInterval = this.unimplementedScalarTripleToInterval.bind(\n    this,\n    'mixPreciseInterval'\n  );\n  public readonly mixIntervals = [this.mixImpreciseInterval, this.mixPreciseInterval];\n  public readonly modfInterval = this.modfIntervalImpl.bind(this);\n  public readonly multiplicationInterval = this.multiplicationIntervalImpl.bind(this);\n  public readonly multiplicationMatrixMatrixInterval = this.unimplementedMatrixPairToMatrix.bind(\n    this,\n    'multiplicationMatrixMatrixInterval'\n  );\n  public readonly multiplicationMatrixScalarInterval = this.unimplementedMatrixScalarToMatrix.bind(\n    this,\n    'multiplicationMatrixScalarInterval'\n  );\n  public readonly multiplicationScalarMatrixInterval = this.unimplementedScalarMatrixToMatrix.bind(\n    this,\n    'multiplicationScalarMatrixInterval'\n  );\n  public readonly multiplicationMatrixVectorInterval = this.unimplementedMatrixVectorToVector.bind(\n    this,\n    'multiplicationMatrixVectorInterval'\n  );\n  public readonly multiplicationVectorMatrixInterval = this.unimplementedVectorMatrixToVector.bind(\n    this,\n    'multiplicationVectorMatrixInterval'\n  );\n  public readonly negationInterval = this.negationIntervalImpl.bind(this);\n  public readonly normalizeInterval = this.unimplementedVectorToVector.bind(\n    this,\n    'normalizeInterval'\n  );\n  public readonly powInterval = this.unimplementedScalarPairToInterval.bind(this, 'powInterval');\n  public readonly radiansInterval = this.radiansIntervalImpl.bind(this);\n  public readonly reflectInterval = this.unimplementedVectorPairToVector.bind(\n    this,\n    'reflectInterval'\n  );\n  public readonly refractInterval = this.unimplementedRefract.bind(this);\n  public readonly remainderInterval = (x: number, y: number): FPInterval => {\n    return this.toInterval(kF32Traits.remainderInterval(x, y));\n  };\n  public readonly roundInterval = this.unimplementedScalarToInterval.bind(this, 'roundInterval');\n  public readonly saturateInterval = this.saturateIntervalImpl.bind(this);\n  public readonly signInterval = this.signIntervalImpl.bind(this);\n  public readonly sinInterval = this.unimplementedScalarToInterval.bind(this, 'sinInterval');\n  public readonly sinhInterval = this.unimplementedScalarToInterval.bind(this, 'sinhInterval');\n  public readonly smoothStepInterval = this.unimplementedScalarTripleToInterval.bind(\n    this,\n    'smoothStepInterval'\n  );\n  public readonly sqrtInterval = this.unimplementedScalarToInterval.bind(this, 'sqrtInterval');\n  public readonly stepInterval = this.unimplementedScalarPairToInterval.bind(this, 'stepInterval');\n  public readonly subtractionInterval = this.subtractionIntervalImpl.bind(this);\n  public readonly subtractionMatrixMatrixInterval = this.subtractionMatrixMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly tanInterval = this.unimplementedScalarToInterval.bind(this, 'tanInterval');\n  public readonly tanhInterval = this.unimplementedScalarToInterval.bind(this, 'tanhInterval');\n  public readonly transposeInterval = this.transposeIntervalImpl.bind(this);\n  public readonly truncInterval = this.truncIntervalImpl.bind(this);\n}\n\n// Pre-defined values that get used multiple times in _constants' initializers. Cannot use FPTraits members, since this\n// executes before they are defined.\nconst kF16UnboundedInterval = new FPInterval(\n  'f16',\n  Number.NEGATIVE_INFINITY,\n  Number.POSITIVE_INFINITY\n);\nconst kF16ZeroInterval = new FPInterval('f16', 0);\n\n// This is implementation is incomplete\nclass F16Traits extends FPTraits {\n  private static _constants: FPConstants = {\n    positive: {\n      min: kValue.f16.positive.min,\n      max: kValue.f16.positive.max,\n      infinity: kValue.f16.positive.infinity,\n      nearest_max: kValue.f16.positive.nearest_max,\n      less_than_one: kValue.f16.positive.less_than_one,\n      subnormal: {\n        min: kValue.f16.positive.subnormal.min,\n        max: kValue.f16.positive.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f16.positive.pi.whole,\n        three_quarters: kValue.f16.positive.pi.three_quarters,\n        half: kValue.f16.positive.pi.half,\n        third: kValue.f16.positive.pi.third,\n        quarter: kValue.f16.positive.pi.quarter,\n        sixth: kValue.f16.positive.pi.sixth,\n      },\n      e: kValue.f16.positive.e,\n    },\n    negative: {\n      min: kValue.f16.negative.min,\n      max: kValue.f16.negative.max,\n      infinity: kValue.f16.negative.infinity,\n      nearest_min: kValue.f16.negative.nearest_min,\n      less_than_one: kValue.f16.negative.less_than_one,\n      subnormal: {\n        min: kValue.f16.negative.subnormal.min,\n        max: kValue.f16.negative.subnormal.max,\n      },\n      pi: {\n        whole: kValue.f16.negative.pi.whole,\n        three_quarters: kValue.f16.negative.pi.three_quarters,\n        half: kValue.f16.negative.pi.half,\n        third: kValue.f16.negative.pi.third,\n        quarter: kValue.f16.negative.pi.quarter,\n        sixth: kValue.f16.negative.pi.sixth,\n      },\n    },\n    unboundedInterval: kF16UnboundedInterval,\n    zeroInterval: kF16ZeroInterval,\n    // Have to use the constants.ts values here, because values defined in the\n    // initializer cannot be referenced in the initializer\n    negPiToPiInterval: new FPInterval(\n      'f16',\n      kValue.f16.negative.pi.whole,\n      kValue.f16.positive.pi.whole\n    ),\n    greaterThanZeroInterval: new FPInterval(\n      'f16',\n      kValue.f16.positive.subnormal.min,\n      kValue.f16.positive.max\n    ),\n    zeroVector: {\n      2: [kF16ZeroInterval, kF16ZeroInterval],\n      3: [kF16ZeroInterval, kF16ZeroInterval, kF16ZeroInterval],\n      4: [kF16ZeroInterval, kF16ZeroInterval, kF16ZeroInterval, kF16ZeroInterval],\n    },\n    unboundedVector: {\n      2: [kF16UnboundedInterval, kF16UnboundedInterval],\n      3: [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n      4: [\n        kF16UnboundedInterval,\n        kF16UnboundedInterval,\n        kF16UnboundedInterval,\n        kF16UnboundedInterval,\n      ],\n    },\n    unboundedMatrix: {\n      2: {\n        2: [\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        3: [\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        4: [\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n        ],\n      },\n      3: {\n        2: [\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        3: [\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        4: [\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n        ],\n      },\n      4: {\n        2: [\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        3: [\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n          [kF16UnboundedInterval, kF16UnboundedInterval, kF16UnboundedInterval],\n        ],\n        4: [\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n          [\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n            kF16UnboundedInterval,\n          ],\n        ],\n      },\n    },\n  };\n\n  public constructor() {\n    super('f16');\n  }\n\n  public constants(): FPConstants {\n    return F16Traits._constants;\n  }\n\n  // Utilities - Overrides\n  public readonly quantize = quantizeToF16;\n  public readonly correctlyRounded = correctlyRoundedF16;\n  public readonly isFinite = isFiniteF16;\n  public readonly isSubnormal = isSubnormalNumberF16;\n  public readonly flushSubnormal = flushSubnormalNumberF16;\n  public readonly oneULP = oneULPF16;\n  public readonly scalarBuilder = f16;\n\n  // Framework - Fundamental Error Intervals - Overrides\n  public readonly absoluteErrorInterval = this.absoluteErrorIntervalImpl.bind(this);\n  public readonly correctlyRoundedInterval = this.correctlyRoundedIntervalImpl.bind(this);\n  public readonly correctlyRoundedMatrix = this.correctlyRoundedMatrixImpl.bind(this);\n  public readonly ulpInterval = this.ulpIntervalImpl.bind(this);\n\n  // Framework - API - Overrides\n  public readonly absInterval = this.absIntervalImpl.bind(this);\n  public readonly acosInterval = this.acosIntervalImpl.bind(this);\n  public readonly acoshAlternativeInterval = this.acoshAlternativeIntervalImpl.bind(this);\n  public readonly acoshPrimaryInterval = this.acoshPrimaryIntervalImpl.bind(this);\n  public readonly acoshIntervals = [this.acoshAlternativeInterval, this.acoshPrimaryInterval];\n  public readonly additionInterval = this.additionIntervalImpl.bind(this);\n  public readonly additionMatrixMatrixInterval = this.additionMatrixMatrixIntervalImpl.bind(this);\n  public readonly asinInterval = this.asinIntervalImpl.bind(this);\n  public readonly asinhInterval = this.asinhIntervalImpl.bind(this);\n  public readonly atanInterval = this.atanIntervalImpl.bind(this);\n  public readonly atan2Interval = this.atan2IntervalImpl.bind(this);\n  public readonly atanhInterval = this.atanhIntervalImpl.bind(this);\n  public readonly ceilInterval = this.ceilIntervalImpl.bind(this);\n  public readonly clampMedianInterval = this.clampMedianIntervalImpl.bind(this);\n  public readonly clampMinMaxInterval = this.clampMinMaxIntervalImpl.bind(this);\n  public readonly clampIntervals = [this.clampMedianInterval, this.clampMinMaxInterval];\n  public readonly cosInterval = this.cosIntervalImpl.bind(this);\n  public readonly coshInterval = this.coshIntervalImpl.bind(this);\n  public readonly crossInterval = this.crossIntervalImpl.bind(this);\n  public readonly degreesInterval = this.degreesIntervalImpl.bind(this);\n  public readonly determinantInterval = this.determinantIntervalImpl.bind(this);\n  public readonly distanceInterval = this.distanceIntervalImpl.bind(this);\n  public readonly divisionInterval = this.divisionIntervalImpl.bind(this);\n  public readonly dotInterval = this.dotIntervalImpl.bind(this);\n  public readonly expInterval = this.expIntervalImpl.bind(this);\n  public readonly exp2Interval = this.exp2IntervalImpl.bind(this);\n  public readonly faceForwardIntervals = this.faceForwardIntervalsImpl.bind(this);\n  public readonly floorInterval = this.floorIntervalImpl.bind(this);\n  public readonly fmaInterval = this.fmaIntervalImpl.bind(this);\n  public readonly fractInterval = this.fractIntervalImpl.bind(this);\n  public readonly inverseSqrtInterval = this.inverseSqrtIntervalImpl.bind(this);\n  public readonly ldexpInterval = this.ldexpIntervalImpl.bind(this);\n  public readonly lengthInterval = this.lengthIntervalImpl.bind(this);\n  public readonly logInterval = this.logIntervalImpl.bind(this);\n  public readonly log2Interval = this.log2IntervalImpl.bind(this);\n  public readonly maxInterval = this.maxIntervalImpl.bind(this);\n  public readonly minInterval = this.minIntervalImpl.bind(this);\n  public readonly mixImpreciseInterval = this.mixImpreciseIntervalImpl.bind(this);\n  public readonly mixPreciseInterval = this.mixPreciseIntervalImpl.bind(this);\n  public readonly mixIntervals = [this.mixImpreciseInterval, this.mixPreciseInterval];\n  public readonly modfInterval = this.modfIntervalImpl.bind(this);\n  public readonly multiplicationInterval = this.multiplicationIntervalImpl.bind(this);\n  public readonly multiplicationMatrixMatrixInterval = this.multiplicationMatrixMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationMatrixScalarInterval = this.multiplicationMatrixScalarIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationScalarMatrixInterval = this.multiplicationScalarMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationMatrixVectorInterval = this.multiplicationMatrixVectorIntervalImpl.bind(\n    this\n  );\n  public readonly multiplicationVectorMatrixInterval = this.multiplicationVectorMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly negationInterval = this.negationIntervalImpl.bind(this);\n  public readonly normalizeInterval = this.normalizeIntervalImpl.bind(this);\n  public readonly powInterval = this.powIntervalImpl.bind(this);\n  public readonly radiansInterval = this.radiansIntervalImpl.bind(this);\n  public readonly reflectInterval = this.reflectIntervalImpl.bind(this);\n  public readonly refractInterval = this.refractIntervalImpl.bind(this);\n  public readonly remainderInterval = this.remainderIntervalImpl.bind(this);\n  public readonly roundInterval = this.roundIntervalImpl.bind(this);\n  public readonly saturateInterval = this.saturateIntervalImpl.bind(this);\n  public readonly signInterval = this.signIntervalImpl.bind(this);\n  public readonly sinInterval = this.sinIntervalImpl.bind(this);\n  public readonly sinhInterval = this.sinhIntervalImpl.bind(this);\n  public readonly smoothStepInterval = this.smoothStepIntervalImpl.bind(this);\n  public readonly sqrtInterval = this.sqrtIntervalImpl.bind(this);\n  public readonly stepInterval = this.stepIntervalImpl.bind(this);\n  public readonly subtractionInterval = this.subtractionIntervalImpl.bind(this);\n  public readonly subtractionMatrixMatrixInterval = this.subtractionMatrixMatrixIntervalImpl.bind(\n    this\n  );\n  public readonly tanInterval = this.tanIntervalImpl.bind(this);\n  public readonly tanhInterval = this.tanhIntervalImpl.bind(this);\n  public readonly transposeInterval = this.transposeIntervalImpl.bind(this);\n  public readonly truncInterval = this.truncIntervalImpl.bind(this);\n}\n\nexport const FP = {\n  f32: kF32Traits,\n  f16: new F16Traits(),\n  abstract: new FPAbstractTraits(),\n};\n\n/** @returns the floating-point traits for `type` */\nexport function fpTraitsFor(type: ScalarType): FPTraits {\n  switch (type.kind) {\n    case 'abstract-float':\n      return FP.abstract;\n    case 'f32':\n      return FP.f32;\n    case 'f16':\n      return FP.f16;\n    default:\n      unreachable(`unsupported type: ${type}`);\n  }\n}\n\n/** @returns true if the value `value` is representable with `type` */\nexport function isRepresentable(value: number, type: ScalarType) {\n  if (!Number.isFinite(value)) {\n    return false;\n  }\n  if (isFloatType(type)) {\n    const constants = fpTraitsFor(type).constants();\n    return value >= constants.negative.min && value <= constants.positive.max;\n  }\n  assert(false, `isRepresentable() is not yet implemented for type ${type}`);\n}\n"],"mappings":";AAAA;AAAA,GACA,SAASA,MAAM,EAAEC,WAAW,QAAQ,2BAA2B,CAC/D,SAASC,YAAY,QAAQ,+CAA+C;;;;AAI5E,SAASC,KAAK,QAAQ,cAAc;AACpC,SAASC,MAAM,QAAQ,gBAAgB;AACvC;AACEC,aAAa;AACbC,GAAG;AACHC,GAAG;AACHC,WAAW;;;AAGXC,QAAQ;AACRC,QAAQ;AACRC,GAAG;AACE,iBAAiB;AACxB;AACEC,qBAAqB;AACrBC,gBAAgB;AAChBC,mBAAmB;AACnBC,mBAAmB;AACnBC,mBAAmB;AACnBC,cAAc;;AAEdC,uBAAuB;AACvBC,uBAAuB;AACvBC,uBAAuB;AACvBC,WAAW;AACXC,WAAW;AACXC,oBAAoB;AACpBC,oBAAoB;AACpBC,oBAAoB;AACpBC,UAAU;AACVC,SAAS;AACTC,SAAS;AACTC,aAAa;AACbC,aAAa;AACbC,gBAAgB;AAChBC,YAAY;AACP,WAAW;;AAElB;;;AAGKC,wBAAwB;;;;;;AAM7B,yEANKA,wBAAwB,GAAxBA,wBAAwB,CAAxBA,wBAAwB,+BAAxBA,wBAAwB,CAAxBA,wBAAwB,qBAAxBA,wBAAwB,CAAxBA,wBAAwB,wBAAxBA,wBAAwB,KAAxBA,wBAAwB;AAO7B,OAAO,SAASC,eAAe,CAACC,CAAe,EAAEC,KAAa,EAAE;EAC9D,QAAQA,KAAK;IACX,KAAK,UAAU;MACbD,CAAC,CAACE,OAAO,CAACJ,wBAAwB,CAACK,QAAQ,CAAC;MAC5C;IACF,KAAK,KAAK;MACRH,CAAC,CAACE,OAAO,CAACJ,wBAAwB,CAACM,GAAG,CAAC;MACvC;IACF,KAAK,KAAK;MACRJ,CAAC,CAACE,OAAO,CAACJ,wBAAwB,CAACO,GAAG,CAAC;MACvC,MAAM;;AAEZ;;AAEA;AACA,OAAO,SAASC,iBAAiB,CAACN,CAAe,EAAU;EACzD,MAAMO,IAAI,GAAGP,CAAC,CAACQ,MAAM,EAAE;EACvB,QAAQD,IAAI;IACV,KAAKT,wBAAwB,CAACK,QAAQ;MACpC,OAAO,UAAU;IACnB,KAAKL,wBAAwB,CAACM,GAAG;MAC/B,OAAO,KAAK;IACd,KAAKN,wBAAwB,CAACO,GAAG;MAC/B,OAAO,KAAK;IACd;MACEvC,WAAW,CAAE,gCAA+ByC,IAAK,EAAC,CAAC,CAAC;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,OAAO,MAAME,UAAU,CAAC;;;;;EAKtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSC,WAAW,CAACH,IAAY,EAAE,GAAGI,MAAsB,EAAE;IAC1D,IAAI,CAACJ,IAAI,GAAGA,IAAI;;IAEhB,MAAM,CAACK,KAAK,EAAEC,GAAG,CAAC,GAAGF,MAAM,CAACG,MAAM,KAAK,CAAC,GAAGH,MAAM,GAAG,CAACA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IAC1E9C,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACJ,KAAK,CAAC,IAAI,CAACG,MAAM,CAACC,KAAK,CAACH,GAAG,CAAC,EAAG,2BAA0B,CAAC;IAC/EhD,MAAM,CAAC+C,KAAK,IAAIC,GAAG,EAAG,cAAaD,KAAM,+CAA8CC,GAAI,GAAE,CAAC;;IAE9F,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;EAChB;;EAEA;EACOI,MAAM,GAAa;IACxB,OAAOC,EAAE,CAAC,IAAI,CAACX,IAAI,CAAC;EACtB;;EAEA;EACOI,MAAM,GAAmB;IAC9B,OAAO,IAAI,CAACQ,OAAO,EAAE,GAAG,CAAC,IAAI,CAACP,KAAK,CAAC,GAAG,CAAC,IAAI,CAACA,KAAK,EAAE,IAAI,CAACC,GAAG,CAAC;EAC/D;;EAEA;EACOO,QAAQ,CAACC,CAAsB,EAAW;IAC/C,IAAIN,MAAM,CAACC,KAAK,CAACK,CAAC,CAAC,EAAE;MACnB;MACA;MACA;MACA,OAAO,IAAI,CAACT,KAAK,KAAKG,MAAM,CAACO,iBAAiB,IAAI,IAAI,CAACT,GAAG,KAAKE,MAAM,CAACQ,iBAAiB;IACzF;;IAEA,IAAIF,CAAC,YAAYZ,UAAU,EAAE;MAC3B,OAAO,IAAI,CAACG,KAAK,IAAIS,CAAC,CAACT,KAAK,IAAI,IAAI,CAACC,GAAG,IAAIQ,CAAC,CAACR,GAAG;IACnD;IACA,OAAO,IAAI,CAACD,KAAK,IAAIS,CAAC,IAAI,IAAI,CAACR,GAAG,IAAIQ,CAAC;EACzC;;EAEA;AACF;AACA;EACSG,wBAAwB,GAAY;IACzC,OAAO;IACL,IAAI,CAACX,GAAG,GAAG,IAAI,CAACI,MAAM,EAAE,CAACQ,SAAS,EAAE,CAACC,QAAQ,CAACC,SAAS,CAACC,GAAG;IAC3D,IAAI,CAAChB,KAAK,GAAG,IAAI,CAACK,MAAM,EAAE,CAACQ,SAAS,EAAE,CAACI,QAAQ,CAACF,SAAS,CAACG,GAAG,CAC9D;;EACH;;EAEA;EACOX,OAAO,GAAY;IACxB,OAAO,IAAI,CAACP,KAAK,KAAK,IAAI,CAACC,GAAG;EAChC;;EAEA;EACOkB,QAAQ,GAAY;IACzB,OAAO,IAAI,CAACd,MAAM,EAAE,CAACc,QAAQ,CAAC,IAAI,CAACnB,KAAK,CAAC,IAAI,IAAI,CAACK,MAAM,EAAE,CAACc,QAAQ,CAAC,IAAI,CAAClB,GAAG,CAAC;EAC/E;;EAEA;EACOmB,QAAQ,GAAW;IACxB,OAAQ,MAAK,IAAI,CAACzB,IAAK,OAAM,IAAI,CAACI,MAAM,EAAE,CAACsB,GAAG,CAAC,IAAI,CAAChB,MAAM,EAAE,CAACiB,aAAa,CAAE,KAAI;EAClF;AACF;;AAEA;AACA,OAAO,SAASC,mBAAmB,CAACnC,CAAe,EAAEoC,CAAa,EAAE;EAClErC,eAAe,CAACC,CAAC,EAAEoC,CAAC,CAAC7B,IAAI,CAAC;EAC1B,MAAMU,MAAM,GAAGC,EAAE,CAACkB,CAAC,CAAC7B,IAAI,CAAC;EACzBP,CAAC,CAACqC,SAAS,CAACD,CAAC,KAAKnB,MAAM,CAACQ,SAAS,EAAE,CAACa,iBAAiB,EAAE;IACtDC,OAAO,EAAE,MAAM;MACb;MACA,QAAQH,CAAC,CAAC7B,IAAI;QACZ,KAAK,UAAU;UACbP,CAAC,CAACwC,QAAQ,CAACJ,CAAC,CAACxB,KAAK,CAAC;UACnBZ,CAAC,CAACwC,QAAQ,CAACJ,CAAC,CAACvB,GAAG,CAAC;UACjB;QACF,KAAK,KAAK;UACRb,CAAC,CAACyC,QAAQ,CAACL,CAAC,CAACxB,KAAK,CAAC;UACnBZ,CAAC,CAACyC,QAAQ,CAACL,CAAC,CAACvB,GAAG,CAAC;UACjB;QACF,KAAK,KAAK;UACRb,CAAC,CAAC0C,QAAQ,CAACN,CAAC,CAACxB,KAAK,CAAC;UACnBZ,CAAC,CAAC0C,QAAQ,CAACN,CAAC,CAACvB,GAAG,CAAC;UACjB;QACF;UACE/C,WAAW,CAAE,kCAAiCsE,CAAE,EAAC,CAAC;UAClD,MAAM;;IAEZ,CAAC;IACDO,QAAQ,EAAE,MAAM;;MACd;IAAA,CACD,CACH,CAAC,CAAC;AACJ;;AAEA;AACA,OAAO,SAASC,qBAAqB,CAAC5C,CAAe,EAAc;EACjE,MAAMO,IAAI,GAAGD,iBAAiB,CAACN,CAAC,CAAC;EACjC,MAAMiB,MAAM,GAAGC,EAAE,CAACX,IAAI,CAAC;EACvB,OAAOP,CAAC,CAAC6C,QAAQ,CAAC;IAChBN,OAAO,EAAE,MAAM;MACb;MACA,QAAQhC,IAAI;QACV,KAAK,UAAU;UACb,OAAOU,MAAM,CAAC6B,UAAU,CAAC,CAAC9C,CAAC,CAAC+C,OAAO,EAAE,EAAE/C,CAAC,CAAC+C,OAAO,EAAE,CAAC,CAAC;QACtD,KAAK,KAAK;UACR,OAAO9B,MAAM,CAAC6B,UAAU,CAAC,CAAC9C,CAAC,CAACgD,OAAO,EAAE,EAAEhD,CAAC,CAACgD,OAAO,EAAE,CAAC,CAAC;QACtD,KAAK,KAAK;UACR,OAAO/B,MAAM,CAAC6B,UAAU,CAAC,CAAC9C,CAAC,CAACiD,OAAO,EAAE,EAAEjD,CAAC,CAACiD,OAAO,EAAE,CAAC,CAAC,CAAC;;MAEzDnF,WAAW,CAAE,8CAA6CyC,IAAK,EAAC,CAAC;IACnE,CAAC;IACDoC,QAAQ,EAAE,MAAM;MACd;MACA,OAAO1B,MAAM,CAACQ,SAAS,EAAE,CAACa,iBAAiB;IAC7C;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;;AAEA;AACA;AACA;AACA,SAASY,qBAAqB,CAACC,MAAyB,EAAqB;EAC3E,OAAOA,MAAM,CAACC,IAAI,CAAC,CAAAC,CAAC,KAAIA,CAAC,KAAK,CAAC,IAAIjE,oBAAoB,CAACiE,CAAC,CAAC,CAAC,GAAGF,MAAM,CAACG,MAAM,CAAC,CAAC,CAAC,GAAGH,MAAM;AACzF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqVA;AACA,OAAO,MAAeI,QAAQ,CAAC;;EAEnB7C,WAAW,CAAC8C,CAAS,EAAE;IAC/B,IAAI,CAACjD,IAAI,GAAGiD,CAAC;EACf;;;;EAIA;;EAEA;EACOV,UAAU,CAACzB,CAAuC,EAAc;IACrE,IAAIA,CAAC,YAAYZ,UAAU,EAAE;MAC3B,IAAIY,CAAC,CAACd,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;QACxB,OAAOc,CAAC;MACV;;MAEA;MACA,IAAI,CAACA,CAAC,CAACU,QAAQ,EAAE,EAAE;QACjB,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;MAC3C;;MAEA,OAAO,IAAI7B,UAAU,CAAC,IAAI,CAACF,IAAI,EAAE,GAAGc,CAAC,CAACV,MAAM,EAAE,CAAC;IACjD;;IAEA,IAAIU,CAAC,YAAYoC,KAAK,EAAE;MACtB,OAAO,IAAIhD,UAAU,CAAC,IAAI,CAACF,IAAI,EAAE,GAAGc,CAAC,CAAC;IACxC;;IAEA,OAAO,IAAIZ,UAAU,CAAC,IAAI,CAACF,IAAI,EAAEc,CAAC,EAAEA,CAAC,CAAC;EACxC;;EAEA;AACF;AACA;EACSqC,OAAO,CAACrC,CAA0B,EAAmB;IAC1D,OAAO;MACLd,IAAI,EAAE,IAAI,CAACA,IAAI;MACfoD,QAAQ,EAAEtC;IACZ,CAAC;EACH;;EAEA;AACF;AACA;EACSuC,SAAS;EACdC,CAA4C;EACN;IACtC,MAAMC,KAAK,GAAGD,CAAoB;IAClC,IAAIC,KAAK,CAACH,QAAQ,IAAIG,KAAK,CAACvD,IAAI,EAAE;MAChC1C,MAAM,CAACiG,KAAK,CAACvD,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC;MAChC,OAAO,IAAI,CAACuC,UAAU,CAACgB,KAAK,CAACH,QAAQ,CAAC;IACxC;IACA,OAAOE,CAAC;EACV;;EAEA;AACF;AACA;AACA;EACSE,aAAa,CAAC,GAAGC,SAAgC,EAAc;IACpEnG,MAAM,CAACmG,SAAS,CAAClD,MAAM,GAAG,CAAC,EAAG,qDAAoD,CAAC;IACnFjD,MAAM;IACJmG,SAAS,CAACC,KAAK,CAAC,CAAA7B,CAAC,KAAIA,CAAC,CAAC7B,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC;IACzC,uDAAsD,CACxD;;IACD,IAAIK,KAAK,GAAGG,MAAM,CAACQ,iBAAiB;IACpC,IAAIV,GAAG,GAAGE,MAAM,CAACO,iBAAiB;IAClC0C,SAAS,CAACE,OAAO,CAAC,CAAA9B,CAAC,KAAI;MACrBxB,KAAK,GAAGuD,IAAI,CAACvC,GAAG,CAACQ,CAAC,CAACxB,KAAK,EAAEA,KAAK,CAAC;MAChCC,GAAG,GAAGsD,IAAI,CAACrC,GAAG,CAACM,CAAC,CAACvB,GAAG,EAAEA,GAAG,CAAC;IAC5B,CAAC,CAAC;IACF,OAAO,IAAI,CAACiC,UAAU,CAAC,CAAClC,KAAK,EAAEC,GAAG,CAAC,CAAC;EACtC;;EAEA;EACOuD,QAAQ,CAACf,CAAsD,EAAiB;IACrF,IAAIA,CAAC,CAACY,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,YAAY5D,UAAU,IAAI4D,CAAC,CAAC9D,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC,EAAE;MACjE,OAAO8C,CAAC,CAACvC,MAAM,KAAK,CAAC,IAAIuC,CAAC,CAACvC,MAAM,KAAK,CAAC,IAAIuC,CAAC,CAACvC,MAAM,KAAK,CAAC;IAC3D;IACA,OAAO,KAAK;EACd;;EAEA;EACOvC,QAAQ,CAAC8E,CAAsD,EAAY;IAChF,IAAI,IAAI,CAACe,QAAQ,CAACf,CAAC,CAAC,IAAIA,CAAC,CAACY,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,CAAC9D,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC,EAAE;MAC1D,OAAO8C,CAAC;IACV;;IAEA,MAAMiB,CAAC,GAAGjB,CAAC,CAACpB,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAACvB,UAAU,CAACuB,CAAC,CAAC,CAAC;IACxC;IACA;IACA,IAAI,IAAI,CAACD,QAAQ,CAACE,CAAC,CAAC,EAAE;MACpB,OAAOA,CAAC;IACV;IACAxG,WAAW,CAAE,mBAAkBuF,CAAE,eAAc,CAAC;EAClD;;EAEA;AACF;AACA;AACA;EACSkB,WAAW,CAAC,GAAGC,OAAmB,EAAY;IACnD3G,MAAM;IACJ2G,OAAO,CAACP,KAAK,CAAC,CAAAI,CAAC,KAAI,IAAI,CAACD,QAAQ,CAACC,CAAC,CAAC,CAAC;IACpC,0EAA0E,CAC3E;;;IAED,MAAMI,aAAa,GAAGD,OAAO,CAAC,CAAC,CAAC,CAAC1D,MAAM;IACvCjD,MAAM;IACJ2G,OAAO,CAACP,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,CAACvD,MAAM,KAAK2D,aAAa,CAAC;IAC7C,6DAA4D,CAC9D;;;IAED,MAAMC,MAAoB,GAAG,IAAIjB,KAAK,CAAagB,aAAa,CAAC;;IAEjE,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,aAAa,EAAErC,CAAC,EAAE,EAAE;MACtCsC,MAAM,CAACtC,CAAC,CAAC,GAAG,IAAI,CAAC2B,aAAa,CAAC,GAAGS,OAAO,CAACvC,GAAG,CAAC,CAAAoB,CAAC,KAAIA,CAAC,CAACjB,CAAC,CAAC,CAAC,CAAC;IAC3D;IACA,OAAO,IAAI,CAAC7D,QAAQ,CAACmG,MAAM,CAAC;EAC9B;;EAEA;EACOC,QAAQ,CAACC,CAA6D,EAAiB;IAC5F,IAAI,CAACA,CAAC,CAACX,KAAK,CAAC,CAAAY,CAAC,KAAIA,CAAC,CAACZ,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,YAAY5D,UAAU,IAAI4D,CAAC,CAAC9D,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC,CAAC,EAAE;MAChF,OAAO,KAAK;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACAqE,CAAC,GAAGA,CAA6B;;IAEjC,IAAIA,CAAC,CAAC9D,MAAM,GAAG,CAAC,IAAI8D,CAAC,CAAC9D,MAAM,GAAG,CAAC,EAAE;MAChC,OAAO,KAAK;IACd;;IAEA,MAAMgE,QAAQ,GAAGF,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM;IAC5B,IAAIgE,QAAQ,GAAG,CAAC,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAChC,OAAO,KAAK;IACd;;IAEA,OAAOF,CAAC,CAACX,KAAK,CAAC,CAAAY,CAAC,KAAIA,CAAC,CAAC/D,MAAM,KAAKgE,QAAQ,CAAC;EAC5C;;EAEA;EACOxG,QAAQ,CAACsG,CAA6D,EAAY;IACvF;IACE,IAAI,CAACD,QAAQ,CAACC,CAAC,CAAC;IAChB/E,YAAY,CAAC+E,CAAC,EAAE,CAACP,CAAa,KAAK;MACjC,OAAOA,CAAC,CAAC9D,IAAI,KAAK,IAAI,CAACA,IAAI;IAC7B,CAAC,CAAC;IACF;MACA,OAAOqE,CAAC;IACV;;IAEA,MAAMF,MAAM,GAAGnF,UAAU,CAACqF,CAAC,EAAE,IAAI,CAAC9B,UAAU,CAACiC,IAAI,CAAC,IAAI,CAAC,CAAC;;IAExD;IACA;IACA,IAAI,IAAI,CAACJ,QAAQ,CAACD,MAAM,CAAC,EAAE;MACzB,OAAOA,MAAM;IACf;IACA5G,WAAW,CAAE,kBAAiB8G,CAAE,cAAa,CAAC;EAChD;;EAEA;AACF;AACA;AACA;EACSI,YAAY,CAAC,GAAGC,QAAoB,EAAY;IACrD;IACA;IACA;IACA,MAAMC,EAAE,GAAGD,QAAiC;IAC5C,MAAME,QAAQ,GAAGD,EAAE,CAAC,CAAC,CAAC,CAACpE,MAAM;IAC7B,MAAMgE,QAAQ,GAAGI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACpE,MAAM;IAChCjD,MAAM;IACJqH,EAAE,CAACjB,KAAK,CAAC,CAAAW,CAAC,KAAIA,CAAC,CAAC9D,MAAM,KAAKqE,QAAQ,IAAIP,CAAC,CAACX,KAAK,CAAC,CAAAmB,CAAC,KAAIA,CAAC,CAACtE,MAAM,KAAKgE,QAAQ,CAAC,CAAC;IAC1E,iEAAgE,CAClE;;;IAED,MAAMJ,MAAsB,GAAG,CAAC,GAAGjB,KAAK,CAAC0B,QAAQ,CAAC,CAAC,CAAClD,GAAG,CAAC,CAAAoD,CAAC,KAAI,CAAC,GAAG5B,KAAK,CAACqB,QAAQ,CAAC,CAAC,CAAC;IAClF,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,QAAQ,EAAE/C,CAAC,EAAE,EAAE;MACjC,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,QAAQ,EAAEQ,CAAC,EAAE,EAAE;QACjCZ,MAAM,CAACtC,CAAC,CAAC,CAACkD,CAAC,CAAC,GAAG,IAAI,CAACvB,aAAa,CAAC,GAAGmB,EAAE,CAACjD,GAAG,CAAC,CAAA2C,CAAC,KAAIA,CAAC,CAACxC,CAAC,CAAC,CAACkD,CAAC,CAAC,CAAC,CAAC;MAC5D;IACF;;IAEA,OAAO,IAAI,CAAChH,QAAQ,CAACoG,MAAM,CAAC;EAC9B;;EAEA;EACOa,kBAAkB,CAACpC,MAAyB,EAAqB;IACtE,MAAMqC,UAAU,GAAGrC,MAAM,CAACsC,MAAM,CAAC,IAAI,CAACC,WAAW,CAAC;IAClD,MAAMC,UAAU,GAAGH,UAAU,CAAC1E,MAAM,GAAG,CAAC,IAAI0E,UAAU,CAACvB,KAAK,CAAC,CAAAjE,CAAC,KAAIA,CAAC,KAAK,CAAC,CAAC;IAC1E,OAAO2F,UAAU,GAAGxC,MAAM,CAACG,MAAM,CAAC,CAAC,CAAC,GAAGH,MAAM;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYyC,2BAA2B;EACnCC,MAAkB;EAClBC,IAAsB;EACJ;IAClB,OAAO,CAACzE,CAAS,KAAiB;MAChC,OAAOwE,MAAM,CAACzE,QAAQ,CAACC,CAAC,CAAC,GAAGyE,IAAI,CAACzE,CAAC,CAAC,GAAG,IAAI,CAACI,SAAS,EAAE,CAACa,iBAAiB;IAC1E,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYyD,+BAA+B;EACvCF,MAAkC;EAClCC,IAA0B;EACJ;IACtB,OAAO,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC3C,IAAI,CAACJ,MAAM,CAACG,CAAC,CAAC5C,IAAI,CAAC,CAAA8C,CAAC,KAAIA,CAAC,CAAC9E,QAAQ,CAAC4E,CAAC,CAAC,CAAC,IAAI,CAACH,MAAM,CAACI,CAAC,CAAC7C,IAAI,CAAC,CAAA8C,CAAC,KAAIA,CAAC,CAAC9E,QAAQ,CAAC6E,CAAC,CAAC,CAAC,EAAE;QAC5E,OAAO,IAAI,CAACxE,SAAS,EAAE,CAACa,iBAAiB;MAC3C;;MAEA,OAAOwD,IAAI,CAACE,CAAC,EAAEC,CAAC,CAAC;IACnB,CAAC;EACH;;EAEA;EACUE,6BAA6B,CAACC,IAAY,EAAEC,EAAuB,EAAc;IACzFvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU+F,iCAAiC;EACzCF,IAAY;EACZC,EAAuB;EACvBE,EAAuB;EACX;IACZzI,WAAW,CAAE,IAAGsI,IAAK,6BAA4B,IAAI,CAAC7F,IAAK,GAAE,CAAC;EAChE;;EAEA;EACUiG,mCAAmC;EAC3CJ,IAAY;EACZC,EAAuB;EACvBE,EAAuB;EACvBE,EAAuB;EACX;IACZ3I,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUmG,2BAA2B,CAACN,IAAY,EAAEC,EAAuB,EAAY;IACrFvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUoG,6BAA6B,CAACP,IAAY,EAAEC,EAA2B,EAAc;IAC7FvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUqG,iCAAiC;EACzCR,IAAY;EACZC,EAAoC;EACpCE,EAAoC;EACxB;IACZzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUsG,2BAA2B;EACnCT,IAAY;EACZC,EAAoC;EAC1B;IACVvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUuG,+BAA+B;EACvCV,IAAY;EACZC,EAAoC;EACpCE,EAAoC;EAC1B;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUwG,iCAAiC;EACzCX,IAAY;EACZC,EAAoC;EACpCE,EAAuB;EACb;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUyG,iCAAiC;EACzCZ,IAAY;EACZC,EAAuB;EACvBE,EAA2B;EACjB;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU0G,6BAA6B,CAACb,IAAY,EAAEC,EAAmB,EAAc;IACrFvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU2G,2BAA2B,CAACd,IAAY,EAAEC,EAAmB,EAAY;IACjFvI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU4G,+BAA+B;EACvCf,IAAY;EACZC,EAAmB;EACnBE,EAAmB;EACT;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU6G,iCAAiC;EACzChB,IAAY;EACZC,EAAmB;EACnBE,EAAuB;EACb;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU8G,iCAAiC;EACzCjB,IAAY;EACZC,EAAuB;EACvBE,EAAmB;EACT;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACU+G,iCAAiC;EACzClB,IAAY;EACZC,EAAmB;EACnBE,EAAoC;EAC1B;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUgH,iCAAiC;EACzCnB,IAAY;EACZC,EAAoC;EACpCE,EAAmB;EACT;IACVzI,WAAW,CAAE,IAAGsI,IAAK,iCAAgC,IAAI,CAAC7F,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUiH,qBAAqB;EAC7BnB,EAA8B;EAC9BE,EAA8B;EAClB;IACZzI,WAAW,CAAE,0CAAyC,IAAI,CAACyC,IAAK,GAAE,CAAC;EACrE;;EAEA;EACUkH,wBAAwB;EAChCpB,EAAqB;EACrBE,EAAqB;EACrBE,EAAqB;EACK;IAC1B3I,WAAW,CAAE,6CAA4C,IAAI,CAACyC,IAAK,GAAE,CAAC;EACxE;;EAEA;EACUmH,mBAAmB;EAC3BrB,EAAsD;EAC1C;IACZvI,WAAW,CAAE,wCAAuC,IAAI,CAACyC,IAAK,GAAE,CAAC;EACnE;;EAEA;EACUoH,iBAAiB,CAACtB,EAAU,EAA4C;IAChFvI,WAAW,CAAE,sCAAqC,IAAI,CAACyC,IAAK,GAAE,CAAC;EACjE;;EAEA;EACUqH,oBAAoB;EAC5BC,EAAqB;EACrBC,EAAqB;EACrBC,EAAU;EACA;IACVjK,WAAW,CAAE,yCAAwC,IAAI,CAACyC,IAAK,GAAE,CAAC;EACpE;;EAEA;EACUyH,8BAA8B,CAACC,EAAU,EAAEC,YAAoB,EAAc;IACrF,OAAO,IAAI,CAACzG,SAAS,EAAE,CAACa,iBAAiB;EAC3C;;EAEA;EACU6F,oBAAoB,CAACF,EAAU,EAAEG,OAAe,EAAc;IACtE,OAAO,IAAI,CAAC3G,SAAS,EAAE,CAACa,iBAAiB;EAC3C;;EAEA;EACA;AACF;AACA;AACA;;;;;;;;;;;;;;;EAeE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACU+F,wBAAwB;EAC9BvE,KAAa;EACb2B,MAAsB;EACtB,GAAG6C,GAAuB;EACR;IAClBxE,KAAK,GAAG,IAAI,CAACyE,QAAQ,CAACzE,KAAK,CAAC;;IAE5B,MAAME,SAAS,GAAGsE,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACxC,IAAI2B,MAAM,KAAK,QAAQ,IAAIzB,SAAS,CAACZ,IAAI,CAAC,CAAAhB,CAAC,KAAI,CAACA,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE;MAC7D,OAAO0G,SAAS;IAClB;IACA,OAAO,EAAEC,KAAK,EAAE,CAAC,IAAI,CAACxG,aAAa,CAAC4B,KAAK,CAAC,CAAC,EAAE6E,QAAQ,EAAE3K,KAAK,CAAC,GAAGgG,SAAS,CAAC,CAAC,CAAC;EAC9E;;EAEA;AACF;AACA;AACA;AACA;AACA;EACS4E,6BAA6B;EAClCC,MAAyB;EACzBpD,MAAsB;EACtB,GAAG6C,GAAuB;EAClB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAACwD,wBAAwB,CAAChE,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MAC1D,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACUwF,4BAA4B;EAClCC,MAAc;EACdC,MAAc;EACd1D,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClBY,MAAM,GAAG,IAAI,CAACX,QAAQ,CAACW,MAAM,CAAC;IAC9BC,MAAM,GAAG,IAAI,CAACZ,QAAQ,CAACY,MAAM,CAAC;;IAE9B,MAAMnF,SAAS,GAAGsE,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACU,MAAM,EAAEC,MAAM,CAAC,CAAC;IACjD,IAAI1D,MAAM,KAAK,QAAQ,IAAIzB,SAAS,CAACZ,IAAI,CAAC,CAAAhB,CAAC,KAAI,CAACA,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE;MAC7D,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAAC,IAAI,CAACxG,aAAa,CAACgH,MAAM,CAAC,EAAE,IAAI,CAAChH,aAAa,CAACiH,MAAM,CAAC,CAAC;MAC/DR,QAAQ,EAAE3K,KAAK,CAAC,GAAGgG,SAAS;IAC9B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACSoF,iCAAiC;EACtCC,OAA0B;EAC1BC,OAA0B;EAC1B7D,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR,OAAO5J,gBAAgB,CAAC2K,OAAO,EAAEC,OAAO,CAAC,CAACR,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MAC7D,MAAMQ,CAAC,GAAG,IAAI,CAACoE,4BAA4B,CAAC5E,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACvE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACS8F,8BAA8B;EACnCL,MAAc;EACdC,MAAc;EACdK,MAAc;EACd/D,MAAsB;EACtB,GAAG6C,GAA6B;EACd;IAClBY,MAAM,GAAG,IAAI,CAACX,QAAQ,CAACW,MAAM,CAAC;IAC9BC,MAAM,GAAG,IAAI,CAACZ,QAAQ,CAACY,MAAM,CAAC;IAC9BK,MAAM,GAAG,IAAI,CAACjB,QAAQ,CAACiB,MAAM,CAAC;;IAE9B,MAAMxF,SAAS,GAAGsE,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACU,MAAM,EAAEC,MAAM,EAAEK,MAAM,CAAC,CAAC;IACzD,IAAI/D,MAAM,KAAK,QAAQ,IAAIzB,SAAS,CAACZ,IAAI,CAAC,CAAAhB,CAAC,KAAI,CAACA,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE;MAC7D,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAAC,IAAI,CAACxG,aAAa,CAACgH,MAAM,CAAC,EAAE,IAAI,CAAChH,aAAa,CAACiH,MAAM,CAAC,EAAE,IAAI,CAACjH,aAAa,CAACsH,MAAM,CAAC,CAAC;MAC3Fb,QAAQ,EAAE3K,KAAK,CAAC,GAAGgG,SAAS;IAC9B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSyF,mCAAmC;EACxCJ,OAA0B;EAC1BC,OAA0B;EAC1BI,OAA0B;EAC1BjE,MAAsB;EACtB,GAAG6C,GAA6B;EACxB;IACR,OAAO5J,gBAAgB,CAAC2K,OAAO,EAAEC,OAAO,EAAEI,OAAO,CAAC,CAACZ,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACtE,MAAMQ,CAAC,GAAG,IAAI,CAAC0E,8BAA8B,CAAClF,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MAC/E,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACUkG,wBAAwB;EAC9B7F,KAAwB;EACxB2B,MAAsB;EACtB,GAAG6C,GAAuB;EACR;IAClBxE,KAAK,GAAGA,KAAK,CAAC7B,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;;IAEhC,MAAMvE,SAAS,GAAGsE,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACxC,IAAI2B,MAAM,KAAK,QAAQ,IAAIzB,SAAS,CAACZ,IAAI,CAAC,CAAAhB,CAAC,KAAI,CAACA,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE;MAC7D,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAACuF,KAAK,EAAE,IAAI,CAAC5B,aAAa,CAAC,CAAC;MAC5CyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGgG,SAAS;IAC9B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACS4F,6BAA6B;EAClCf,MAA4B;EAC5BpD,MAAsB;EACtB,GAAG6C,GAAuB;EAClB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAAC8E,wBAAwB,CAACtF,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MAC1D,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACUoG,4BAA4B;EAClCX,MAAyB;EACzBC,MAAyB;EACzB1D,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClBY,MAAM,GAAGA,MAAM,CAACjH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClCY,MAAM,GAAGA,MAAM,CAAClH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;;IAElC,MAAMvE,SAAS,GAAGsE,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACU,MAAM,EAAEC,MAAM,CAAC,CAAC;IACjD,IAAI1D,MAAM,KAAK,QAAQ,IAAIzB,SAAS,CAACZ,IAAI,CAAC,CAAAhB,CAAC,KAAI,CAACA,CAAC,CAACL,QAAQ,EAAE,CAAC,EAAE;MAC7D,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAAC2K,MAAM,EAAE,IAAI,CAAChH,aAAa,CAAC,EAAE3D,QAAQ,CAAC4K,MAAM,EAAE,IAAI,CAACjH,aAAa,CAAC,CAAC;MACnFyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGgG,SAAS;IAC9B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACS8F,iCAAiC;EACtCT,OAA6B;EAC7BC,OAA6B;EAC7B7D,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR,OAAO5J,gBAAgB,CAAC2K,OAAO,EAAEC,OAAO,CAAC,CAACR,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MAC7D,MAAMQ,CAAC,GAAG,IAAI,CAACgF,4BAA4B,CAACxF,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACvE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACUsG,sBAAsB;EAC5BjG,KAAwB;EACxB2B,MAAsB;EACtB,GAAG6C,GAAqB;EACN;IAClBxE,KAAK,GAAGA,KAAK,CAAC7B,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;;IAEhC,MAAM/D,OAAO,GAAG8D,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACtC,IAAI2B,MAAM,KAAK,QAAQ,IAAIjB,OAAO,CAACpB,IAAI,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACD,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAACuF,KAAK,EAAE,IAAI,CAAC5B,aAAa,CAAC,CAAC;MAC5CyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGwG,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACSwF,2BAA2B;EAChCnB,MAA4B;EAC5BpD,MAAsB;EACtB,GAAG6C,GAAqB;EAChB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAACkF,sBAAsB,CAAC1F,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACxD,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACUwG,4BAA4B;EAClCC,MAAc;EACdC,MAAyB;EACzB1E,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClB4B,MAAM,GAAG,IAAI,CAAC3B,QAAQ,CAAC2B,MAAM,CAAC;IAC9BC,MAAM,GAAGA,MAAM,CAAClI,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;;IAElC,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC0B,MAAM,EAAEC,MAAM,CAAC,CAAC;IAC/C,IAAI1E,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAgC,CAAC,KAAIA,CAAC,CAAChC,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAAC,IAAI,CAACxG,aAAa,CAACgI,MAAM,CAAC,EAAE3L,QAAQ,CAAC4L,MAAM,EAAE,IAAI,CAACjI,aAAa,CAAC,CAAC;MACzEyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACSC,iCAAiC;EACtCC,OAA0B;EAC1B9F,OAA6B;EAC7BiB,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxBuB,OAAO,CAACpG,OAAO,CAAC,CAAAgG,MAAM,KAAI;MACxB1F,OAAO,CAACN,OAAO,CAAC,CAAAiG,MAAM,KAAI;QACxB,MAAMtF,CAAC,GAAG,IAAI,CAACoF,4BAA4B,CAACC,MAAM,EAAEC,MAAM,EAAE1E,MAAM,EAAE,GAAG6C,GAAG,CAAC;QAC3E,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACUwB,4BAA4B;EAClCJ,MAAyB;EACzBD,MAAc;EACdzE,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClB6B,MAAM,GAAGA,MAAM,CAAClI,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClC2B,MAAM,GAAG,IAAI,CAAC3B,QAAQ,CAAC2B,MAAM,CAAC;;IAE9B,MAAME,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC2B,MAAM,EAAED,MAAM,CAAC,CAAC;IAC/C,IAAIzE,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAgC,CAAC,KAAIA,CAAC,CAAChC,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAAC4L,MAAM,EAAE,IAAI,CAACjI,aAAa,CAAC,EAAE,IAAI,CAACA,aAAa,CAACgI,MAAM,CAAC,CAAC;MACzEvB,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACSI,iCAAiC;EACtChG,OAA6B;EAC7B8F,OAA0B;EAC1B7E,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxBvE,OAAO,CAACN,OAAO,CAAC,CAAAiG,MAAM,KAAI;MACxBG,OAAO,CAACpG,OAAO,CAAC,CAAAgG,MAAM,KAAI;QACxB,MAAMrF,CAAC,GAAG,IAAI,CAAC0F,4BAA4B,CAACJ,MAAM,EAAED,MAAM,EAAEzE,MAAM,EAAE,GAAG6C,GAAG,CAAC;QAC3E,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACU0B,0BAA0B;EAChCvB,MAAyB;EACzBC,MAAyB;EACzB1D,MAAsB;EACtB,GAAG6C,GAAyB;EACV;IAClBY,MAAM,GAAGA,MAAM,CAACjH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClCY,MAAM,GAAGA,MAAM,CAAClH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClC,MAAM/D,OAAO,GAAG8D,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACU,MAAM,EAAEC,MAAM,CAAC,CAAC;IAC/C,IAAI1D,MAAM,KAAK,QAAQ,IAAIjB,OAAO,CAACpB,IAAI,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACD,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAAC2K,MAAM,EAAE,IAAI,CAAChH,aAAa,CAAC,EAAE3D,QAAQ,CAAC4K,MAAM,EAAE,IAAI,CAACjH,aAAa,CAAC,CAAC;MACnFyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGwG,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSkG,+BAA+B;EACpCrB,OAA6B;EAC7BC,OAA6B;EAC7B7D,MAAsB;EACtB,GAAG6C,GAAyB;EACpB;IACR,OAAO5J,gBAAgB,CAAC2K,OAAO,EAAEC,OAAO,CAAC,CAACR,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MAC7D,MAAMQ,CAAC,GAAG,IAAI,CAAC4F,0BAA0B,CAACpG,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACrE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUkH,6CAA6C;EACnDzB,MAAyB;EACzBC,MAAyB;EACzBK,MAAc;EACd/D,MAAsB;EACtB,GAAGmF,gBAA0C;EAC3B;IAClB;IACA,MAAMC,KAAK,GAAG3B,MAAM,CAACpI,MAAM;IAC3BjD,MAAM,CAAC,CAAC,IAAIgN,KAAK,IAAIA,KAAK,IAAI,CAAC,EAAE,yCAAyC,CAAC;IAC3EhN,MAAM,CAACsL,MAAM,CAACrI,MAAM,KAAK+J,KAAK,EAAE,4CAA4C,CAAC;IAC7E3B,MAAM,GAAGA,MAAM,CAACjH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClCY,MAAM,GAAGA,MAAM,CAAClH,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAClCiB,MAAM,GAAG,IAAI,CAACjB,QAAQ,CAACiB,MAAM,CAAC;;IAE9B;IACA,MAAMY,OAAO,GAAGQ,gBAAgB,CAAC3I,GAAG,CAAC,CAAAuG,CAAC,KAAI;MACxC,OAAOU,MAAM,CAACjH,GAAG,CAAC,CAAC6I,GAAG,EAAEC,KAAK,KAAKvC,CAAC,CAACsC,GAAG,EAAE3B,MAAM,CAAC4B,KAAK,CAAC,EAAEvB,MAAM,CAAC,CAAC;IAClE,CAAC,CAAC;IACF,IAAI/D,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAgC,CAAC,KAAIA,CAAC,CAAChC,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE;MACLnK,QAAQ,CAAC2K,MAAM,EAAE,IAAI,CAAChH,aAAa,CAAC;MACpC3D,QAAQ,CAAC4K,MAAM,EAAE,IAAI,CAACjH,aAAa,CAAC;MACpC,IAAI,CAACA,aAAa,CAACsH,MAAM,CAAC,CAC3B;;MACDb,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSY,iDAAiD;EACtD3B,OAA6B;EAC7BC,OAA6B;EAC7BI,OAA0B;EAC1BjE,MAAsB;EACtB,GAAGmF,gBAA0C;EACrC;IACR;IACA,MAAM7B,KAAa,GAAG,EAAE;IACxBM,OAAO,CAACnF,OAAO,CAAC,CAAAgF,MAAM,KAAI;MACxBI,OAAO,CAACpF,OAAO,CAAC,CAAAiF,MAAM,KAAI;QACxBO,OAAO,CAACxF,OAAO,CAAC,CAAAsF,MAAM,KAAI;UACxB,MAAM3E,CAAC,GAAG,IAAI,CAAC8F,6CAA6C;UAC1DzB,MAAM;UACNC,MAAM;UACNK,MAAM;UACN/D,MAAM;UACN,GAAGmF,gBAAgB,CACpB;;UACD,IAAI/F,CAAC,KAAK4D,SAAS,EAAE;YACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;UACf;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;EACUkC,sBAAsB;EAC5BnH,KAA2B;EAC3B2B,MAAsB;EACtB,GAAG6C,GAAqB;EACN;IAClBxE,KAAK,GAAGvE,UAAU,CAACuE,KAAK,EAAE,IAAI,CAACyE,QAAQ,CAAC;;IAExC,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACtC,IAAI2B,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,EAAE;MAC3D,OAAO0G,SAAS;IAClB;;IAEA,OAAO;MACLC,KAAK,EAAE,CAACpK,QAAQ,CAACwF,KAAK,EAAE,IAAI,CAAC5B,aAAa,CAAC,CAAC;MAC5CyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACSc,2BAA2B;EAChCrC,MAAiC;EACjCpD,MAAsB;EACtB,GAAG6C,GAAqB;EAChB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAACoG,sBAAsB,CAAC5G,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACxD,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACU0H,sBAAsB;EAC5BrH,KAA2B;EAC3B2B,MAAsB;EACtB,GAAG6C,GAAqB;EACN;IAClBxE,KAAK,GAAGvE,UAAU,CAACuE,KAAK,EAAE,IAAI,CAACyE,QAAQ,CAAC;;IAExC,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACtC,IAAI2B,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAwB,CAAC,KAAIA,CAAC,CAACxB,IAAI,CAAC,CAAAyB,CAAC,KAAIA,CAAC,CAACzB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;MACrF,OAAO0G,SAAS;IAClB;;IAEA,OAAO;MACLC,KAAK,EAAE,CAACpK,QAAQ,CAACwF,KAAK,EAAE,IAAI,CAAC5B,aAAa,CAAC,CAAC;MAC5CyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACSgB,2BAA2B;EAChCvC,MAAiC;EACjCpD,MAAsB;EACtB,GAAG6C,GAAqB;EAChB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAACsG,sBAAsB,CAAC9G,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACxD,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACU4H,0BAA0B;EAChCnC,MAA4B;EAC5BC,MAA4B;EAC5B1D,MAAsB;EACtB,GAAG6C,GAAyB;EACV;IAClBY,MAAM,GAAG3J,UAAU,CAAC2J,MAAM,EAAE,IAAI,CAACX,QAAQ,CAAC;IAC1CY,MAAM,GAAG5J,UAAU,CAAC4J,MAAM,EAAE,IAAI,CAACZ,QAAQ,CAAC;;IAE1C,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACU,MAAM,EAAEC,MAAM,CAAC,CAAC;IAC/C,IAAI1D,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAwB,CAAC,KAAIA,CAAC,CAACxB,IAAI,CAAC,CAAAyB,CAAC,KAAIA,CAAC,CAACzB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;MACrF,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACpK,QAAQ,CAAC4K,MAAM,EAAE,IAAI,CAAChH,aAAa,CAAC,EAAE5D,QAAQ,CAAC6K,MAAM,EAAE,IAAI,CAACjH,aAAa,CAAC,CAAC;MACnFyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSkB,+BAA+B;EACpCjC,OAAkC;EAClCC,OAAkC;EAClC7D,MAAsB;EACtB,GAAG6C,GAAyB;EACpB;IACR,OAAO5J,gBAAgB,CAAC2K,OAAO,EAAEC,OAAO,CAAC,CAACR,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MAC7D,MAAMQ,CAAC,GAAG,IAAI,CAACwG,0BAA0B,CAAChH,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACrE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACU8H,4BAA4B;EAClCC,GAAyB;EACzBtB,MAAc;EACdzE,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClBkD,GAAG,GAAGjM,UAAU,CAACiM,GAAG,EAAE,IAAI,CAACjD,QAAQ,CAAC;IACpC2B,MAAM,GAAG,IAAI,CAAC3B,QAAQ,CAAC2B,MAAM,CAAC;;IAE9B,MAAME,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACgD,GAAG,EAAEtB,MAAM,CAAC,CAAC;IAC5C,IAAIzE,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAwB,CAAC,KAAIA,CAAC,CAACxB,IAAI,CAAC,CAAAyB,CAAC,KAAIA,CAAC,CAACzB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;MACrF,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACpK,QAAQ,CAACkN,GAAG,EAAE,IAAI,CAACtJ,aAAa,CAAC,EAAE,IAAI,CAACA,aAAa,CAACgI,MAAM,CAAC,CAAC;MACtEvB,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSqB,iCAAiC;EACtCC,IAA+B;EAC/BpB,OAA0B;EAC1B7E,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxB2C,IAAI,CAACxH,OAAO,CAAC,CAAAsH,GAAG,KAAI;MAClBlB,OAAO,CAACpG,OAAO,CAAC,CAAAgG,MAAM,KAAI;QACxB,MAAMrF,CAAC,GAAG,IAAI,CAAC0G,4BAA4B,CAACC,GAAG,EAAEtB,MAAM,EAAEzE,MAAM,EAAE,GAAG6C,GAAG,CAAC;QACxE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACU4C,4BAA4B;EAClCzB,MAAc;EACdsB,GAAyB;EACzB/F,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClB4B,MAAM,GAAG,IAAI,CAAC3B,QAAQ,CAAC2B,MAAM,CAAC;IAC9BsB,GAAG,GAAGjM,UAAU,CAACiM,GAAG,EAAE,IAAI,CAACjD,QAAQ,CAAC;;IAEpC,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC0B,MAAM,EAAEsB,GAAG,CAAC,CAAC;IAC5C,IAAI/F,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAwB,CAAC,KAAIA,CAAC,CAACxB,IAAI,CAAC,CAAAyB,CAAC,KAAIA,CAAC,CAACzB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;MACrF,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAAC,IAAI,CAACxG,aAAa,CAACgI,MAAM,CAAC,EAAE5L,QAAQ,CAACkN,GAAG,EAAE,IAAI,CAACtJ,aAAa,CAAC,CAAC;MACtEyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSwB,iCAAiC;EACtCtB,OAA0B;EAC1BoB,IAA+B;EAC/BjG,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxB2C,IAAI,CAACxH,OAAO,CAAC,CAAAsH,GAAG,KAAI;MAClBlB,OAAO,CAACpG,OAAO,CAAC,CAAAgG,MAAM,KAAI;QACxB,MAAMrF,CAAC,GAAG,IAAI,CAAC8G,4BAA4B,CAACzB,MAAM,EAAEsB,GAAG,EAAE/F,MAAM,EAAE,GAAG6C,GAAG,CAAC;QACxE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACU8C,4BAA4B;EAClCL,GAAyB;EACzBM,GAAsB;EACtBrG,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClBkD,GAAG,GAAGjM,UAAU,CAACiM,GAAG,EAAE,IAAI,CAACjD,QAAQ,CAAC;IACpCuD,GAAG,GAAGA,GAAG,CAAC7J,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;;IAE5B,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACgD,GAAG,EAAEM,GAAG,CAAC,CAAC;IACzC,IAAIrG,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACD,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACpK,QAAQ,CAACkN,GAAG,EAAE,IAAI,CAACtJ,aAAa,CAAC,EAAE3D,QAAQ,CAACuN,GAAG,EAAE,IAAI,CAAC5J,aAAa,CAAC,CAAC;MAC7EyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACS2B,iCAAiC;EACtCL,IAA+B;EAC/BM,IAA0B;EAC1BvG,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxB2C,IAAI,CAACxH,OAAO,CAAC,CAAAsH,GAAG,KAAI;MAClBQ,IAAI,CAAC9H,OAAO,CAAC,CAAA4H,GAAG,KAAI;QAClB,MAAMjH,CAAC,GAAG,IAAI,CAACgH,4BAA4B,CAACL,GAAG,EAAEM,GAAG,EAAErG,MAAM,EAAE,GAAG6C,GAAG,CAAC;QACrE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACUkD,4BAA4B;EAClCH,GAAsB;EACtBN,GAAyB;EACzB/F,MAAsB;EACtB,GAAG6C,GAA2B;EACZ;IAClBwD,GAAG,GAAGA,GAAG,CAAC7J,GAAG,CAAC,IAAI,CAACsG,QAAQ,CAAC;IAC5BiD,GAAG,GAAGjM,UAAU,CAACiM,GAAG,EAAE,IAAI,CAACjD,QAAQ,CAAC;;IAEpC,MAAM6B,OAAO,GAAG9B,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAACsD,GAAG,EAAEN,GAAG,CAAC,CAAC;IACzC,IAAI/F,MAAM,KAAK,QAAQ,IAAI2E,OAAO,CAAChH,IAAI,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACD,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACxE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAE,CAACnK,QAAQ,CAACuN,GAAG,EAAE,IAAI,CAAC5J,aAAa,CAAC,EAAE5D,QAAQ,CAACkN,GAAG,EAAE,IAAI,CAACtJ,aAAa,CAAC,CAAC;MAC7EyG,QAAQ,EAAE3K,KAAK,CAAC,GAAGoM,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACS8B,iCAAiC;EACtCF,IAA0B;EAC1BN,IAA+B;EAC/BjG,MAAsB;EACtB,GAAG6C,GAA2B;EACtB;IACR;IACA,MAAMS,KAAa,GAAG,EAAE;IACxBiD,IAAI,CAAC9H,OAAO,CAAC,CAAA4H,GAAG,KAAI;MAClBJ,IAAI,CAACxH,OAAO,CAAC,CAAAsH,GAAG,KAAI;QAClB,MAAM3G,CAAC,GAAG,IAAI,CAACoH,4BAA4B,CAACH,GAAG,EAAEN,GAAG,EAAE/F,MAAM,EAAE,GAAG6C,GAAG,CAAC;QACrE,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;UACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;QACf;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOkE,KAAK;EACd;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUoD,6BAA6B,CAAC9K,CAAS,EAAE+K,EAAsB,EAAE;IACvEvO,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACK,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrD,MAAM8B,MAAM,GAAG,IAAI,CAACkJ,gBAAgB,CAAChL,CAAC,CAAC;IACvC,MAAMiL,MAAM,GAAG,IAAI,CAAC/G,kBAAkB,CAACpC,MAAM,CAAC;IAC9C,MAAMiH,OAAO,GAAG,IAAImC,GAAG,CAAaD,MAAM,CAACrK,GAAG,CAACmK,EAAE,CAACtG,IAAI,CAAC,CAAC;IACxD,OAAO,IAAI,CAAC/B,aAAa,CAAC,GAAGqG,OAAO,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUoC,iCAAiC;EACvCxG,CAAS;EACTC,CAAS;EACTmG,EAA0B;EACd;IACZvO,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACgF,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrDnI,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACiF,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrD,MAAMwG,QAAQ,GAAG,IAAI,CAACJ,gBAAgB,CAACrG,CAAC,CAAC;IACzC,MAAM0G,QAAQ,GAAG,IAAI,CAACL,gBAAgB,CAACpG,CAAC,CAAC;IACzC,MAAM0G,QAAQ,GAAG,IAAI,CAACpH,kBAAkB,CAACkH,QAAQ,CAAC;IAClD,MAAMG,QAAQ,GAAG,IAAI,CAACrH,kBAAkB,CAACmH,QAAQ,CAAC;IAClD,MAAM1I,SAAS,GAAG,IAAIuI,GAAG,EAAc;IACvCI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BD,QAAQ,CAAC1I,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1B9I,SAAS,CAAC+I,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,EAAEC,OAAO,CAAC,CAAC;MAC1C,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAAC/I,aAAa,CAAC,GAAGC,SAAS,CAAC;EACzC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUgJ,mCAAmC;EACzChH,CAAS;EACTC,CAAS;EACTgH,CAAS;EACTb,EAA4B;EAChB;IACZvO,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACgF,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrDnI,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACiF,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrDpI,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACiM,CAAC,CAAC,EAAG,2BAA0B,CAAC;IACrD,MAAMR,QAAQ,GAAG,IAAI,CAACJ,gBAAgB,CAACrG,CAAC,CAAC;IACzC,MAAM0G,QAAQ,GAAG,IAAI,CAACL,gBAAgB,CAACpG,CAAC,CAAC;IACzC,MAAMiH,QAAQ,GAAG,IAAI,CAACb,gBAAgB,CAACY,CAAC,CAAC;IACzC,MAAMN,QAAQ,GAAG,IAAI,CAACpH,kBAAkB,CAACkH,QAAQ,CAAC;IAClD,MAAMG,QAAQ,GAAG,IAAI,CAACrH,kBAAkB,CAACmH,QAAQ,CAAC;IAClD,MAAMS,QAAQ,GAAG,IAAI,CAAC5H,kBAAkB,CAAC2H,QAAQ,CAAC;IAClD,MAAMlJ,SAAS,GAAG,IAAIuI,GAAG,EAAc;;IAEvCI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BD,QAAQ,CAAC1I,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1BK,QAAQ,CAACjJ,OAAO,CAAC,CAAAkJ,OAAO,KAAI;UAC1BpJ,SAAS,CAAC+I,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,EAAEC,OAAO,EAAEM,OAAO,CAAC,CAAC;QACnD,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,OAAO,IAAI,CAACrJ,aAAa,CAAC,GAAGC,SAAS,CAAC;EACzC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUqJ,6BAA6B,CAACrH,CAAoB,EAAEoG,EAAsB,EAAc;IAC9FvO,MAAM;IACJmI,CAAC,CAAC/B,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;;IAED,MAAMiJ,SAA+B,GAAGtH,CAAC,CAAC/D,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMkB,SAA+B,GAAGD,SAAS,CAACrL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM4H,QAAQ,GAAGjO,gBAAgB,CAAS,GAAG6O,SAAS,CAAC;;IAEvD,MAAMvJ,SAAS,GAAG,IAAIuI,GAAG,EAAc;IACvCI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1B7I,SAAS,CAAC+I,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,CAAC,CAAC;IACjC,CAAC,CAAC;IACF,OAAO,IAAI,CAAC9I,aAAa,CAAC,GAAGC,SAAS,CAAC;EACzC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUwJ,iCAAiC;EACvCxH,CAAoB;EACpBC,CAAoB;EACpBmG,EAA0B;EACd;IACZvO,MAAM;IACJmI,CAAC,CAAC/B,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;IACDxG,MAAM;IACJoI,CAAC,CAAChC,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;;IAED,MAAMiJ,SAA+B,GAAGtH,CAAC,CAAC/D,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMoB,SAA+B,GAAGxH,CAAC,CAAChE,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMkB,SAA+B,GAAGD,SAAS,CAACrL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM2I,SAA+B,GAAGD,SAAS,CAACxL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM4H,QAAQ,GAAGjO,gBAAgB,CAAS,GAAG6O,SAAS,CAAC;IACvD,MAAMX,QAAQ,GAAGlO,gBAAgB,CAAS,GAAGgP,SAAS,CAAC;;IAEvD,MAAM1J,SAAS,GAAG,IAAIuI,GAAG,EAAc;IACvCI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BD,QAAQ,CAAC1I,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1B9I,SAAS,CAAC+I,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,EAAEC,OAAO,CAAC,CAAC;MAC1C,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAAC/I,aAAa,CAAC,GAAGC,SAAS,CAAC;EACzC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACU2J,2BAA2B,CAAC3H,CAAoB,EAAEoG,EAAoB,EAAY;IACxFvO,MAAM;IACJmI,CAAC,CAAC/B,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;;IAED,MAAMiJ,SAA+B,GAAGtH,CAAC,CAAC/D,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMkB,SAA+B,GAAGD,SAAS,CAACrL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM4H,QAAQ,GAAGjO,gBAAgB,CAAS,GAAG6O,SAAS,CAAC;;IAEvD,MAAMK,gBAAgB,GAAG,IAAIrB,GAAG,EAAY;IAC5CI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1Be,gBAAgB,CAACb,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,CAAC,CAAC;IACxC,CAAC,CAAC;;IAEF,OAAO,IAAI,CAACtI,WAAW,CAAC,GAAGqJ,gBAAgB,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUC,+BAA+B;EACrC7H,CAAoB;EACpBC,CAAoB;EACpBmG,EAAwB;EACd;IACVvO,MAAM;IACJmI,CAAC,CAAC/B,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;IACDxG,MAAM;IACJoI,CAAC,CAAChC,KAAK,CAAC,CAAAI,CAAC,KAAI,CAACtD,MAAM,CAACC,KAAK,CAACqD,CAAC,CAAC,CAAC;IAC7B,2BAA0B,CAC5B;;;IAED,MAAMiJ,SAA+B,GAAGtH,CAAC,CAAC/D,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMoB,SAA+B,GAAGxH,CAAC,CAAChE,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACpE,MAAMkB,SAA+B,GAAGD,SAAS,CAACrL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM2I,SAA+B,GAAGD,SAAS,CAACxL,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAM4H,QAAQ,GAAGjO,gBAAgB,CAAS,GAAG6O,SAAS,CAAC;IACvD,MAAMX,QAAQ,GAAGlO,gBAAgB,CAAS,GAAGgP,SAAS,CAAC;;IAEvD,MAAME,gBAAgB,GAAG,IAAIrB,GAAG,EAAY;IAC5CI,QAAQ,CAACzI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BD,QAAQ,CAAC1I,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1Bc,gBAAgB,CAACb,GAAG,CAACX,EAAE,CAACtG,IAAI,CAAC+G,OAAO,EAAEC,OAAO,CAAC,CAAC;MACjD,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,OAAO,IAAI,CAACvI,WAAW,CAAC,GAAGqJ,gBAAgB,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUE,2BAA2B,CAAClJ,CAAkB,EAAEwH,EAAoB,EAAY;IACtF,MAAMjH,QAAQ,GAAGP,CAAC,CAAC9D,MAAM;IACzB,MAAMgE,QAAQ,GAAGF,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM;IAC5BjD,MAAM;IACJ+G,CAAC,CAACX,KAAK,CAAC,CAAAY,CAAC,KAAIA,CAAC,CAACZ,KAAK,CAAC,CAAAmB,CAAC,KAAI,CAACrE,MAAM,CAACC,KAAK,CAACoE,CAAC,CAAC,CAAC,CAAC;IAC3C,2BAA0B,CAC5B;;;IAED,MAAM2I,MAAM,GAAGjP,cAAc,CAAC8F,CAAC,CAAC;IAChC,MAAMoJ,SAA+B,GAAGD,MAAM,CAAC9L,GAAG,CAAC,IAAI,CAACoK,gBAAgB,CAAC;IACzE,MAAM4B,SAA+B,GAAGD,SAAS,CAAC/L,GAAG,CAAC,IAAI,CAACsD,kBAAkB,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF,MAAMmJ,SAA+B,GAAGxP,gBAAgB,CAAS,GAAGuP,SAAS,CAAC;IAC9E,MAAME,QAAmC,GAAGD,SAAS,CAACjM,GAAG,CAAC,CAAAoC,CAAC;IACzDzE,gBAAgB,CAACyE,CAAC,EAAEc,QAAQ,EAAEL,QAAQ,CAAC,CACxC;;;IAED,MAAMsJ,iBAAiB,GAAG,IAAI7B,GAAG,EAAY;IAC7C4B,QAAQ,CAACjK,OAAO,CAAC,CAAAmK,OAAO,KAAI;MAC1BD,iBAAiB,CAACrB,GAAG,CAACX,EAAE,CAACtG,IAAI,CAACuI,OAAO,CAAC,CAAC;IACzC,CAAC,CAAC;;IAEF,OAAO,IAAI,CAACrJ,YAAY,CAAC,GAAGoJ,iBAAiB,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYE,qBAAqB,CAACtI,CAAa,EAAEoG,EAAsB,EAAc;IACjF,IAAI,CAACpG,CAAC,CAACjE,QAAQ,EAAE,EAAE;MACjB,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;IAC3C;;IAEA,IAAI8J,EAAE,CAACmC,OAAO,KAAK9F,SAAS,EAAE;MAC5BzC,CAAC,GAAGoG,EAAE,CAACmC,OAAO,CAACvI,CAAC,CAAC;IACnB;;IAEA,MAAMtB,MAAM,GAAG,IAAI,CAACX,aAAa;IAC/B,GAAGiC,CAAC,CAACrF,MAAM,EAAE,CAACsB,GAAG,CAAC,CAAAuM,CAAC,KAAI,IAAI,CAACrC,6BAA6B,CAACqC,CAAC,EAAEpC,EAAE,CAAC,CAAC,CAClE;;IACD,OAAO1H,MAAM,CAAC3C,QAAQ,EAAE,GAAG2C,MAAM,GAAG,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYmM,yBAAyB;EACjCzI,CAAa;EACbC,CAAa;EACbmG,EAA0B;EACd;IACZ,IAAI,CAACpG,CAAC,CAACjE,QAAQ,EAAE,IAAI,CAACkE,CAAC,CAAClE,QAAQ,EAAE,EAAE;MAClC,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;IAC3C;;IAEA,IAAI8J,EAAE,CAACmC,OAAO,KAAK9F,SAAS,EAAE;MAC5B,CAACzC,CAAC,EAAEC,CAAC,CAAC,GAAGmG,EAAE,CAACmC,OAAO,CAACvI,CAAC,EAAEC,CAAC,CAAC;IAC3B;;IAEA,MAAMyI,OAAO,GAAG,IAAInC,GAAG,EAAc;IACrCvG,CAAC,CAACrF,MAAM,EAAE,CAACuD,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC5B5G,CAAC,CAACtF,MAAM,EAAE,CAACuD,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC5B4B,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACP,iCAAiC,CAACK,OAAO,EAAEC,OAAO,EAAEV,EAAE,CAAC,CAAC;MAC3E,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACX,aAAa,CAAC,GAAG2K,OAAO,CAAC;IAC7C,OAAOhK,MAAM,CAAC3C,QAAQ,EAAE,GAAG2C,MAAM,GAAG,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYqM,2BAA2B;EACnC3I,CAAa;EACbC,CAAa;EACbgH,CAAa;EACbb,EAA4B;EAChB;IACZ,IAAI,CAACpG,CAAC,CAACjE,QAAQ,EAAE,IAAI,CAACkE,CAAC,CAAClE,QAAQ,EAAE,IAAI,CAACkL,CAAC,CAAClL,QAAQ,EAAE,EAAE;MACnD,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;IAC3C;;IAEA,MAAMoM,OAAO,GAAG,IAAInC,GAAG,EAAc;IACrCvG,CAAC,CAACrF,MAAM,EAAE,CAACuD,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC5B5G,CAAC,CAACtF,MAAM,EAAE,CAACuD,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC5BG,CAAC,CAACtM,MAAM,EAAE,CAACuD,OAAO,CAAC,CAAAkJ,OAAO,KAAI;UAC5BsB,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACC,mCAAmC,CAACH,OAAO,EAAEC,OAAO,EAAEM,OAAO,EAAEhB,EAAE,CAAC,CAAC;QACtF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACX,aAAa,CAAC,GAAG2K,OAAO,CAAC;IAC7C,OAAOhK,MAAM,CAAC3C,QAAQ,EAAE,GAAG2C,MAAM,GAAG,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACYsM,qBAAqB,CAAC5I,CAAW,EAAEoG,EAAsB,EAAc;IAC/E,IAAIpG,CAAC,CAAC5C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,EAAE;MAC9B,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;IAC3C;;IAEA,MAAMmK,QAAQ,GAAG/N,gBAAgB,CAAS,GAAGsH,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;;IAEpE,MAAM+N,OAAO,GAAG,IAAInC,GAAG,EAAc;IACrCE,QAAQ,CAACvI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1B6B,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACM,6BAA6B,CAACR,OAAO,EAAET,EAAE,CAAC,CAAC;IAC9D,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACX,aAAa,CAAC,GAAG2K,OAAO,CAAC;IAC7C,OAAOhK,MAAM,CAAC3C,QAAQ,EAAE,GAAG2C,MAAM,GAAG,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYuM,yBAAyB;EACjC7I,CAAW;EACXC,CAAW;EACXmG,EAA0B;EACd;IACZ,IAAIpG,CAAC,CAAC5C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,IAAIkE,CAAC,CAAC7C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,EAAE;MAC5D,OAAO,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB;IAC3C;;IAEA,MAAMmK,QAAQ,GAAG/N,gBAAgB,CAAS,GAAGsH,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;IACpE,MAAM+L,QAAQ,GAAGhO,gBAAgB,CAAS,GAAGuH,CAAC,CAAChE,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;;IAEpE,MAAM+N,OAAO,GAAG,IAAInC,GAAG,EAAc;IACrCE,QAAQ,CAACvI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BH,QAAQ,CAACxI,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1B4B,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACS,iCAAiC,CAACX,OAAO,EAAEC,OAAO,EAAEV,EAAE,CAAC,CAAC;MAC3E,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACX,aAAa,CAAC,GAAG2K,OAAO,CAAC;IAC7C,OAAOhK,MAAM,CAAC3C,QAAQ,EAAE,GAAG2C,MAAM,GAAG,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACYwM,mBAAmB,CAAC9I,CAAW,EAAEoG,EAAoB,EAAY;IACzE,IAAIpG,CAAC,CAAC5C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,EAAE;MAC9B,OAAO,IAAI,CAACN,SAAS,EAAE,CAACsN,eAAe,CAAC/I,CAAC,CAAClF,MAAM,CAAC;IACnD;;IAEA,MAAM2L,QAAQ,GAAG/N,gBAAgB,CAAS,GAAGsH,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;;IAEpE,MAAM+N,OAAO,GAAG,IAAInC,GAAG,EAAY;IACnCE,QAAQ,CAACvI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1B6B,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACY,2BAA2B,CAACd,OAAO,EAAET,EAAE,CAAC,CAAC;IAC5D,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACH,WAAW,CAAC,GAAGmK,OAAO,CAAC;IAC3C,OAAOhK,MAAM,CAACT,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,CAACtC,QAAQ,EAAE,CAAC;IAClC2C,MAAM;IACN,IAAI,CAACjD,SAAS,EAAE,CAACsN,eAAe,CAACrK,MAAM,CAAC5D,MAAM,CAAC;EACrD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYkO,kCAAkC,CAAChJ,CAAW,EAAEoG,EAAsB,EAAY;IAC1F,OAAO,IAAI,CAAC7N,QAAQ,CAACyH,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAACiK,qBAAqB,CAACjK,CAAC,EAAE+H,EAAE,CAAC,CAAC,CAAC;EACrE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACY6C,uBAAuB,CAACjJ,CAAW,EAAEC,CAAW,EAAEmG,EAAwB,EAAY;IAC9F,IAAIpG,CAAC,CAAC5C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,IAAIkE,CAAC,CAAC7C,IAAI,CAAC,CAAAiB,CAAC,KAAI,CAACA,CAAC,CAACtC,QAAQ,EAAE,CAAC,EAAE;MAC5D,OAAO,IAAI,CAACN,SAAS,EAAE,CAACsN,eAAe,CAAC/I,CAAC,CAAClF,MAAM,CAAC;IACnD;;IAEA,MAAM2L,QAAQ,GAAG/N,gBAAgB,CAAS,GAAGsH,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;IACpE,MAAM+L,QAAQ,GAAGhO,gBAAgB,CAAS,GAAGuH,CAAC,CAAChE,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;;IAEpE,MAAM+N,OAAO,GAAG,IAAInC,GAAG,EAAY;IACnCE,QAAQ,CAACvI,OAAO,CAAC,CAAA2I,OAAO,KAAI;MAC1BH,QAAQ,CAACxI,OAAO,CAAC,CAAA4I,OAAO,KAAI;QAC1B4B,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACc,+BAA+B,CAAChB,OAAO,EAAEC,OAAO,EAAEV,EAAE,CAAC,CAAC;MACzE,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACH,WAAW,CAAC,GAAGmK,OAAO,CAAC;IAC3C,OAAOhK,MAAM,CAACT,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,CAACtC,QAAQ,EAAE,CAAC;IAClC2C,MAAM;IACN,IAAI,CAACjD,SAAS,EAAE,CAACsN,eAAe,CAACrK,MAAM,CAAC5D,MAAM,CAAC;EACrD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYoO,4CAA4C;EACpDlJ,CAAW;EACXC,CAAW;EACXmG,EAA0B;EAChB;IACVvO,MAAM;IACJmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM;IACpB,sFAAqF,CACvF;;;IAED,OAAO,IAAI,CAACvC,QAAQ;IAClByH,CAAC,CAAC/D,GAAG,CAAC,CAACG,CAAC,EAAE+M,GAAG,KAAK;MAChB,OAAO,IAAI,CAACV,yBAAyB,CAACrM,CAAC,EAAE6D,CAAC,CAACkJ,GAAG,CAAC,EAAE/C,EAAE,CAAC;IACtD,CAAC,CAAC,CACH;;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACYgD,mBAAmB,CAACxK,CAAW,EAAEwH,EAAoB,EAAY;IACzE,MAAMjH,QAAQ,GAAGP,CAAC,CAAC9D,MAAM;IACzB,MAAMgE,QAAQ,GAAGF,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM;IAC5B,IAAI8D,CAAC,CAACxB,IAAI,CAAC,CAAAyB,CAAC,KAAIA,CAAC,CAACzB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC,EAAE;MAC3C,OAAO,IAAI,CAACN,SAAS,EAAE,CAAC4N,eAAe,CAAClK,QAAQ,CAAC,CAACL,QAAQ,CAAC;IAC7D;;IAEA,MAAMiJ,MAA6B,GAAGjP,cAAc,CAAC8F,CAAC,CAAC;IACvD,MAAM0K,QAA8B,GAAG5Q,gBAAgB,CAAS,GAAGqP,MAAM,CAAC9L,GAAG,CAAC,CAAAoC,CAAC,KAAIA,CAAC,CAAC1D,MAAM,EAAE,CAAC,CAAC;;IAE/F,MAAM+N,OAAO,GAAG,IAAInC,GAAG,EAAY;IACnC+C,QAAQ,CAACpL,OAAO,CAAC,CAAAmK,OAAO,KAAI;MAC1B,MAAMkB,QAAQ,GAAG3P,gBAAgB,CAACyO,OAAO,EAAElJ,QAAQ,EAAEL,QAAQ,CAAC;MAC9D4J,OAAO,CAAC3B,GAAG,CAAC,IAAI,CAACe,2BAA2B,CAACyB,QAAQ,EAAEnD,EAAE,CAAC,CAAC;IAC7D,CAAC,CAAC;;IAEF,MAAM1H,MAAM,GAAG,IAAI,CAACM,YAAY,CAAC,GAAG0J,OAAO,CAAC;IAC5C,MAAMc,WAAW,GAAG9K,MAAM,CAAC5D,MAAM;IACjC,MAAM2O,WAAW,GAAG/K,MAAM,CAAC,CAAC,CAAC,CAAC5D,MAAM;;IAEpC;IACA;IACA;IACA,OAAQ4D,MAAM,CAA8BT,KAAK,CAAC,CAAAY,CAAC,KAAIA,CAAC,CAACZ,KAAK,CAAC,CAAAmB,CAAC,KAAIA,CAAC,CAACrD,QAAQ,EAAE,CAAC,CAAC;IAC9E2C,MAAM;IACN,IAAI,CAACjD,SAAS,EAAE,CAAC4N,eAAe,CAACG,WAAW,CAAC,CAACC,WAAW,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYC,4CAA4C;EACpD1J,CAAW;EACXC,CAAW;EACXmG,EAA0B;EAChB;IACVvO,MAAM;IACJmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM,IAAIkF,CAAC,CAAC,CAAC,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAAC,CAAC,CAAC,CAACnF,MAAM;IACnD,uFAAsF,CACxF;;;IAED,MAAM6O,IAAI,GAAG3J,CAAC,CAAClF,MAAM;IACrB,MAAM8O,IAAI,GAAG5J,CAAC,CAAC,CAAC,CAAC,CAAClF,MAAM;IACxB,MAAM+O,MAAM,GAAG/Q,cAAc,CAACkH,CAAC,CAAC;IAChC,MAAM8J,MAAM,GAAGhR,cAAc,CAACmH,CAAC,CAAC;;IAEhC,OAAO,IAAI,CAAC3H,QAAQ;IAClBsB,gBAAgB;IACdiQ,MAAM,CAAC5N,GAAG,CAAC,CAACG,CAAC,EAAE+M,GAAG,KAAK;MACrB,OAAO,IAAI,CAACV,yBAAyB,CAACrM,CAAC,EAAE0N,MAAM,CAACX,GAAG,CAAC,EAAE/C,EAAE,CAAC;IAC3D,CAAC,CAAC;IACFuD,IAAI;IACJC,IAAI,CACL,CACF;;;EACH;;EAEA;;EAEA;EACQG,uBAAuB,CAACC,WAAmB,EAAsB;IACvE,MAAM5D,EAAsB,GAAG;MAC7BtG,IAAI,EAAE,CAACT,CAAS,KAAK;QACnB,OAAO,IAAI,CAAC5D,SAAS,EAAE,CAACa,iBAAiB;MAC3C;IACF,CAAC;;IAEDzE,MAAM;IACJmS,WAAW,IAAI,CAAC;IACf,iEAAgEA,WAAY,EAAC,CAC/E;;;IAED,IAAI,IAAI,CAACjO,QAAQ,CAACiO,WAAW,CAAC,EAAE;MAC9B5D,EAAE,CAACtG,IAAI,GAAG,CAACzE,CAAS,KAAK;QACvBxD,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACK,CAAC,CAAC,EAAG,oCAAmC,CAAC;QAC9D;QACA,IAAI,CAAC,IAAI,CAACU,QAAQ,CAACV,CAAC,CAAC,EAAE;UACrB,OAAO,IAAI,CAACI,SAAS,EAAE,CAACa,iBAAiB;QAC3C;QACA,OAAO,IAAI,CAACQ,UAAU,CAAC,CAACzB,CAAC,GAAG2O,WAAW,EAAE3O,CAAC,GAAG2O,WAAW,CAAC,CAAC;MAC5D,CAAC;IACH;;IAEA,OAAO5D,EAAE;EACX;;EAEU6D,yBAAyB,CAAC5O,CAAS,EAAE2O,WAAmB,EAAc;IAC9EA,WAAW,GAAG7L,IAAI,CAAC+L,GAAG,CAACF,WAAW,CAAC;IACnC,OAAO,IAAI,CAAC1B,qBAAqB;IAC/B,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC;IAClB,IAAI,CAAC0O,uBAAuB,CAACC,WAAW,CAAC,CAC1C;;EACH;;EAEA;;;EAGA;AACF;AACA;AACA;EACmBG,0BAA0B,GAAuB;IAChErK,IAAI,EAAE,CAACzE,CAAS,KAAK;MACnBxD,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACK,CAAC,CAAC,EAAG,8BAA6B,CAAC;MACxD,OAAO,IAAI,CAACyB,UAAU,CAACzB,CAAC,CAAC;IAC3B;EACF,CAAC;;EAES+O,4BAA4B,CAAC/O,CAAsB,EAAc;IACzE,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC8O,0BAA0B,CAAC;EACxF;;EAEA;;;EAGUE,0BAA0B,CAACzL,CAAkB,EAAY;IACjE,OAAO,IAAI,CAACtG,QAAQ,CAACiB,UAAU,CAACqF,CAAC,EAAE,IAAI,CAAC0L,wBAAwB,CAAC,CAAC;EACpE;;EAEA;;;EAGA;EACQC,aAAa,CAACC,MAAc,EAAsB;IACxD,MAAMpE,EAAsB,GAAG;MAC7BtG,IAAI,EAAE,CAACT,CAAS,KAAK;QACnB,OAAO,IAAI,CAAC5D,SAAS,EAAE,CAACa,iBAAiB;MAC3C;IACF,CAAC;;IAED,IAAI,IAAI,CAACP,QAAQ,CAACyO,MAAM,CAAC,EAAE;MACzBpE,EAAE,CAACtG,IAAI,GAAG,CAACzE,CAAS,KAAK;QACvBxD,MAAM,CAAC,CAACkD,MAAM,CAACC,KAAK,CAACK,CAAC,CAAC,EAAG,+BAA8B,CAAC;;QAEzD,MAAMoP,GAAG,GAAG,IAAI,CAACC,MAAM,CAACrP,CAAC,CAAC;QAC1B,MAAMT,KAAK,GAAGS,CAAC,GAAGmP,MAAM,GAAGC,GAAG;QAC9B,MAAM5P,GAAG,GAAGQ,CAAC,GAAGmP,MAAM,GAAGC,GAAG;;QAE5B,OAAO,IAAI,CAAC3N,UAAU,CAAC;QACrBqB,IAAI,CAACvC,GAAG,CAAChB,KAAK,EAAE,IAAI,CAAC+P,cAAc,CAAC/P,KAAK,CAAC,CAAC;QAC3CuD,IAAI,CAACrC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC8P,cAAc,CAAC9P,GAAG,CAAC,CAAC,CACxC,CAAC;;MACJ,CAAC;IACH;;IAEA,OAAOuL,EAAE;EACX;;EAEUwE,eAAe,CAACvP,CAAS,EAAEmP,MAAc,EAAc;IAC/DA,MAAM,GAAGrM,IAAI,CAAC+L,GAAG,CAACM,MAAM,CAAC;IACzB,OAAO,IAAI,CAAClC,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACkP,aAAa,CAACC,MAAM,CAAC,CAAC;EACnF;;EAEA;;;EAGA;;EAEiBK,aAAa,GAAuB;IACnD/K,IAAI,EAAE,CAACzE,CAAS,KAAK;MACnB,OAAO,IAAI,CAACiP,wBAAwB,CAACnM,IAAI,CAAC+L,GAAG,CAAC7O,CAAC,CAAC,CAAC;IACnD;EACF,CAAC;;EAESyP,eAAe,CAACzP,CAAS,EAAc;IAC/C,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACwP,aAAa,CAAC;EAC3E;;EAEA;;;EAGA;EACiBE,cAAc,GAAuB;IACpDjL,IAAI,EAAE,IAAI,CAACF,2BAA2B,CAAC,IAAI,CAAC9C,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,CAACzB,CAAS,KAAK;MAClFxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD;MACA,MAAM0F,CAAC,GAAG,IAAI,CAAC+K,YAAY,CAAC,IAAI,CAACC,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAACC,sBAAsB,CAAC7P,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC;MAC3F,MAAM8P,gBAAgB,GAAG,IAAI,CAAC5Q,IAAI,KAAK,KAAK,GAAG,OAAO,GAAG,OAAO;MAChE,OAAO,IAAI,CAACwD,aAAa;MACvB,IAAI,CAACqN,aAAa,CAACnL,CAAC,EAAE5E,CAAC,CAAC;MACxB,IAAI,CAACgQ,qBAAqB,CAAClN,IAAI,CAACmN,IAAI,CAACjQ,CAAC,CAAC,EAAE8P,gBAAgB,CAAC,CAC3D;;IACH,CAAC;EACH,CAAC;;EAESI,gBAAgB,CAAClQ,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC0P,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBS,0BAA0B,GAAuB;IAChE1L,IAAI,EAAE,CAACE,CAAS,KAAiB;MAC/B;MACA,MAAMyL,WAAW,GAAG,IAAI,CAACP,sBAAsB;MAC7C,IAAI,CAACQ,gBAAgB,CAAC1L,CAAC,EAAE,GAAG,CAAC;MAC7B,IAAI,CAACiL,mBAAmB,CAACjL,CAAC,EAAE,GAAG,CAAC,CACjC;;MACD,MAAM2L,UAAU,GAAG,IAAI,CAACX,YAAY,CAACS,WAAW,CAAC;MACjD,OAAO,IAAI,CAACG,WAAW,CAAC,IAAI,CAACF,gBAAgB,CAAC1L,CAAC,EAAE2L,UAAU,CAAC,CAAC;IAC/D;EACF,CAAC;;EAESE,4BAA4B,CAAC7L,CAAsB,EAAc;IACzE,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAACwL,0BAA0B,CAAC;EACxF;;EAEA;;;EAGiBM,sBAAsB,GAAuB;IAC5DhM,IAAI,EAAE,CAACE,CAAS,KAAiB;MAC/B;MACA,MAAMyL,WAAW,GAAG,IAAI,CAACR,mBAAmB,CAAC,IAAI,CAACC,sBAAsB,CAAClL,CAAC,EAAEA,CAAC,CAAC,EAAE,GAAG,CAAC;MACpF,MAAM2L,UAAU,GAAG,IAAI,CAACX,YAAY,CAACS,WAAW,CAAC;MACjD,OAAO,IAAI,CAACG,WAAW,CAAC,IAAI,CAACF,gBAAgB,CAAC1L,CAAC,EAAE2L,UAAU,CAAC,CAAC;IAC/D;EACF,CAAC;;EAESI,wBAAwB,CAAC/L,CAAsB,EAAc;IACrE,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAAC8L,sBAAsB,CAAC;EACpF;;EAEA;;;;;;EAMiBE,kBAAkB,GAA2B;IAC5DlM,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAACqK,wBAAwB,CAACtK,CAAC,GAAGC,CAAC,CAAC;IAC7C;EACF,CAAC;;EAESgM,oBAAoB,CAACjM,CAAsB,EAAEC,CAAsB,EAAc;IACzF,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC+L,kBAAkB,CACxB;;EACH;;EAEA;;;;;;EAMUE,gCAAgC,CAAClM,CAAkB,EAAEC,CAAkB,EAAY;IAC3F,OAAO,IAAI,CAACyJ,4CAA4C;IACtD,IAAI,CAACpR,QAAQ,CAAC0H,CAAC,CAAC;IAChB,IAAI,CAAC1H,QAAQ,CAAC2H,CAAC,CAAC;IAChB,IAAI,CAAC+L,kBAAkB,CACxB;;EACH;;EAEA;;;;;;EAMA;EACiBG,cAAc,GAAuB;IACpDrM,IAAI,EAAE,IAAI,CAACF,2BAA2B,CAAC,IAAI,CAAC9C,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,CAACzB,CAAS,KAAK;MAClFxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD;MACA,MAAMyF,CAAC,GAAG,IAAI,CAACgL,YAAY,CAAC,IAAI,CAACC,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAACC,sBAAsB,CAAC7P,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC;MAC3F,MAAM8P,gBAAgB,GAAG,IAAI,CAAC5Q,IAAI,KAAK,KAAK,GAAG,OAAO,GAAG,OAAO;MAChE,OAAO,IAAI,CAACwD,aAAa;MACvB,IAAI,CAACqN,aAAa,CAAC/P,CAAC,EAAE2E,CAAC,CAAC;MACxB,IAAI,CAACqL,qBAAqB,CAAClN,IAAI,CAACiO,IAAI,CAAC/Q,CAAC,CAAC,EAAE8P,gBAAgB,CAAC,CAC3D;;IACH,CAAC;EACH,CAAC;;EAED;EACUkB,gBAAgB,CAAChR,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC8Q,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBG,eAAe,GAAuB;IACrDxM,IAAI,EAAE,CAACE,CAAS,KAAiB;MAC/B;MACA,MAAMyL,WAAW,GAAG,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAACR,sBAAsB,CAAClL,CAAC,EAAEA,CAAC,CAAC,EAAE,GAAG,CAAC;MACjF,MAAM2L,UAAU,GAAG,IAAI,CAACX,YAAY,CAACS,WAAW,CAAC;MACjD,OAAO,IAAI,CAACG,WAAW,CAAC,IAAI,CAACF,gBAAgB,CAAC1L,CAAC,EAAE2L,UAAU,CAAC,CAAC;IAC/D;EACF,CAAC;;EAESY,iBAAiB,CAAClR,CAAS,EAAc;IACjD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACiR,eAAe,CAAC;EAC7E;;EAEA;;;EAGiBE,cAAc,GAAuB;IACpD1M,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/BxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMkS,SAAS,GAAG,IAAI,CAAClS,IAAI,KAAK,KAAK,GAAG,IAAI,GAAG,CAAC;MAChD,OAAO,IAAI,CAACmS,WAAW,CAACvO,IAAI,CAACwO,IAAI,CAACtR,CAAC,CAAC,EAAEoR,SAAS,CAAC;IAClD;EACF,CAAC;;EAED;EACUG,gBAAgB,CAACvR,CAAsB,EAAc;IAC7D,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACmR,cAAc,CAAC;EAC5E;;EAEA;;;EAGA;EACQK,sBAAsB,GAA2B;IACvDhV,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;IAClD,MAAMkB,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;IAClC;IACA;IACA;IACA,MAAMqR,QAAQ,GAAG;IACf,IAAI,CAAChQ,UAAU,CAAC,CAACrB,SAAS,CAACC,QAAQ,CAACE,GAAG,EAAEH,SAAS,CAACC,QAAQ,CAACI,GAAG,CAAC,CAAC;IACjE,IAAI,CAACgB,UAAU,CAAC,CAACrB,SAAS,CAACI,QAAQ,CAACD,GAAG,EAAEH,SAAS,CAACI,QAAQ,CAACC,GAAG,CAAC,CAAC,CAClE;;IACD;IACA,MAAMiR,QAAQ;IACZ,IAAI,CAACxS,IAAI,KAAK,KAAK;IACf,CAAC,IAAI,CAACuC,UAAU,CAAC,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACtF,CAAC,IAAI,CAACA,UAAU,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACxF,MAAM2P,SAAS,GAAG,IAAI,CAAClS,IAAI,KAAK,KAAK,GAAG,IAAI,GAAG,CAAC;IAChD,OAAO;MACLuF,IAAI,EAAE,IAAI,CAACC,+BAA+B;MACxC;QACEC,CAAC,EAAE8M,QAAQ;QACX7M,CAAC,EAAE8M;MACL,CAAC;MACD,CAAC9M,CAAS,EAAED,CAAS,KAAiB;QACpC;QACA,IAAIgN,OAAO,GAAG7O,IAAI,CAACwO,IAAI,CAAC1M,CAAC,GAAGD,CAAC,CAAC;QAC9B;QACA;QACA,IAAIA,CAAC,GAAG,CAAC,EAAE;UACT;UACA,IAAIC,CAAC,GAAG,CAAC,EAAE;YACT+M,OAAO,GAAGA,OAAO,GAAG/U,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAACC,KAAK;UAClD,CAAC,MAAM;YACL;YACAH,OAAO,GAAGA,OAAO,GAAG/U,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAACC,KAAK;UAClD;QACF;;QAEA,OAAO,IAAI,CAACT,WAAW,CAACM,OAAO,EAAEP,SAAS,CAAC;MAC7C,CAAC,CACF;;MACDlE,OAAO,EAAE,CAACtI,CAAa,EAAED,CAAa,KAA+B;QACnE;QACA,IAAIC,CAAC,CAAC7E,QAAQ,CAAC,CAAC,CAAC,EAAE;UACjB,IAAI4E,CAAC,CAAC5E,QAAQ,CAAC,CAAC,CAAC,EAAE;YACjB,OAAO,CAAC,IAAI,CAAC0B,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,CAAC;UACjD;UACA,OAAO,CAAC,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,EAAEkD,CAAC,CAAC;QAChC;QACA,OAAO,CAACC,CAAC,EAAED,CAAC,CAAC;MACf;IACF,CAAC;EACH;;EAEUoN,iBAAiB,CAACnN,CAAsB,EAAED,CAAsB,EAAc;IACtF,OAAO,IAAI,CAACyI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACnD,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAC6M,sBAAsB,EAAE,CAC9B;;EACH;;EAEA;;;;;;EAMiBQ,eAAe,GAAuB;IACrDvN,IAAI,EAAE,CAACzE,CAAS,KAAK;MACnB;MACA,MAAMiS,SAAS,GAAG,IAAI,CAAC5B,gBAAgB,CAAC,GAAG,EAAErQ,CAAC,CAAC;MAC/C,MAAMkS,WAAW,GAAG,IAAI,CAACtC,mBAAmB,CAAC,GAAG,EAAE5P,CAAC,CAAC;MACpD,MAAMmS,YAAY,GAAG,IAAI,CAAC5B,WAAW,CAAC,IAAI,CAAC6B,gBAAgB,CAACH,SAAS,EAAEC,WAAW,CAAC,CAAC;MACpF,OAAO,IAAI,CAACrC,sBAAsB,CAACsC,YAAY,EAAE,GAAG,CAAC;IACvD;EACF,CAAC;;EAESE,iBAAiB,CAACrS,CAAS,EAAc;IACjD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACgS,eAAe,CAAC;EAC7E;;EAEA;;;EAGiBM,cAAc,GAAuB;IACpD7N,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACiP,wBAAwB,CAACnM,IAAI,CAACyP,IAAI,CAACvS,CAAC,CAAC,CAAC;IACpD;EACF,CAAC;;EAESwS,gBAAgB,CAACxS,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACsS,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBG,qBAAqB,GAA6B;IACjEhO,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,EAAEgH,CAAS,KAAiB;MACrD,OAAO,IAAI,CAACqD,wBAAwB;MAClC;MACA;MACA,CAACtK,CAAC,EAAEC,CAAC,EAAEgH,CAAC,CAAC,CAAC8G,IAAI,CAAC,CAACC,CAAC,EAAExF,CAAC,KAAK;QACvB,IAAIwF,CAAC,GAAGxF,CAAC,EAAE;UACT,OAAO,CAAC,CAAC;QACX;QACA,IAAIwF,CAAC,GAAGxF,CAAC,EAAE;UACT,OAAO,CAAC;QACV;QACA,OAAO,CAAC;MACV,CAAC,CAAC,CAAC,CAAC,CAAC,CACN;;IACH;EACF,CAAC;;EAESyF,uBAAuB;EAC/BjO,CAAsB;EACtBC,CAAsB;EACtBgH,CAAsB;EACV;IACZ,OAAO,IAAI,CAAC0B,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACnD,UAAU,CAACmK,CAAC,CAAC;IAClB,IAAI,CAAC6G,qBAAqB,CAC3B;;EACH;;EAEA;;;;;;;EAOiBI,qBAAqB,GAA6B;IACjEpO,IAAI,EAAE,CAACE,CAAS,EAAEmO,GAAW,EAAEC,IAAY,KAAiB;MAC1D,OAAO,IAAI,CAACC,WAAW,CAAC,IAAI,CAACC,WAAW,CAACtO,CAAC,EAAEmO,GAAG,CAAC,EAAEC,IAAI,CAAC;IACzD;EACF,CAAC;;EAESG,uBAAuB;EAC/BvO,CAAsB;EACtBmO,GAAwB;EACxBC,IAAyB;EACb;IACZ,OAAO,IAAI,CAACzF,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACqR,GAAG,CAAC;IACpB,IAAI,CAACrR,UAAU,CAACsR,IAAI,CAAC;IACrB,IAAI,CAACF,qBAAqB,CAC3B;;EACH;;EAEA;;;;;;;;;;EAUiBM,aAAa,GAAuB;IACnD1O,IAAI,EAAE,IAAI,CAACF,2BAA2B;IACpC,IAAI,CAACnE,SAAS,EAAE,CAACgT,iBAAiB;IAClC,CAACpT,CAAS,KAAiB;MACzBxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMmU,SAAS,GAAG,IAAI,CAACnU,IAAI,KAAK,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;MAC1D,OAAO,IAAI,CAAC8Q,qBAAqB,CAAClN,IAAI,CAACwQ,GAAG,CAACtT,CAAC,CAAC,EAAEqT,SAAS,CAAC;IAC3D,CAAC;;EAEL,CAAC;;EAESE,eAAe,CAACvT,CAAS,EAAc;IAC/C,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACmT,aAAa,CAAC;EAC3E;;EAEA;;;EAGiBK,cAAc,GAAuB;IACpD/O,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B;MACA,MAAMyT,OAAO,GAAG,IAAI,CAACC,gBAAgB,CAAC1T,CAAC,CAAC;MACxC,OAAO,IAAI,CAAC6P,sBAAsB;MAChC,IAAI,CAACQ,gBAAgB,CAAC,IAAI,CAACsD,WAAW,CAAC3T,CAAC,CAAC,EAAE,IAAI,CAAC2T,WAAW,CAACF,OAAO,CAAC,CAAC;MACrE,GAAG,CACJ;;IACH;EACF,CAAC;;EAESG,gBAAgB,CAAC5T,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACwT,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBK,eAAe,GAAyB;IACvDpP,IAAI,EAAE,CAACE,CAAoB,EAAEC,CAAoB,KAAe;MAC9DpI,MAAM,CAACmI,CAAC,CAAClF,MAAM,KAAK,CAAC,EAAG,mCAAkCkF,CAAC,CAAClF,MAAO,eAAc,CAAC;MAClFjD,MAAM,CAACoI,CAAC,CAACnF,MAAM,KAAK,CAAC,EAAG,mCAAkCmF,CAAC,CAACnF,MAAO,eAAc,CAAC;;MAElF;MACA;MACA;MACA;;MAEA,MAAMqU,EAAE,GAAG,IAAI,CAAClE,mBAAmB;MACjC,IAAI,CAACC,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC;MACvC,IAAI,CAACiL,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,CACxC;;MACD,MAAMmP,EAAE,GAAG,IAAI,CAACnE,mBAAmB;MACjC,IAAI,CAACC,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC;MACvC,IAAI,CAACiL,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,CACxC;;MACD,MAAMoP,EAAE,GAAG,IAAI,CAACpE,mBAAmB;MACjC,IAAI,CAACC,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC;MACvC,IAAI,CAACiL,sBAAsB,CAAClL,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,CACxC;;MACD,OAAO,CAACkP,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACrB;EACF,CAAC;;EAESC,iBAAiB,CAACtP,CAAoB,EAAEC,CAAoB,EAAY;IAChFpI,MAAM,CAACmI,CAAC,CAAClF,MAAM,KAAK,CAAC,EAAG,gCAA+B,CAAC;IACxDjD,MAAM,CAACoI,CAAC,CAACnF,MAAM,KAAK,CAAC,EAAG,gCAA+B,CAAC;IACxD,OAAO,IAAI,CAACmO,uBAAuB,CAAC,IAAI,CAAC1Q,QAAQ,CAACyH,CAAC,CAAC,EAAE,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC,EAAE,IAAI,CAACiP,eAAe,CAAC;EAC/F;;EAEA;;;EAGiBK,iBAAiB,GAAuB;IACvDzP,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAAC6P,sBAAsB,CAAC7P,CAAC,EAAE,qBAAqB,CAAC;IAC9D;EACF,CAAC;;EAESmU,mBAAmB,CAACnU,CAAS,EAAc;IACnD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACkU,iBAAiB,CAAC;EAC/E;;EAEA;;;EAGA;AACF;AACA;AACA;AACA;AACA;EACUE,QAAQ,CAAC7Q,CAAkB,EAAE8Q,GAAW,EAAEC,GAAW,EAAmB;IAC9E,MAAMC,GAAG,GAAGhR,CAAC,CAAC9D,MAAM;IACpBjD,MAAM,CAAC+G,CAAC,CAAC9D,MAAM,KAAK8D,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM,EAAG,iDAAgD,CAAC;IACnFjD,MAAM,CAAC6X,GAAG,IAAI,CAAC,IAAIA,GAAG,GAAGE,GAAG,EAAG,OAAMF,GAAI,kCAAiCE,GAAI,IAAG,CAAC;IAClF/X,MAAM,CAAC8X,GAAG,IAAI,CAAC,IAAIA,GAAG,GAAGC,GAAG,EAAG,OAAMD,GAAI,+BAA8BC,GAAI,IAAG,CAAC;;IAE/E,MAAMlR,MAAkB,GAAG,CAAC,GAAGjB,KAAK,CAACmS,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC3T,GAAG,CAAC,CAAAoD,CAAC,KAAI,CAAC,GAAG5B,KAAK,CAACmS,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;;IAE5E,MAAMC,WAA8B,GAAG,CAAC,GAAGpS,KAAK,CAACmS,GAAG,CAAC,CAACE,IAAI,EAAE,CAAC,CAACrQ,MAAM,CAAC,CAAApB,CAAC,KAAIA,CAAC,KAAKqR,GAAG,CAAC;IACpF,MAAMK,WAA8B,GAAG,CAAC,GAAGtS,KAAK,CAACmS,GAAG,CAAC,CAACE,IAAI,EAAE,CAAC,CAACrQ,MAAM,CAAC,CAAApB,CAAC,KAAIA,CAAC,KAAKsR,GAAG,CAAC;;IAEpFE,WAAW,CAAC3R,OAAO,CAAC,CAACW,CAAC,EAAEzC,CAAC,KAAK;MAC5B2T,WAAW,CAAC7R,OAAO,CAAC,CAACkB,CAAC,EAAEE,CAAC,KAAK;QAC5BZ,MAAM,CAACtC,CAAC,CAAC,CAACkD,CAAC,CAAC,GAAGV,CAAC,CAACC,CAAC,CAAC,CAACO,CAAC,CAAC;MACxB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOV,MAAM;EACf;;EAEA;EACQsR,sBAAsB,CAACpR,CAAkB,EAAc;IAC7D/G,MAAM;IACJ+G,CAAC,CAAC9D,MAAM,KAAK8D,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM,IAAI8D,CAAC,CAAC9D,MAAM,KAAK,CAAC;IACzC,iDAAgD,CAClD;;IACD,OAAO,IAAI,CAACmQ,mBAAmB;IAC7B,IAAI,CAACC,sBAAsB,CAACtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,IAAI,CAACsM,sBAAsB,CAACtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC9C;;EACH;;EAEA;EACQqR,sBAAsB,CAACrR,CAAkB,EAAc;IAC7D/G,MAAM;IACJ+G,CAAC,CAAC9D,MAAM,KAAK8D,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM,IAAI8D,CAAC,CAAC9D,MAAM,KAAK,CAAC;IACzC,iDAAgD,CAClD;;;IAED;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMoV,CAAC,GAAG,IAAI,CAAChF,sBAAsB;IACnCtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACP,IAAI,CAACoR,sBAAsB,CAAC,IAAI,CAACP,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;IACD,MAAMuR,CAAC,GAAG,IAAI,CAACjF,sBAAsB;IACnC,CAACtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACR,IAAI,CAACoR,sBAAsB,CAAC,IAAI,CAACP,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;IACD,MAAMwR,CAAC,GAAG,IAAI,CAAClF,sBAAsB;IACnCtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACP,IAAI,CAACoR,sBAAsB,CAAC,IAAI,CAACP,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;;IAED;IACA;IACA,MAAMyR,YAAsC,GAAG5X,qBAAqB,CAAC,CAACyX,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC;IAC/E,OAAO,IAAI,CAACrS,aAAa;IACvB,GAAGsS,YAAY,CAACpU,GAAG,CAAC,CAAA4B,CAAC;IACnBA,CAAC,CAACiF,MAAM,CAAC,CAACwN,IAAgB,EAAEC,GAAe,KAAK,IAAI,CAAC7E,gBAAgB,CAAC4E,IAAI,EAAEC,GAAG,CAAC,CAAC,CAClF,CACF;;;EACH;;EAEA;EACQC,sBAAsB,CAAC5R,CAAkB,EAAc;IAC7D/G,MAAM;IACJ+G,CAAC,CAAC9D,MAAM,KAAK8D,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM,IAAI8D,CAAC,CAAC9D,MAAM,KAAK,CAAC;IACzC,iDAAgD,CAClD;;;IAED;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMoV,CAAC,GAAG,IAAI,CAAChF,sBAAsB;IACnCtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACP,IAAI,CAACqR,sBAAsB,CAAC,IAAI,CAACR,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;IACD,MAAMuR,CAAC,GAAG,IAAI,CAACjF,sBAAsB;IACnC,CAACtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACR,IAAI,CAACqR,sBAAsB,CAAC,IAAI,CAACR,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;IACD,MAAMwR,CAAC,GAAG,IAAI,CAAClF,sBAAsB;IACnCtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACP,IAAI,CAACqR,sBAAsB,CAAC,IAAI,CAACR,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;IACD,MAAM6R,CAAC,GAAG,IAAI,CAACvF,sBAAsB;IACnC,CAACtM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACR,IAAI,CAACqR,sBAAsB,CAAC,IAAI,CAACR,QAAQ,CAAC7Q,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CACpD;;;IAED;IACA;IACA,MAAMyR,YAAsC,GAAG5X,qBAAqB,CAAC,CAACyX,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEK,CAAC,CAAC,CAAC;IAClF,OAAO,IAAI,CAAC1S,aAAa;IACvB,GAAGsS,YAAY,CAACpU,GAAG,CAAC,CAAA4B,CAAC;IACnBA,CAAC,CAACiF,MAAM,CAAC,CAACwN,IAAgB,EAAEC,GAAe,KAAK,IAAI,CAAC7E,gBAAgB,CAAC4E,IAAI,EAAEC,GAAG,CAAC,CAAC,CAClF,CACF;;;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYG,uBAAuB,CAAC1Q,CAAkB,EAAc;IAChE,MAAM4P,GAAG,GAAG5P,CAAC,CAAClF,MAAM;IACpBjD,MAAM;IACJmI,CAAC,CAAC,CAAC,CAAC,CAAClF,MAAM,KAAK8U,GAAG,KAAKA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,CAAC;IAC3D,gEAA+D,CACjE;;IACD,QAAQA,GAAG;MACT,KAAK,CAAC;QACJ,OAAO,IAAI,CAACI,sBAAsB,CAAChQ,CAAC,CAAC;MACvC,KAAK,CAAC;QACJ,OAAO,IAAI,CAACiQ,sBAAsB,CAACjQ,CAAC,CAAC;MACvC,KAAK,CAAC;QACJ,OAAO,IAAI,CAACwQ,sBAAsB,CAACxQ,CAAC,CAAC,CAAC;;IAE1ClI,WAAW;IACT,sFAAsF,CACvF;;EACH;;EAEA;;;EAGiB6Y,wBAAwB,GAA2B;IAClE7Q,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAAC2Q,cAAc,CAAC,IAAI,CAAC3F,mBAAmB,CAACjL,CAAC,EAAEC,CAAC,CAAC,CAAC;IAC5D;EACF,CAAC;;EAEgB4Q,wBAAwB,GAA2B;IAClE/Q,IAAI,EAAE,CAACE,CAAoB,EAAEC,CAAoB,KAAiB;MAChE,OAAO,IAAI,CAAC2Q,cAAc;MACxB,IAAI,CAAC1H,4CAA4C;MAC/C,IAAI,CAAC3Q,QAAQ,CAACyH,CAAC,CAAC;MAChB,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC;MAChB,IAAI,CAAC6Q,qBAAqB,CAC3B,CACF;;;IACH;EACF,CAAC;;EAESC,oBAAoB;EAC5B/Q,CAA6B;EAC7BC,CAA6B;EACjB;IACZ,IAAID,CAAC,YAAYvC,KAAK,IAAIwC,CAAC,YAAYxC,KAAK,EAAE;MAC5C5F,MAAM;MACJmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM;MACpB,2EAA0E,CAC5E;;MACD,OAAO,IAAI,CAAC+N,yBAAyB;MACnC,IAAI,CAACtQ,QAAQ,CAACyH,CAAC,CAAC;MAChB,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC;MAChB,IAAI,CAAC4Q,wBAAwB,CAC9B;;IACH,CAAC,MAAM,IAAI,EAAE7Q,CAAC,YAAYvC,KAAK,CAAC,IAAI,EAAEwC,CAAC,YAAYxC,KAAK,CAAC,EAAE;MACzD,OAAO,IAAI,CAACgL,yBAAyB;MACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;MAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;MAClB,IAAI,CAAC0Q,wBAAwB,CAC9B;;IACH;IACA7Y,WAAW;IACR,wFAAuF,CACzF;;EACH;;EAEA;;;;;;EAMA;EACQkZ,yBAAyB,GAA2B;IAC1D,MAAMvV,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;IAClC,MAAMqR,QAAQ,GAAG,CAAC,IAAI,CAAChQ,UAAU,CAAC,CAACrB,SAAS,CAACC,QAAQ,CAACE,GAAG,EAAEH,SAAS,CAACI,QAAQ,CAACC,GAAG,CAAC,CAAC,CAAC;IACpF,MAAMiR,QAAQ;IACZ,IAAI,CAACxS,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,UAAU;IAC3C,CAAC,IAAI,CAACuC,UAAU,CAAC,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACtF,CAAC,IAAI,CAACA,UAAU,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACxF,OAAO;MACLgD,IAAI,EAAE,IAAI,CAACC,+BAA+B;MACxC;QACEC,CAAC,EAAE8M,QAAQ;QACX7M,CAAC,EAAE8M;MACL,CAAC;MACD,CAAC/M,CAAS,EAAEC,CAAS,KAAiB;QACpC,IAAIA,CAAC,KAAK,CAAC,EAAE;UACX,OAAOxE,SAAS,CAACa,iBAAiB;QACpC;QACA,OAAO,IAAI,CAACoQ,WAAW,CAAC1M,CAAC,GAAGC,CAAC,EAAE,GAAG,CAAC;MACrC,CAAC,CACF;;MACDsI,OAAO,EAAE,CAACvI,CAAa,EAAEC,CAAa,KAA+B;QACnE;QACA,IAAIA,CAAC,CAAC7E,QAAQ,CAAC,CAAC,CAAC,EAAE;UACjB6E,CAAC,GAAG,IAAI,CAACnD,UAAU,CAAC,CAAC,CAAC;QACxB;QACA,OAAO,CAACkD,CAAC,EAAEC,CAAC,CAAC;MACf;IACF,CAAC;EACH;;EAEUgR,oBAAoB,CAACjR,CAAsB,EAAEC,CAAsB,EAAc;IACzF,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC+Q,yBAAyB,EAAE,CACjC;;EACH;;EAEA;;;;;;EAMiBE,aAAa,GAA2B;IACvDpR,IAAI,EAAE,CAACE,CAAoB,EAAEC,CAAoB,KAAiB;MAChE;MACA,MAAMkR,eAAe,GAAG,IAAI,CAACjI,4CAA4C;MACvE,IAAI,CAAC3Q,QAAQ,CAACyH,CAAC,CAAC;MAChB,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC;MAChB,IAAI,CAACmR,wBAAwB,CAC9B;;;MAED;MACA,IAAID,eAAe,CAACrW,MAAM,KAAK,CAAC,EAAE;QAChC,OAAO,IAAI,CAAC4Q,gBAAgB,CAACyF,eAAe,CAAC,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC,CAAC,CAAC;MACtE;;MAEA;MACA;MACA;MACA;MACA,MAAMd,YAAsC,GAAG5X,qBAAqB,CAAC0Y,eAAe,CAAC;MACrF,OAAO,IAAI,CAACpT,aAAa;MACvB,GAAGsS,YAAY,CAACpU,GAAG,CAAC,CAAA4B,CAAC,KAAIA,CAAC,CAACiF,MAAM,CAAC,CAACwN,IAAI,EAAEC,GAAG,KAAK,IAAI,CAAC7E,gBAAgB,CAAC4E,IAAI,EAAEC,GAAG,CAAC,CAAC,CAAC,CACpF;;IACH;EACF,CAAC;;EAESc,eAAe;EACvBrR,CAA4C;EAC5CC,CAA4C;EAChC;IACZpI,MAAM,CAACmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM,EAAG,oDAAmD,CAAC;IACnF,OAAO,IAAI,CAAC+N,yBAAyB,CAAC,IAAI,CAACtQ,QAAQ,CAACyH,CAAC,CAAC,EAAE,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC,EAAE,IAAI,CAACiR,aAAa,CAAC;EAC/F;;EAEA;;;;;;EAMiBI,aAAa,GAAuB;IACnDxR,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/BxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMkS,SAAS,GAAG,IAAI,CAAClS,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG4D,IAAI,CAAC+L,GAAG,CAAC7O,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG8C,IAAI,CAAC+L,GAAG,CAAC7O,CAAC,CAAC;MACjF,OAAO,IAAI,CAACqR,WAAW,CAACvO,IAAI,CAACoT,GAAG,CAAClW,CAAC,CAAC,EAAEoR,SAAS,CAAC;IACjD;EACF,CAAC;;EAES+E,eAAe,CAACxR,CAAsB,EAAc;IAC5D,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAACsR,aAAa,CAAC;EAC3E;;EAEA;;;EAGiBG,cAAc,GAAuB;IACpD3R,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/BxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMkS,SAAS,GAAG,IAAI,CAAClS,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG4D,IAAI,CAAC+L,GAAG,CAAC7O,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG8C,IAAI,CAAC+L,GAAG,CAAC7O,CAAC,CAAC;MACjF,OAAO,IAAI,CAACqR,WAAW,CAACvO,IAAI,CAACuT,GAAG,CAAC,CAAC,EAAErW,CAAC,CAAC,EAAEoR,SAAS,CAAC;IACpD;EACF,CAAC;;EAESkF,gBAAgB,CAAC3R,CAAsB,EAAc;IAC7D,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAACyR,cAAc,CAAC;EAC5E;;EAEA;;;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYG,wBAAwB;EAChC5R,CAAoB;EACpBC,CAAoB;EACpBgH,CAAoB;EACM;IAC1B,MAAM4K,KAAK,GAAG,IAAI,CAACtZ,QAAQ,CAACyH,CAAC,CAAC;IAC9B;IACA;IACA;IACA,MAAM8R,UAAU,GAAG,IAAI,CAAC9I,kCAAkC,CAAC6I,KAAK,EAAE;MAChE/R,IAAI,EAAE,CAAC1D,CAAS,KAAiB;QAC/B,OAAO,IAAI,CAACU,UAAU,CAACV,CAAC,CAAC;MAC3B;IACF,CAAC,CAAC;IACF,MAAM2V,UAAU,GAAG,IAAI,CAAC/I,kCAAkC,CAAC6I,KAAK,EAAE,IAAI,CAACG,kBAAkB,CAAC;;IAE1F,MAAMC,YAAY,GAAG,IAAI,CAACC,WAAW,CAACjL,CAAC,EAAEhH,CAAC,CAAC;;IAE3C,MAAMmE,OAAiC,GAAG,EAAE;;IAE5C,IAAI,CAAC6N,YAAY,CAAClW,QAAQ,EAAE,EAAE;MAC5B;MACA;MACA;MACA;MACA;MACA;MACA;;MAEAqI,OAAO,CAACpB,IAAI,CAACP,SAAS,CAAC;IACzB;;IAEA;IACA;IACA,IAAIwP,YAAY,CAACrX,KAAK,GAAG,CAAC,IAAIqX,YAAY,CAACpX,GAAG,GAAG,CAAC,EAAE;MAClDuJ,OAAO,CAACpB,IAAI,CAAC8O,UAAU,CAAC;IAC1B;;IAEA,IAAIG,YAAY,CAACrX,KAAK,IAAI,CAAC,IAAIqX,YAAY,CAACpX,GAAG,IAAI,CAAC,EAAE;MACpDuJ,OAAO,CAACpB,IAAI,CAAC+O,UAAU,CAAC;IAC1B;;IAEAla,MAAM;IACJuM,OAAO,CAACtJ,MAAM,GAAG,CAAC,IAAIsJ,OAAO,CAACnG,KAAK,CAAC,CAAAmB,CAAC,KAAIA,CAAC,KAAKqD,SAAS,CAAC;IACxD,0GAAyG,CAC3G;;IACD,OAAO2B,OAAO;EAChB;;EAEA;;;;;;;EAOiB+N,eAAe,GAAuB;IACrDrS,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACiP,wBAAwB,CAACnM,IAAI,CAACiU,KAAK,CAAC/W,CAAC,CAAC,CAAC;IACrD;EACF,CAAC;;EAESgX,iBAAiB,CAAChX,CAAS,EAAc;IACjD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC8W,eAAe,CAAC;EAC7E;;EAEA;;;EAGiBG,aAAa,GAA6B;IACzDxS,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,EAAEgH,CAAS,KAAiB;MACrD,OAAO,IAAI,CAACyE,gBAAgB,CAAC,IAAI,CAACR,sBAAsB,CAAClL,CAAC,EAAEC,CAAC,CAAC,EAAEgH,CAAC,CAAC;IACpE;EACF,CAAC;;EAESsL,eAAe,CAACvS,CAAS,EAAEC,CAAS,EAAEgH,CAAS,EAAc;IACrE,OAAO,IAAI,CAAC0B,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACnD,UAAU,CAACmK,CAAC,CAAC;IAClB,IAAI,CAACqL,aAAa,CACnB;;EACH;;EAEA;;;EAGiBE,eAAe,GAAuB;IACrD1S,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B;MACA;MACA;MACA;MACA;MACA;MACA,MAAMqD,MAAM,GAAG,IAAI,CAACuM,mBAAmB,CAAC5P,CAAC,EAAE,IAAI,CAACoX,aAAa,CAACpX,CAAC,CAAC,CAAC;MACjExD,MAAM;MACJ;MACA;MACA,IAAI,CAACiF,UAAU,CAAC,CAAC,IAAI,CAACrB,SAAS,EAAE,CAACC,QAAQ,CAACC,SAAS,CAACC,GAAG,EAAE,GAAG,CAAC,CAAC,CAACR,QAAQ,CAACsD,MAAM,CAAC;MAC/E,SAAQrD,CAAE,eAAcqD,MAAO,2CAA0C,CAC3E;;MACD,IAAIA,MAAM,CAACtD,QAAQ,CAAC,CAAC,CAAC,EAAE;QACtB;QACA;QACA;QACA;QACA,OAAO,IAAI,CAAC2C,aAAa,CAACW,MAAM,EAAE,IAAI,CAAC5B,UAAU,CAAC,IAAI,CAACrB,SAAS,EAAE,CAACI,QAAQ,CAAC6W,aAAa,CAAC,CAAC;MAC7F;MACA,OAAOhU,MAAM;IACf;EACF,CAAC;;EAESiU,iBAAiB,CAACtX,CAAS,EAAc;IACjD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACmX,eAAe,CAAC;EAC7E;;EAEA;;;EAGiBI,qBAAqB,GAAuB;IAC3D9S,IAAI,EAAE,IAAI,CAACF,2BAA2B;IACpC,IAAI,CAACnE,SAAS,EAAE,CAACoX,uBAAuB;IACxC,CAACxX,CAAS,KAAiB;MACzB,OAAO,IAAI,CAACqR,WAAW,CAAC,CAAC,GAAGvO,IAAI,CAAC2U,IAAI,CAACzX,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9C,CAAC;;EAEL,CAAC;;EAES0X,uBAAuB,CAAC1X,CAAsB,EAAc;IACpE,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACuX,qBAAqB,CAAC;EACnF;;EAEA;;;EAGiBI,eAAe,GAA2B;IACzDlT,IAAI,EAAE,CAACmT,EAAU,EAAEC,EAAU,KAAK;MAChCrb,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD1C,MAAM,CAACkD,MAAM,CAACoY,SAAS,CAACD,EAAE,CAAC,EAAE,8CAA8C,CAAC;MAC5E,MAAME,IAAI,GAAG,IAAI,CAAC7Y,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,EAAE;MAC3C;MACA,IAAI2Y,EAAE,GAAGE,IAAI,GAAG,CAAC,EAAE;QACjB,OAAO,IAAI,CAAC3X,SAAS,EAAE,CAACa,iBAAiB;MAC3C;MACA;MACA;MACA;MACA;MACA;MACA,MAAMoC,MAAM,GAAGuU,EAAE,GAAG,CAAC,IAAIC,EAAE;MAC3B,IAAI,CAACnY,MAAM,CAACgB,QAAQ,CAAC2C,MAAM,CAAC,EAAE;QAC5B;QACA,OAAO,IAAI,CAACjD,SAAS,EAAE,CAACa,iBAAiB;MAC3C;MACA;MACA;MACA;MACA;MACA;MACA,OAAO,IAAI,CAACgO,wBAAwB,CAAC5L,MAAM,CAAC;IAC9C;EACF,CAAC;;EAES2U,iBAAiB,CAACJ,EAAU,EAAEC,EAAU,EAAc;IAC9D;IACA;IACA,OAAO,IAAI,CAAC/M,6BAA6B,CAAC8M,EAAE,EAAE;MAC5CnT,IAAI,EAAE,CAACmT,EAAU,KAAK,IAAI,CAACD,eAAe,CAAClT,IAAI,CAACmT,EAAE,EAAEC,EAAE;IACxD,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGmBI,sBAAsB,GAAuB;IAC5DxT,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAAC2P,YAAY,CAAC,IAAI,CAACE,sBAAsB,CAAC7P,CAAC,EAAEA,CAAC,CAAC,CAAC;IAC7D;EACF,CAAC;;EAEgBkY,sBAAsB,GAAuB;IAC5DzT,IAAI,EAAE,CAACzE,CAAoB,KAAiB;MAC1C,OAAO,IAAI,CAAC2P,YAAY,CAAC,IAAI,CAACkH,WAAW,CAAC7W,CAAC,EAAEA,CAAC,CAAC,CAAC;IAClD;EACF,CAAC;;EAESmY,kBAAkB,CAACnY,CAAqD,EAAc;IAC9F,IAAIA,CAAC,YAAYoC,KAAK,EAAE;MACtB,OAAO,IAAI,CAACmL,qBAAqB,CAAC,IAAI,CAACrQ,QAAQ,CAAC8C,CAAC,CAAC,EAAE,IAAI,CAACkY,sBAAsB,CAAC;IAClF,CAAC,MAAM;MACL,OAAO,IAAI,CAACjL,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACiY,sBAAsB,CAAC;IACpF;EACF;;EAEA;;;;;EAKiBG,aAAa,GAAuB;IACnD3T,IAAI,EAAE,IAAI,CAACF,2BAA2B;IACpC,IAAI,CAACnE,SAAS,EAAE,CAACoX,uBAAuB;IACxC,CAACxX,CAAS,KAAiB;MACzBxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMmU,SAAS,GAAG,IAAI,CAACnU,IAAI,KAAK,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;MAC1D,IAAIc,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAI,GAAG,EAAE;QACxB,OAAO,IAAI,CAACgQ,qBAAqB,CAAClN,IAAI,CAACuV,GAAG,CAACrY,CAAC,CAAC,EAAEqT,SAAS,CAAC;MAC3D;MACA,OAAO,IAAI,CAAChC,WAAW,CAACvO,IAAI,CAACuV,GAAG,CAACrY,CAAC,CAAC,EAAE,CAAC,CAAC;IACzC,CAAC;;EAEL,CAAC;;EAESsY,eAAe,CAAC3T,CAAsB,EAAc;IAC5D,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAACyT,aAAa,CAAC;EAC3E;;EAEA;;;EAGiBG,cAAc,GAAuB;IACpD9T,IAAI,EAAE,IAAI,CAACF,2BAA2B;IACpC,IAAI,CAACnE,SAAS,EAAE,CAACoX,uBAAuB;IACxC,CAACxX,CAAS,KAAiB;MACzBxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMmU,SAAS,GAAG,IAAI,CAACnU,IAAI,KAAK,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;MAC1D,IAAIc,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAI,GAAG,EAAE;QACxB,OAAO,IAAI,CAACgQ,qBAAqB,CAAClN,IAAI,CAAC0V,IAAI,CAACxY,CAAC,CAAC,EAAEqT,SAAS,CAAC;MAC5D;MACA,OAAO,IAAI,CAAChC,WAAW,CAACvO,IAAI,CAAC0V,IAAI,CAACxY,CAAC,CAAC,EAAE,CAAC,CAAC;IAC1C,CAAC;;EAEL,CAAC;;EAESyY,gBAAgB,CAAC9T,CAAsB,EAAc;IAC7D,OAAO,IAAI,CAACsI,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAAC4T,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBG,aAAa,GAA2B;IACvDjU,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C;MACA,IAAI,IAAI,CAACP,WAAW,CAACM,CAAC,CAAC,IAAI,IAAI,CAACN,WAAW,CAACO,CAAC,CAAC,EAAE;QAC9C,OAAO,IAAI,CAACqK,wBAAwB;QAClC,IAAI,CAACvM,aAAa,CAAC,IAAI,CAACjB,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC,CAAC,CAC3D;;MACH;;MAEA,OAAO,IAAI,CAACqK,wBAAwB,CAACnM,IAAI,CAACrC,GAAG,CAACkE,CAAC,EAAEC,CAAC,CAAC,CAAC;IACtD;EACF,CAAC;;EAES+T,eAAe,CAAChU,CAAsB,EAAEC,CAAsB,EAAc;IACpF,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC8T,aAAa,CACnB;;EACH;;EAEA;;;;;;EAMiBE,aAAa,GAA2B;IACvDnU,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C;MACA,IAAI,IAAI,CAACP,WAAW,CAACM,CAAC,CAAC,IAAI,IAAI,CAACN,WAAW,CAACO,CAAC,CAAC,EAAE;QAC9C,OAAO,IAAI,CAACqK,wBAAwB;QAClC,IAAI,CAACvM,aAAa,CAAC,IAAI,CAACjB,UAAU,CAACkD,CAAC,CAAC,EAAE,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC,CAAC,CAC3D;;MACH;;MAEA,OAAO,IAAI,CAACqK,wBAAwB,CAACnM,IAAI,CAACvC,GAAG,CAACoE,CAAC,EAAEC,CAAC,CAAC,CAAC;IACtD;EACF,CAAC;;EAESiU,eAAe,CAAClU,CAAsB,EAAEC,CAAsB,EAAc;IACpF,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACgU,aAAa,CACnB;;EACH;;EAEA;;;;;;EAMiBE,sBAAsB,GAA6B;IAClErU,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,EAAEgH,CAAS,KAAiB;MACrD;MACA;MACA,MAAMmN,CAAC,GAAG,IAAI,CAAClJ,sBAAsB,CAAC,IAAI,CAACD,mBAAmB,CAAChL,CAAC,EAAED,CAAC,CAAC,EAAEiH,CAAC,CAAC;MACxE,OAAO,IAAI,CAACyE,gBAAgB,CAAC1L,CAAC,EAAEoU,CAAC,CAAC;IACpC;EACF,CAAC;;EAESC,wBAAwB,CAACrU,CAAS,EAAEC,CAAS,EAAEgH,CAAS,EAAc;IAC9E,OAAO,IAAI,CAAC0B,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACnD,UAAU,CAACmK,CAAC,CAAC;IAClB,IAAI,CAACkN,sBAAsB,CAC5B;;EACH;;EAEA;;;EAGiBG,oBAAoB,GAA6B;IAChExU,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,EAAEgH,CAAS,KAAiB;MACrD;MACA;MACA,MAAMmN,CAAC,GAAG,IAAI,CAAClJ,sBAAsB,CAAClL,CAAC,EAAE,IAAI,CAACiL,mBAAmB,CAAC,GAAG,EAAEhE,CAAC,CAAC,CAAC;MAC1E,MAAMjN,CAAC,GAAG,IAAI,CAACkR,sBAAsB,CAACjL,CAAC,EAAEgH,CAAC,CAAC;MAC3C,OAAO,IAAI,CAACyE,gBAAgB,CAAC0I,CAAC,EAAEpa,CAAC,CAAC;IACpC;EACF,CAAC;;EAESua,sBAAsB,CAACvU,CAAS,EAAEC,CAAS,EAAEgH,CAAS,EAAc;IAC5E,OAAO,IAAI,CAAC0B,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACnD,UAAU,CAACmK,CAAC,CAAC;IAClB,IAAI,CAACqN,oBAAoB,CAC1B;;EACH;;EAEA;;;;;;EAMUE,gBAAgB,CAACnZ,CAAS,EAA4C;IAC9E,MAAMoZ,KAAK,GAAG,IAAI,CAACnK,wBAAwB,CAACjP,CAAC,GAAG,GAAG,CAAC;IACpD,MAAM8R,KAAK,GAAG,IAAI,CAAC7C,wBAAwB,CAACjP,CAAC,GAAIA,CAAC,GAAG,GAAI,CAAC;IAC1D,OAAO,EAAEoZ,KAAK,EAAEtH,KAAK,CAAC,CAAC;EACzB;;EAEA;;;EAGiBuH,qBAAqB,GAAG;IACvC5U,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAACqK,wBAAwB,CAACtK,CAAC,GAAGC,CAAC,CAAC;IAC7C;EACF,CAAC;;EAEgBmR,wBAAwB,GAA2B;IAClEtR,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAACuG,iCAAiC,CAACxG,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACyU,qBAAqB,CAAC;IACjF;EACF,CAAC;;EAESC,0BAA0B,CAAC3U,CAAsB,EAAEC,CAAsB,EAAc;IAC/F,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAACmR,wBAAwB,CAC9B;;EACH;;EAEA;;;;;;EAMA;AACF;AACA;AACA;EACUwD,sBAAsB,CAACvX,CAAoB,EAAEwB,CAAsB,EAAY;IACrF,OAAO,IAAI,CAACtG,QAAQ,CAAC8E,CAAC,CAACpB,GAAG,CAAC,CAAA+D,CAAC,KAAI,IAAI,CAACkL,sBAAsB,CAAClL,CAAC,EAAEnB,CAAC,CAAC,CAAC,CAAC;EACrE;;EAEUgW,sCAAsC,CAACrP,GAAoB,EAAEtB,MAAc,EAAY;IAC/F,MAAMyF,IAAI,GAAGnE,GAAG,CAAC1K,MAAM;IACvB,MAAM8O,IAAI,GAAGpE,GAAG,CAAC,CAAC,CAAC,CAAC1K,MAAM;IAC1B,OAAO,IAAI,CAACxC,QAAQ;IAClBsB,gBAAgB;IACdd,cAAc,CAAC0M,GAAG,CAAC,CAACvJ,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAAC6M,sBAAsB,CAAC7M,CAAC,EAAE6F,MAAM,CAAC,CAAC;IACpEyF,IAAI;IACJC,IAAI,CACL,CACF;;;EACH;;EAEA;;;;;;EAMUkL,sCAAsC,CAAC5Q,MAAc,EAAEsB,GAAoB,EAAY;IAC/F,OAAO,IAAI,CAACqP,sCAAsC,CAACrP,GAAG,EAAEtB,MAAM,CAAC;EACjE;;EAEA;;;;;;EAMU6Q,sCAAsC;EAC9CC,KAAsB;EACtBC,KAAsB;EACZ;IACV,MAAMC,MAAM,GAAGF,KAAK,CAACla,MAAM;IAC3B,MAAMqa,MAAM,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACla,MAAM;IAC9B,MAAMsa,MAAM,GAAGH,KAAK,CAACna,MAAM;IAC3B,MAAMua,MAAM,GAAGJ,KAAK,CAAC,CAAC,CAAC,CAACna,MAAM;IAC9BjD,MAAM,CAACqd,MAAM,KAAKG,MAAM,EAAG,OAAMH,MAAO,IAAGC,MAAO,SAAQC,MAAO,IAAGC,MAAO,kBAAiB,CAAC;;IAE7F,MAAMC,YAAY,GAAG,IAAI,CAACC,iBAAiB,CAACP,KAAK,CAAC;;IAElD,MAAMtW,MAAsB,GAAG,CAAC,GAAGjB,KAAK,CAAC2X,MAAM,CAAC,CAAC,CAACnZ,GAAG,CAAC,CAAAoD,CAAC,KAAI,CAAC,GAAG5B,KAAK,CAAC0X,MAAM,CAAC,CAAC,CAAC;IAC9EF,KAAK,CAAC/W,OAAO,CAAC,CAAC+B,CAAC,EAAE7D,CAAC,KAAK;MACtBkZ,YAAY,CAACpX,OAAO,CAAC,CAAC8B,CAAC,EAAEV,CAAC,KAAK;QAC7BZ,MAAM,CAACtC,CAAC,CAAC,CAACkD,CAAC,CAAC,GAAG,IAAI,CAAC4S,WAAW,CAAClS,CAAC,EAAEC,CAAC,CAAC;MACvC,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF,OAAQvB,MAAM;EAChB;;EAEA;;;;;;EAMU8W,sCAAsC;EAC9CxV,CAAkB;EAClBC,CAAoB;EACV;IACV,MAAM0J,IAAI,GAAG3J,CAAC,CAAClF,MAAM;IACrB,MAAM8O,IAAI,GAAG5J,CAAC,CAAC,CAAC,CAAC,CAAClF,MAAM;IACxBjD,MAAM,CAACoI,CAAC,CAACnF,MAAM,KAAK6O,IAAI,EAAG,OAAMA,IAAK,IAAGC,IAAK,SAAQ3J,CAAC,CAACnF,MAAO,kBAAiB,CAAC;;IAEjF,OAAO,IAAI,CAACya,iBAAiB,CAACvV,CAAC,CAAC,CAAC/D,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAAC6T,WAAW,CAAC7T,CAAC,EAAE4B,CAAC,CAAC,CAAC;EACnE;;EAEA;;;;;;EAMUwV,sCAAsC;EAC9CzV,CAAoB;EACpBC,CAAkB;EACR;IACV,MAAM0J,IAAI,GAAG1J,CAAC,CAACnF,MAAM;IACrB,MAAM8O,IAAI,GAAG3J,CAAC,CAAC,CAAC,CAAC,CAACnF,MAAM;IACxBjD,MAAM,CAACmI,CAAC,CAAClF,MAAM,KAAK8O,IAAI,EAAG,OAAM5J,CAAC,CAAClF,MAAO,SAAQ6O,IAAK,IAAGC,IAAK,kBAAiB,CAAC;;IAEjF,OAAO3J,CAAC,CAAChE,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAAC6T,WAAW,CAAClS,CAAC,EAAE3B,CAAC,CAAC,CAAC;EAC3C;;EAEA;;;;;;EAMiB2T,kBAAkB,GAAuB;IACxDlS,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACiP,wBAAwB,CAAC,CAACjP,CAAC,CAAC;IAC1C;EACF,CAAC;;EAESqa,oBAAoB,CAACra,CAAS,EAAc;IACpD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC2W,kBAAkB,CAAC;EAChF;;EAEA;;;EAGiB2D,mBAAmB,GAAqB;IACvD7V,IAAI,EAAE,CAACzE,CAAoB,KAAe;MACxC,MAAMP,MAAM,GAAG,IAAI,CAAC8V,cAAc,CAACvV,CAAC,CAAC;MACrC,OAAO,IAAI,CAAC9C,QAAQ,CAAC8C,CAAC,CAACY,GAAG,CAAC,CAAAoC,CAAC,KAAI,IAAI,CAACoP,gBAAgB,CAACpP,CAAC,EAAEvD,MAAM,CAAC,CAAC,CAAC;IACpE;EACF,CAAC;;EAES8a,qBAAqB,CAACva,CAAoB,EAAY;IAC9D,OAAO,IAAI,CAACyN,mBAAmB,CAAC,IAAI,CAACvQ,QAAQ,CAAC8C,CAAC,CAAC,EAAE,IAAI,CAACsa,mBAAmB,CAAC;EAC7E;;;;EAIiBE,aAAa,GAA2B;IACvD;IACA;IACA;IACA/V,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAAC6V,YAAY,CAAC,IAAI,CAAC5K,sBAAsB,CAACjL,CAAC,EAAE,IAAI,CAAC8V,YAAY,CAAC/V,CAAC,CAAC,CAAC,CAAC;IAChF;EACF,CAAC;;EAESgW,eAAe,CAAChW,CAAsB,EAAEC,CAAsB,EAAc;IACpF,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC4V,aAAa,CACnB;;EACH;;EAEA;;;;;;EAMiBI,iBAAiB,GAAuB;IACvDnW,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAAC6P,sBAAsB,CAAC7P,CAAC,EAAE,uBAAuB,CAAC;IAChE;EACF,CAAC;;EAES6a,mBAAmB,CAAC7a,CAAS,EAAc;IACnD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC4a,iBAAiB,CAAC;EAC/E;;EAEA;;;EAGiBE,iBAAiB,GAAyB;IACzDrW,IAAI,EAAE,CAACE,CAAoB,EAAEC,CAAoB,KAAe;MAC9DpI,MAAM;MACJmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM;MACpB,iCAAgCkF,CAAE,YAAWC,CAAE,sCAAqC,CACtF;;;MAED;MACA;MACA;MACA;MACA,MAAMmU,CAAC,GAAG,IAAI,CAAClJ,sBAAsB,CAAC,GAAG,EAAE,IAAI,CAACgH,WAAW,CAAClS,CAAC,EAAEC,CAAC,CAAC,CAAC;MAClE,MAAMmW,GAAG,GAAG,IAAI,CAACxB,sBAAsB,CAAC3U,CAAC,EAAEmU,CAAC,CAAC;MAC7C,OAAO,IAAI,CAAClL,4CAA4C;MACtD,IAAI,CAAC3Q,QAAQ,CAACyH,CAAC,CAAC;MAChBoW,GAAG;MACH,IAAI,CAACtF,qBAAqB,CAC3B;;IACH;EACF,CAAC;;EAESuF,mBAAmB,CAACrW,CAAoB,EAAEC,CAAoB,EAAY;IAClFpI,MAAM;IACJmI,CAAC,CAAClF,MAAM,KAAKmF,CAAC,CAACnF,MAAM;IACpB,sEAAqE,CACvE;;IACD,OAAO,IAAI,CAACmO,uBAAuB,CAAC,IAAI,CAAC1Q,QAAQ,CAACyH,CAAC,CAAC,EAAE,IAAI,CAACzH,QAAQ,CAAC0H,CAAC,CAAC,EAAE,IAAI,CAACkW,iBAAiB,CAAC;EACjG;;EAEA;;;;;;EAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACYG,mBAAmB,CAACla,CAAoB,EAAEpC,CAAoB,EAAEoF,CAAS,EAAY;IAC7FvH,MAAM;IACJuE,CAAC,CAACtB,MAAM,KAAKd,CAAC,CAACc,MAAM;IACpB,sEAAqE,CACvE;;;IAED,MAAMyb,SAAS,GAAG,IAAI,CAACrL,sBAAsB,CAAC9L,CAAC,EAAEA,CAAC,CAAC;IACnD,MAAMoX,GAAG,GAAG,IAAI,CAACtE,WAAW,CAAClY,CAAC,EAAEoC,CAAC,CAAC;IAClC,MAAMqa,WAAW,GAAG,IAAI,CAACvL,sBAAsB,CAACsL,GAAG,EAAEA,GAAG,CAAC;IACzD,MAAME,qBAAqB,GAAG,IAAI,CAACzL,mBAAmB,CAAC,CAAC,EAAEwL,WAAW,CAAC;IACtE,MAAMjZ,CAAC,GAAG,IAAI,CAACyN,mBAAmB;IAChC,GAAG;IACH,IAAI,CAACC,sBAAsB,CAACqL,SAAS,EAAEG,qBAAqB,CAAC,CAC9D;;;IAED,IAAI,CAAClZ,CAAC,CAACzB,QAAQ,EAAE,IAAIyB,CAAC,CAAChC,wBAAwB,EAAE,EAAE;MACjD;MACA,OAAO,IAAI,CAACC,SAAS,EAAE,CAACsN,eAAe,CAAC,IAAI,CAACxQ,QAAQ,CAAC6D,CAAC,CAAC,CAACtB,MAAM,CAAC;IAClE;;IAEA,IAAI0C,CAAC,CAAC3C,GAAG,GAAG,GAAG,EAAE;MACf;MACA,OAAO,IAAI,CAACY,SAAS,EAAE,CAACkb,UAAU,CAAC,IAAI,CAACpe,QAAQ,CAAC6D,CAAC,CAAC,CAACtB,MAAM,CAAC;IAC7D;;IAEA,MAAM8b,WAAW,GAAG,IAAI,CAAC1L,sBAAsB,CAACsL,GAAG,EAAEpX,CAAC,CAAC;IACvD,MAAMyX,MAAM,GAAG,IAAI,CAAC7L,YAAY,CAACxN,CAAC,CAAC;IACnC,MAAM4W,CAAC,GAAG,IAAI,CAAC1I,gBAAgB,CAACkL,WAAW,EAAEC,MAAM,CAAC,CAAC,CAAC;;IAEtD,OAAO,IAAI,CAAC3N,4CAA4C;IACtD,IAAI,CAAC0L,sBAAsB,CAACxY,CAAC,EAAEgD,CAAC,CAAC;IACjC,IAAI,CAACwV,sBAAsB,CAAC5a,CAAC,EAAEoa,CAAC,CAAC;IACjC,IAAI,CAACtD,qBAAqB,CAC3B;IAAE;EACL;;EAEA;;;;;;;EAOiBgG,mBAAmB,GAA2B;IAC7DhX,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C;MACA,OAAO,IAAI,CAACgL,mBAAmB;MAC7BjL,CAAC;MACD,IAAI,CAACkL,sBAAsB,CAACjL,CAAC,EAAE,IAAI,CAAC8W,aAAa,CAAC,IAAI,CAACtJ,gBAAgB,CAACzN,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAChF;;IACH;EACF,CAAC;;EAED;EACU+W,qBAAqB,CAAChX,CAAS,EAAEC,CAAS,EAAc;IAChE,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC6W,mBAAmB,CACzB;;EACH;;EAEA;;;EAGiBG,eAAe,GAAuB;IACrDnX,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,MAAMmC,CAAC,GAAGW,IAAI,CAACiU,KAAK,CAAC/W,CAAC,CAAC;MACvB,MAAM6b,WAAW,GAAG7b,CAAC,GAAGmC,CAAC;MACzB,MAAM2Z,UAAU,GAAG3Z,CAAC,GAAG,CAAC,GAAGnC,CAAC;MAC5B,IAAI6b,WAAW,GAAGC,UAAU,EAAE;QAC5B,OAAO,IAAI,CAAC7M,wBAAwB,CAAC9M,CAAC,CAAC;MACzC,CAAC,MAAM,IAAI0Z,WAAW,GAAGC,UAAU,EAAE;QACnC,OAAO,IAAI,CAAC7M,wBAAwB,CAAC9M,CAAC,GAAG,CAAC,CAAC;MAC7C;;MAEA;MACA;MACA,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QACf,OAAO,IAAI,CAAC8M,wBAAwB,CAAC9M,CAAC,CAAC;MACzC;MACA,OAAO,IAAI,CAAC8M,wBAAwB,CAAC9M,CAAC,GAAG,CAAC,CAAC;IAC7C;EACF,CAAC;;EAES4Z,iBAAiB,CAAC/b,CAAS,EAAc;IACjD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC4b,eAAe,CAAC;EAC7E;;EAEA;;;EAGA;AACF;AACA;AACA;AACA;EACYI,oBAAoB,CAAChc,CAAS,EAAc;IACpD,OAAO,IAAI,CAACsN,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACzB,CAAC,CAAC;IAClB,IAAI,CAACyB,UAAU,CAAC,GAAG,CAAC;IACpB,IAAI,CAACA,UAAU,CAAC,GAAG,CAAC;IACpB,IAAI,CAACoR,qBAAqB,CAC3B;;EACH;;EAEA;;;EAGiBoJ,cAAc,GAAuB;IACpDxX,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,IAAIA,CAAC,GAAG,GAAG,EAAE;QACX,OAAO,IAAI,CAACiP,wBAAwB,CAAC,GAAG,CAAC;MAC3C;MACA,IAAIjP,CAAC,GAAG,GAAG,EAAE;QACX,OAAO,IAAI,CAACiP,wBAAwB,CAAC,CAAC,GAAG,CAAC;MAC5C;;MAEA,OAAO,IAAI,CAACA,wBAAwB,CAAC,GAAG,CAAC;IAC3C;EACF,CAAC;;EAESiN,gBAAgB,CAAClc,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACic,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBE,aAAa,GAAuB;IACnD1X,IAAI,EAAE,IAAI,CAACF,2BAA2B;IACpC,IAAI,CAACnE,SAAS,EAAE,CAACgT,iBAAiB;IAClC,CAACpT,CAAS,KAAiB;MACzBxD,MAAM,CAAC,IAAI,CAAC0C,IAAI,KAAK,KAAK,IAAI,IAAI,CAACA,IAAI,KAAK,KAAK,CAAC;MAClD,MAAMmU,SAAS,GAAG,IAAI,CAACnU,IAAI,KAAK,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;MAC1D,OAAO,IAAI,CAAC8Q,qBAAqB,CAAClN,IAAI,CAACsZ,GAAG,CAACpc,CAAC,CAAC,EAAEqT,SAAS,CAAC;IAC3D,CAAC;;EAEL,CAAC;;EAESgJ,eAAe,CAACrc,CAAS,EAAc;IAC/C,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACmc,aAAa,CAAC;EAC3E;;EAEA;;;EAGiBG,cAAc,GAAuB;IACpD7X,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B;MACA,MAAMyT,OAAO,GAAG,IAAI,CAACC,gBAAgB,CAAC1T,CAAC,CAAC;MACxC,OAAO,IAAI,CAAC6P,sBAAsB;MAChC,IAAI,CAACD,mBAAmB,CAAC,IAAI,CAAC+D,WAAW,CAAC3T,CAAC,CAAC,EAAE,IAAI,CAAC2T,WAAW,CAACF,OAAO,CAAC,CAAC;MACxE,GAAG,CACJ;;IACH;EACF,CAAC;;EAES8I,gBAAgB,CAACvc,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACsc,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBE,YAAY,GAA6B;IACxD/X,IAAI,EAAE,CAACqO,GAAW,EAAEC,IAAY,EAAEpO,CAAS,KAAiB;MAC1D;MACA;MACA;;MAEA,MAAMoU,CAAC,GAAG,IAAI,CAAC0D,mBAAmB;MAChC,IAAI,CAACrK,gBAAgB;MACnB,IAAI,CAACxC,mBAAmB,CAACjL,CAAC,EAAEmO,GAAG,CAAC;MAChC,IAAI,CAAClD,mBAAmB,CAACmD,IAAI,EAAED,GAAG,CAAC,CAAC;MACtC,GAAG;MACH,GAAG,CAAC;MACN;;MAEA,OAAO,IAAI,CAACjD,sBAAsB;MAChCkJ,CAAC;MACD,IAAI,CAAClJ,sBAAsB,CAACkJ,CAAC;MAC3B,IAAI,CAACnJ,mBAAmB,CAAC,GAAG;MAC1B,IAAI,CAACC,sBAAsB,CAAC,GAAG,EAAEkJ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9C;EACF,CAAC;;EAES2D,sBAAsB,CAAC5J,GAAW,EAAEC,IAAY,EAAEpO,CAAS,EAAc;IACjF,OAAO,IAAI,CAAC2I,2BAA2B;IACrC,IAAI,CAAC7L,UAAU,CAACqR,GAAG,CAAC;IACpB,IAAI,CAACrR,UAAU,CAACsR,IAAI,CAAC;IACrB,IAAI,CAACtR,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAC6X,YAAY,CAClB;;EACH;;EAEA;;;EAGiBG,cAAc,GAAuB;IACpDlY,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACoS,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAACwK,mBAAmB,CAAC5c,CAAC,CAAC,CAAC;IAChE;EACF,CAAC;;EAES6c,gBAAgB,CAAC7c,CAAsB,EAAc;IAC7D,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC2c,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBG,cAAc,GAA2B;IACxDrY,IAAI,EAAE,CAACsY,IAAY,EAAEpY,CAAS,KAAiB;MAC7C,IAAIoY,IAAI,IAAIpY,CAAC,EAAE;QACb,OAAO,IAAI,CAACsK,wBAAwB,CAAC,GAAG,CAAC;MAC3C;MACA,OAAO,IAAI,CAACA,wBAAwB,CAAC,GAAG,CAAC;IAC3C;EACF,CAAC;;EAES+N,gBAAgB,CAACD,IAAY,EAAEpY,CAAS,EAAc;IAC9D,OAAO,IAAI,CAACyI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACsb,IAAI,CAAC;IACrB,IAAI,CAACtb,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAACmY,cAAc,CACpB;;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGmBrH,qBAAqB,GAA2B;IAC/DhR,IAAI,EAAE,CAACE,CAAS,EAAEC,CAAS,KAAiB;MAC1C,OAAO,IAAI,CAACqK,wBAAwB,CAACtK,CAAC,GAAGC,CAAC,CAAC;IAC7C;EACF,CAAC;;EAESqY,uBAAuB,CAACtY,CAAsB,EAAEC,CAAsB,EAAc;IAC5F,OAAO,IAAI,CAACwI,yBAAyB;IACnC,IAAI,CAAC3L,UAAU,CAACkD,CAAC,CAAC;IAClB,IAAI,CAAClD,UAAU,CAACmD,CAAC,CAAC;IAClB,IAAI,CAAC6Q,qBAAqB,CAC3B;;EACH;;EAEA;;;;;;EAMUyH,mCAAmC,CAACvY,CAAkB,EAAEC,CAAkB,EAAY;IAC9F,OAAO,IAAI,CAACyJ,4CAA4C;IACtD,IAAI,CAACpR,QAAQ,CAAC0H,CAAC,CAAC;IAChB,IAAI,CAAC1H,QAAQ,CAAC2H,CAAC,CAAC;IAChB,IAAI,CAAC6Q,qBAAqB,CAC3B;;EACH;;EAEA;;;;;;EAMiB0H,aAAa,GAAuB;IACnD1Y,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACoS,gBAAgB,CAAC,IAAI,CAACgL,WAAW,CAACpd,CAAC,CAAC,EAAE,IAAI,CAACqd,WAAW,CAACrd,CAAC,CAAC,CAAC;IACxE;EACF,CAAC;;EAESsd,eAAe,CAACtd,CAAS,EAAc;IAC/C,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACmd,aAAa,CAAC;EAC3E;;EAEA;;;EAGiBI,cAAc,GAAuB;IACpD9Y,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACoS,gBAAgB,CAAC,IAAI,CAACoL,YAAY,CAACxd,CAAC,CAAC,EAAE,IAAI,CAACyd,YAAY,CAACzd,CAAC,CAAC,CAAC;IAC1E;EACF,CAAC;;EAES0d,gBAAgB,CAAC1d,CAAS,EAAc;IAChD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAACud,cAAc,CAAC;EAC5E;;EAEA;;;EAGiBI,mBAAmB,GAAqB;IACvDlZ,IAAI,EAAE,CAAClB,CAAkB,KAAe;MACtC,MAAMO,QAAQ,GAAGP,CAAC,CAAC9D,MAAM;MACzB,MAAMgE,QAAQ,GAAGF,CAAC,CAAC,CAAC,CAAC,CAAC9D,MAAM;MAC5B,MAAM4D,MAAsB,GAAG,CAAC,GAAGjB,KAAK,CAACqB,QAAQ,CAAC,CAAC,CAAC7C,GAAG,CAAC,CAAAoD,CAAC,KAAI,CAAC,GAAG5B,KAAK,CAAC0B,QAAQ,CAAC,CAAC,CAAC;;MAElF,KAAK,IAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,QAAQ,EAAE/C,CAAC,EAAE,EAAE;QACjC,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,QAAQ,EAAEQ,CAAC,EAAE,EAAE;UACjCZ,MAAM,CAACY,CAAC,CAAC,CAAClD,CAAC,CAAC,GAAG,IAAI,CAACkO,wBAAwB,CAAC1L,CAAC,CAACxC,CAAC,CAAC,CAACkD,CAAC,CAAC,CAAC;QACvD;MACF;MACA,OAAO,IAAI,CAAChH,QAAQ,CAACoG,MAAM,CAAC;IAC9B;EACF,CAAC;;EAESua,qBAAqB,CAACra,CAAkB,EAAY;IAC5D,OAAO,IAAI,CAACwK,mBAAmB,CAAC,IAAI,CAAC9Q,QAAQ,CAACsG,CAAC,CAAC,EAAE,IAAI,CAACoa,mBAAmB,CAAC;EAC7E;;EAEA;;;EAGiBE,eAAe,GAAuB;IACrDpZ,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,OAAO,IAAI,CAACiP,wBAAwB,CAACnM,IAAI,CAACgb,KAAK,CAAC9d,CAAC,CAAC,CAAC;IACrD;EACF,CAAC;;EAES+d,iBAAiB,CAAC/d,CAAsB,EAAc;IAC9D,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC6d,eAAe,CAAC;EAC7E;;EAEA;;AAEF;;AAEA;AACA;AACA,MAAMG,qBAAqB,GAAG,IAAI5e,UAAU;AAC1C,KAAK;AACLM,MAAM,CAACO,iBAAiB;AACxBP,MAAM,CAACQ,iBAAiB,CACzB;;AACD,MAAM+d,gBAAgB,GAAG,IAAI7e,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;;AAEjD,MAAM8e,SAAS,SAAShc,QAAQ,CAAC;EAC/B,OAAeic,UAAU,GAAgB;IACvC3d,QAAQ,EAAE;MACRD,GAAG,EAAE3D,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACD,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACC,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAAC4d,QAAQ;MACtCC,WAAW,EAAEzhB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAAC6d,WAAW;MAC5ChH,aAAa,EAAEza,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAAC6W,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACF,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACF,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAAC6M;MAChC,CAAC;MACD1b,CAAC,EAAEpG,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACwC;IACzB,CAAC;IACD3C,QAAQ,EAAE;MACRE,GAAG,EAAE3D,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACE,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACI,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAAC+d,QAAQ;MACtCO,WAAW,EAAE/hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACse,WAAW;MAC5CtH,aAAa,EAAEza,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACgX,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACC,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACC,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAAC6M;MAChC;IACF,CAAC;IACDzd,iBAAiB,EAAE+c,qBAAqB;IACxCY,YAAY,EAAEX,gBAAgB;IAC9B;IACA;IACA7K,iBAAiB,EAAE,IAAIhU,UAAU;IAC/B,KAAK;IACLxC,MAAM,CAACG,GAAG,CAACsD,QAAQ,CAACwR,EAAE,CAACC,KAAK;IAC5BlV,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACqR,EAAE,CAACC,KAAK,CAC7B;;IACD0F,uBAAuB,EAAE,IAAIpY,UAAU;IACrC,KAAK;IACLxC,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACF,SAAS,CAACC,GAAG;IACjC3D,MAAM,CAACG,GAAG,CAACyD,QAAQ,CAACC,GAAG,CACxB;;IACD6a,UAAU,EAAE;MACV,CAAC,EAAE,CAAC2C,gBAAgB,EAAEA,gBAAgB,CAAC;MACvC,CAAC,EAAE,CAACA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,CAAC;MACzD,CAAC,EAAE,CAACA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB;IAC5E,CAAC;IACDvQ,eAAe,EAAE;MACf,CAAC,EAAE,CAACsQ,qBAAqB,EAAEA,qBAAqB,CAAC;MACjD,CAAC,EAAE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;MACxE,CAAC,EAAE;MACDA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;;IAEzB,CAAC;IACDhQ,eAAe,EAAE;MACf,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACgQ,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL;IACF;EACF,CAAC;;EAEM3e,WAAW,GAAG;IACnB,KAAK,CAAC,KAAK,CAAC;EACd;;EAEOe,SAAS,GAAgB;IAC9B,OAAO8d,SAAS,CAACC,UAAU;EAC7B;;EAEA;EACgBjX,QAAQ,GAAG7I,aAAa;EACxB2M,gBAAgB,GAAGzN,mBAAmB;EACtCmD,QAAQ,GAAG5C,WAAW;EACtBuG,WAAW,GAAGrG,oBAAoB;EAClCsR,cAAc,GAAG3R,uBAAuB;EACxC0R,MAAM,GAAGjR,SAAS;EAClByC,aAAa,GAAG9D,GAAG;;EAEnC;EACgBiT,qBAAqB,GAAG,IAAI,CAACpB,yBAAyB,CAAClL,IAAI,CAAC,IAAI,CAAC;EACjEuL,wBAAwB,GAAG,IAAI,CAACF,4BAA4B,CAACrL,IAAI,CAAC,IAAI,CAAC;EACvEmb,sBAAsB,GAAG,IAAI,CAAC7P,0BAA0B,CAACtL,IAAI,CAAC,IAAI,CAAC;EACnE2N,WAAW,GAAG,IAAI,CAAC9B,eAAe,CAAC7L,IAAI,CAAC,IAAI,CAAC;;EAE7D;EACgBob,WAAW,GAAG,IAAI,CAACrP,eAAe,CAAC/L,IAAI,CAAC,IAAI,CAAC;EAC7Cqb,YAAY,GAAG,IAAI,CAAC7O,gBAAgB,CAACxM,IAAI,CAAC,IAAI,CAAC;EAC/Csb,wBAAwB,GAAG,IAAI,CAACxO,4BAA4B,CAAC9M,IAAI,CAAC,IAAI,CAAC;EACvEub,oBAAoB,GAAG,IAAI,CAACvO,wBAAwB,CAAChN,IAAI,CAAC,IAAI,CAAC;EAC/Dwb,cAAc,GAAG,CAAC,IAAI,CAACF,wBAAwB,EAAE,IAAI,CAACC,oBAAoB,CAAC;EAC3E5O,gBAAgB,GAAG,IAAI,CAACO,oBAAoB,CAAClN,IAAI,CAAC,IAAI,CAAC;EACvDyb,4BAA4B,GAAG,IAAI,CAACtO,gCAAgC,CAACnN,IAAI,CAAC,IAAI,CAAC;EAC/E0b,YAAY,GAAG,IAAI,CAACpO,gBAAgB,CAACtN,IAAI,CAAC,IAAI,CAAC;EAC/C2b,aAAa,GAAG,IAAI,CAACnO,iBAAiB,CAACxN,IAAI,CAAC,IAAI,CAAC;EACjD4b,YAAY,GAAG,IAAI,CAAC/N,gBAAgB,CAAC7N,IAAI,CAAC,IAAI,CAAC;EAC/CqM,aAAa,GAAG,IAAI,CAACgC,iBAAiB,CAACrO,IAAI,CAAC,IAAI,CAAC;EACjD6b,aAAa,GAAG,IAAI,CAAClN,iBAAiB,CAAC3O,IAAI,CAAC,IAAI,CAAC;EACjD8b,YAAY,GAAG,IAAI,CAAChN,gBAAgB,CAAC9O,IAAI,CAAC,IAAI,CAAC;EAC/C+Y,mBAAmB,GAAG,IAAI,CAAC7J,uBAAuB,CAAClP,IAAI,CAAC,IAAI,CAAC;EAC7D+b,mBAAmB,GAAG,IAAI,CAACvM,uBAAuB,CAACxP,IAAI,CAAC,IAAI,CAAC;EAC7Dgc,cAAc,GAAG,CAAC,IAAI,CAACjD,mBAAmB,EAAE,IAAI,CAACgD,mBAAmB,CAAC;EACrEpC,WAAW,GAAG,IAAI,CAAC9J,eAAe,CAAC7P,IAAI,CAAC,IAAI,CAAC;EAC7C+Z,YAAY,GAAG,IAAI,CAAC7J,gBAAgB,CAAClQ,IAAI,CAAC,IAAI,CAAC;EAC/Cic,aAAa,GAAG,IAAI,CAAC1L,iBAAiB,CAACvQ,IAAI,CAAC,IAAI,CAAC;EACjDkc,eAAe,GAAG,IAAI,CAACzL,mBAAmB,CAACzQ,IAAI,CAAC,IAAI,CAAC;EACrDmc,mBAAmB,GAAG,IAAI,CAACxK,uBAAuB,CAAC3R,IAAI,CAAC,IAAI,CAAC;EAC7Doc,gBAAgB,GAAG,IAAI,CAACpK,oBAAoB,CAAChS,IAAI,CAAC,IAAI,CAAC;EACvD0O,gBAAgB,GAAG,IAAI,CAACwD,oBAAoB,CAAClS,IAAI,CAAC,IAAI,CAAC;EACvDmT,WAAW,GAAG,IAAI,CAACb,eAAe,CAACtS,IAAI,CAAC,IAAI,CAAC;EAC7CiQ,WAAW,GAAG,IAAI,CAACwC,eAAe,CAACzS,IAAI,CAAC,IAAI,CAAC;EAC7C+W,YAAY,GAAG,IAAI,CAACnE,gBAAgB,CAAC5S,IAAI,CAAC,IAAI,CAAC;EAC/Cqc,oBAAoB,GAAG,IAAI,CAACxJ,wBAAwB,CAAC7S,IAAI,CAAC,IAAI,CAAC;EAC/D0T,aAAa,GAAG,IAAI,CAACJ,iBAAiB,CAACtT,IAAI,CAAC,IAAI,CAAC;EACjDsc,WAAW,GAAG,IAAI,CAAC9I,eAAe,CAACxT,IAAI,CAAC,IAAI,CAAC;EAC7Cuc,aAAa,GAAG,IAAI,CAAC3I,iBAAiB,CAAC5T,IAAI,CAAC,IAAI,CAAC;EACjDkZ,mBAAmB,GAAG,IAAI,CAAClF,uBAAuB,CAAChU,IAAI,CAAC,IAAI,CAAC;EAC7Dwc,aAAa,GAAG,IAAI,CAAClI,iBAAiB,CAACtU,IAAI,CAAC,IAAI,CAAC;EACjD6R,cAAc,GAAG,IAAI,CAAC4C,kBAAkB,CAACzU,IAAI,CAAC,IAAI,CAAC;EACnD6M,WAAW,GAAG,IAAI,CAAC+H,eAAe,CAAC5U,IAAI,CAAC,IAAI,CAAC;EAC7CgX,YAAY,GAAG,IAAI,CAACjC,gBAAgB,CAAC/U,IAAI,CAAC,IAAI,CAAC;EAC/CuP,WAAW,GAAG,IAAI,CAAC0F,eAAe,CAACjV,IAAI,CAAC,IAAI,CAAC;EAC7CsP,WAAW,GAAG,IAAI,CAAC6F,eAAe,CAACnV,IAAI,CAAC,IAAI,CAAC;EAC7Cyc,oBAAoB,GAAG,IAAI,CAACnH,wBAAwB,CAACtV,IAAI,CAAC,IAAI,CAAC;EAC/D0c,kBAAkB,GAAG,IAAI,CAAClH,sBAAsB,CAACxV,IAAI,CAAC,IAAI,CAAC;EAC3D2c,YAAY,GAAG,CAAC,IAAI,CAACF,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;EACnEE,YAAY,GAAG,IAAI,CAACnH,gBAAgB,CAACzV,IAAI,CAAC,IAAI,CAAC;EAC/CmM,sBAAsB,GAAG,IAAI,CAACyJ,0BAA0B,CAAC5V,IAAI,CAAC,IAAI,CAAC;EACnE6c,kCAAkC,GAAG,IAAI,CAAC7G,sCAAsC,CAAChW,IAAI;EACnG,IAAI,CACL;;EACe8c,kCAAkC,GAAG,IAAI,CAAChH,sCAAsC,CAAC9V,IAAI;EACnG,IAAI,CACL;;EACe+c,kCAAkC,GAAG,IAAI,CAAChH,sCAAsC,CAAC/V,IAAI;EACnG,IAAI,CACL;;EACegd,kCAAkC,GAAG,IAAI,CAACvG,sCAAsC,CAACzW,IAAI;EACnG,IAAI,CACL;;EACeid,kCAAkC,GAAG,IAAI,CAACvG,sCAAsC,CAAC1W,IAAI;EACnG,IAAI,CACL;;EACegQ,gBAAgB,GAAG,IAAI,CAAC2G,oBAAoB,CAAC3W,IAAI,CAAC,IAAI,CAAC;EACvDkd,iBAAiB,GAAG,IAAI,CAACrG,qBAAqB,CAAC7W,IAAI,CAAC,IAAI,CAAC;EACzDmd,WAAW,GAAG,IAAI,CAAClG,eAAe,CAACjX,IAAI,CAAC,IAAI,CAAC;EAC7Cod,eAAe,GAAG,IAAI,CAACjG,mBAAmB,CAACnX,IAAI,CAAC,IAAI,CAAC;EACrDqd,eAAe,GAAG,IAAI,CAAC/F,mBAAmB,CAACtX,IAAI,CAAC,IAAI,CAAC;EACrDsd,eAAe,GAAG,IAAI,CAAC/F,mBAAmB,CAACvX,IAAI,CAAC,IAAI,CAAC;EACrDud,iBAAiB,GAAG,IAAI,CAACtF,qBAAqB,CAACjY,IAAI,CAAC,IAAI,CAAC;EACzDwd,aAAa,GAAG,IAAI,CAACnF,iBAAiB,CAACrY,IAAI,CAAC,IAAI,CAAC;EACjDyd,gBAAgB,GAAG,IAAI,CAACnF,oBAAoB,CAACtY,IAAI,CAAC,IAAI,CAAC;EACvD0d,YAAY,GAAG,IAAI,CAAClF,gBAAgB,CAACxY,IAAI,CAAC,IAAI,CAAC;EAC/C0Z,WAAW,GAAG,IAAI,CAACf,eAAe,CAAC3Y,IAAI,CAAC,IAAI,CAAC;EAC7C8Z,YAAY,GAAG,IAAI,CAACjB,gBAAgB,CAAC7Y,IAAI,CAAC,IAAI,CAAC;EAC/C2d,kBAAkB,GAAG,IAAI,CAAC3E,sBAAsB,CAAChZ,IAAI,CAAC,IAAI,CAAC;EAC3DiM,YAAY,GAAG,IAAI,CAACkN,gBAAgB,CAACnZ,IAAI,CAAC,IAAI,CAAC;EAC/C4d,YAAY,GAAG,IAAI,CAACtE,gBAAgB,CAACtZ,IAAI,CAAC,IAAI,CAAC;EAC/CkM,mBAAmB,GAAG,IAAI,CAACqN,uBAAuB,CAACvZ,IAAI,CAAC,IAAI,CAAC;EAC7D6d,+BAA+B,GAAG,IAAI,CAACrE,mCAAmC,CAACxZ,IAAI;EAC7F,IAAI,CACL;;EACe8d,WAAW,GAAG,IAAI,CAAClE,eAAe,CAAC5Z,IAAI,CAAC,IAAI,CAAC;EAC7C+d,YAAY,GAAG,IAAI,CAAC/D,gBAAgB,CAACha,IAAI,CAAC,IAAI,CAAC;EAC/CwW,iBAAiB,GAAG,IAAI,CAAC0D,qBAAqB,CAACla,IAAI,CAAC,IAAI,CAAC;EACzDgY,aAAa,GAAG,IAAI,CAACqC,iBAAiB,CAACra,IAAI,CAAC,IAAI,CAAC;;EAEjE;;EAEA;EACA;AACF;AACA;AACA;AACA;AACA;AACA;EACUge,mBAAmB;EACzBjf,KAAa;EACb2B,MAAsB;EACtB,GAAG6C,GAAqB;EACN;IAClBxE,KAAK,GAAGK,IAAI,CAACgb,KAAK,CAACrb,KAAK,CAAC;;IAEzB,MAAMU,OAAO,GAAG8D,GAAG,CAACrG,GAAG,CAAC,CAAAuG,CAAC,KAAIA,CAAC,CAAC1E,KAAK,CAAC,CAAC;IACtC,IAAI2B,MAAM,KAAK,QAAQ,IAAIjB,OAAO,CAACpB,IAAI,CAAC,CAAAC,CAAC,KAAI,CAACA,CAAC,CAACY,KAAK,CAAC,CAAAI,CAAC,KAAIA,CAAC,CAACtC,QAAQ,EAAE,CAAC,CAAC,EAAE;MACzE,OAAO0G,SAAS;IAClB;IACA,OAAO;MACLC,KAAK,EAAElK,GAAG,CAACsF,KAAK,CAAC;MACjB6E,QAAQ,EAAE3K,KAAK,CAAC,GAAGwG,OAAO;IAC5B,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACSwe,0BAA0B;EAC/Bna,MAAyB;EACzBpD,MAAsB;EACtB,GAAG6C,GAAqB;EAChB;IACR,OAAOO,MAAM,CAACC,MAAM,CAAC,CAACC,KAAK,EAAE1E,CAAC,KAAK;MACjC,MAAMQ,CAAC,GAAG,IAAI,CAACke,mBAAmB,CAAC1e,CAAC,EAAEoB,MAAM,EAAE,GAAG6C,GAAG,CAAC;MACrD,IAAIzD,CAAC,KAAK4D,SAAS,EAAE;QACnBM,KAAK,CAACC,IAAI,CAACnE,CAAC,CAAC;MACf;MACA,OAAOkE,KAAK;IACd,CAAC,EAAE,IAAItF,KAAK,EAAQ,CAAC;EACvB;;EAEA;;EAEiBwf,uBAAuB,GAAuB;IAC7Dnd,IAAI,EAAE,CAACzE,CAAS,KAAiB;MAC/B,MAAM6hB,OAAO,GAAGvkB,mBAAmB,CAAC0C,CAAC,CAAC;MACtC,MAAM8hB,OAAO,GAAGjgB,qBAAqB,CAACggB,OAAO,CAAC;MAC9C,OAAO,IAAI,CAACnf,aAAa,CAAC,GAAGof,OAAO,CAAClhB,GAAG,CAAC,CAAAqC,CAAC,KAAI,IAAI,CAACxB,UAAU,CAACwB,CAAC,CAAC,CAAC,CAAC;IACpE;EACF,CAAC;;EAES8e,yBAAyB,CAAC/hB,CAAS,EAAc;IACzD,OAAO,IAAI,CAACiN,qBAAqB,CAAC,IAAI,CAACxL,UAAU,CAACzB,CAAC,CAAC,EAAE,IAAI,CAAC4hB,uBAAuB,CAAC;EACrF;;EAEA;EACgBI,qBAAqB,GAAG,IAAI,CAACD,yBAAyB,CAACre,IAAI,CAAC,IAAI,CAAC;;EAEjF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACmBue,UAAU,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;EAC/BC,aAAa,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACH,UAAU,CAAC;EAChDI,aAAa,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACL,UAAU,CAAC;EAChDM,YAAY,GAAG,IAAIC,UAAU,CAAC,IAAI,CAACP,UAAU,CAAC;EAC9CQ,aAAa,GAAG,IAAIC,UAAU,CAAC,IAAI,CAACT,UAAU,CAAC;EAC/CU,YAAY,GAAG,IAAIC,SAAS,CAAC,IAAI,CAACX,UAAU,CAAC;EAC7CY,aAAa,GAAG,IAAInmB,YAAY,CAAC,IAAI,CAACulB,UAAU,CAAC;;EAE1Da,2BAA2B,CAAC9iB,CAAS,EAAY;IACvDxD,MAAM;IACJwD,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACoD,GAAG,IAAIP,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACsD,GAAG;IAC1C,kEAAkE,CACnE;;IACD,IAAI,CAAC0hB,aAAa,CAAC,CAAC,CAAC,GAAGniB,CAAC;IACzB,IAAI,IAAI,CAAC6iB,aAAa,CAAC9gB,IAAI,CAAC,CAAAkB,CAAC,KAAI,CAACpF,WAAW,CAACoF,CAAC,CAAC,CAAC,EAAE;MACjD,OAAO,CAAC,IAAI,CAAC7C,SAAS,EAAE,CAACa,iBAAiB,EAAE,IAAI,CAACb,SAAS,EAAE,CAACa,iBAAiB,CAAC;IACjF;;IAEA,MAAMoC,MAAgB,GAAG;IACvB,IAAI,CAAC2e,qBAAqB,CAAC,IAAI,CAACa,aAAa,CAAC,CAAC,CAAC,CAAC;IACjD,IAAI,CAACb,qBAAqB,CAAC,IAAI,CAACa,aAAa,CAAC,CAAC,CAAC,CAAC,CAClD;;;IAED,IAAIxf,MAAM,CAACtB,IAAI,CAAC,CAAAgC,CAAC,KAAI,CAACA,CAAC,CAACrD,QAAQ,EAAE,CAAC,EAAE;MACnC,OAAO,CAAC,IAAI,CAACN,SAAS,EAAE,CAACa,iBAAiB,EAAE,IAAI,CAACb,SAAS,EAAE,CAACa,iBAAiB,CAAC;IACjF;IACA,OAAOoC,MAAM;EACf;;EAEA;EACgB0f,uBAAuB,GAAG,IAAI,CAACD,2BAA2B,CAACpf,IAAI,CAAC,IAAI,CAAC;;EAE7Esf,2BAA2B,CAAChjB,CAAS,EAAY;IACvDxD,MAAM;IACJwD,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACoD,GAAG,IAAIP,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACsD,GAAG;IAC1C,kEAAkE,CACnE;;IACD,MAAMsK,EAAE,GAAG,CAAC/K,CAAS,KAAiB;MACpC,OAAO,IAAI,CAACqR,WAAW,CAACvO,IAAI,CAACrC,GAAG,CAACT,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACrD,CAAC;;IAED,IAAI,CAACmiB,aAAa,CAAC,CAAC,CAAC,GAAGniB,CAAC;IACzB,OAAO,CAAC+K,EAAE,CAAC,IAAI,CAAC0X,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE1X,EAAE,CAAC,IAAI,CAAC0X,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;EAC/D;;EAEA;EACgBQ,uBAAuB,GAAG,IAAI,CAACD,2BAA2B,CAACtf,IAAI,CAAC,IAAI,CAAC;;EAE7Ewf,2BAA2B,CAACljB,CAAS,EAAY;IACvDxD,MAAM;IACJwD,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACoD,GAAG,IAAIP,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACsD,GAAG;IAC1C,kEAAkE,CACnE;;IACD,MAAMsK,EAAE,GAAG,CAAC/K,CAAS,KAAiB;MACpC,OAAO,IAAI,CAACqR,WAAW,CAACrR,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC;IACvC,CAAC;;IAED,IAAI,CAACmiB,aAAa,CAAC,CAAC,CAAC,GAAGniB,CAAC;IACzB,OAAO,CAAC+K,EAAE,CAAC,IAAI,CAACsX,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEtX,EAAE,CAAC,IAAI,CAACsX,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;EAC/D;;EAEA;EACgBc,uBAAuB,GAAG,IAAI,CAACD,2BAA2B,CAACxf,IAAI,CAAC,IAAI,CAAC;;EAE7E0f,0BAA0B,CAACpjB,CAAS,EAAY;IACtDxD,MAAM;IACJwD,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACoD,GAAG,IAAIP,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACsD,GAAG;IAC1C,iEAAiE,CAClE;;IACD,MAAMsK,EAAE,GAAG,CAAC/K,CAAS,KAAiB;MACpC,OAAO,IAAI,CAACqR,WAAW,CAACvO,IAAI,CAACrC,GAAG,CAACT,CAAC,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACnD,CAAC;IACD,IAAI,CAACmiB,aAAa,CAAC,CAAC,CAAC,GAAGniB,CAAC;IACzB,OAAO;IACL+K,EAAE,CAAC,IAAI,CAAC4X,YAAY,CAAC,CAAC,CAAC,CAAC;IACxB5X,EAAE,CAAC,IAAI,CAAC4X,YAAY,CAAC,CAAC,CAAC,CAAC;IACxB5X,EAAE,CAAC,IAAI,CAAC4X,YAAY,CAAC,CAAC,CAAC,CAAC;IACxB5X,EAAE,CAAC,IAAI,CAAC4X,YAAY,CAAC,CAAC,CAAC,CAAC,CACzB;;EACH;;EAEA;EACgBU,sBAAsB,GAAG,IAAI,CAACD,0BAA0B,CAAC1f,IAAI,CAAC,IAAI,CAAC;;EAE3E4f,0BAA0B,CAACtjB,CAAS,EAAY;IACtDxD,MAAM;IACJwD,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACoD,GAAG,IAAIP,CAAC,IAAIpD,MAAM,CAACO,GAAG,CAACsD,GAAG;IAC1C,iEAAiE,CAClE;;IACD,MAAMsK,EAAE,GAAG,CAAC/K,CAAS,KAAiB;MACpC,OAAO,IAAI,CAACqR,WAAW,CAACrR,CAAC,GAAG,GAAG,EAAE,CAAC,CAAC;IACrC,CAAC;;IAED,IAAI,CAACmiB,aAAa,CAAC,CAAC,CAAC,GAAGniB,CAAC;IACzB,OAAO;IACL+K,EAAE,CAAC,IAAI,CAACwX,YAAY,CAAC,CAAC,CAAC,CAAC;IACxBxX,EAAE,CAAC,IAAI,CAACwX,YAAY,CAAC,CAAC,CAAC,CAAC;IACxBxX,EAAE,CAAC,IAAI,CAACwX,YAAY,CAAC,CAAC,CAAC,CAAC;IACxBxX,EAAE,CAAC,IAAI,CAACwX,YAAY,CAAC,CAAC,CAAC,CAAC,CACzB;;EACH;;EAEA;EACgBgB,sBAAsB,GAAG,IAAI,CAACD,0BAA0B,CAAC5f,IAAI,CAAC,IAAI,CAAC;AACrF;;AAEA;AACA;AACA,MAAM8f,UAAU,GAAG,IAAItF,SAAS,EAAE;;AAElC;AACA;AACA,MAAMuF,0BAA0B,GAAG,IAAIrkB,UAAU;AAC/C,UAAU;AACVM,MAAM,CAACO,iBAAiB;AACxBP,MAAM,CAACQ,iBAAiB,CACzB;;AACD,MAAMwjB,qBAAqB,GAAG,IAAItkB,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC;;AAE3D;AACA,MAAMukB,gBAAgB,SAASzhB,QAAQ,CAAC;EACtC,OAAeic,UAAU,GAAgB;IACvC3d,QAAQ,EAAE;MACRD,GAAG,EAAE3D,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACD,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACC,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAAC4d,QAAQ;MACtCC,WAAW,EAAEzhB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAAC6d,WAAW;MAC5ChH,aAAa,EAAEza,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAAC6W,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACF,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACF,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAAC6M;MAChC,CAAC;MACD1b,CAAC,EAAEpG,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACwC;IACzB,CAAC;IACD3C,QAAQ,EAAE;MACRE,GAAG,EAAE3D,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACE,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACI,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAAC+d,QAAQ;MACtCO,WAAW,EAAE/hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACse,WAAW;MAC5CtH,aAAa,EAAEza,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACgX,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACC,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACC,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAAC6M;MAChC;IACF,CAAC;IACDzd,iBAAiB,EAAEwiB,0BAA0B;IAC7C7E,YAAY,EAAE8E,qBAAqB;IACnC;IACA;IACAtQ,iBAAiB,EAAE,IAAIhU,UAAU;IAC/B,UAAU;IACVxC,MAAM,CAACgV,GAAG,CAACvR,QAAQ,CAACwR,EAAE,CAACC,KAAK;IAC5BlV,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACqR,EAAE,CAACC,KAAK,CAC7B;;IACD0F,uBAAuB,EAAE,IAAIpY,UAAU;IACrC,UAAU;IACVxC,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACF,SAAS,CAACC,GAAG;IACjC3D,MAAM,CAACgV,GAAG,CAACpR,QAAQ,CAACC,GAAG,CACxB;;IACD6a,UAAU,EAAE;MACV,CAAC,EAAE,CAACoI,qBAAqB,EAAEA,qBAAqB,CAAC;MACjD,CAAC,EAAE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;MACxE,CAAC,EAAE;MACDA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;;IAEzB,CAAC;IACDhW,eAAe,EAAE;MACf,CAAC,EAAE,CAAC+V,0BAA0B,EAAEA,0BAA0B,CAAC;MAC3D,CAAC,EAAE,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;MACvF,CAAC,EAAE;MACDA,0BAA0B;MAC1BA,0BAA0B;MAC1BA,0BAA0B;MAC1BA,0BAA0B;;IAE9B,CAAC;IACDzV,eAAe,EAAE;MACf,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACyV,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC,CACzD;;QACD,CAAC,EAAE;QACD,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC,CACrF;;QACD,CAAC,EAAE;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC,CACzD;;QACD,CAAC,EAAE;QACD,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC,CACrF;;QACD,CAAC,EAAE;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC;QACxD,CAACA,0BAA0B,EAAEA,0BAA0B,CAAC,CACzD;;QACD,CAAC,EAAE;QACD,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC;QACpF,CAACA,0BAA0B,EAAEA,0BAA0B,EAAEA,0BAA0B,CAAC,CACrF;;QACD,CAAC,EAAE;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;QACD;QACEA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B;QAC1BA,0BAA0B,CAC3B;;;MAEL;IACF;EACF,CAAC;;EAEMpkB,WAAW,GAAG;IACnB,KAAK,CAAC,UAAU,CAAC;EACnB;;EAEOe,SAAS,GAAgB;IAC9B,OAAOujB,gBAAgB,CAACxF,UAAU;EACpC;;EAEA;EACA;EACA;EACgBjX,QAAQ,GAAG,CAAClH,CAAS,KAAK;IACxC,OAAOA,CAAC;EACV,CAAC;EACegL,gBAAgB,GAAGxN,mBAAmB;EACtCkD,QAAQ,GAAGhB,MAAM,CAACgB,QAAQ;EAC1B2D,WAAW,GAAGpG,oBAAoB;EAClCqR,cAAc,GAAG1R,uBAAuB;EACxCyR,MAAM,GAAG,CAACuU,OAAe,EAAEC,KAAgB,GAAG,OAAO,KAAa;IAChFpnB,WAAW,CAAE,iDAAgD,CAAC;EAChE,CAAC;EACeoE,aAAa,GAAGhE,aAAa;;EAE7C;EACgBmT,qBAAqB,GAAG,IAAI,CAACrJ,8BAA8B,CAACjD,IAAI,CAAC,IAAI,CAAC;EACtEuL,wBAAwB,GAAG,IAAI,CAACF,4BAA4B,CAACrL,IAAI,CAAC,IAAI,CAAC;EACvEmb,sBAAsB,GAAG,IAAI,CAAC7P,0BAA0B,CAACtL,IAAI,CAAC,IAAI,CAAC;EACnE2N,WAAW,GAAG,CAACrR,CAAS,EAAEmP,MAAc,KAAiB;IACvE,OAAO,IAAI,CAAC1N,UAAU,CAAC+hB,UAAU,CAACnS,WAAW,CAACrR,CAAC,EAAEmP,MAAM,CAAC,CAAC;EAC3D,CAAC;;EAED;EACgB2P,WAAW,GAAG,IAAI,CAACrP,eAAe,CAAC/L,IAAI,CAAC,IAAI,CAAC;EAC7Cqb,YAAY,GAAG,IAAI,CAACja,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5Esb,wBAAwB,GAAG,IAAI,CAACla,6BAA6B,CAACpB,IAAI;EAChF,IAAI;EACJ,0BAA0B,CAC3B;;EACeub,oBAAoB,GAAG,IAAI,CAACna,6BAA6B,CAACpB,IAAI;EAC5E,IAAI;EACJ,sBAAsB,CACvB;;EACewb,cAAc,GAAG,CAAC,IAAI,CAACF,wBAAwB,EAAE,IAAI,CAACC,oBAAoB,CAAC;EAC3E5O,gBAAgB,GAAG,IAAI,CAACO,oBAAoB,CAAClN,IAAI,CAAC,IAAI,CAAC;EACvDyb,4BAA4B,GAAG,IAAI,CAACtO,gCAAgC,CAACnN,IAAI,CAAC,IAAI,CAAC;EAC/E0b,YAAY,GAAG,IAAI,CAACta,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5E2b,aAAa,GAAG,IAAI,CAACva,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC;EAC9E4b,YAAY,GAAG,IAAI,CAACxa,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5EqM,aAAa,GAAG,IAAI,CAAC9K,iCAAiC,CAACvB,IAAI;EACzE,IAAI;EACJ,eAAe,CAChB;;EACe6b,aAAa,GAAG,IAAI,CAACza,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC;EAC9E8b,YAAY,GAAG,IAAI,CAAC1a,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5E+Y,mBAAmB,GAAG,IAAI,CAAC7J,uBAAuB,CAAClP,IAAI,CAAC,IAAI,CAAC;EAC7D+b,mBAAmB,GAAG,IAAI,CAACvM,uBAAuB,CAACxP,IAAI,CAAC,IAAI,CAAC;EAC7Dgc,cAAc,GAAG,CAAC,IAAI,CAACjD,mBAAmB,EAAE,IAAI,CAACgD,mBAAmB,CAAC;EACrEpC,WAAW,GAAG,IAAI,CAACvY,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC1E+Z,YAAY,GAAG,IAAI,CAAC3Y,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5Eic,aAAa,GAAG,IAAI,CAAC1L,iBAAiB,CAACvQ,IAAI,CAAC,IAAI,CAAC;EACjDkc,eAAe,GAAG,IAAI,CAACzL,mBAAmB,CAACzQ,IAAI,CAAC,IAAI,CAAC;EACrDmc,mBAAmB,GAAG,IAAI,CAACja,6BAA6B,CAAClC,IAAI;EAC3E,IAAI;EACJ,qBAAqB,CACtB;;EACeoc,gBAAgB,GAAG,IAAI,CAAC3Z,qBAAqB,CAACzC,IAAI,CAAC,IAAI,CAAC;EACxD0O,gBAAgB,GAAG;EACjCzN,CAAsB;EACtBC,CAAsB;EACP;IACf,OAAO,IAAI,CAACnD,UAAU,CAAC+hB,UAAU,CAACpR,gBAAgB,CAACzN,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC3D,CAAC;EACeiS,WAAW,GAAG,IAAI,CAACtR,iCAAiC,CAAC7B,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC9EiQ,WAAW,GAAG,IAAI,CAAC7O,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC1E+W,YAAY,GAAG,IAAI,CAAC3V,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5Eqc,oBAAoB,GAAG,IAAI,CAAC3Z,wBAAwB,CAAC1C,IAAI,CAAC,IAAI,CAAC;EAC/D0T,aAAa,GAAG,IAAI,CAACJ,iBAAiB,CAACtT,IAAI,CAAC,IAAI,CAAC;EACjDsc,WAAW,GAAG,IAAI,CAAC9I,eAAe,CAACxT,IAAI,CAAC,IAAI,CAAC;EAC7Cuc,aAAa,GAAG,IAAI,CAACnb,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC;EAC9EkZ,mBAAmB,GAAG,IAAI,CAAC9X,6BAA6B,CAACpB,IAAI;EAC3E,IAAI;EACJ,qBAAqB,CACtB;;EACewc,aAAa,GAAG,IAAI,CAACjb,iCAAiC,CAACvB,IAAI;EACzE,IAAI;EACJ,eAAe,CAChB;;EACe6R,cAAc,GAAG,IAAI,CAAClP,mBAAmB,CAAC3C,IAAI,CAAC,IAAI,CAAC;EACpD6M,WAAW,GAAG,IAAI,CAACzL,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC1EgX,YAAY,GAAG,IAAI,CAAC5V,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5EuP,WAAW,GAAG,IAAI,CAAC0F,eAAe,CAACjV,IAAI,CAAC,IAAI,CAAC;EAC7CsP,WAAW,GAAG,IAAI,CAAC6F,eAAe,CAACnV,IAAI,CAAC,IAAI,CAAC;EAC7Cyc,oBAAoB,GAAG,IAAI,CAAChb,mCAAmC,CAACzB,IAAI;EAClF,IAAI;EACJ,sBAAsB,CACvB;;EACe0c,kBAAkB,GAAG,IAAI,CAACjb,mCAAmC,CAACzB,IAAI;EAChF,IAAI;EACJ,oBAAoB,CACrB;;EACe2c,YAAY,GAAG,CAAC,IAAI,CAACF,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;EACnEE,YAAY,GAAG,IAAI,CAACnH,gBAAgB,CAACzV,IAAI,CAAC,IAAI,CAAC;EAC/CmM,sBAAsB,GAAG,IAAI,CAACyJ,0BAA0B,CAAC5V,IAAI,CAAC,IAAI,CAAC;EACnE6c,kCAAkC,GAAG,IAAI,CAACza,+BAA+B,CAACpC,IAAI;EAC5F,IAAI;EACJ,oCAAoC,CACrC;;EACe8c,kCAAkC,GAAG,IAAI,CAACza,iCAAiC,CAACrC,IAAI;EAC9F,IAAI;EACJ,oCAAoC,CACrC;;EACe+c,kCAAkC,GAAG,IAAI,CAACza,iCAAiC,CAACtC,IAAI;EAC9F,IAAI;EACJ,oCAAoC,CACrC;;EACegd,kCAAkC,GAAG,IAAI,CAACza,iCAAiC,CAACvC,IAAI;EAC9F,IAAI;EACJ,oCAAoC,CACrC;;EACeid,kCAAkC,GAAG,IAAI,CAACza,iCAAiC,CAACxC,IAAI;EAC9F,IAAI;EACJ,oCAAoC,CACrC;;EACegQ,gBAAgB,GAAG,IAAI,CAAC2G,oBAAoB,CAAC3W,IAAI,CAAC,IAAI,CAAC;EACvDkd,iBAAiB,GAAG,IAAI,CAACpb,2BAA2B,CAAC9B,IAAI;EACvE,IAAI;EACJ,mBAAmB,CACpB;;EACemd,WAAW,GAAG,IAAI,CAAC5b,iCAAiC,CAACvB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC9Eod,eAAe,GAAG,IAAI,CAACjG,mBAAmB,CAACnX,IAAI,CAAC,IAAI,CAAC;EACrDqd,eAAe,GAAG,IAAI,CAACtb,+BAA+B,CAAC/B,IAAI;EACzE,IAAI;EACJ,iBAAiB,CAClB;;EACesd,eAAe,GAAG,IAAI,CAACza,oBAAoB,CAAC7C,IAAI,CAAC,IAAI,CAAC;EACtDud,iBAAiB,GAAG,CAACtc,CAAS,EAAEC,CAAS,KAAiB;IACxE,OAAO,IAAI,CAACnD,UAAU,CAAC+hB,UAAU,CAACvC,iBAAiB,CAACtc,CAAC,EAAEC,CAAC,CAAC,CAAC;EAC5D,CAAC;EACesc,aAAa,GAAG,IAAI,CAACpc,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC;EAC9Eyd,gBAAgB,GAAG,IAAI,CAACnF,oBAAoB,CAACtY,IAAI,CAAC,IAAI,CAAC;EACvD0d,YAAY,GAAG,IAAI,CAAClF,gBAAgB,CAACxY,IAAI,CAAC,IAAI,CAAC;EAC/C0Z,WAAW,GAAG,IAAI,CAACtY,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC1E8Z,YAAY,GAAG,IAAI,CAAC1Y,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5E2d,kBAAkB,GAAG,IAAI,CAAClc,mCAAmC,CAACzB,IAAI;EAChF,IAAI;EACJ,oBAAoB,CACrB;;EACeiM,YAAY,GAAG,IAAI,CAAC7K,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5E4d,YAAY,GAAG,IAAI,CAACrc,iCAAiC,CAACvB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAChFkM,mBAAmB,GAAG,IAAI,CAACqN,uBAAuB,CAACvZ,IAAI,CAAC,IAAI,CAAC;EAC7D6d,+BAA+B,GAAG,IAAI,CAACrE,mCAAmC,CAACxZ,IAAI;EAC7F,IAAI,CACL;;EACe8d,WAAW,GAAG,IAAI,CAAC1c,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC;EAC1E+d,YAAY,GAAG,IAAI,CAAC3c,6BAA6B,CAACpB,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;EAC5EwW,iBAAiB,GAAG,IAAI,CAAC0D,qBAAqB,CAACla,IAAI,CAAC,IAAI,CAAC;EACzDgY,aAAa,GAAG,IAAI,CAACqC,iBAAiB,CAACra,IAAI,CAAC,IAAI,CAAC;AACnE;;AAEA;AACA;AACA,MAAMogB,qBAAqB,GAAG,IAAI1kB,UAAU;AAC1C,KAAK;AACLM,MAAM,CAACO,iBAAiB;AACxBP,MAAM,CAACQ,iBAAiB,CACzB;;AACD,MAAM6jB,gBAAgB,GAAG,IAAI3kB,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;;AAEjD;AACA,MAAM4kB,SAAS,SAAS9hB,QAAQ,CAAC;EAC/B,OAAeic,UAAU,GAAgB;IACvC3d,QAAQ,EAAE;MACRD,GAAG,EAAE3D,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACD,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACC,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAAC4d,QAAQ;MACtCC,WAAW,EAAEzhB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAAC6d,WAAW;MAC5ChH,aAAa,EAAEza,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAAC6W,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACF,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACF,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAAC6M;MAChC,CAAC;MACD1b,CAAC,EAAEpG,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACwC;IACzB,CAAC;IACD3C,QAAQ,EAAE;MACRE,GAAG,EAAE3D,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACE,GAAG;MAC5BE,GAAG,EAAE7D,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACI,GAAG;MAC5B2d,QAAQ,EAAExhB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAAC+d,QAAQ;MACtCO,WAAW,EAAE/hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACse,WAAW;MAC5CtH,aAAa,EAAEza,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACgX,aAAa;MAChD/W,SAAS,EAAE;QACTC,GAAG,EAAE3D,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACC,SAAS,CAACC,GAAG;QACtCE,GAAG,EAAE7D,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACC,SAAS,CAACG;MACrC,CAAC;MACDoR,EAAE,EAAE;QACFC,KAAK,EAAElV,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAACC,KAAK;QACnCwM,cAAc,EAAE1hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAACyM,cAAc;QACrDC,IAAI,EAAE3hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAAC0M,IAAI;QACjCC,KAAK,EAAE5hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAAC2M,KAAK;QACnCC,OAAO,EAAE7hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAAC4M,OAAO;QACvCC,KAAK,EAAE9hB,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAAC6M;MAChC;IACF,CAAC;IACDzd,iBAAiB,EAAE6iB,qBAAqB;IACxClF,YAAY,EAAEmF,gBAAgB;IAC9B;IACA;IACA3Q,iBAAiB,EAAE,IAAIhU,UAAU;IAC/B,KAAK;IACLxC,MAAM,CAACE,GAAG,CAACuD,QAAQ,CAACwR,EAAE,CAACC,KAAK;IAC5BlV,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACqR,EAAE,CAACC,KAAK,CAC7B;;IACD0F,uBAAuB,EAAE,IAAIpY,UAAU;IACrC,KAAK;IACLxC,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACF,SAAS,CAACC,GAAG;IACjC3D,MAAM,CAACE,GAAG,CAAC0D,QAAQ,CAACC,GAAG,CACxB;;IACD6a,UAAU,EAAE;MACV,CAAC,EAAE,CAACyI,gBAAgB,EAAEA,gBAAgB,CAAC;MACvC,CAAC,EAAE,CAACA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,CAAC;MACzD,CAAC,EAAE,CAACA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB,EAAEA,gBAAgB;IAC5E,CAAC;IACDrW,eAAe,EAAE;MACf,CAAC,EAAE,CAACoW,qBAAqB,EAAEA,qBAAqB,CAAC;MACjD,CAAC,EAAE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;MACxE,CAAC,EAAE;MACDA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;MACrBA,qBAAqB;;IAEzB,CAAC;IACD9V,eAAe,EAAE;MACf,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAAC8V,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL,CAAC;MACD,CAAC,EAAE;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC;QAC9C,CAACA,qBAAqB,EAAEA,qBAAqB,CAAC,CAC/C;;QACD,CAAC,EAAE;QACD,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC;QACrE,CAACA,qBAAqB,EAAEA,qBAAqB,EAAEA,qBAAqB,CAAC,CACtE;;QACD,CAAC,EAAE;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;QACD;QACEA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB;QACrBA,qBAAqB,CACtB;;;MAEL;IACF;EACF,CAAC;;EAEMzkB,WAAW,GAAG;IACnB,KAAK,CAAC,KAAK,CAAC;EACd;;EAEOe,SAAS,GAAgB;IAC9B,OAAO4jB,SAAS,CAAC7F,UAAU;EAC7B;;EAEA;EACgBjX,QAAQ,GAAG5I,aAAa;EACxB0M,gBAAgB,GAAG1N,mBAAmB;EACtCoD,QAAQ,GAAG7C,WAAW;EACtBwG,WAAW,GAAGtG,oBAAoB;EAClCuR,cAAc,GAAG5R,uBAAuB;EACxC2R,MAAM,GAAGlR,SAAS;EAClB0C,aAAa,GAAG/D,GAAG;;EAEnC;EACgBkT,qBAAqB,GAAG,IAAI,CAACpB,yBAAyB,CAAClL,IAAI,CAAC,IAAI,CAAC;EACjEuL,wBAAwB,GAAG,IAAI,CAACF,4BAA4B,CAACrL,IAAI,CAAC,IAAI,CAAC;EACvEmb,sBAAsB,GAAG,IAAI,CAAC7P,0BAA0B,CAACtL,IAAI,CAAC,IAAI,CAAC;EACnE2N,WAAW,GAAG,IAAI,CAAC9B,eAAe,CAAC7L,IAAI,CAAC,IAAI,CAAC;;EAE7D;EACgBob,WAAW,GAAG,IAAI,CAACrP,eAAe,CAAC/L,IAAI,CAAC,IAAI,CAAC;EAC7Cqb,YAAY,GAAG,IAAI,CAAC7O,gBAAgB,CAACxM,IAAI,CAAC,IAAI,CAAC;EAC/Csb,wBAAwB,GAAG,IAAI,CAACxO,4BAA4B,CAAC9M,IAAI,CAAC,IAAI,CAAC;EACvEub,oBAAoB,GAAG,IAAI,CAACvO,wBAAwB,CAAChN,IAAI,CAAC,IAAI,CAAC;EAC/Dwb,cAAc,GAAG,CAAC,IAAI,CAACF,wBAAwB,EAAE,IAAI,CAACC,oBAAoB,CAAC;EAC3E5O,gBAAgB,GAAG,IAAI,CAACO,oBAAoB,CAAClN,IAAI,CAAC,IAAI,CAAC;EACvDyb,4BAA4B,GAAG,IAAI,CAACtO,gCAAgC,CAACnN,IAAI,CAAC,IAAI,CAAC;EAC/E0b,YAAY,GAAG,IAAI,CAACpO,gBAAgB,CAACtN,IAAI,CAAC,IAAI,CAAC;EAC/C2b,aAAa,GAAG,IAAI,CAACnO,iBAAiB,CAACxN,IAAI,CAAC,IAAI,CAAC;EACjD4b,YAAY,GAAG,IAAI,CAAC/N,gBAAgB,CAAC7N,IAAI,CAAC,IAAI,CAAC;EAC/CqM,aAAa,GAAG,IAAI,CAACgC,iBAAiB,CAACrO,IAAI,CAAC,IAAI,CAAC;EACjD6b,aAAa,GAAG,IAAI,CAAClN,iBAAiB,CAAC3O,IAAI,CAAC,IAAI,CAAC;EACjD8b,YAAY,GAAG,IAAI,CAAChN,gBAAgB,CAAC9O,IAAI,CAAC,IAAI,CAAC;EAC/C+Y,mBAAmB,GAAG,IAAI,CAAC7J,uBAAuB,CAAClP,IAAI,CAAC,IAAI,CAAC;EAC7D+b,mBAAmB,GAAG,IAAI,CAACvM,uBAAuB,CAACxP,IAAI,CAAC,IAAI,CAAC;EAC7Dgc,cAAc,GAAG,CAAC,IAAI,CAACjD,mBAAmB,EAAE,IAAI,CAACgD,mBAAmB,CAAC;EACrEpC,WAAW,GAAG,IAAI,CAAC9J,eAAe,CAAC7P,IAAI,CAAC,IAAI,CAAC;EAC7C+Z,YAAY,GAAG,IAAI,CAAC7J,gBAAgB,CAAClQ,IAAI,CAAC,IAAI,CAAC;EAC/Cic,aAAa,GAAG,IAAI,CAAC1L,iBAAiB,CAACvQ,IAAI,CAAC,IAAI,CAAC;EACjDkc,eAAe,GAAG,IAAI,CAACzL,mBAAmB,CAACzQ,IAAI,CAAC,IAAI,CAAC;EACrDmc,mBAAmB,GAAG,IAAI,CAACxK,uBAAuB,CAAC3R,IAAI,CAAC,IAAI,CAAC;EAC7Doc,gBAAgB,GAAG,IAAI,CAACpK,oBAAoB,CAAChS,IAAI,CAAC,IAAI,CAAC;EACvD0O,gBAAgB,GAAG,IAAI,CAACwD,oBAAoB,CAAClS,IAAI,CAAC,IAAI,CAAC;EACvDmT,WAAW,GAAG,IAAI,CAACb,eAAe,CAACtS,IAAI,CAAC,IAAI,CAAC;EAC7CiQ,WAAW,GAAG,IAAI,CAACwC,eAAe,CAACzS,IAAI,CAAC,IAAI,CAAC;EAC7C+W,YAAY,GAAG,IAAI,CAACnE,gBAAgB,CAAC5S,IAAI,CAAC,IAAI,CAAC;EAC/Cqc,oBAAoB,GAAG,IAAI,CAACxJ,wBAAwB,CAAC7S,IAAI,CAAC,IAAI,CAAC;EAC/D0T,aAAa,GAAG,IAAI,CAACJ,iBAAiB,CAACtT,IAAI,CAAC,IAAI,CAAC;EACjDsc,WAAW,GAAG,IAAI,CAAC9I,eAAe,CAACxT,IAAI,CAAC,IAAI,CAAC;EAC7Cuc,aAAa,GAAG,IAAI,CAAC3I,iBAAiB,CAAC5T,IAAI,CAAC,IAAI,CAAC;EACjDkZ,mBAAmB,GAAG,IAAI,CAAClF,uBAAuB,CAAChU,IAAI,CAAC,IAAI,CAAC;EAC7Dwc,aAAa,GAAG,IAAI,CAAClI,iBAAiB,CAACtU,IAAI,CAAC,IAAI,CAAC;EACjD6R,cAAc,GAAG,IAAI,CAAC4C,kBAAkB,CAACzU,IAAI,CAAC,IAAI,CAAC;EACnD6M,WAAW,GAAG,IAAI,CAAC+H,eAAe,CAAC5U,IAAI,CAAC,IAAI,CAAC;EAC7CgX,YAAY,GAAG,IAAI,CAACjC,gBAAgB,CAAC/U,IAAI,CAAC,IAAI,CAAC;EAC/CuP,WAAW,GAAG,IAAI,CAAC0F,eAAe,CAACjV,IAAI,CAAC,IAAI,CAAC;EAC7CsP,WAAW,GAAG,IAAI,CAAC6F,eAAe,CAACnV,IAAI,CAAC,IAAI,CAAC;EAC7Cyc,oBAAoB,GAAG,IAAI,CAACnH,wBAAwB,CAACtV,IAAI,CAAC,IAAI,CAAC;EAC/D0c,kBAAkB,GAAG,IAAI,CAAClH,sBAAsB,CAACxV,IAAI,CAAC,IAAI,CAAC;EAC3D2c,YAAY,GAAG,CAAC,IAAI,CAACF,oBAAoB,EAAE,IAAI,CAACC,kBAAkB,CAAC;EACnEE,YAAY,GAAG,IAAI,CAACnH,gBAAgB,CAACzV,IAAI,CAAC,IAAI,CAAC;EAC/CmM,sBAAsB,GAAG,IAAI,CAACyJ,0BAA0B,CAAC5V,IAAI,CAAC,IAAI,CAAC;EACnE6c,kCAAkC,GAAG,IAAI,CAAC7G,sCAAsC,CAAChW,IAAI;EACnG,IAAI,CACL;;EACe8c,kCAAkC,GAAG,IAAI,CAAChH,sCAAsC,CAAC9V,IAAI;EACnG,IAAI,CACL;;EACe+c,kCAAkC,GAAG,IAAI,CAAChH,sCAAsC,CAAC/V,IAAI;EACnG,IAAI,CACL;;EACegd,kCAAkC,GAAG,IAAI,CAACvG,sCAAsC,CAACzW,IAAI;EACnG,IAAI,CACL;;EACeid,kCAAkC,GAAG,IAAI,CAACvG,sCAAsC,CAAC1W,IAAI;EACnG,IAAI,CACL;;EACegQ,gBAAgB,GAAG,IAAI,CAAC2G,oBAAoB,CAAC3W,IAAI,CAAC,IAAI,CAAC;EACvDkd,iBAAiB,GAAG,IAAI,CAACrG,qBAAqB,CAAC7W,IAAI,CAAC,IAAI,CAAC;EACzDmd,WAAW,GAAG,IAAI,CAAClG,eAAe,CAACjX,IAAI,CAAC,IAAI,CAAC;EAC7Cod,eAAe,GAAG,IAAI,CAACjG,mBAAmB,CAACnX,IAAI,CAAC,IAAI,CAAC;EACrDqd,eAAe,GAAG,IAAI,CAAC/F,mBAAmB,CAACtX,IAAI,CAAC,IAAI,CAAC;EACrDsd,eAAe,GAAG,IAAI,CAAC/F,mBAAmB,CAACvX,IAAI,CAAC,IAAI,CAAC;EACrDud,iBAAiB,GAAG,IAAI,CAACtF,qBAAqB,CAACjY,IAAI,CAAC,IAAI,CAAC;EACzDwd,aAAa,GAAG,IAAI,CAACnF,iBAAiB,CAACrY,IAAI,CAAC,IAAI,CAAC;EACjDyd,gBAAgB,GAAG,IAAI,CAACnF,oBAAoB,CAACtY,IAAI,CAAC,IAAI,CAAC;EACvD0d,YAAY,GAAG,IAAI,CAAClF,gBAAgB,CAACxY,IAAI,CAAC,IAAI,CAAC;EAC/C0Z,WAAW,GAAG,IAAI,CAACf,eAAe,CAAC3Y,IAAI,CAAC,IAAI,CAAC;EAC7C8Z,YAAY,GAAG,IAAI,CAACjB,gBAAgB,CAAC7Y,IAAI,CAAC,IAAI,CAAC;EAC/C2d,kBAAkB,GAAG,IAAI,CAAC3E,sBAAsB,CAAChZ,IAAI,CAAC,IAAI,CAAC;EAC3DiM,YAAY,GAAG,IAAI,CAACkN,gBAAgB,CAACnZ,IAAI,CAAC,IAAI,CAAC;EAC/C4d,YAAY,GAAG,IAAI,CAACtE,gBAAgB,CAACtZ,IAAI,CAAC,IAAI,CAAC;EAC/CkM,mBAAmB,GAAG,IAAI,CAACqN,uBAAuB,CAACvZ,IAAI,CAAC,IAAI,CAAC;EAC7D6d,+BAA+B,GAAG,IAAI,CAACrE,mCAAmC,CAACxZ,IAAI;EAC7F,IAAI,CACL;;EACe8d,WAAW,GAAG,IAAI,CAAClE,eAAe,CAAC5Z,IAAI,CAAC,IAAI,CAAC;EAC7C+d,YAAY,GAAG,IAAI,CAAC/D,gBAAgB,CAACha,IAAI,CAAC,IAAI,CAAC;EAC/CwW,iBAAiB,GAAG,IAAI,CAAC0D,qBAAqB,CAACla,IAAI,CAAC,IAAI,CAAC;EACzDgY,aAAa,GAAG,IAAI,CAACqC,iBAAiB,CAACra,IAAI,CAAC,IAAI,CAAC;AACnE;;AAEA,OAAO,MAAM7D,EAAE,GAAG;EAChB9C,GAAG,EAAEymB,UAAU;EACf1mB,GAAG,EAAE,IAAIknB,SAAS,EAAE;EACpBC,QAAQ,EAAE,IAAIN,gBAAgB;AAChC,CAAC;;AAED;AACA,OAAO,SAASO,WAAW,CAACC,IAAgB,EAAY;EACtD,QAAQA,IAAI,CAACjlB,IAAI;IACf,KAAK,gBAAgB;MACnB,OAAOW,EAAE,CAACokB,QAAQ;IACpB,KAAK,KAAK;MACR,OAAOpkB,EAAE,CAAC9C,GAAG;IACf,KAAK,KAAK;MACR,OAAO8C,EAAE,CAAC/C,GAAG;IACf;MACEL,WAAW,CAAE,qBAAoB0nB,IAAK,EAAC,CAAC,CAAC;;AAE/C;;AAEA;AACA,OAAO,SAASC,eAAe,CAACxlB,KAAa,EAAEulB,IAAgB,EAAE;EAC/D,IAAI,CAACzkB,MAAM,CAACgB,QAAQ,CAAC9B,KAAK,CAAC,EAAE;IAC3B,OAAO,KAAK;EACd;EACA,IAAI5B,WAAW,CAACmnB,IAAI,CAAC,EAAE;IACrB,MAAM/jB,SAAS,GAAG8jB,WAAW,CAACC,IAAI,CAAC,CAAC/jB,SAAS,EAAE;IAC/C,OAAOxB,KAAK,IAAIwB,SAAS,CAACC,QAAQ,CAACE,GAAG,IAAI3B,KAAK,IAAIwB,SAAS,CAACI,QAAQ,CAACC,GAAG;EAC3E;EACAjE,MAAM,CAAC,KAAK,EAAG,qDAAoD2nB,IAAK,EAAC,CAAC;AAC5E"}