{"version":3,"file":"device_pool.js","names":["SkipTestCase","globalTestConfig","attemptGarbageCollection","getGPU","getDefaultRequestAdapterOptions","assert","raceWithRejectOnTimeout","assertReject","unreachable","getDefaultLimits","kPossibleLimits","TestFailedButDeviceReusable","Error","FeaturesNotSupported","TestOOMedShouldAttemptGC","DevicePool","holders","acquire","recorder","descriptor","descriptorModifier","errorMessage","DescriptorToHolderMap","getOrCreate","undefined","ex","name","message","holder","state","beginTestScope","release","DeviceHolder","deviceNeedsReplacement","endTestScope","expectedLostReason","lostInfo","reason","deviceDueForReplacement","testCaseUseCounter","casesBetweenReplacingDevice","delete","device","destroy","lost","clear","unsupported","Set","Map","k","v","uncanonicalizedDescriptor","baseKey","canonicalizeDescriptor","key","keyModifier","has","JSON","stringify","value","get","set","create","add","insertAndCleanUp","kMaxEntries","size","desc","featuresCanonicalized","requiredFeatures","Array","from","sort","limitsCanonicalized","featureLevel","defaultLimits","requiredLimits","limit","requestedValue","defaultValue","default","descriptorCanonicalized","defaultQueue","supportsFeature","adapter","feature","features","gpu","requestAdapter","requestDevice","constructor","_device","then","ev","pushErrorScope","expectDeviceLost","kTimeout","attemptEndTestScope","gpuValidationError","gpuInternalError","gpuOutOfMemoryError","queue","onSubmittedWorkDone","Promise","all","popErrorScope","allowMissingStack","GPUOutOfMemoryError","GPUInternalError","GPUValidationError"],"sources":["../../../src/webgpu/util/device_pool.ts"],"sourcesContent":["import { SkipTestCase, TestCaseRecorder } from '../../common/framework/fixture.js';\nimport { globalTestConfig } from '../../common/framework/test_config.js';\nimport { attemptGarbageCollection } from '../../common/util/collect_garbage.js';\nimport { getGPU, getDefaultRequestAdapterOptions } from '../../common/util/navigator_gpu.js';\nimport {\n  assert,\n  raceWithRejectOnTimeout,\n  assertReject,\n  unreachable,\n} from '../../common/util/util.js';\nimport { getDefaultLimits, kPossibleLimits } from '../capability_info.js';\n\n// MUST_NOT_BE_IMPORTED_BY_DATA_CACHE\n// This file should not be transitively imported by .cache.ts files\n\nexport interface DeviceProvider {\n  /** Adapter the device was created from. Cannot be reused; just for adapter info. */\n  readonly adapter: GPUAdapter;\n  readonly device: GPUDevice;\n  expectDeviceLost(reason: GPUDeviceLostReason): void;\n}\n\nclass TestFailedButDeviceReusable extends Error {}\nclass FeaturesNotSupported extends Error {}\nexport class TestOOMedShouldAttemptGC extends Error {}\n\n/**\n * DescriptorModifier lets you supply a function to select a device\n * based on the limits/features available from the adapter.\n * Devices pooled based on a key and that key is derived before\n * an adapter is requested. That means you select key without\n * knowledge of what the adapter will provide. You do this by\n * providing a keyModifier function that appends a suffix.\n *\n * For example: If your modifier adds all the limits you might\n * choose 'maxLimits' are your suffix\n *\n * ```js\n *   keyModifier(s: string) { return `${s}:maxLimits`; },\n * ```\n *\n * If your modifier selects only `maxBindGroups` and `maxColorAttachments`\n * then your suffix might be `maxBindGroups&maxColorAttachments`\n *\n * ```js\n *   keyModifier(s: string) { return `${s}:maxBindGroups&maxColorAttachments`; },\n * ```\n */\nexport type DescriptorModifier = {\n  keyModifier(baseKey: string): string;\n  descriptorModifier(\n    adapter: GPUAdapter,\n    desc: CanonicalDeviceDescriptor | undefined\n  ): CanonicalDeviceDescriptor;\n};\n\nexport class DevicePool {\n  private holders: 'uninitialized' | 'failed' | DescriptorToHolderMap = 'uninitialized';\n\n  /** Acquire a device from the pool and begin the error scopes. */\n  async acquire(\n    recorder: TestCaseRecorder,\n    descriptor: UncanonicalizedDeviceDescriptor | undefined,\n    descriptorModifier: DescriptorModifier | undefined\n  ): Promise<DeviceProvider> {\n    let errorMessage = '';\n    if (this.holders === 'uninitialized') {\n      this.holders = new DescriptorToHolderMap();\n      try {\n        await this.holders.getOrCreate(recorder, undefined, descriptorModifier);\n      } catch (ex) {\n        this.holders = 'failed';\n        if (ex instanceof Error) {\n          errorMessage = ` with ${ex.name} \"${ex.message}\"`;\n        }\n      }\n    }\n\n    assert(\n      this.holders !== 'failed',\n      `WebGPU device failed to initialize${errorMessage}; not retrying`\n    );\n\n    const holder = await this.holders.getOrCreate(recorder, descriptor, descriptorModifier);\n\n    assert(holder.state === 'free', 'Device was in use on DevicePool.acquire');\n    holder.state = 'acquired';\n    holder.beginTestScope();\n    return holder;\n  }\n\n  /**\n   * End the error scopes and check for errors.\n   * Then, if the device seems reusable, release it back into the pool. Otherwise, drop it.\n   */\n  async release(holder: DeviceProvider): Promise<void> {\n    assert(this.holders instanceof DescriptorToHolderMap, 'DevicePool got into a bad state');\n    assert(holder instanceof DeviceHolder, 'DeviceProvider should always be a DeviceHolder');\n\n    assert(holder.state === 'acquired', 'trying to release a device while already released');\n    let deviceNeedsReplacement = false;\n    try {\n      await holder.endTestScope();\n\n      if (holder.expectedLostReason) {\n        deviceNeedsReplacement = true;\n        assert(holder.lostInfo !== undefined, 'Device expected to be lost, but was not lost');\n        assert(\n          holder.lostInfo.reason === holder.expectedLostReason,\n          `Expected device loss reason \"${holder.expectedLostReason}\", got \"${holder.lostInfo?.reason}\"`\n        );\n      } else {\n        // Hopefully if the device was lost, it has been reported by the time endErrorScopes()\n        // has finished (or timed out). If not, it could cause a finite number of extra test\n        // failures following this test. (It should recover after one test in most cases.)\n        assert(holder.lostInfo === undefined, 'Device lost unexpectedly during test');\n      }\n    } catch (ex) {\n      // Any error that isn't explicitly TestFailedButDeviceReusable forces a new device to be\n      // created for the next test.\n      if (!(ex instanceof TestFailedButDeviceReusable)) {\n        deviceNeedsReplacement = true;\n\n        // Try to clean up, in case there are stray resources in need of collection that won't be\n        // cleaned up by destroying the device - either outside the device (related to\n        // interop/video/canvas/ImageBitmap/etc.) or not destroyed along with the device for some\n        // other reason.\n        if (ex instanceof TestOOMedShouldAttemptGC) {\n          await attemptGarbageCollection();\n        }\n      }\n\n      throw ex;\n    } finally {\n      const deviceDueForReplacement =\n        holder.testCaseUseCounter >= globalTestConfig.casesBetweenReplacingDevice;\n      if (deviceNeedsReplacement || deviceDueForReplacement) {\n        this.holders.delete(holder);\n        holder.device.destroy();\n        await holder.device.lost;\n      }\n\n      // Mark the holder as free so the device can be reused (if it's still in this.devices).\n      holder.state = 'free';\n    }\n  }\n\n  /**\n   * Destroy the pool, moving it to the persistent 'failed' state and destroy()ing any devices\n   * in the pool, regardless of whether they're in use by a test.\n   */\n  destroy() {\n    if (this.holders instanceof DescriptorToHolderMap) {\n      this.holders.clear();\n    }\n    this.holders = 'failed';\n  }\n}\n\n/**\n * Map from GPUDeviceDescriptor to DeviceHolder.\n */\nclass DescriptorToHolderMap {\n  /** Map keys that are known to be unsupported and can be rejected quickly. */\n  private unsupported: Set<string> = new Set();\n  private holders: Map<string, DeviceHolder> = new Map();\n\n  /** Deletes an item from the map by DeviceHolder value. */\n  delete(holder: DeviceHolder): void {\n    for (const [k, v] of this.holders) {\n      if (v === holder) {\n        holder.device.destroy();\n        this.holders.delete(k);\n        return;\n      }\n    }\n    unreachable(\"internal error: couldn't find DeviceHolder to delete\");\n  }\n\n  /**\n   * Gets a DeviceHolder from the map if it exists; otherwise, calls create() to create one,\n   * inserts it, and returns it.\n   *\n   * If an `uncanonicalizedDescriptor` is provided, it is canonicalized and used as the map key.\n   * If one is not provided, the map key is `\"\"` (empty string).\n   *\n   * Throws SkipTestCase if devices with this descriptor are unsupported.\n   */\n  async getOrCreate(\n    recorder: TestCaseRecorder,\n    uncanonicalizedDescriptor: UncanonicalizedDeviceDescriptor | undefined,\n    descriptorModifier: DescriptorModifier | undefined\n  ): Promise<DeviceHolder> {\n    const [descriptor, baseKey] = canonicalizeDescriptor(uncanonicalizedDescriptor);\n    const key = descriptorModifier?.keyModifier(baseKey) || baseKey;\n    // Quick-reject descriptors that are known to be unsupported already.\n    if (this.unsupported.has(key)) {\n      throw new SkipTestCase(\n        `GPUDeviceDescriptor previously failed: ${JSON.stringify(descriptor)}`\n      );\n    }\n\n    // Search for an existing device with the same descriptor.\n    {\n      const value = this.holders.get(key);\n      if (value) {\n        // Move it to the end of the Map (most-recently-used).\n        this.holders.delete(key);\n        this.holders.set(key, value);\n        return value;\n      }\n    }\n\n    // No existing item was found; add a new one.\n    let value;\n    try {\n      value = await DeviceHolder.create(recorder, descriptor, descriptorModifier);\n    } catch (ex) {\n      if (ex instanceof FeaturesNotSupported) {\n        this.unsupported.add(key);\n        throw new SkipTestCase(\n          `GPUDeviceDescriptor not supported: ${JSON.stringify(descriptor)}\\n${ex?.message ?? ''}`\n        );\n      }\n\n      throw ex;\n    }\n    this.insertAndCleanUp(key, value);\n    return value;\n  }\n\n  /**\n   * Insert an entry, then remove and destroy() the least-recently-used devices\n   * if there are too many.\n   */\n  private insertAndCleanUp(key: string, value: DeviceHolder) {\n    this.holders.set(key, value);\n\n    const kMaxEntries = 5;\n    if (this.holders.size > kMaxEntries) {\n      // Delete the first (least recently used) item in the set.\n      for (const [key, value] of this.holders) {\n        value.device.destroy();\n        this.holders.delete(key);\n        break;\n      }\n    }\n  }\n\n  /** Destroy all the devices and clear the map. This destroys devices even if they're in use. */\n  clear() {\n    for (const [, value] of this.holders) {\n      value.device.destroy();\n    }\n    this.holders.clear();\n  }\n}\n\nexport type UncanonicalizedDeviceDescriptor = {\n  requiredFeatures?: Iterable<GPUFeatureName>;\n  requiredLimits?: Record<string, GPUSize32>;\n};\nexport type CanonicalDeviceDescriptor = Omit<\n  Required<GPUDeviceDescriptor>,\n  'label' | 'nonGuaranteedFeatures' | 'nonGuaranteedLimits'\n>;\n/**\n * Make a stringified map-key from a GPUDeviceDescriptor.\n * Tries to make sure all defaults are resolved, first - but it's okay if some are missed\n * (it just means some GPUDevice objects won't get deduplicated).\n *\n * This does **not** canonicalize `undefined` (the \"default\" descriptor) into a fully-qualified\n * GPUDeviceDescriptor. This is just because `undefined` is a common case and we want to use it\n * as a sanity check that WebGPU is working.\n */\nfunction canonicalizeDescriptor(\n  desc: UncanonicalizedDeviceDescriptor | undefined\n): [CanonicalDeviceDescriptor | undefined, string] {\n  if (desc === undefined) {\n    return [undefined, ''];\n  }\n\n  const featuresCanonicalized = desc.requiredFeatures\n    ? Array.from(new Set(desc.requiredFeatures)).sort()\n    : [];\n\n  /** Canonicalized version of the requested limits: in canonical order, with only values which are\n   * specified _and_ non-default. */\n  const limitsCanonicalized: Record<string, number> = {};\n  const featureLevel = getDefaultRequestAdapterOptions()?.featureLevel ?? 'core';\n  assert(featureLevel === 'compatibility' || featureLevel === 'core');\n  const defaultLimits = getDefaultLimits(featureLevel);\n  if (desc.requiredLimits) {\n    for (const limit of kPossibleLimits) {\n      const requestedValue = desc.requiredLimits[limit];\n      const defaultValue = defaultLimits[limit]?.default;\n      // Skip adding a limit to limitsCanonicalized if it is the same as the default.\n      if (requestedValue !== undefined && requestedValue !== defaultValue) {\n        limitsCanonicalized[limit] = requestedValue;\n      }\n    }\n  }\n\n  // Type ensures every field is carried through.\n  const descriptorCanonicalized: CanonicalDeviceDescriptor = {\n    requiredFeatures: featuresCanonicalized,\n    requiredLimits: limitsCanonicalized,\n    defaultQueue: {},\n  };\n  return [descriptorCanonicalized, JSON.stringify(descriptorCanonicalized)];\n}\n\nfunction supportsFeature(\n  adapter: GPUAdapter,\n  descriptor: CanonicalDeviceDescriptor | undefined\n): boolean {\n  if (descriptor === undefined) {\n    return true;\n  }\n\n  for (const feature of descriptor.requiredFeatures) {\n    if (!adapter.features.has(feature)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * DeviceHolder has three states:\n * - 'free': Free to be used for a new test.\n * - 'acquired': In use by a running test.\n */\ntype DeviceHolderState = 'free' | 'acquired';\n\n/**\n * Holds a GPUDevice and tracks its state (free/acquired) and handles device loss.\n */\nclass DeviceHolder implements DeviceProvider {\n  /** Adapter the device was created from. Cannot be reused; just for adapter info. */\n  readonly adapter: GPUAdapter;\n  /** The device. Will be cleared during cleanup if there were unexpected errors. */\n  private readonly _device: GPUDevice;\n  /** Whether the device is in use by a test or not. */\n  state: DeviceHolderState = 'free';\n  /** initially undefined; becomes set when the device is lost */\n  lostInfo?: GPUDeviceLostInfo;\n  /** Set if the device is expected to be lost. */\n  expectedLostReason?: GPUDeviceLostReason;\n  /** Number of test cases the device has been used for. */\n  testCaseUseCounter = 0;\n\n  // Gets a device and creates a DeviceHolder.\n  // If the device is lost, DeviceHolder.lost gets set.\n  static async create(\n    recorder: TestCaseRecorder,\n    descriptor: CanonicalDeviceDescriptor | undefined,\n    descriptorModifier: DescriptorModifier | undefined\n  ): Promise<DeviceHolder> {\n    const gpu = getGPU(recorder);\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null, 'requestAdapter returned null');\n    if (descriptorModifier) {\n      descriptor = descriptorModifier.descriptorModifier(adapter, descriptor);\n    }\n    if (!supportsFeature(adapter, descriptor)) {\n      throw new FeaturesNotSupported('One or more features are not supported');\n    }\n    // No trackForCleanup because we plan to reuse the device for the next test.\n    // eslint-disable-next-line no-restricted-syntax\n    const device = await adapter.requestDevice(descriptor);\n    assert(device !== null, 'requestDevice returned null');\n\n    return new DeviceHolder(adapter, device);\n  }\n\n  private constructor(adapter: GPUAdapter, device: GPUDevice) {\n    this.adapter = adapter;\n    this._device = device;\n    void this._device.lost.then(ev => {\n      this.lostInfo = ev;\n    });\n  }\n\n  get device() {\n    return this._device;\n  }\n\n  /** Push error scopes that surround test execution. */\n  beginTestScope(): void {\n    assert(this.state === 'acquired');\n    this.testCaseUseCounter++;\n    this.device.pushErrorScope('validation');\n    this.device.pushErrorScope('internal');\n    this.device.pushErrorScope('out-of-memory');\n  }\n\n  /** Mark the DeviceHolder as expecting a device loss when the test scope ends. */\n  expectDeviceLost(reason: GPUDeviceLostReason) {\n    assert(this.state === 'acquired');\n    this.expectedLostReason = reason;\n  }\n\n  /**\n   * Attempt to end test scopes: Check that there are no extra error scopes, and that no\n   * otherwise-uncaptured errors occurred during the test. Time out if it takes too long.\n   */\n  endTestScope(): Promise<void> {\n    assert(this.state === 'acquired');\n    const kTimeout = 5000;\n\n    // Time out if attemptEndTestScope (popErrorScope or onSubmittedWorkDone) never completes. If\n    // this rejects, the device won't be reused, so it's OK that popErrorScope calls may not have\n    // finished.\n    //\n    // This could happen due to a browser bug - e.g.,\n    // as of this writing, on Chrome GPU process crash, popErrorScope just hangs.\n    return raceWithRejectOnTimeout(this.attemptEndTestScope(), kTimeout, 'endTestScope timed out');\n  }\n\n  private async attemptEndTestScope(): Promise<void> {\n    let gpuValidationError: GPUError | null;\n    let gpuInternalError: GPUError | null;\n    let gpuOutOfMemoryError: GPUError | null;\n\n    // Wait for queue to be idle just in case there are any implementation bugs where errors are not\n    // reported promptly. (This won't catch everything, e.g. deferred pipeline creations, but is\n    // still slightly more likely to catch things.)\n    await this.device.queue.onSubmittedWorkDone();\n\n    try {\n      // If the device is lost, all of these should return null.\n      [gpuOutOfMemoryError, gpuInternalError, gpuValidationError] = await Promise.all([\n        this.device.popErrorScope(),\n        this.device.popErrorScope(),\n        this.device.popErrorScope(),\n      ]);\n    } catch (ex) {\n      unreachable('popErrorScope failed. Did the test body pop too many scopes?');\n    }\n\n    if (!this.expectedLostReason) {\n      await assertReject('OperationError', this.device.popErrorScope(), {\n        allowMissingStack: true,\n        message: 'There was an extra error scope on the stack after a test',\n      });\n    }\n\n    if (gpuOutOfMemoryError !== null) {\n      assert(gpuOutOfMemoryError instanceof GPUOutOfMemoryError);\n      // Don't allow the device to be reused; unexpected OOM could break the device.\n      throw new TestOOMedShouldAttemptGC('Unexpected out-of-memory error occurred');\n    }\n    if (gpuInternalError !== null) {\n      assert(gpuInternalError instanceof GPUInternalError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected internal error occurred: ${gpuInternalError.message}`\n      );\n    }\n    if (gpuValidationError !== null) {\n      assert(gpuValidationError instanceof GPUValidationError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected validation error occurred: ${gpuValidationError.message}`\n      );\n    }\n  }\n}\n"],"mappings":"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"}