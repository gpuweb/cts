{"version":3,"file":"texture_ok.js","names":["assert","ErrorWithExtra","unreachable","getTextureFormatType","isColorTextureFormat","isDepthTextureFormat","numbersApproximatelyEqual","generatePrettyTable","numericToStringBuilder","reifyExtent3D","reifyOrigin3D","fullSubrectCoordinates","getTextureSubCopyLayout","kTexelRepresentationInfo","TexelView","makeTexelViewComparer","format","actTexelView","expTexelView","opts","maxIntDiff","maxFractionalDiff","maxDiffULPsForNormFormat","maxDiffULPsForFloatFormat","undefined","fmtIsInt","includes","fmtIsNorm","fmtIsFloat","tvc","predicate","coords","comparePerComponent","color","ulpFromZero","repr","tableRows","failedCoords","act","exp","componentOrder","map","ch","join","toleranceULPs","toPrecision","actual","expected","maxDiff","Object","keys","every","key","k","createTextureCopyForMapRead","t","source","copySize","byteLength","bytesPerRow","rowsPerImage","aspect","buffer","createBufferTracked","usage","GPUBufferUsage","COPY_DST","MAP_READ","size","cmd","device","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","findFailedPixels","subrectOrigin","subrectSize","texelCompareOptions","comparer","lowerCorner","width","height","depthOrArrayLayers","upperCorner","failedPixels","coord","x","y","z","push","Math","min","max","length","printAsInteger","numericToString","componentOrderStr","printCoords","printActualBytes","Array","from","bytes","b","toString","padStart","printActualColors","pixel","printExpectedColors","printActualULPs","printExpectedULPs","fillToWidth","textureContentIsOKByT2B","copySize_","origin","mapAsync","GPUMapMode","READ","data","Uint8Array","getMappedRange","texelViewConfig","fromTextureDataByReference","failedPixelsMessage","msg","slice"],"sources":["../../../../src/webgpu/util/texture/texture_ok.ts"],"sourcesContent":["import { assert, ErrorWithExtra, unreachable } from '../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  getTextureFormatType,\n  isColorTextureFormat,\n  isDepthTextureFormat,\n} from '../../format_info.js';\nimport { GPUTestBase } from '../../gpu_test.js';\nimport { numbersApproximatelyEqual } from '../conversion.js';\nimport { generatePrettyTable, numericToStringBuilder } from '../pretty_diff_tables.js';\nimport { reifyExtent3D, reifyOrigin3D } from '../unions.js';\n\nimport { fullSubrectCoordinates } from './base.js';\nimport { getTextureSubCopyLayout } from './layout.js';\nimport { kTexelRepresentationInfo, PerTexelComponent, TexelComponent } from './texel_data.js';\nimport { TexelView } from './texel_view.js';\n\ntype PerPixelAtLevel<T> = (coords: Required<GPUOrigin3DDict>) => T;\n\n/** Threshold options for comparing texels of different formats (norm/float/int). */\nexport type TexelCompareOptions = {\n  /** Threshold for integer texture formats. Defaults to 0. */\n  maxIntDiff?: number;\n  /** Threshold for non-integer (norm/float) texture formats, if not overridden. */\n  maxFractionalDiff?: number;\n  /** Threshold in ULPs for unorm/snorm texture formats. Overrides `maxFractionalDiff`. */\n  maxDiffULPsForNormFormat?: number;\n  /** Threshold in ULPs for float/ufloat texture formats. Overrides `maxFractionalDiff`. */\n  maxDiffULPsForFloatFormat?: number;\n};\n\nexport type PixelExpectation = PerTexelComponent<number> | Uint8Array;\n\nexport type PerPixelComparison<E extends PixelExpectation> = {\n  coord: GPUOrigin3D;\n  exp: E;\n};\n\ntype TexelViewComparer = {\n  /** Given coords, returns whether the two texel views are considered matching at that point. */\n  predicate: PerPixelAtLevel<boolean>;\n  /**\n   * Given a list of failed coords, returns table rows for `generatePrettyTable` that\n   * display the actual/expected values and diffs for debugging.\n   */\n  tableRows: (failedCoords: readonly Required<GPUOrigin3DDict>[]) => Iterable<string>[];\n};\n\nfunction makeTexelViewComparer(\n  format: EncodableTextureFormat,\n  { actTexelView, expTexelView }: { actTexelView: TexelView; expTexelView: TexelView },\n  opts: TexelCompareOptions\n): TexelViewComparer {\n  const {\n    maxIntDiff = 0,\n    maxFractionalDiff,\n    maxDiffULPsForNormFormat,\n    maxDiffULPsForFloatFormat,\n  } = opts;\n\n  assert(maxIntDiff >= 0, 'threshold must be non-negative');\n  if (maxFractionalDiff !== undefined) {\n    assert(maxFractionalDiff >= 0, 'threshold must be non-negative');\n  }\n  if (maxDiffULPsForFloatFormat !== undefined) {\n    assert(maxDiffULPsForFloatFormat >= 0, 'threshold must be non-negative');\n  }\n  if (maxDiffULPsForNormFormat !== undefined) {\n    assert(maxDiffULPsForNormFormat >= 0, 'threshold must be non-negative');\n  }\n\n  const fmtIsInt = format.includes('int');\n  const fmtIsNorm = format.includes('norm');\n  const fmtIsFloat = format.includes('float');\n\n  const tvc = {} as TexelViewComparer;\n  if (fmtIsInt) {\n    tvc.predicate = coords =>\n      comparePerComponent(actTexelView.color(coords), expTexelView.color(coords), maxIntDiff);\n  } else if (fmtIsNorm && maxDiffULPsForNormFormat !== undefined) {\n    tvc.predicate = coords =>\n      comparePerComponent(\n        actTexelView.ulpFromZero(coords),\n        expTexelView.ulpFromZero(coords),\n        maxDiffULPsForNormFormat\n      );\n  } else if (fmtIsFloat && maxDiffULPsForFloatFormat !== undefined) {\n    tvc.predicate = coords =>\n      comparePerComponent(\n        actTexelView.ulpFromZero(coords),\n        expTexelView.ulpFromZero(coords),\n        maxDiffULPsForFloatFormat\n      );\n  } else if (maxFractionalDiff !== undefined) {\n    tvc.predicate = coords =>\n      comparePerComponent(\n        actTexelView.color(coords),\n        expTexelView.color(coords),\n        maxFractionalDiff\n      );\n  } else {\n    if (fmtIsNorm) {\n      unreachable('need maxFractionalDiff or maxDiffULPsForNormFormat to compare norm textures');\n    } else if (fmtIsFloat) {\n      unreachable('need maxFractionalDiff or maxDiffULPsForFloatFormat to compare float textures');\n    } else {\n      unreachable();\n    }\n  }\n\n  const repr = kTexelRepresentationInfo[format];\n  if (fmtIsInt) {\n    tvc.tableRows = failedCoords => [\n      [`tolerance ± ${maxIntDiff}`],\n      (function* () {\n        yield* [` diff (act - exp)`, '==', ''];\n        for (const coords of failedCoords) {\n          const act = actTexelView.color(coords);\n          const exp = expTexelView.color(coords);\n          yield repr.componentOrder.map(ch => act[ch]! - exp[ch]!).join(',');\n        }\n      })(),\n    ];\n  } else if (\n    (fmtIsNorm && maxDiffULPsForNormFormat !== undefined) ||\n    (fmtIsFloat && maxDiffULPsForFloatFormat !== undefined)\n  ) {\n    const toleranceULPs = fmtIsNorm ? maxDiffULPsForNormFormat! : maxDiffULPsForFloatFormat!;\n    tvc.tableRows = failedCoords => [\n      [`tolerance ± ${toleranceULPs} normal-ULPs`],\n      (function* () {\n        yield* [` diff (act - exp) in normal-ULPs`, '==', ''];\n        for (const coords of failedCoords) {\n          const act = actTexelView.ulpFromZero(coords);\n          const exp = expTexelView.ulpFromZero(coords);\n          yield repr.componentOrder.map(ch => act[ch]! - exp[ch]!).join(',');\n        }\n      })(),\n    ];\n  } else {\n    assert(maxFractionalDiff !== undefined);\n    tvc.tableRows = failedCoords => [\n      [`tolerance ± ${maxFractionalDiff}`],\n      (function* () {\n        yield* [` diff (act - exp)`, '==', ''];\n        for (const coords of failedCoords) {\n          const act = actTexelView.color(coords);\n          const exp = expTexelView.color(coords);\n          yield repr.componentOrder.map(ch => (act[ch]! - exp[ch]!).toPrecision(4)).join(',');\n        }\n      })(),\n    ];\n  }\n\n  return tvc;\n}\n\nfunction comparePerComponent(\n  actual: PerTexelComponent<number>,\n  expected: PerTexelComponent<number>,\n  maxDiff: number\n) {\n  return Object.keys(actual).every(key => {\n    const k = key as TexelComponent;\n    const act = actual[k]!;\n    const exp = expected[k];\n    if (exp === undefined) return false;\n    return numbersApproximatelyEqual(act, exp, maxDiff);\n  });\n}\n\n/** Create a new mappable GPUBuffer, and copy a subrectangle of GPUTexture data into it. */\nfunction createTextureCopyForMapRead(\n  t: GPUTestBase,\n  source: GPUTexelCopyTextureInfo,\n  copySize: GPUExtent3D,\n  { format }: { format: EncodableTextureFormat }\n): { buffer: GPUBuffer; bytesPerRow: number; rowsPerImage: number } {\n  const { byteLength, bytesPerRow, rowsPerImage } = getTextureSubCopyLayout(format, copySize, {\n    aspect: source.aspect,\n  });\n\n  const buffer = t.createBufferTracked({\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    size: byteLength,\n  });\n\n  const cmd = t.device.createCommandEncoder();\n  cmd.copyTextureToBuffer(source, { buffer, bytesPerRow, rowsPerImage }, copySize);\n  t.device.queue.submit([cmd.finish()]);\n\n  return { buffer, bytesPerRow, rowsPerImage };\n}\n\nexport function findFailedPixels(\n  format: EncodableTextureFormat,\n  subrectOrigin: Required<GPUOrigin3DDict>,\n  subrectSize: Required<GPUExtent3DDict>,\n  { actTexelView, expTexelView }: { actTexelView: TexelView; expTexelView: TexelView },\n  texelCompareOptions: TexelCompareOptions,\n  coords?: Generator<Required<GPUOrigin3DDict>>\n) {\n  const comparer = makeTexelViewComparer(\n    format,\n    { actTexelView, expTexelView },\n    texelCompareOptions\n  );\n\n  const lowerCorner = [subrectSize.width, subrectSize.height, subrectSize.depthOrArrayLayers];\n  const upperCorner = [0, 0, 0];\n  const failedPixels: Required<GPUOrigin3DDict>[] = [];\n  for (const coord of coords ?? fullSubrectCoordinates(subrectOrigin, subrectSize)) {\n    const { x, y, z } = coord;\n    if (!comparer.predicate(coord)) {\n      failedPixels.push(coord);\n      lowerCorner[0] = Math.min(lowerCorner[0], x);\n      lowerCorner[1] = Math.min(lowerCorner[1], y);\n      lowerCorner[2] = Math.min(lowerCorner[2], z);\n      upperCorner[0] = Math.max(upperCorner[0], x);\n      upperCorner[1] = Math.max(upperCorner[1], y);\n      upperCorner[2] = Math.max(upperCorner[2], z);\n    }\n  }\n  if (failedPixels.length === 0) {\n    return undefined;\n  }\n\n  const repr = kTexelRepresentationInfo[format];\n  // MAINTENANCE_TODO: Print depth-stencil formats as float+int instead of float+float.\n  const printAsInteger = isColorTextureFormat(format)\n    ? // For color, pick the type based on the format type\n      ['uint', 'sint'].includes(getTextureFormatType(format))\n    : // Print depth as \"float\", depth-stencil as \"float,float\", stencil as \"int\".\n      !isDepthTextureFormat(format);\n  const numericToString = numericToStringBuilder(printAsInteger);\n\n  const componentOrderStr = repr.componentOrder.join(',') + ':';\n\n  const printCoords = (function* () {\n    yield* [' coords', '==', 'X,Y,Z:'];\n    for (const coords of failedPixels) yield `${coords.x},${coords.y},${coords.z}`;\n  })();\n  const printActualBytes = (function* () {\n    yield* [' act. texel bytes (little-endian)', '==', '0x:'];\n    for (const coords of failedPixels) {\n      yield Array.from(actTexelView.bytes(coords), b => b.toString(16).padStart(2, '0')).join(' ');\n    }\n  })();\n  const printActualColors = (function* () {\n    yield* [' act. colors', '==', componentOrderStr];\n    for (const coords of failedPixels) {\n      const pixel = actTexelView.color(coords);\n      yield `${repr.componentOrder.map(ch => numericToString(pixel[ch]!)).join(',')}`;\n    }\n  })();\n  const printExpectedColors = (function* () {\n    yield* [' exp. colors', '==', componentOrderStr];\n    for (const coords of failedPixels) {\n      const pixel = expTexelView.color(coords);\n      yield `${repr.componentOrder.map(ch => numericToString(pixel[ch]!)).join(',')}`;\n    }\n  })();\n  const printActualULPs = (function* () {\n    yield* [' act. normal-ULPs-from-zero', '==', componentOrderStr];\n    for (const coords of failedPixels) {\n      const pixel = actTexelView.ulpFromZero(coords);\n      yield `${repr.componentOrder.map(ch => pixel[ch]).join(',')}`;\n    }\n  })();\n  const printExpectedULPs = (function* () {\n    yield* [` exp. normal-ULPs-from-zero`, '==', componentOrderStr];\n    for (const coords of failedPixels) {\n      const pixel = expTexelView.ulpFromZero(coords);\n      yield `${repr.componentOrder.map(ch => pixel[ch]).join(',')}`;\n    }\n  })();\n\n  const opts = {\n    fillToWidth: 120,\n    numericToString,\n  };\n  return `\\\n between ${lowerCorner} and ${upperCorner} inclusive:\n${generatePrettyTable(opts, [\n  printCoords,\n  printActualBytes,\n  printActualColors,\n  printExpectedColors,\n  printActualULPs,\n  printExpectedULPs,\n  ...comparer.tableRows(failedPixels),\n])}`;\n}\n\n/**\n * Check the contents of a GPUTexture by reading it back (with copyTextureToBuffer+mapAsync), then\n * comparing the data with the data in `expTexelView`.\n *\n * The actual and expected texture data are both converted to the \"NormalULPFromZero\" format,\n * which is a signed number representing how far the number is from zero, in ULPs, skipping\n * subnormal numbers (where ULP is defined for float, normalized, and integer formats).\n */\nexport async function textureContentIsOKByT2B(\n  t: GPUTestBase,\n  source: GPUTexelCopyTextureInfo,\n  copySize_: GPUExtent3D,\n  { expTexelView }: { expTexelView: TexelView },\n  texelCompareOptions: TexelCompareOptions,\n  coords?: Generator<Required<GPUOrigin3DDict>>\n): Promise<ErrorWithExtra | undefined> {\n  const subrectOrigin = reifyOrigin3D(source.origin ?? [0, 0, 0]);\n  const subrectSize = reifyExtent3D(copySize_);\n  const format = expTexelView.format;\n\n  const { buffer, bytesPerRow, rowsPerImage } = createTextureCopyForMapRead(\n    t,\n    source,\n    subrectSize,\n    { format }\n  );\n\n  await buffer.mapAsync(GPUMapMode.READ);\n  const data = new Uint8Array(buffer.getMappedRange());\n\n  const texelViewConfig = {\n    bytesPerRow,\n    rowsPerImage,\n    subrectOrigin,\n    subrectSize,\n  } as const;\n\n  const actTexelView = TexelView.fromTextureDataByReference(format, data, texelViewConfig);\n\n  const failedPixelsMessage = findFailedPixels(\n    format,\n    subrectOrigin,\n    subrectSize,\n    { actTexelView, expTexelView },\n    texelCompareOptions,\n    coords\n  );\n\n  if (failedPixelsMessage === undefined) {\n    return undefined;\n  }\n\n  const msg = 'Texture level had unexpected contents:\\n' + failedPixelsMessage;\n  return new ErrorWithExtra(msg, () => ({\n    expTexelView,\n    // Make a new TexelView with a copy of the data so we can unmap the buffer (debug mode only).\n    actTexelView: TexelView.fromTextureDataByReference(format, data.slice(), texelViewConfig),\n  }));\n}\n"],"mappings":"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"}