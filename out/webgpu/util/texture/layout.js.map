{"version":3,"file":"layout.js","names":["assert","memcpy","resolvePerAspectFormat","getBlockInfoForTextureFormat","getBlockInfoForEncodableTextureFormat","align","reifyExtent3D","physicalMipSize","virtualMipSize","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","aspect","getTextureCopyLayout","format","dimension","baseSize","mipSize","width","height","depthOrArrayLayers","layout","getTextureSubCopyLayout","copySize","blockWidth","blockHeight","bytesPerBlock","copySize_","copySizeBlocks","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","size","options","outputTexelValueBytes","Uint8Array","slice","row","col","byteOffset","src","dst","start","createTextureUploadBuffer","t","buffer","createBufferTracked","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap","kImageCopyTypes","bytesInACompleteRow","copyWidth","info","validateBytesPerRow","bytesInLastRow","sizeInBlocks","validateRowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","method","copyExtent","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"sources":["../../../../src/webgpu/util/texture/layout.ts"],"sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport {\n  resolvePerAspectFormat,\n  SizedTextureFormat,\n  EncodableTextureFormat,\n  getBlockInfoForTextureFormat,\n  getBlockInfoForEncodableTextureFormat,\n} from '../../format_info.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../math.js';\nimport { reifyExtent3D } from '../unions.js';\n\nimport { physicalMipSize, virtualMipSize } from './base.js';\n\n/** The minimum `bytesPerRow` alignment, per spec. */\nexport const kBytesPerRowAlignment = 256;\n/** The minimum buffer copy alignment, per spec. */\nexport const kBufferCopyAlignment = 4;\n\n/**\n * Overridable layout options for {@link getTextureCopyLayout}.\n */\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n  aspect?: GPUTextureAspect;\n}\n\nconst kDefaultLayoutOptions = {\n  mipLevel: 0,\n  bytesPerRow: undefined,\n  rowsPerImage: undefined,\n  aspect: 'all' as const,\n};\n\n/** The info returned by {@link getTextureSubCopyLayout}. */\nexport interface TextureSubCopyLayout {\n  bytesPerBlock: number;\n  byteLength: number;\n  /** Number of bytes in each row, not accounting for {@link kBytesPerRowAlignment}. */\n  minBytesPerRow: number;\n  /**\n   * Actual value of bytesPerRow, defaulting to `align(minBytesPerRow, kBytesPerRowAlignment}`\n   * if not overridden.\n   */\n  bytesPerRow: number;\n  /** Actual value of rowsPerImage, defaulting to `mipSize[1]` if not overridden. */\n  rowsPerImage: number;\n}\n\n/** The info returned by {@link getTextureCopyLayout}. */\nexport interface TextureCopyLayout extends TextureSubCopyLayout {\n  mipSize: [number, number, number];\n}\n\n/**\n * Computes layout information for a copy of the whole subresource at `mipLevel` of a GPUTexture\n * of size `baseSize` with the provided `format` and `dimension`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n *\n * MAINTENANCE_TODO: Change input/output to Required<GPUExtent3DDict> for consistency.\n */\nexport function getTextureCopyLayout(\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  baseSize: readonly [number, number, number],\n  { mipLevel, bytesPerRow, rowsPerImage, aspect }: LayoutOptions = kDefaultLayoutOptions\n): TextureCopyLayout {\n  const mipSize = physicalMipSize(\n    { width: baseSize[0], height: baseSize[1], depthOrArrayLayers: baseSize[2] },\n    format,\n    dimension,\n    mipLevel\n  );\n\n  const layout = getTextureSubCopyLayout(format, mipSize, { bytesPerRow, rowsPerImage, aspect });\n  return { ...layout, mipSize: [mipSize.width, mipSize.height, mipSize.depthOrArrayLayers] };\n}\n\n/**\n * Computes layout information for a copy of size `copySize` to/from a GPUTexture with the provided\n * `format`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureSubCopyLayout(\n  format: GPUTextureFormat,\n  copySize: GPUExtent3D,\n  {\n    bytesPerRow,\n    rowsPerImage,\n    aspect = 'all' as const,\n  }: {\n    readonly bytesPerRow?: number;\n    readonly rowsPerImage?: number;\n    readonly aspect?: GPUTextureAspect;\n  } = {}\n): TextureSubCopyLayout {\n  format = resolvePerAspectFormat(format, aspect);\n  const { blockWidth, blockHeight, bytesPerBlock } = getBlockInfoForTextureFormat(format);\n  assert(bytesPerBlock !== undefined);\n\n  const copySize_ = reifyExtent3D(copySize);\n  assert(\n    copySize_.width > 0 && copySize_.height > 0 && copySize_.depthOrArrayLayers > 0,\n    'not implemented for empty copySize'\n  );\n  assert(\n    copySize_.width % blockWidth === 0 && copySize_.height % blockHeight === 0,\n    () =>\n      `copySize (${copySize_.width},${copySize_.height}) must be a multiple of the block size (${blockWidth},${blockHeight})`\n  );\n  const copySizeBlocks = {\n    width: copySize_.width / blockWidth,\n    height: copySize_.height / blockHeight,\n    depthOrArrayLayers: copySize_.depthOrArrayLayers,\n  };\n\n  const minBytesPerRow = copySizeBlocks.width * bytesPerBlock;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(bytesPerRow % kBytesPerRowAlignment === 0);\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= copySizeBlocks.height);\n  } else {\n    rowsPerImage = copySizeBlocks.height;\n  }\n\n  const bytesPerSlice = bytesPerRow * rowsPerImage;\n  const sliceSize =\n    bytesPerRow * (copySizeBlocks.height - 1) + bytesPerBlock * copySizeBlocks.width;\n  const byteLength = bytesPerSlice * (copySizeBlocks.depthOrArrayLayers - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\n/**\n * Fill an ArrayBuffer with the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n * Preserves the contents of `outputBuffer` which are in \"padding\" space between image rows.\n *\n * Effectively emulates a copyTextureToBuffer from a solid-color texture to a buffer.\n */\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = getBlockInfoForEncodableTextureFormat(format);\n  // Block formats are not handled correctly below.\n  assert(blockWidth === 1);\n  assert(blockHeight === 1);\n\n  assert(bytesPerBlock === texelValue.byteLength, 'texelValue must be of size bytesPerBlock');\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = virtualMipSize(dimension, size, options.mipLevel);\n\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        memcpy({ src: texelValue }, { dst: outputTexelValueBytes, start: byteOffset });\n      }\n    }\n  }\n}\n\n/**\n * Create a `COPY_SRC` GPUBuffer containing the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n */\nexport function createTextureUploadBuffer(\n  t: GPUTest,\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = t.createBufferTracked({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n/**\n * Computes `bytesInACompleteRow` (as defined by the WebGPU spec) for image copies (B2T/T2B/writeTexture).\n */\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = getBlockInfoForTextureFormat(format);\n  assert(!!info.bytesPerBlock);\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUTexelCopyBufferLayout;\n  format: SizedTextureFormat;\n  copySize: Readonly<GPUExtent3DDict> | readonly number[];\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = reifyExtent3D(copySize_);\n\n  const info = getBlockInfoForTextureFormat(format);\n  assert(!!info.bytesPerBlock);\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"mappings":"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"}