{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","memcpy","kTextureFormatInfo","resolvePerAspectFormat","align","reifyExtent3D","physicalMipSize","virtualMipSize","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","aspect","getTextureCopyLayout","format","dimension","baseSize","mipSize","width","height","depthOrArrayLayers","layout","getTextureSubCopyLayout","copySize","blockWidth","blockHeight","bytesPerBlock","copySize_","copySizeBlocks","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","size","options","outputTexelValueBytes","Uint8Array","slice","row","col","byteOffset","src","dst","start","createTextureUploadBuffer","device","buffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap","kImageCopyTypes","bytesInACompleteRow","copyWidth","info","validateBytesPerRow","bytesInLastRow","sizeInBlocks","validateRowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","method","copyExtent","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"mappings":"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","sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  kTextureFormatInfo,\n  resolvePerAspectFormat,\n  SizedTextureFormat,\n} from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { reifyExtent3D } from '../unions.js';\n\nimport { physicalMipSize, virtualMipSize } from './base.js';\n\n/** The minimum `bytesPerRow` alignment, per spec. */\nexport const kBytesPerRowAlignment = 256;\n/** The minimum buffer copy alignment, per spec. */\nexport const kBufferCopyAlignment = 4;\n\n/**\n * Overridable layout options for {@link getTextureCopyLayout}.\n */\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n  aspect?: GPUTextureAspect;\n}\n\nconst kDefaultLayoutOptions = {\n  mipLevel: 0,\n  bytesPerRow: undefined,\n  rowsPerImage: undefined,\n  aspect: 'all' as const,\n};\n\n/** The info returned by {@link getTextureSubCopyLayout}. */\nexport interface TextureSubCopyLayout {\n  bytesPerBlock: number;\n  byteLength: number;\n  /** Number of bytes in each row, not accounting for {@link kBytesPerRowAlignment}. */\n  minBytesPerRow: number;\n  /**\n   * Actual value of bytesPerRow, defaulting to `align(minBytesPerRow, kBytesPerRowAlignment}`\n   * if not overridden.\n   */\n  bytesPerRow: number;\n  /** Actual value of rowsPerImage, defaulting to `mipSize[1]` if not overridden. */\n  rowsPerImage: number;\n}\n\n/** The info returned by {@link getTextureCopyLayout}. */\nexport interface TextureCopyLayout extends TextureSubCopyLayout {\n  mipSize: [number, number, number];\n}\n\n/**\n * Computes layout information for a copy of the whole subresource at `mipLevel` of a GPUTexture\n * of size `baseSize` with the provided `format` and `dimension`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n *\n * MAINTENANCE_TODO: Change input/output to Required<GPUExtent3DDict> for consistency.\n */\nexport function getTextureCopyLayout(\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  baseSize: readonly [number, number, number],\n  { mipLevel, bytesPerRow, rowsPerImage, aspect }: LayoutOptions = kDefaultLayoutOptions\n): TextureCopyLayout {\n  const mipSize = physicalMipSize(\n    { width: baseSize[0], height: baseSize[1], depthOrArrayLayers: baseSize[2] },\n    format,\n    dimension,\n    mipLevel\n  );\n\n  const layout = getTextureSubCopyLayout(format, mipSize, { bytesPerRow, rowsPerImage, aspect });\n  return { ...layout, mipSize: [mipSize.width, mipSize.height, mipSize.depthOrArrayLayers] };\n}\n\n/**\n * Computes layout information for a copy of size `copySize` to/from a GPUTexture with the provided\n * `format`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureSubCopyLayout(\n  format: GPUTextureFormat,\n  copySize: GPUExtent3D,\n  {\n    bytesPerRow,\n    rowsPerImage,\n    aspect = 'all' as const,\n  }: {\n    readonly bytesPerRow?: number;\n    readonly rowsPerImage?: number;\n    readonly aspect?: GPUTextureAspect;\n  } = {}\n): TextureSubCopyLayout {\n  format = resolvePerAspectFormat(format, aspect);\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  assert(bytesPerBlock !== undefined);\n\n  const copySize_ = reifyExtent3D(copySize);\n  assert(\n    copySize_.width > 0 && copySize_.height > 0 && copySize_.depthOrArrayLayers > 0,\n    'not implemented for empty copySize'\n  );\n  assert(\n    copySize_.width % blockWidth === 0 && copySize_.height % blockHeight === 0,\n    'copySize must be a multiple of the block size'\n  );\n  const copySizeBlocks = {\n    width: copySize_.width / blockWidth,\n    height: copySize_.height / blockHeight,\n    depthOrArrayLayers: copySize_.depthOrArrayLayers,\n  };\n\n  const minBytesPerRow = copySizeBlocks.width * bytesPerBlock!;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(bytesPerRow % kBytesPerRowAlignment === 0);\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= copySizeBlocks.height);\n  } else {\n    rowsPerImage = copySizeBlocks.height;\n  }\n\n  const bytesPerSlice = bytesPerRow * rowsPerImage;\n  const sliceSize =\n    bytesPerRow * (copySizeBlocks.height - 1) + bytesPerBlock! * copySizeBlocks.width;\n  const byteLength = bytesPerSlice * (copySizeBlocks.depthOrArrayLayers - 1) + sliceSize;\n\n  return {\n    bytesPerBlock: bytesPerBlock!,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\n/**\n * Fill an ArrayBuffer with the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n * Preserves the contents of `outputBuffer` which are in \"padding\" space between image rows.\n *\n * Effectively emulates a copyTextureToBuffer from a solid-color texture to a buffer.\n */\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  // Block formats are not handled correctly below.\n  assert(blockWidth === 1);\n  assert(blockHeight === 1);\n\n  assert(bytesPerBlock === texelValue.byteLength, 'texelValue must be of size bytesPerBlock');\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = virtualMipSize(dimension, size, options.mipLevel);\n\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        memcpy({ src: texelValue }, { dst: outputTexelValueBytes, start: byteOffset });\n      }\n    }\n  }\n}\n\n/**\n * Create a `COPY_SRC` GPUBuffer containing the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n */\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n/**\n * Computes `bytesInACompleteRow` (as defined by the WebGPU spec) for image copies (B2T/T2B/writeTexture).\n */\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUImageDataLayout;\n  format: SizedTextureFormat;\n  copySize: Readonly<GPUExtent3DDict> | readonly number[];\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = reifyExtent3D(copySize_);\n\n  const info = kTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"file":"layout.js"}