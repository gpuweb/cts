{"version":3,"sources":["../../../../src/webgpu/util/texture/base.ts"],"names":["assert","unreachable","kTextureFormatInfo","align","reifyExtent3D","maxMipLevelCount","size","dimension","sizeDict","maxMippedDimension","Math","max","width","height","depthOrArrayLayers","floor","log2","physicalMipSize","baseSize","format","level","virtualWidthAtLevel","virtualHeightAtLevel","physicalWidthAtLevel","blockWidth","physicalHeightAtLevel","blockHeight","virtualMipSize","mipLevel","shiftMinOne","n","getTextureDimensionFromView","viewDimension","viewDimensionsForTextureDimension","textureDimension","reifyTextureDescriptor","desc","mipLevelCount","sampleCount","reifyTextureViewDescriptor","textureDescriptor","view","texture","baseMipLevel","baseArrayLayer","aspect","arrayLayerCount","undefined"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../common/util/util.js';\nimport { kTextureFormatInfo } from '../../capability_info.js';\nimport { align } from '../../util/math.js';\nimport { reifyExtent3D } from '../../util/unions.js';\n\n/**\n * Compute the maximum mip level count allowed for a given texture size and texture dimension.\n */\nexport function maxMipLevelCount({\n  size,\n  dimension = '2d',\n}: {\n  readonly size: Readonly<GPUExtent3DDict> | readonly number[];\n  readonly dimension?: GPUTextureDimension;\n}): number {\n  const sizeDict = reifyExtent3D(size);\n\n  let maxMippedDimension = 0;\n  switch (dimension) {\n    case '1d':\n      maxMippedDimension = 1; // No mipmaps allowed.\n      break;\n    case '2d':\n      maxMippedDimension = Math.max(sizeDict.width, sizeDict.height);\n      break;\n    case '3d':\n      maxMippedDimension = Math.max(sizeDict.width, sizeDict.height, sizeDict.depthOrArrayLayers);\n      break;\n  }\n\n  return Math.floor(Math.log2(maxMippedDimension)) + 1;\n}\n\n/**\n * Compute the \"physical size\" of a mip level: the size of the level, rounded up to a\n * multiple of the texel block size.\n */\nexport function physicalMipSize(\n  baseSize: Required<GPUExtent3DDict>,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  level: number\n): Required<GPUExtent3DDict> {\n  switch (dimension) {\n    case '1d':\n      assert(level === 0, '1d textures cannot be mipmapped');\n      assert(baseSize.height === 1 && baseSize.depthOrArrayLayers === 1, '1d texture not Wx1x1');\n      return { width: baseSize.width, height: 1, depthOrArrayLayers: 1 };\n\n    case '2d': {\n      assert(\n        Math.max(baseSize.width, baseSize.height) >> level > 0,\n        () => `level (${level}) too large for base size (${baseSize.width}x${baseSize.height})`\n      );\n\n      const virtualWidthAtLevel = Math.max(baseSize.width >> level, 1);\n      const virtualHeightAtLevel = Math.max(baseSize.height >> level, 1);\n      const physicalWidthAtLevel = align(\n        virtualWidthAtLevel,\n        kTextureFormatInfo[format].blockWidth\n      );\n      const physicalHeightAtLevel = align(\n        virtualHeightAtLevel,\n        kTextureFormatInfo[format].blockHeight\n      );\n      return {\n        width: physicalWidthAtLevel,\n        height: physicalHeightAtLevel,\n        depthOrArrayLayers: baseSize.depthOrArrayLayers,\n      };\n    }\n\n    case '3d': {\n      assert(\n        Math.max(baseSize.width, baseSize.height, baseSize.depthOrArrayLayers) >> level > 0,\n        () =>\n          `level (${level}) too large for base size (${baseSize.width}x${baseSize.height}x${baseSize.depthOrArrayLayers})`\n      );\n      assert(\n        kTextureFormatInfo[format].blockWidth === 1 && kTextureFormatInfo[format].blockHeight === 1,\n        'not implemented for 3d block formats'\n      );\n      return {\n        width: Math.max(baseSize.width >> level, 1),\n        height: Math.max(baseSize.height >> level, 1),\n        depthOrArrayLayers: Math.max(baseSize.depthOrArrayLayers >> level, 1),\n      };\n    }\n  }\n}\n\n/**\n * Compute the \"virtual size\" of a mip level of a texture (not accounting for texel block rounding).\n *\n * MAINTENANCE_TODO: Change input/output to Required<GPUExtent3DDict> for consistency.\n */\nexport function virtualMipSize(\n  dimension: GPUTextureDimension,\n  size: readonly [number, number, number],\n  mipLevel: number\n): [number, number, number] {\n  const shiftMinOne = (n: number) => Math.max(1, n >> mipLevel);\n  switch (dimension) {\n    case '1d':\n      assert(size[2] === 1);\n      return [shiftMinOne(size[0]), size[1], size[2]];\n    case '2d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), size[2]];\n    case '3d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), shiftMinOne(size[2])];\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Get texture dimension from view dimension in order to create an compatible texture for a given\n * view dimension.\n */\nexport function getTextureDimensionFromView(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return '1d';\n    case '2d':\n    case '2d-array':\n    case 'cube':\n    case 'cube-array':\n      return '2d';\n    case '3d':\n      return '3d';\n    default:\n      unreachable();\n  }\n}\n\n/** Returns the possible valid view dimensions for a given texture dimension. */\nexport function viewDimensionsForTextureDimension(textureDimension: GPUTextureDimension) {\n  switch (textureDimension) {\n    case '1d':\n      return ['1d'] as const;\n    case '2d':\n      return ['2d', '2d-array', 'cube', 'cube-array'] as const;\n    case '3d':\n      return ['3d'] as const;\n  }\n}\n\n/** Reifies the optional fields of `GPUTextureDescriptor`.\n * MAINTENANCE_TODO: viewFormats should not be omitted here, but it seems likely that the\n * @webgpu/types definition will have to change before we can include it again.\n */\nexport function reifyTextureDescriptor(\n  desc: Readonly<GPUTextureDescriptor>\n): Required<Omit<GPUTextureDescriptor, 'label' | 'viewFormats'>> {\n  return { dimension: '2d' as const, mipLevelCount: 1, sampleCount: 1, ...desc };\n}\n\n/** Reifies the optional fields of `GPUTextureViewDescriptor` (given a `GPUTextureDescriptor`). */\nexport function reifyTextureViewDescriptor(\n  textureDescriptor: Readonly<GPUTextureDescriptor>,\n  view: Readonly<GPUTextureViewDescriptor>\n): Required<Omit<GPUTextureViewDescriptor, 'label'>> {\n  const texture = reifyTextureDescriptor(textureDescriptor);\n\n  // IDL defaulting\n\n  const baseMipLevel = view.baseMipLevel ?? 0;\n  const baseArrayLayer = view.baseArrayLayer ?? 0;\n  const aspect = view.aspect ?? 'all';\n\n  // Spec defaulting\n\n  const format = view.format ?? texture.format;\n  const mipLevelCount = view.mipLevelCount ?? texture.mipLevelCount - baseMipLevel;\n  const dimension = view.dimension ?? texture.dimension;\n\n  let arrayLayerCount = view.arrayLayerCount;\n  if (arrayLayerCount === undefined) {\n    if (dimension === '2d-array' || dimension === 'cube-array') {\n      arrayLayerCount = reifyExtent3D(texture.size).depthOrArrayLayers - baseArrayLayer;\n    } else if (dimension === 'cube') {\n      arrayLayerCount = 6;\n    } else {\n      arrayLayerCount = 1;\n    }\n  }\n\n  return {\n    format,\n    dimension,\n    aspect,\n    baseMipLevel,\n    mipLevelCount,\n    baseArrayLayer,\n    arrayLayerCount,\n  };\n}\n"],"file":"base.js"}