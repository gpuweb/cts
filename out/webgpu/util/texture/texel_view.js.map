{"version":3,"file":"texel_view.js","names":["assert","memcpy","kTextureFormatInfo","generatePrettyTable","numericToStringBuilder","reifyExtent3D","reifyOrigin3D","fullSubrectCoordinates","kTexelRepresentationInfo","makeClampToRange","TexelView","constructor","format","bytes","ulpFromZero","color","fromTextureDataByReference","subrectData","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","sampleCount","origin","size","info","blockWidth","blockHeight","fromTexelsAsBytes","coords","x","y","z","width","height","depthOrArrayLayers","imageOffsetInRows","rowOffset","offset","sampleIndex","bytesPerBlock","subarray","generator","repr","bitsToULPFromZero","unpackBits","bitsToNumber","fromTexelsAsColors","clampToFormatRange","applyClamp","oldGenerator","Uint8Array","pack","encode","numberToBits","writeTextureData","subrectOrigin_","subrectSize_","start","src","dst","toString","printAsInteger","includes","type","depth","numericToString","componentOrderStr","componentOrder","join","subrectCoords","printCoords","printActualBytes","t","Array","from","b","padStart","printActualColors","pixel","map","ch","opts","fillToWidth"],"sources":["../../../../src/webgpu/util/texture/texel_view.ts"],"sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport { kTextureFormatInfo, EncodableTextureFormat } from '../../format_info.js';\nimport { generatePrettyTable, numericToStringBuilder } from '../pretty_diff_tables.js';\nimport { reifyExtent3D, reifyOrigin3D } from '../unions.js';\n\nimport { fullSubrectCoordinates, SampleCoord } from './base.js';\nimport { kTexelRepresentationInfo, makeClampToRange, PerTexelComponent } from './texel_data.js';\n\n/** Function taking some x,y,z coordinates and returning `Readonly<T>`. */\nexport type PerPixelAtLevel<T> = (coords: SampleCoord) => Readonly<T>;\n\n/**\n * Wrapper to view various representations of texture data in other ways. E.g., can:\n * - Provide a mapped buffer, containing copied texture data, and read color values.\n * - Provide a function that generates color values by coordinate, and convert to ULPs-from-zero.\n *\n * MAINTENANCE_TODO: Would need some refactoring to support block formats, which could be partially\n * supported if useful.\n */\nexport class TexelView {\n  /** The GPUTextureFormat of the TexelView. */\n  readonly format: EncodableTextureFormat;\n  /** Generates the bytes for the texel at the given coordinates. */\n  readonly bytes: PerPixelAtLevel<Uint8Array>;\n  /** Generates the ULPs-from-zero for the texel at the given coordinates. */\n  readonly ulpFromZero: PerPixelAtLevel<PerTexelComponent<number>>;\n  /** Generates the color for the texel at the given coordinates. */\n  readonly color: PerPixelAtLevel<PerTexelComponent<number>>;\n\n  private constructor(\n    format: EncodableTextureFormat,\n    {\n      bytes,\n      ulpFromZero,\n      color,\n    }: {\n      bytes: PerPixelAtLevel<Uint8Array>;\n      ulpFromZero: PerPixelAtLevel<PerTexelComponent<number>>;\n      color: PerPixelAtLevel<PerTexelComponent<number>>;\n    }\n  ) {\n    this.format = format;\n    this.bytes = bytes;\n    this.ulpFromZero = ulpFromZero;\n    this.color = color;\n  }\n\n  /**\n   * Produces a TexelView from \"linear image data\", i.e. the `writeTexture` format. Takes a\n   * reference to the input `subrectData`, so any changes to it will be visible in the TexelView.\n   */\n  static fromTextureDataByReference(\n    format: EncodableTextureFormat,\n    subrectData: Uint8Array | Uint8ClampedArray,\n    {\n      bytesPerRow,\n      rowsPerImage,\n      subrectOrigin,\n      subrectSize,\n      sampleCount = 1,\n    }: {\n      bytesPerRow: number;\n      rowsPerImage: number;\n      subrectOrigin: GPUOrigin3D;\n      subrectSize: GPUExtent3D;\n      sampleCount?: number;\n    }\n  ) {\n    const origin = reifyOrigin3D(subrectOrigin);\n    const size = reifyExtent3D(subrectSize);\n\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    return TexelView.fromTexelsAsBytes(format, (coords: SampleCoord) => {\n      assert(\n        coords.x >= origin.x &&\n          coords.y >= origin.y &&\n          coords.z >= origin.z &&\n          coords.x < origin.x + size.width &&\n          coords.y < origin.y + size.height &&\n          coords.z < origin.z + size.depthOrArrayLayers,\n        () => `coordinate (${coords.x},${coords.y},${coords.z}) out of bounds`\n      );\n\n      const imageOffsetInRows = (coords.z - origin.z) * rowsPerImage;\n      const rowOffset = (imageOffsetInRows + (coords.y - origin.y)) * bytesPerRow;\n      const offset =\n        rowOffset +\n        ((coords.x - origin.x) * sampleCount + (coords.sampleIndex ?? 0)) * info.bytesPerBlock;\n\n      // MAINTENANCE_TODO: To support block formats, decode the block and then index into the result.\n      return subrectData.subarray(offset, offset + info.bytesPerBlock) as Uint8Array;\n    });\n  }\n\n  /** Produces a TexelView from a generator of bytes for individual texel blocks. */\n  static fromTexelsAsBytes(\n    format: EncodableTextureFormat,\n    generator: PerPixelAtLevel<Uint8Array>\n  ): TexelView {\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    const repr = kTexelRepresentationInfo[format];\n    return new TexelView(format, {\n      bytes: generator,\n      ulpFromZero: coords => repr.bitsToULPFromZero(repr.unpackBits(generator(coords))),\n      color: coords => repr.bitsToNumber(repr.unpackBits(generator(coords))),\n    });\n  }\n\n  /** Produces a TexelView from a generator of numeric \"color\" values for each texel. */\n  static fromTexelsAsColors(\n    format: EncodableTextureFormat,\n    generator: PerPixelAtLevel<PerTexelComponent<number>>,\n    { clampToFormatRange = false }: { clampToFormatRange?: boolean } = {}\n  ): TexelView {\n    const info = kTextureFormatInfo[format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    if (clampToFormatRange) {\n      const applyClamp = makeClampToRange(format);\n      const oldGenerator = generator;\n      generator = coords => applyClamp(oldGenerator(coords));\n    }\n\n    const repr = kTexelRepresentationInfo[format];\n    return new TexelView(format, {\n      bytes: coords => new Uint8Array(repr.pack(repr.encode(generator(coords)))),\n      ulpFromZero: coords => repr.bitsToULPFromZero(repr.numberToBits(generator(coords))),\n      color: generator,\n    });\n  }\n\n  /** Writes the contents of a TexelView as \"linear image data\", i.e. the `writeTexture` format. */\n  writeTextureData(\n    subrectData: Uint8Array | Uint8ClampedArray,\n    {\n      bytesPerRow,\n      rowsPerImage,\n      subrectOrigin: subrectOrigin_,\n      subrectSize: subrectSize_,\n      sampleCount = 1,\n    }: {\n      bytesPerRow: number;\n      rowsPerImage: number;\n      subrectOrigin: GPUOrigin3D;\n      subrectSize: GPUExtent3D;\n      sampleCount?: number;\n    }\n  ): void {\n    const subrectOrigin = reifyOrigin3D(subrectOrigin_);\n    const subrectSize = reifyExtent3D(subrectSize_);\n\n    const info = kTextureFormatInfo[this.format];\n    assert(info.blockWidth === 1 && info.blockHeight === 1, 'unimplemented for block formats');\n\n    for (let z = subrectOrigin.z; z < subrectOrigin.z + subrectSize.depthOrArrayLayers; ++z) {\n      for (let y = subrectOrigin.y; y < subrectOrigin.y + subrectSize.height; ++y) {\n        for (let x = subrectOrigin.x; x < subrectOrigin.x + subrectSize.width; ++x) {\n          for (let sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            const start =\n              (z * rowsPerImage + y) * bytesPerRow +\n              (x * sampleCount + sampleIndex) * info.bytesPerBlock;\n            memcpy({ src: this.bytes({ x, y, z, sampleIndex }) }, { dst: subrectData, start });\n          }\n        }\n      }\n    }\n  }\n\n  /** Returns a pretty table string of the given coordinates and their values. */\n  // MAINTENANCE_TODO: Unify some internal helpers with those in texture_ok.ts.\n  toString(subrectOrigin: SampleCoord, subrectSize: Required<GPUExtent3DDict>) {\n    const info = kTextureFormatInfo[this.format];\n    const repr = kTexelRepresentationInfo[this.format];\n\n    // MAINTENANCE_TODO: Print depth-stencil formats as float+int instead of float+float.\n    const printAsInteger = info.color\n      ? // For color, pick the type based on the format type\n        ['uint', 'sint'].includes(info.color.type)\n      : // Print depth as \"float\", depth-stencil as \"float,float\", stencil as \"int\".\n        !info.depth;\n    const numericToString = numericToStringBuilder(printAsInteger);\n\n    const componentOrderStr = repr.componentOrder.join(',') + ':';\n    const subrectCoords = [...fullSubrectCoordinates(subrectOrigin, subrectSize)];\n\n    const printCoords = (function* () {\n      yield* [' coords', '==', 'X,Y,Z:'];\n      for (const coords of subrectCoords) yield `${coords.x},${coords.y},${coords.z}`;\n    })();\n    const printActualBytes = (function* (t: TexelView) {\n      yield* [' act. texel bytes (little-endian)', '==', '0x:'];\n      for (const coords of subrectCoords) {\n        yield Array.from(t.bytes(coords), b => b.toString(16).padStart(2, '0')).join(' ');\n      }\n    })(this);\n    const printActualColors = (function* (t: TexelView) {\n      yield* [' act. colors', '==', componentOrderStr];\n      for (const coords of subrectCoords) {\n        const pixel = t.color(coords);\n        yield `${repr.componentOrder.map(ch => numericToString(pixel[ch]!)).join(',')}`;\n      }\n    })(this);\n\n    const opts = {\n      fillToWidth: 120,\n      numericToString,\n    };\n    return `${generatePrettyTable(opts, [printCoords, printActualBytes, printActualColors])}`;\n  }\n}\n"],"mappings":"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"}