{"version":3,"file":"math.js","names":["assert","Float16Array","getFloat16","hfround","setFloat16","kBit","kValue","reinterpretF64AsU64","reinterpretU64AsF64","reinterpretU32AsF32","reinterpretU16AsF16","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF64","val","isSubnormalNumberF64","f64","negative","positive","flushSubnormalNumberF32","isSubnormalNumberF32","f32","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","f16","isFiniteF16","nextAfterF64Data","ArrayBuffer","nextAfterF64Int","BigUint64Array","nextAfterF64Float","Float64Array","nextAfterF64","dir","mode","isNaN","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","is_positive","nextAfterF32Data","nextAfterF32Int","Uint32Array","nextAfterF32Float","Float32Array","nextAfterF32","nextAfterF16Data","nextAfterF16Hex","Uint16Array","nextAfterF16Float","nextAfterF16","oneULPF64","target","NaN","max_ulp","before","after","oneULPF32","converted","quantizeToF32","hashU32","values","v","oneULPF16","quantizeToF16","correctlyRoundedF64","correctlyRoundedF32","emax","n_32","other","correctlyRoundedF16","n_16","frexp","trait","buffer","dataView","DataView","expBitCount","fractBitCount","expBias","expMaskForHigh16Bits","targetExpBitsForHigh16Bits","setFloatToBuffer","getFloatFromBuffer","isFinite","isSubnormal","setFloat32","getFloat32","setFloat64","getFloat64","extractUnbiasedExpFromNormalFloatInBuffer","high16BitsAsUint16","getUint16","modifyExpOfNormalFloatInBuffer","modifiedHigh16Bits","setUint16","fract","exp","lerp","a","b","t","x","lerpBigInt","idx","steps","trunc","y","big_idx","BigInt","big_steps","linearRange","num_steps","Array","from","keys","map","i","linearRangeBigInt","biasedRange","c","pow","biasedRangeBigInt","scaling","scaled_num_steps","biased_i","scaled_i","scalarF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","filteredScalarF32Range","source","low","high","filter","scalarF16Range","scalarF64Range","limitedScalarF64Range","begin","end","u64_begin","u64_end","kInterestingI32Values","i32","sparseI32Range","kVectorI32Values","flatMap","f","vectorI32Range","dim","kSparseVectorI32Values","sparseVectorI32Range","fullI32Range","kInterestingU32Values","u32","sparseU32Range","kVectorU32Values","vectorU32Range","kSparseVectorU32Values","sparseVectorU32Range","fullU32Range","count","kInterestingI64Values","i64","sparseI64Range","kVectorI64Values","vectorI64Range","kSparseVectorI64Values","sparseVectorI64Range","fullI64Range","kInterestingF32Values","sparseScalarF32Range","kVectorF32Values","vectorF32Range","kSparseVectorF32Values","sparseVectorF32Range","kSparseMatrixF32Values","sparseMatrixF32Range","r","kInterestingF16Values","sparseScalarF16Range","kVectorF16Values","vectorF16Range","kSparseVectorF16Values","sparseVectorF16Range","kSparseMatrixF16Values","sparseMatrixF16Range","kInterestingF64Values","sparseScalarF64Range","kVectorF64Values","vectorF64Range","kSparseVectorF64Values","sparseVectorF64Range","kSparseMatrixF64Values","sparseMatrixF64Range","cols","rows","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","num","fround","quantizeToI32","quantizeToU32","quantizeToI64","isPowerOfTwo","gcd","bTemp","lcm","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs","calculatePermutations","input","head","tail","slice","concat","permutations","flatten2DArray","every","j","unflatten2DArray","_","map2DArray","op","every2DArray","col","el","subtractVectors","v1","v2","dotProduct","reduce","absBigInt","maxBigInt","vals","prev","cur","minBigInt"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { ROArrayArray, ROArrayArrayArray } from '../../common/util/types.js';\nimport { assert } from '../../common/util/util.js';\nimport {\n  Float16Array,\n  getFloat16,\n  hfround,\n  setFloat16,\n} from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport {\n  reinterpretF64AsU64,\n  reinterpretU64AsF64,\n  reinterpretU32AsF32,\n  reinterpretU16AsF16,\n} from './reinterpret.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f64 number, otherwise returns |val| */\nexport function flushSubnormalNumberF64(val: number): number {\n  return isSubnormalNumberF64(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f64 */\nexport function isSubnormalNumberF64(n: number): boolean {\n  return n > kValue.f64.negative.max && n < kValue.f64.positive.min;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/** Should nextAfter calculate towards positive infinity or negative infinity */\nexport type NextDirection = 'positive' | 'negative';\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF64 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF64Data = new ArrayBuffer(8);\nconst nextAfterF64Int = new BigUint64Array(nextAfterF64Data);\nconst nextAfterF64Float = new Float64Array(nextAfterF64Data);\n\n/**\n * @returns the next f64 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF64 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF64 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f64, max f64]\n */\nexport function nextAfterF64(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f64.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f64.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f64.positive.max && val >= kValue.f64.negative.min,\n    `${val} is not in the range of f64`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF64(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f64.positive.min : kValue.f64.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f64.negative.max : kValue.f64.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF64Float[0] = val;\n  const is_positive = (nextAfterF64Int[0] & 0x8000_0000_0000_0000n) === 0n;\n  if (is_positive === (dir === 'positive')) {\n    nextAfterF64Int[0] += 1n;\n  } else {\n    nextAfterF64Int[0] -= 1n;\n  }\n\n  // Checking for overflow\n  if ((nextAfterF64Int[0] & 0x7ff0_0000_0000_0000n) === 0x7ff0_0000_0000_0000n) {\n    if (dir === 'positive') {\n      return kValue.f64.positive.infinity;\n    } else {\n      return kValue.f64.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF64(nextAfterF64Float[0]) : nextAfterF64Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF32 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF32Data = new ArrayBuffer(4);\nconst nextAfterF32Int = new Uint32Array(nextAfterF32Data);\nconst nextAfterF32Float = new Float32Array(nextAfterF32Data);\n\n/**\n * @returns the next f32 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f32.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f32.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of f32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f32.positive.min : kValue.f32.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f32.negative.max : kValue.f32.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF32Float[0] = val; // This quantizes from number (f64) to f32\n  if (\n    (dir === 'positive' && nextAfterF32Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF32Float[0] >= val)\n  ) {\n    // val is either f32 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF32Int[0] & 0x80000000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF32Int[0] += 1;\n    } else {\n      nextAfterF32Int[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF32Int[0] & 0x7f800000) === 0x7f800000) {\n    if (dir === 'positive') {\n      return kValue.f32.positive.infinity;\n    } else {\n      return kValue.f32.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF32(nextAfterF32Float[0]) : nextAfterF32Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF16 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF16Data = new ArrayBuffer(2);\nconst nextAfterF16Hex = new Uint16Array(nextAfterF16Data);\nconst nextAfterF16Float = new Float16Array(nextAfterF16Data);\n\n/**\n * @returns the next f16 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF16 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f16.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f16.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of f16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f16.positive.min : kValue.f16.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f16.negative.max : kValue.f16.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF16Float[0] = val; // This quantizes from number (f64) to f16\n  if (\n    (dir === 'positive' && nextAfterF16Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF16Float[0] >= val)\n  ) {\n    // val is either f16 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF16Hex[0] & 0x8000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF16Hex[0] += 1;\n    } else {\n      nextAfterF16Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF16Hex[0] & 0x7c00) === 0x7c00) {\n    if (dir === 'positive') {\n      return kValue.f16.positive.infinity;\n    } else {\n      return kValue.f16.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF16(nextAfterF16Float[0]) : nextAfterF16Float[0];\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 64-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF64(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF64(target) : target;\n\n  // For values out of bounds for f64 ulp(x) is defined as the\n  // distance between the two nearest f64 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f64.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f64.negative.min\n  ) {\n    return kValue.f64.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f64 representable\n  const before = nextAfterF64(target, 'negative', mode);\n  const after = nextAfterF64(target, 'positive', mode);\n  // Since number is internally a f64, |target| is always f64 representable, so\n  // either before or after will be x\n  return Math.min(target - before, after - target);\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF32(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values out of bounds for f32 ulp(x) is defined as the\n  // distance between the two nearest f32 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f32.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f32.negative.min\n  ) {\n    return kValue.f32.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, 'negative', mode);\n  const after = nextAfterF32(target, 'positive', mode);\n  const converted: number = quantizeToF32(target);\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * @returns an integer value between 0..0xffffffff using a simple non-cryptographic hash function\n * @param values integers to generate hash from.\n */\nexport function hashU32(...values: number[]) {\n  let n = 0x3504_f333;\n  for (const v of values) {\n    n = v + (n << 7) + (n >>> 1);\n    n = (n * 0x29493) & 0xffff_ffff;\n  }\n  n ^= n >>> 8;\n  n += n << 15;\n  n = n & 0xffff_ffff;\n  if (n < 0) {\n    n = ~n * 2 + 1;\n  }\n  return n;\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF16(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF16(target) : target;\n\n  // For values out of bounds for f16 ulp(x) is defined as the\n  // distance between the two nearest f16 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f16.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f16.negative.min\n  ) {\n    return kValue.f16.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f16 representable\n  const before = nextAfterF16(target, 'negative', mode);\n  const after = nextAfterF16(target, 'positive', mode);\n  const converted: number = quantizeToF16(target);\n  if (converted === target) {\n    // |target| is f16 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f16 representable so taking distance of neighbouring f16s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 64-bit floats\n *\n * TS/JS's number type is internally a f64, so the supplied value will be\n * quanitized by definition. The only corner cases occur if a non-finite value\n * is provided, since the valid roundings include the appropriate min or max\n * value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 64-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF64(n: number): readonly number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f64 range\n  if (n === Number.POSITIVE_INFINITY) {\n    return [kValue.f64.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f64 range\n  if (n === Number.NEGATIVE_INFINITY) {\n    return [Number.NEGATIVE_INFINITY, kValue.f64.negative.min];\n  }\n\n  return [n];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f32.emax + 1) and -(2^(f32.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): readonly number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f32.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f32 finite\n  if (n <= kValue.f32.positive.max && n >= kValue.f32.negative.min) {\n    const n_32 = quantizeToF32(n);\n    if (n === n_32) {\n      // n is precisely expressible as a f32, so should not be rounded\n      return [n];\n    }\n\n    if (n_32 > n) {\n      // n_32 rounded towards +inf, so is after n\n      const other = nextAfterF32(n_32, 'negative', 'no-flush');\n      return [other, n_32];\n    } else {\n      // n_32 rounded towards -inf, so is before n\n      const other = nextAfterF32(n_32, 'positive', 'no-flush');\n      return [n_32, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f32.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f16.emax + 1) and -(2^(f16.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): readonly number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f16.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f16 finite\n  if (n <= kValue.f16.positive.max && n >= kValue.f16.negative.min) {\n    const n_16 = quantizeToF16(n);\n    if (n === n_16) {\n      // n is precisely expressible as a f16, so should not be rounded\n      return [n];\n    }\n\n    if (n_16 > n) {\n      // n_16 rounded towards +inf, so is after n\n      const other = nextAfterF16(n_16, 'negative', 'no-flush');\n      return [other, n_16];\n    } else {\n      // n_16 rounded towards -inf, so is before n\n      const other = nextAfterF16(n_16, 'positive', 'no-flush');\n      return [n_16, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f16.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Calculates WGSL frexp\n *\n * Splits val into a fraction and an exponent so that\n * val = fraction * 2 ^ exponent.\n * The fraction is 0.0 or its magnitude is in the range [0.5, 1.0).\n *\n * @param val the float to split\n * @param trait the float type, f32 or f16 or f64\n * @returns the results of splitting val\n */\nexport function frexp(val: number, trait: 'f32' | 'f16' | 'f64'): { fract: number; exp: number } {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n\n  // expBitCount and fractBitCount is the bitwidth of exponent and fractional part of the given FP type.\n  // expBias is the bias constant of exponent of the given FP type.\n  // Biased exponent (unsigned integer, i.e. the exponent part of float) = unbiased exponent (signed integer) + expBias.\n  let expBitCount: number, fractBitCount: number, expBias: number;\n  // To handle the exponent bits of given FP types (f16, f32, and f64), considering the highest 16\n  // bits is enough.\n  // expMaskForHigh16Bits indicates the exponent bitfield in the highest 16 bits of the given FP\n  // type, and targetExpBitsForHigh16Bits is the exponent bits that corresponding to unbiased\n  // exponent -1, i.e. the exponent bits when the FP values is in range [0.5, 1.0).\n  let expMaskForHigh16Bits: number, targetExpBitsForHigh16Bits: number;\n  // Helper function that store the given FP value into buffer as the given FP types\n  let setFloatToBuffer: (v: number) => void;\n  // Helper function that read back FP value from buffer as the given FP types\n  let getFloatFromBuffer: () => number;\n\n  let isFinite: (v: number) => boolean;\n  let isSubnormal: (v: number) => boolean;\n\n  if (trait === 'f32') {\n    // f32 bit pattern: s_eeeeeeee_fffffff_ffffffffffffffff\n    expBitCount = 8;\n    fractBitCount = 23;\n    expBias = 127;\n    // The exponent bitmask for high 16 bits of f32.\n    expMaskForHigh16Bits = 0x7f80;\n    // The target exponent bits is equal to those for f32 0.5 = 0x3f000000.\n    targetExpBitsForHigh16Bits = 0x3f00;\n    isFinite = isFiniteF32;\n    isSubnormal = isSubnormalNumberF32;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => dataView.setFloat32(0, v, false);\n    getFloatFromBuffer = () => dataView.getFloat32(0, false);\n  } else if (trait === 'f16') {\n    // f16 bit pattern: s_eeeee_ffffffffff\n    expBitCount = 5;\n    fractBitCount = 10;\n    expBias = 15;\n    // The exponent bitmask for 16 bits of f16.\n    expMaskForHigh16Bits = 0x7c00;\n    // The target exponent bits is equal to those for f16 0.5 = 0x3800.\n    targetExpBitsForHigh16Bits = 0x3800;\n    isFinite = isFiniteF16;\n    isSubnormal = isSubnormalNumberF16;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => setFloat16(dataView, 0, v, false);\n    getFloatFromBuffer = () => getFloat16(dataView, 0, false);\n  } else {\n    assert(trait === 'f64');\n    // f64 bit pattern: s_eeeeeeeeeee_ffff_ffffffffffffffffffffffffffffffffffffffffffffffff\n    expBitCount = 11;\n    fractBitCount = 52;\n    expBias = 1023;\n    // The exponent bitmask for 16 bits of f64.\n    expMaskForHigh16Bits = 0x7ff0;\n    // The target exponent bits is equal to those for f64 0.5 = 0x3fe0_0000_0000_0000.\n    targetExpBitsForHigh16Bits = 0x3fe0;\n    isFinite = Number.isFinite;\n    isSubnormal = isSubnormalNumberF64;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => dataView.setFloat64(0, v, false);\n    getFloatFromBuffer = () => dataView.getFloat64(0, false);\n  }\n  // Helper function that extract the unbiased exponent of the float in buffer.\n  const extractUnbiasedExpFromNormalFloatInBuffer = () => {\n    // Assert the float in buffer is finite normal float.\n    assert(isFinite(getFloatFromBuffer()) && !isSubnormal(getFloatFromBuffer()));\n    // Get the highest 16 bits of float as uint16, which can contain the whole exponent part for both f16, f32, and f64.\n    const high16BitsAsUint16 = dataView.getUint16(0, false);\n    // Return the unbiased exp by masking, shifting and unbiasing.\n    return ((high16BitsAsUint16 & expMaskForHigh16Bits) >> (16 - 1 - expBitCount)) - expBias;\n  };\n  // Helper function that modify the exponent of float in buffer to make it in range [0.5, 1.0).\n  // By setting the unbiased exponent to -1, the fp value will be in range 2**-1 * [1.0, 2.0), i.e. [0.5, 1.0).\n  const modifyExpOfNormalFloatInBuffer = () => {\n    // Assert the float in buffer is finite normal float.\n    assert(isFinite(getFloatFromBuffer()) && !isSubnormal(getFloatFromBuffer()));\n    // Get the highest 16 bits of float as uint16, which contains the whole exponent part for both f16, f32, and f64.\n    const high16BitsAsUint16 = dataView.getUint16(0, false);\n    // Modify the exponent bits.\n    const modifiedHigh16Bits =\n      (high16BitsAsUint16 & ~expMaskForHigh16Bits) | targetExpBitsForHigh16Bits;\n    // Set back to buffer\n    dataView.setUint16(0, modifiedHigh16Bits, false);\n  };\n\n  // +/- 0.0\n  if (val === 0) {\n    return { fract: val, exp: 0 };\n  }\n  // NaN and Inf\n  if (!isFinite(val)) {\n    return { fract: val, exp: 0 };\n  }\n\n  setFloatToBuffer(val);\n  // Don't use val below. Use helper functions working with buffer instead.\n\n  let exp = 0;\n  // Normailze the value if it is subnormal. Increase the exponent by multiplying a subnormal value\n  // with 2**fractBitCount will result in a finite normal FP value of the given FP type.\n  if (isSubnormal(getFloatFromBuffer())) {\n    setFloatToBuffer(getFloatFromBuffer() * 2 ** fractBitCount);\n    exp = -fractBitCount;\n  }\n  // A normal FP value v is represented as v = ((-1)**s)*(2**(unbiased exponent))*f, where f is in\n  // range [1.0, 2.0). By moving a factor 2 from f to exponent, we have\n  // v = ((-1)**s)*(2**(unbiased exponent + 1))*(f / 2), where (f / 2) is in range [0.5, 1.0), so\n  // the exp = (unbiased exponent + 1) and fract = ((-1)**s)*(f / 2) is what we expect to get from\n  // frexp function. Note that fract and v only differs in exponent bitfield as long as v is normal.\n  // Calc the result exp by getting the unbiased float exponent and plus 1.\n  exp += extractUnbiasedExpFromNormalFloatInBuffer() + 1;\n  // Modify the exponent of float in buffer to make it be in range [0.5, 1.0) to get fract.\n  modifyExpOfNormalFloatInBuffer();\n\n  return { fract: getFloatFromBuffer(), exp };\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/**\n * Version of lerp that operates on bigint values\n *\n * lerp was not made into a generic or to take in (number|bigint), because that\n * introduces a bunch of complexity overhead related to type differentiation\n */\nexport function lerpBigInt(a: bigint, b: bigint, idx: number, steps: number): bigint {\n  assert(Math.trunc(idx) === idx);\n  assert(Math.trunc(steps) === steps);\n\n  // This constrains t to [0.0, 1.0]\n  assert(idx >= 0);\n  assert(steps > 0);\n  assert(idx < steps);\n\n  if (steps === 1) {\n    return a;\n  }\n  if (idx === 0) {\n    return a;\n  }\n  if (idx === steps - 1) {\n    return b;\n  }\n\n  const min = (x: bigint, y: bigint): bigint => {\n    return x < y ? x : y;\n  };\n  const max = (x: bigint, y: bigint): bigint => {\n    return x > y ? x : y;\n  };\n\n  // For number the variable t is used, there t = idx / (steps - 1),\n  // but that is a fraction on [0, 1], so becomes either 0 or 1 when converted\n  // to bigint, so need to expand things out.\n  const big_idx = BigInt(idx);\n  const big_steps = BigInt(steps);\n  if ((a <= 0n && b >= 0n) || (a >= 0n && b <= 0n)) {\n    return (b * big_idx) / (big_steps - 1n) + (a - (a * big_idx) / (big_steps - 1n));\n  }\n\n  const x = a + (b * big_idx) / (big_steps - 1n) - (a * big_idx) / (big_steps - 1n);\n  return !(b > a) ? max(b, x) : min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): readonly number[] {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * Version of linearRange that operates on bigint values\n *\n * linearRange was not made into a generic or to take in (number|bigint),\n * because that introduces a bunch of complexity overhead related to type\n * differentiation\n */\nexport function linearRangeBigInt(a: bigint, b: bigint, num_steps: number): Array<bigint> {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerpBigInt(a, b, i, num_steps));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): readonly number[] {\n  const c = 2;\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, Math.pow(i / (num_steps - 1), c)));\n}\n\n/**\n * Version of biasedRange that operates on bigint values\n *\n * biasedRange was not made into a generic or to take in (number|bigint),\n * because that introduces a bunch of complexity overhead related to type\n * differentiation.\n *\n * Scaling is used internally so that the number of possible indices is\n * significantly larger than num_steps. This is done to avoid duplicate entries\n * in the resulting range due to quantizing to integers during the calculation.\n *\n *  If a and b are close together, such that the number of integers between them\n *  is close to num_steps, then duplicates will occur regardless of scaling.\n */\nexport function biasedRangeBigInt(a: bigint, b: bigint, num_steps: number): readonly bigint[] {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  const c = 2;\n  const scaling = 1000;\n  const scaled_num_steps = num_steps * scaling;\n\n  return Array.from(Array(num_steps).keys()).map(i => {\n    const biased_i = Math.pow(i / (num_steps - 1), c); // Floating Point on [0, 1]\n    const scaled_i = Math.trunc((scaled_num_steps - 1) * biased_i); // Integer on [0, scaled_num_steps - 1]\n    return lerpBigInt(a, b, scaled_i, scaled_num_steps);\n  });\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseScalarF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function scalarF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.negative.subnormal.min,\n      kBit.f32.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x80000000,\n    // +0.0\n    0,\n    ...linearRange(\n      kBit.f32.positive.subnormal.min,\n      kBit.f32.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU32AsF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function filteredScalarF32Range(source: String, low: number, high: number): Array<number> {\n  return scalarF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseScalarF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function scalarF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.negative.subnormal.min,\n      kBit.f16.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000,\n    // +0.0\n    0,\n    ...linearRange(\n      kBit.f16.positive.subnormal.min,\n      kBit.f16.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU16AsF16);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 64-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f64 range.\n *\n * This function is intended to provide dense coverage of the f64 range, for a minimal list of values to use to cover\n * f64 behaviour, use sparseScalarF64Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function scalarF64Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(kBit.f64.negative.min, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.negative.subnormal.min,\n      kBit.f64.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000_0000_0000_0000n,\n    // +0.0\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.positive.subnormal.min,\n      kBit.f64.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, kBit.f64.positive.max, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/**\n * @returns an ascending sorted array of f64 values spread over specific range of f64 normal floats\n *\n * Numbers are divided into 4 regions: negative 64-bit normals, negative 64-bit subnormals, positive 64-bit subnormals &\n * positive 64-bit normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the range.\n *\n * @param begin a negative f64 normal float value\n * @param end a positive f64 normal float value\n * @param counts structure param with 4 entries indicating the number of entries\n *               to be generated each region, entries must be 0 or greater.\n */\nexport function limitedScalarF64Range(\n  begin: number,\n  end: number,\n  counts: { neg_norm?: number; neg_sub?: number; pos_sub: number; pos_norm: number } = {\n    pos_sub: 10,\n    pos_norm: 50,\n  }\n): Array<number> {\n  assert(\n    begin <= kValue.f64.negative.max,\n    `Beginning of range ${begin} must be negative f64 normal`\n  );\n  assert(end >= kValue.f64.positive.min, `Ending of range ${end} must be positive f64 normal`);\n\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  const u64_begin = reinterpretF64AsU64(begin);\n  const u64_end = reinterpretF64AsU64(end);\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(u64_begin, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.negative.subnormal.min,\n      kBit.f64.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000_0000_0000_0000n,\n    // +0.0\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.positive.subnormal.min,\n      kBit.f64.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, u64_end, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/** Short list of i32 values of interest to test against */\nconst kInterestingI32Values: readonly number[] = [\n  kValue.i32.negative.max,\n  Math.trunc(kValue.i32.negative.max / 2),\n  -256,\n  -10,\n  -1,\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.i32.positive.max / 2),\n  kValue.i32.positive.max,\n];\n\n/** @returns minimal i32 values that cover the entire range of i32 behaviours\n *\n * This is used instead of fullI32Range when the number of test cases being\n * generated is a super linear function of the length of i32 values which is\n * leading to time outs.\n */\nexport function sparseI32Range(): readonly number[] {\n  return kInterestingI32Values;\n}\n\nconst kVectorI32Values = {\n  2: kInterestingI32Values.flatMap(f => [\n    [f, 1],\n    [-1, f],\n  ]),\n  3: kInterestingI32Values.flatMap(f => [\n    [f, 1, -2],\n    [-1, f, 2],\n    [1, -2, f],\n  ]),\n  4: kInterestingI32Values.flatMap(f => [\n    [f, -1, 2, 3],\n    [1, f, -2, 3],\n    [1, 2, f, -3],\n    [-1, 2, -3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI32Range(dim: number): ROArrayArray<number> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI32Range only accepts dimensions 2, 3, and 4');\n  return kVectorI32Values[dim];\n}\n\nconst kSparseVectorI32Values = {\n  2: sparseI32Range().map((i, idx) => [idx % 2 === 0 ? i : idx, idx % 2 === 1 ? i : -idx]),\n  3: sparseI32Range().map((i, idx) => [\n    idx % 3 === 0 ? i : idx,\n    idx % 3 === 1 ? i : -idx,\n    idx % 3 === 2 ? i : idx,\n  ]),\n  4: sparseI32Range().map((i, idx) => [\n    idx % 4 === 0 ? i : idx,\n    idx % 4 === 1 ? i : -idx,\n    idx % 4 === 2 ? i : idx,\n    idx % 4 === 3 ? i : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting\n * abstract integer values.\n *\n * This is an even more stripped down version of `vectorI32Range` for when\n * pairs of vectors are being tested.\n * All interesting integers from sparseI32Range are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseVectorI32Range(dim: number): ROArrayArray<number> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorI32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorI32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of u32 values of interest to test against */\nconst kInterestingU32Values: readonly number[] = [\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.u32.max / 2),\n  kValue.u32.max,\n];\n\n/** @returns minimal u32 values that cover the entire range of u32 behaviours\n *\n * This is used instead of fullU32Range when the number of test cases being\n * generated is a super linear function of the length of u32 values which is\n * leading to time outs.\n */\nexport function sparseU32Range(): readonly number[] {\n  return kInterestingU32Values;\n}\n\nconst kVectorU32Values = {\n  2: kInterestingU32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n  ]),\n  3: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n  ]),\n  4: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting u32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting u32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting u32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorU32Range(dim: number): ROArrayArray<number> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorU32Range only accepts dimensions 2, 3, and 4');\n  return kVectorU32Values[dim];\n}\n\nconst kSparseVectorU32Values = {\n  2: sparseU32Range().map((i, idx) => [idx % 2 === 0 ? i : idx, idx % 2 === 1 ? i : -idx]),\n  3: sparseU32Range().map((i, idx) => [\n    idx % 3 === 0 ? i : idx,\n    idx % 3 === 1 ? i : -idx,\n    idx % 3 === 2 ? i : idx,\n  ]),\n  4: sparseU32Range().map((i, idx) => [\n    idx % 4 === 0 ? i : idx,\n    idx % 4 === 1 ? i : -idx,\n    idx % 4 === 2 ? i : idx,\n    idx % 4 === 3 ? i : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting\n * abstract integer values.\n *\n * This is an even more stripped down version of `vectorU32Range` for when\n * pairs of vectors are being tested.\n * All interesting integers from sparseU32Range are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseVectorU32Range(dim: number): ROArrayArray<number> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorU32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorU32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of i64 values of interest to test against */\nconst kInterestingI64Values: readonly bigint[] = [\n  kValue.i64.negative.max,\n  kValue.i64.negative.max / 2n,\n  -256n,\n  -10n,\n  -1n,\n  0n,\n  1n,\n  10n,\n  256n,\n  kValue.i64.positive.max / 2n,\n  kValue.i64.positive.max,\n];\n\n/** @returns minimal i64 values that cover the entire range of i64 behaviours\n *\n * This is used instead of fullI64Range when the number of test cases being\n * generated is a super linear function of the length of i64 values which is\n * leading to time outs.\n */\nexport function sparseI64Range(): readonly bigint[] {\n  return kInterestingI64Values;\n}\n\nconst kVectorI64Values = {\n  2: kInterestingI64Values.flatMap(f => [\n    [f, 1n],\n    [-1n, f],\n  ]),\n  3: kInterestingI64Values.flatMap(f => [\n    [f, 1n, -2n],\n    [-1n, f, 2n],\n    [1n, -2n, f],\n  ]),\n  4: kInterestingI64Values.flatMap(f => [\n    [f, -1n, 2n, 3n],\n    [1n, f, -2n, 3n],\n    [1n, 2n, f, -3n],\n    [-1n, 2n, -3n, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i64\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i64 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i64 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI64Range(dim: number): ROArrayArray<bigint> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI64Range only accepts dimensions 2, 3, and 4');\n  return kVectorI64Values[dim];\n}\n\nconst kSparseVectorI64Values = {\n  2: sparseI64Range().map((i, idx) => [\n    idx % 2 === 0 ? i : BigInt(idx),\n    idx % 2 === 1 ? i : -BigInt(idx),\n  ]),\n  3: sparseI64Range().map((i, idx) => [\n    idx % 3 === 0 ? i : BigInt(idx),\n    idx % 3 === 1 ? i : -BigInt(idx),\n    idx % 3 === 2 ? i : BigInt(idx),\n  ]),\n  4: sparseI64Range().map((i, idx) => [\n    idx % 4 === 0 ? i : BigInt(idx),\n    idx % 4 === 1 ? i : -BigInt(idx),\n    idx % 4 === 2 ? i : BigInt(idx),\n    idx % 4 === 3 ? i : -BigInt(idx),\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting\n * abstract integer values.\n *\n * This is an even more stripped down version of `vectorI64Range` for when\n * pairs of vectors are being tested.\n * All interesting integers from sparseI64Range are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseVectorI64Range(dim: number): ROArrayArray<bigint> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorI64Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorI64Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 64-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI64Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<bigint> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRangeBigInt(kValue.i64.negative.min, -1n, counts.negative),\n    0n,\n    ...biasedRangeBigInt(1n, kValue.i64.positive.max, counts.positive),\n  ];\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: readonly number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f32.negative.max,\n  kValue.f32.negative.subnormal.min,\n  kValue.f32.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f32.positive.subnormal.min,\n  kValue.f32.positive.subnormal.max,\n  kValue.f32.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseScalarF32Range(): readonly number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: kInterestingF32Values.flatMap(f => [\n    [f, 1.0],\n    [-1.0, f],\n  ]),\n  3: kInterestingF32Values.flatMap(f => [\n    [f, 1.0, -2.0],\n    [-1.0, f, 2.0],\n    [1.0, -2.0, f],\n  ]),\n  4: kInterestingF32Values.flatMap(f => [\n    [f, -1.0, 2.0, 3.0],\n    [1.0, f, -2.0, 3.0],\n    [1.0, 2.0, f, -3.0],\n    [-1.0, 2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): ROArrayArray<number> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseScalarF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseScalarF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseScalarF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseScalarF32 are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseVectorF32Range(dim: number): ROArrayArray<number> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n\nconst kSparseMatrixF32Values = {\n  2: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing\n * interesting float values.\n *\n * This is the matrix analogue of `sparseVectorF32Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f32 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseScalarF32 are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseMatrixF32Range(c: number, r: number): ROArrayArrayArray<number> {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF32Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF32Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF32Values[c][r];\n}\n\n/** Short list of f16 values of interest to test against */\nconst kInterestingF16Values: readonly number[] = [\n  kValue.f16.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f16.negative.max,\n  kValue.f16.negative.subnormal.min,\n  kValue.f16.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f16.positive.subnormal.min,\n  kValue.f16.positive.subnormal.max,\n  kValue.f16.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f16.positive.max,\n];\n\n/** @returns minimal f16 values that cover the entire range of f16 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF16Range when the number of test cases being\n * generated is a super linear function of the length of f16 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f16\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseScalarF16Range(): readonly number[] {\n  return kInterestingF16Values;\n}\n\nconst kVectorF16Values = {\n  2: kInterestingF16Values.flatMap(f => [\n    [f, 1.0],\n    [-1.0, f],\n  ]),\n  3: kInterestingF16Values.flatMap(f => [\n    [f, 1.0, -2.0],\n    [-1.0, f, 2.0],\n    [1.0, -2.0, f],\n  ]),\n  4: kInterestingF16Values.flatMap(f => [\n    [f, -1.0, 2.0, 3.0],\n    [1.0, f, -2.0, 3.0],\n    [1.0, 2.0, f, -3.0],\n    [-1.0, 2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting f16\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f16 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF16Range(dim: number): ROArrayArray<number> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF16Range only accepts dimensions 2, 3, and 4');\n  return kVectorF16Values[dim];\n}\n\nconst kSparseVectorF16Values = {\n  2: sparseScalarF16Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseScalarF16Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseScalarF16Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting f16\n * values.\n *\n * This is an even more stripped down version of `vectorF16Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseScalarF16 are guaranteed to be\n * tested, but not in every position.\n */\nexport function sparseVectorF16Range(dim: number): ROArrayArray<number> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF16Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF16Values[dim];\n}\n\nconst kSparseMatrixF16Values = {\n  2: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * f16 values.\n *\n * This is the matrix analogue of `sparseVectorF16Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f16 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseScalarF16 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF16Range(c: number, r: number): ROArrayArray<number>[] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF16Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF16Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF16Values[c][r];\n}\n\n/** Short list of f64 values of interest to test against */\nconst kInterestingF64Values: readonly number[] = [\n  kValue.f64.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f64.negative.max,\n  kValue.f64.negative.subnormal.min,\n  kValue.f64.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f64.positive.subnormal.min,\n  kValue.f64.positive.subnormal.max,\n  kValue.f64.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f64.positive.max,\n];\n\n/** @returns minimal F64 values that cover the entire range of F64 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF64Range when the number of test cases being\n * generated is a super linear function of the length of F64 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of F64\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseScalarF64Range(): readonly number[] {\n  return kInterestingF64Values;\n}\n\nconst kVectorF64Values = {\n  2: kInterestingF64Values.flatMap(f => [\n    [f, 1.0],\n    [-1.0, f],\n  ]),\n  3: kInterestingF64Values.flatMap(f => [\n    [f, 1.0, -2.0],\n    [-1.0, f, 2.0],\n    [1.0, -2.0, f],\n  ]),\n  4: kInterestingF64Values.flatMap(f => [\n    [f, -1.0, 2.0, 3.0],\n    [1.0, f, -2.0, 3.0],\n    [1.0, 2.0, f, -3.0],\n    [-1.0, 2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting F64 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF64Range(dim: number): ROArrayArray<number> {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF64Range only accepts dimensions 2, 3, and 4');\n  return kVectorF64Values[dim];\n}\n\nconst kSparseVectorF64Values = {\n  2: sparseScalarF64Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseScalarF64Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseScalarF64Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting f64\n * values.\n *\n * This is an even more stripped down version of `vectorF64Range` for when\n * pairs of vectors are being tested.\n * All the interesting floats from sparseScalarF64 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF64Range(dim: number): ROArrayArray<number> {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF64Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF64Values[dim];\n}\n\nconst kSparseMatrixF64Values = {\n  2: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF64Range`, so it is producing a\n * minimal coverage set of matrices that test all the interesting f64 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All the interesting floats from sparseScalarF64 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF64Range(cols: number, rows: number): ROArrayArrayArray<number> {\n  assert(\n    cols === 2 || cols === 3 || cols === 4,\n    'sparseMatrixF64Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    rows === 2 || rows === 3 || rows === 4,\n    'sparseMatrixF64Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF64Values[cols][rows];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\nexport interface QuantizeFunc<T> {\n  (num: T): T;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return Math.fround(num);\n}\n\n/** @returns the closest 16-bit floating point value to the input */\nexport function quantizeToF16(num: number): number {\n  return hfround(num);\n}\n\n/**\n * @returns the closest 32-bit signed integer value to the input, rounding\n * towards 0, if not already an integer\n */\nexport function quantizeToI32(num: number): number {\n  if (num >= kValue.i32.positive.max) {\n    return kValue.i32.positive.max;\n  }\n  if (num <= kValue.i32.negative.min) {\n    return kValue.i32.negative.min;\n  }\n  return Math.trunc(num);\n}\n\n/**\n * @returns the closest 32-bit unsigned integer value to the input, rounding\n * towards 0, if not already an integer\n */\nexport function quantizeToU32(num: number): number {\n  if (num >= kValue.u32.max) {\n    return kValue.u32.max;\n  }\n  if (num <= 0) {\n    return 0;\n  }\n  return Math.trunc(num);\n}\n\n/**\n * @returns the closest 64-bit signed integer value to the input.\n */\nexport function quantizeToI64(num: bigint): bigint {\n  if (num >= kValue.i64.positive.max) {\n    return kValue.i64.positive.max;\n  }\n  if (num <= kValue.i64.negative.min) {\n    return kValue.i64.negative.min;\n  }\n  return num;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  assert((n | 0) === n, 'isPowerOfTwo only supports 32-bit numbers');\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(\n  elements: readonly T[],\n  intermediate: ROArrayArray<T>\n): ROArrayArray<T> {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: readonly T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: ROArrayArray<T>): ROArrayArray<T> {\n  let result: ROArrayArray<T> = [];\n  inputs.forEach((i: readonly T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n\n/** @returns all of the permutations of an array\n *\n * Recursively calculates all of the permutations, does not cull duplicate\n * entries.\n *\n * Only feasible for inputs of lengths 5 or so, since the number of permutations\n * is (input.length)!, so will cause the stack to explode for longer inputs.\n *\n * This code could be made iterative using something like\n * SteinhausJohnsonTrotter and additionally turned into a generator to reduce\n * the stack size, but there is still a fundamental combinatorial explosion\n * here that will affect runtime.\n *\n * @param input the array to get permutations of\n */\nexport function calculatePermutations<T>(input: readonly T[]): ROArrayArray<T> {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (input.length === 1) {\n    return [input];\n  }\n\n  if (input.length === 2) {\n    return [input, [input[1], input[0]]];\n  }\n\n  const result: T[][] = [];\n  input.forEach((head, idx) => {\n    const tail = input.slice(0, idx).concat(input.slice(idx + 1));\n    const permutations = calculatePermutations(tail);\n    permutations.forEach(p => {\n      result.push([head, ...p]);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Convert an Array of Arrays to linear array\n *\n * Caller is responsible to retaining the dimensions of the array for later\n * unflattening\n *\n * @param m Matrix to convert\n */\nexport function flatten2DArray<T>(m: ROArrayArray<T>): T[] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to flatten`\n  );\n  const result: T[] = Array<T>(c * r);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[j + i * r] = m[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Convert linear array to an Array of Arrays\n * @param n an array to convert\n * @param c number of elements in the array containing arrays\n * @param r number of elements in the arrays that are contained\n */\nexport function unflatten2DArray<T>(n: readonly T[], c: number, r: number): ROArrayArray<T> {\n  assert(\n    c > 0 && Number.isInteger(c) && r > 0 && Number.isInteger(r),\n    `columns (${c}) and rows (${r}) need to be positive integers`\n  );\n  assert(n.length === c * r, `m.length(${n.length}) should equal c * r (${c * r})`);\n  const result: T[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = n[j + i * r];\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .map over a matrix and return the result\n * The shape of the input and output matrices will be the same\n *\n * @param m input matrix of type T\n * @param op operation that converts an element of type T to one of type S\n * @returns a matrix with elements of type S that are calculated by applying op element by element\n */\nexport function map2DArray<T, S>(m: ROArrayArray<T>, op: (input: T) => S): ROArrayArray<S> {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  const result: S[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = op(m[i][j]);\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .every over a matrix and return the result\n *\n * @param m input matrix of type T\n * @param op operation that performs a test on an element\n * @returns a boolean indicating if the test passed for every element\n */\nexport function every2DArray<T>(m: ROArrayArray<T>, op: (input: T) => boolean): boolean {\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  return m.every(col => col.every(el => op(el)));\n}\n\n/**\n * Subtracts 2 vectors\n */\nexport function subtractVectors(v1: readonly number[], v2: readonly number[]) {\n  return v1.map((v, i) => v - v2[i]);\n}\n\n/**\n * Computes the dot product of 2 vectors\n */\nexport function dotProduct(v1: readonly number[], v2: readonly number[]) {\n  return v1.reduce((a, v, i) => a + v * v2[i], 0);\n}\n\n/** @returns the absolute value of a bigint */\nexport function absBigInt(v: bigint): bigint {\n  return v < 0n ? -v : v;\n}\n\n/** @returns the maximum from a list of bigints */\nexport function maxBigInt(...vals: bigint[]): bigint {\n  return vals.reduce((prev, cur) => (cur > prev ? cur : prev));\n}\n\n/** @returns the minimum from a list of bigints */\nexport function minBigInt(...vals: bigint[]): bigint {\n  return vals.reduce((prev, cur) => (cur < prev ? cur : prev));\n}\n"],"mappings":";;GACA,SAASA,MAAM,QAAQ,2BAA2B,CAClD;EACEC,YAAY;EACZC,UAAU;EACVC,OAAO;EACPC,UAAU;AACL,+CAA+C;;AAEtD,SAASC,IAAI,EAAEC,MAAM,QAAQ,gBAAgB;AAC7C;EACEC,mBAAmB;EACnBC,mBAAmB;EACnBC,mBAAmB;EACnBC,mBAAmB;AACd,kBAAkB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,gBAAgB,GAAG,CAAC;;AAE9D;AACA;AACA,OAAO,SAASC,KAAKA,CAACC,CAAS,EAAEC,SAAiB,EAAU;EAC1DhB,MAAM,CAACY,MAAM,CAACK,SAAS,CAACF,CAAC,CAAC,IAAIA,CAAC,IAAI,CAAC,EAAE,kCAAkC,CAAC;EACzEf,MAAM,CAACY,MAAM,CAACK,SAAS,CAACD,SAAS,CAAC,IAAIA,SAAS,GAAG,CAAC,EAAE,sCAAsC,CAAC;EAC5F,OAAOE,IAAI,CAACC,IAAI,CAACJ,CAAC,GAAGC,SAAS,CAAC,GAAGA,SAAS;AAC7C;;AAEA;AACA,OAAO,SAASI,SAASA,CAACL,CAAS,EAAEC,SAAiB,EAAU;EAC9DhB,MAAM,CAACY,MAAM,CAACK,SAAS,CAACF,CAAC,CAAC,IAAIA,CAAC,IAAI,CAAC,EAAE,kCAAkC,CAAC;EACzEf,MAAM,CAACY,MAAM,CAACK,SAAS,CAACD,SAAS,CAAC,IAAIA,SAAS,GAAG,CAAC,EAAE,sCAAsC,CAAC;EAC5F,OAAOE,IAAI,CAACG,KAAK,CAACN,CAAC,GAAGC,SAAS,CAAC,GAAGA,SAAS;AAC9C;;AAEA;AACA,OAAO,SAASM,KAAKA,CAACP,CAAS,EAAE,EAAEQ,GAAG,EAAEC,GAAG,CAA+B,CAAC,EAAU;EACnFxB,MAAM,CAACwB,GAAG,IAAID,GAAG,CAAC;EAClB,OAAOL,IAAI,CAACK,GAAG,CAACL,IAAI,CAACM,GAAG,CAACT,CAAC,EAAEQ,GAAG,CAAC,EAAEC,GAAG,CAAC;AACxC;;AAEA;AACA,OAAO,SAASC,uBAAuBA,CAACC,GAAW,EAAU;EAC3D,OAAOC,oBAAoB,CAACD,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAG;AAC5C;;AAEA;AACA,OAAO,SAASC,oBAAoBA,CAACZ,CAAS,EAAW;EACvD,OAAOA,CAAC,GAAGT,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACL,GAAG,IAAIT,CAAC,GAAGT,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACP,GAAG;AACnE;;AAEA;AACA,OAAO,SAASQ,uBAAuBA,CAACL,GAAW,EAAU;EAC3D,OAAOM,oBAAoB,CAACN,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAG;AAC5C;;AAEA;AACA,OAAO,SAASM,oBAAoBA,CAACjB,CAAS,EAAW;EACvD,OAAOA,CAAC,GAAGT,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACL,GAAG,IAAIT,CAAC,GAAGT,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACP,GAAG;AACnE;;AAEA;AACA,OAAO,SAASW,WAAWA,CAACnB,CAAS,EAAE;EACrC,OAAOA,CAAC,IAAIT,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG,IAAIR,CAAC,IAAIT,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG;AACrE;;AAEA;AACA,OAAO,SAASW,uBAAuBA,CAACT,GAAW,EAAU;EAC3D,OAAOU,oBAAoB,CAACV,GAAG,CAAC,GAAG,CAAC,GAAGA,GAAG;AAC5C;;AAEA;AACA,OAAO,SAASU,oBAAoBA,CAACrB,CAAS,EAAW;EACvD,OAAOA,CAAC,GAAGT,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACL,GAAG,IAAIT,CAAC,GAAGT,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACP,GAAG;AACnE;;AAEA;AACA,OAAO,SAASe,WAAWA,CAACvB,CAAS,EAAE;EACrC,OAAOA,CAAC,IAAIT,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG,IAAIR,CAAC,IAAIT,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG;AACrE;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMe,gBAAgB,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;AAC3C,MAAMC,eAAe,GAAG,IAAIC,cAAc,CAACH,gBAAgB,CAAC;AAC5D,MAAMI,iBAAiB,GAAG,IAAIC,YAAY,CAACL,gBAAgB,CAAC;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,YAAYA,CAACnB,GAAW,EAAEoB,GAAkB,EAAEC,IAAe,EAAU;EACrF,IAAInC,MAAM,CAACoC,KAAK,CAACtB,GAAG,CAAC,EAAE;IACrB,OAAOA,GAAG;EACZ;;EAEA,IAAIA,GAAG,KAAKd,MAAM,CAACqC,iBAAiB,EAAE;IACpC,OAAO3C,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACoB,QAAQ;EACrC;;EAEA,IAAIxB,GAAG,KAAKd,MAAM,CAACuC,iBAAiB,EAAE;IACpC,OAAO7C,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACqB,QAAQ;EACrC;;EAEAlD,MAAM;IACJ0B,GAAG,IAAIpB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACN,GAAG,IAAIE,GAAG,IAAIpB,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACN,GAAG;IAC/D,GAAEG,GAAI;EACT,CAAC;;EAEDA,GAAG,GAAGqB,IAAI,KAAK,OAAO,GAAGtB,uBAAuB,CAACC,GAAG,CAAC,GAAGA,GAAG;;EAE3D;EACA,IAAIA,GAAG,KAAK,CAAC,EAAE;IACb,IAAIoB,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOC,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACP,GAAG,GAAGjB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IACvF,CAAC,MAAM;MACL,OAAOwB,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACL,GAAG,GAAGlB,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IACvF;EACF;;EAEAmB,iBAAiB,CAAC,CAAC,CAAC,GAAGjB,GAAG;EAC1B,MAAM2B,WAAW,GAAG,CAACZ,eAAe,CAAC,CAAC,CAAC,GAAG,sBAAsB,MAAM,EAAE;EACxE,IAAIY,WAAW,MAAMP,GAAG,KAAK,UAAU,CAAC,EAAE;IACxCL,eAAe,CAAC,CAAC,CAAC,IAAI,EAAE;EAC1B,CAAC,MAAM;IACLA,eAAe,CAAC,CAAC,CAAC,IAAI,EAAE;EAC1B;;EAEA;EACA,IAAI,CAACA,eAAe,CAAC,CAAC,CAAC,GAAG,sBAAsB,MAAM,sBAAsB,EAAE;IAC5E,IAAIK,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOxC,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACoB,QAAQ;IACrC,CAAC,MAAM;MACL,OAAO5C,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACqB,QAAQ;IACrC;EACF;;EAEA,OAAOH,IAAI,KAAK,OAAO,GAAGtB,uBAAuB,CAACkB,iBAAiB,CAAC,CAAC,CAAC,CAAC,GAAGA,iBAAiB,CAAC,CAAC,CAAC;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMW,gBAAgB,GAAG,IAAId,WAAW,CAAC,CAAC,CAAC;AAC3C,MAAMe,eAAe,GAAG,IAAIC,WAAW,CAACF,gBAAgB,CAAC;AACzD,MAAMG,iBAAiB,GAAG,IAAIC,YAAY,CAACJ,gBAAgB,CAAC;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,YAAYA,CAACjC,GAAW,EAAEoB,GAAkB,EAAEC,IAAe,EAAU;EACrF,IAAInC,MAAM,CAACoC,KAAK,CAACtB,GAAG,CAAC,EAAE;IACrB,OAAOA,GAAG;EACZ;;EAEA,IAAIA,GAAG,KAAKd,MAAM,CAACqC,iBAAiB,EAAE;IACpC,OAAO3C,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACoB,QAAQ;EACrC;;EAEA,IAAIxB,GAAG,KAAKd,MAAM,CAACuC,iBAAiB,EAAE;IACpC,OAAO7C,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACqB,QAAQ;EACrC;;EAEAlD,MAAM;IACJ0B,GAAG,IAAIpB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG,IAAIE,GAAG,IAAIpB,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG;IAC/D,GAAEG,GAAI;EACT,CAAC;;EAEDA,GAAG,GAAGqB,IAAI,KAAK,OAAO,GAAGhB,uBAAuB,CAACL,GAAG,CAAC,GAAGA,GAAG;;EAE3D;EACA,IAAIA,GAAG,KAAK,CAAC,EAAE;IACb,IAAIoB,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOC,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACP,GAAG,GAAGjB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IACvF,CAAC,MAAM;MACL,OAAOwB,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACL,GAAG,GAAGlB,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IACvF;EACF;;EAEAiC,iBAAiB,CAAC,CAAC,CAAC,GAAG/B,GAAG,CAAC,CAAC;EAC5B;EACGoB,GAAG,KAAK,UAAU,IAAIW,iBAAiB,CAAC,CAAC,CAAC,IAAI/B,GAAG;EACjDoB,GAAG,KAAK,UAAU,IAAIW,iBAAiB,CAAC,CAAC,CAAC,IAAI/B,GAAI;EACnD;IACA;IACA;IACA;IACA,MAAM2B,WAAW,GAAG,CAACE,eAAe,CAAC,CAAC,CAAC,GAAG,UAAU,MAAM,CAAC;IAC3D,IAAIF,WAAW,MAAMP,GAAG,KAAK,UAAU,CAAC,EAAE;MACxCS,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,CAAC,MAAM;MACLA,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB;EACF;;EAEA;EACA,IAAI,CAACA,eAAe,CAAC,CAAC,CAAC,GAAG,UAAU,MAAM,UAAU,EAAE;IACpD,IAAIT,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOxC,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACoB,QAAQ;IACrC,CAAC,MAAM;MACL,OAAO5C,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACqB,QAAQ;IACrC;EACF;;EAEA,OAAOH,IAAI,KAAK,OAAO,GAAGhB,uBAAuB,CAAC0B,iBAAiB,CAAC,CAAC,CAAC,CAAC,GAAGA,iBAAiB,CAAC,CAAC,CAAC;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,gBAAgB,GAAG,IAAIpB,WAAW,CAAC,CAAC,CAAC;AAC3C,MAAMqB,eAAe,GAAG,IAAIC,WAAW,CAACF,gBAAgB,CAAC;AACzD,MAAMG,iBAAiB,GAAG,IAAI9D,YAAY,CAAC2D,gBAAgB,CAAC;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,YAAYA,CAACtC,GAAW,EAAEoB,GAAkB,EAAEC,IAAe,EAAU;EACrF,IAAInC,MAAM,CAACoC,KAAK,CAACtB,GAAG,CAAC,EAAE;IACrB,OAAOA,GAAG;EACZ;;EAEA,IAAIA,GAAG,KAAKd,MAAM,CAACqC,iBAAiB,EAAE;IACpC,OAAO3C,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACoB,QAAQ;EACrC;;EAEA,IAAIxB,GAAG,KAAKd,MAAM,CAACuC,iBAAiB,EAAE;IACpC,OAAO7C,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACqB,QAAQ;EACrC;;EAEAlD,MAAM;IACJ0B,GAAG,IAAIpB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG,IAAIE,GAAG,IAAIpB,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG;IAC/D,GAAEG,GAAI;EACT,CAAC;;EAEDA,GAAG,GAAGqB,IAAI,KAAK,OAAO,GAAGZ,uBAAuB,CAACT,GAAG,CAAC,GAAGA,GAAG;;EAE3D;EACA,IAAIA,GAAG,KAAK,CAAC,EAAE;IACb,IAAIoB,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOC,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACP,GAAG,GAAGjB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IACvF,CAAC,MAAM;MACL,OAAOwB,IAAI,KAAK,OAAO,GAAGzC,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACL,GAAG,GAAGlB,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IACvF;EACF;;EAEAuC,iBAAiB,CAAC,CAAC,CAAC,GAAGrC,GAAG,CAAC,CAAC;EAC5B;EACGoB,GAAG,KAAK,UAAU,IAAIiB,iBAAiB,CAAC,CAAC,CAAC,IAAIrC,GAAG;EACjDoB,GAAG,KAAK,UAAU,IAAIiB,iBAAiB,CAAC,CAAC,CAAC,IAAIrC,GAAI;EACnD;IACA;IACA;IACA;IACA,MAAM2B,WAAW,GAAG,CAACQ,eAAe,CAAC,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;IACvD,IAAIR,WAAW,MAAMP,GAAG,KAAK,UAAU,CAAC,EAAE;MACxCe,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,CAAC,MAAM;MACLA,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB;EACF;;EAEA;EACA,IAAI,CAACA,eAAe,CAAC,CAAC,CAAC,GAAG,MAAM,MAAM,MAAM,EAAE;IAC5C,IAAIf,GAAG,KAAK,UAAU,EAAE;MACtB,OAAOxC,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACoB,QAAQ;IACrC,CAAC,MAAM;MACL,OAAO5C,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACqB,QAAQ;IACrC;EACF;;EAEA,OAAOH,IAAI,KAAK,OAAO,GAAGZ,uBAAuB,CAAC4B,iBAAiB,CAAC,CAAC,CAAC,CAAC,GAAGA,iBAAiB,CAAC,CAAC,CAAC;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,SAASA,CAACC,MAAc,EAAEnB,IAAe,GAAG,OAAO,EAAU;EAC3E,IAAInC,MAAM,CAACoC,KAAK,CAACkB,MAAM,CAAC,EAAE;IACxB,OAAOtD,MAAM,CAACuD,GAAG;EACnB;;EAEAD,MAAM,GAAGnB,IAAI,KAAK,OAAO,GAAGtB,uBAAuB,CAACyC,MAAM,CAAC,GAAGA,MAAM;;EAEpE;EACA;EACA;EACA;EACEA,MAAM,KAAKtD,MAAM,CAACqC,iBAAiB;EACnCiB,MAAM,IAAI5D,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACN,GAAG;EACjC0C,MAAM,KAAKtD,MAAM,CAACuC,iBAAiB;EACnCe,MAAM,IAAI5D,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACN,GAAG;EACjC;IACA,OAAOjB,MAAM,CAACsB,GAAG,CAACwC,OAAO;EAC3B;;EAEA;EACA;EACA;EACA;EACA,MAAMC,MAAM,GAAGxB,YAAY,CAACqB,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACrD,MAAMuB,KAAK,GAAGzB,YAAY,CAACqB,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACpD;EACA;EACA,OAAO7B,IAAI,CAACK,GAAG,CAAC2C,MAAM,GAAGG,MAAM,EAAEC,KAAK,GAAGJ,MAAM,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,SAASA,CAACL,MAAc,EAAEnB,IAAe,GAAG,OAAO,EAAU;EAC3E,IAAInC,MAAM,CAACoC,KAAK,CAACkB,MAAM,CAAC,EAAE;IACxB,OAAOtD,MAAM,CAACuD,GAAG;EACnB;;EAEAD,MAAM,GAAGnB,IAAI,KAAK,OAAO,GAAGhB,uBAAuB,CAACmC,MAAM,CAAC,GAAGA,MAAM;;EAEpE;EACA;EACA;EACA;EACEA,MAAM,KAAKtD,MAAM,CAACqC,iBAAiB;EACnCiB,MAAM,IAAI5D,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG;EACjC0C,MAAM,KAAKtD,MAAM,CAACuC,iBAAiB;EACnCe,MAAM,IAAI5D,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG;EACjC;IACA,OAAOjB,MAAM,CAAC2B,GAAG,CAACmC,OAAO;EAC3B;;EAEA;EACA;EACA;EACA;EACA,MAAMC,MAAM,GAAGV,YAAY,CAACO,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACrD,MAAMuB,KAAK,GAAGX,YAAY,CAACO,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACpD,MAAMyB,SAAiB,GAAGC,aAAa,CAACP,MAAM,CAAC;EAC/C,IAAIM,SAAS,KAAKN,MAAM,EAAE;IACxB;IACA,OAAOhD,IAAI,CAACK,GAAG,CAAC2C,MAAM,GAAGG,MAAM,EAAEC,KAAK,GAAGJ,MAAM,CAAC;EAClD,CAAC,MAAM;IACL;IACA,OAAOI,KAAK,GAAGD,MAAM;EACvB;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASK,OAAOA,CAAC,GAAGC,MAAgB,EAAE;EAC3C,IAAI5D,CAAC,GAAG,WAAW;EACnB,KAAK,MAAM6D,CAAC,IAAID,MAAM,EAAE;IACtB5D,CAAC,GAAG6D,CAAC,IAAI7D,CAAC,IAAI,CAAC,CAAC,IAAIA,CAAC,KAAK,CAAC,CAAC;IAC5BA,CAAC,GAAIA,CAAC,GAAG,OAAO,GAAI,WAAW;EACjC;EACAA,CAAC,IAAIA,CAAC,KAAK,CAAC;EACZA,CAAC,IAAIA,CAAC,IAAI,EAAE;EACZA,CAAC,GAAGA,CAAC,GAAG,WAAW;EACnB,IAAIA,CAAC,GAAG,CAAC,EAAE;IACTA,CAAC,GAAG,CAACA,CAAC,GAAG,CAAC,GAAG,CAAC;EAChB;EACA,OAAOA,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8D,SAASA,CAACX,MAAc,EAAEnB,IAAe,GAAG,OAAO,EAAU;EAC3E,IAAInC,MAAM,CAACoC,KAAK,CAACkB,MAAM,CAAC,EAAE;IACxB,OAAOtD,MAAM,CAACuD,GAAG;EACnB;;EAEAD,MAAM,GAAGnB,IAAI,KAAK,OAAO,GAAGZ,uBAAuB,CAAC+B,MAAM,CAAC,GAAGA,MAAM;;EAEpE;EACA;EACA;EACA;EACEA,MAAM,KAAKtD,MAAM,CAACqC,iBAAiB;EACnCiB,MAAM,IAAI5D,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG;EACjC0C,MAAM,KAAKtD,MAAM,CAACuC,iBAAiB;EACnCe,MAAM,IAAI5D,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG;EACjC;IACA,OAAOjB,MAAM,CAAC+B,GAAG,CAAC+B,OAAO;EAC3B;;EAEA;EACA;EACA;EACA;EACA,MAAMC,MAAM,GAAGL,YAAY,CAACE,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACrD,MAAMuB,KAAK,GAAGN,YAAY,CAACE,MAAM,EAAE,UAAU,EAAEnB,IAAI,CAAC;EACpD,MAAMyB,SAAiB,GAAGM,aAAa,CAACZ,MAAM,CAAC;EAC/C,IAAIM,SAAS,KAAKN,MAAM,EAAE;IACxB;IACA,OAAOhD,IAAI,CAACK,GAAG,CAAC2C,MAAM,GAAGG,MAAM,EAAEC,KAAK,GAAGJ,MAAM,CAAC;EAClD,CAAC,MAAM;IACL;IACA,OAAOI,KAAK,GAAGD,MAAM;EACvB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,mBAAmBA,CAAChE,CAAS,EAAqB;EAChEf,MAAM,CAAC,CAACY,MAAM,CAACoC,KAAK,CAACjC,CAAC,CAAC,EAAG,yCAAwC,CAAC;EACnE;EACA,IAAIA,CAAC,KAAKH,MAAM,CAACqC,iBAAiB,EAAE;IAClC,OAAO,CAAC3C,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACN,GAAG,EAAEZ,MAAM,CAACqC,iBAAiB,CAAC;EAC5D;;EAEA;EACA,IAAIlC,CAAC,KAAKH,MAAM,CAACuC,iBAAiB,EAAE;IAClC,OAAO,CAACvC,MAAM,CAACuC,iBAAiB,EAAE7C,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACN,GAAG,CAAC;EAC5D;;EAEA,OAAO,CAACR,CAAC,CAAC;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiE,mBAAmBA,CAACjE,CAAS,EAAqB;EAChE,IAAIH,MAAM,CAACoC,KAAK,CAACjC,CAAC,CAAC,EAAE;IACnB,OAAO,CAACA,CAAC,CAAC;EACZ;;EAEA;EACA,IAAIA,CAAC,IAAI,CAAC,KAAKT,MAAM,CAAC2B,GAAG,CAACgD,IAAI,GAAG,CAAC,CAAC,EAAE;IACnC,OAAO,CAACrE,MAAM,CAACqC,iBAAiB,CAAC;EACnC;;EAEA;EACA,IAAIlC,CAAC,GAAGT,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG,EAAE;IAC/B,OAAO,CAAClB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG,EAAEZ,MAAM,CAACqC,iBAAiB,CAAC;EAC5D;;EAEA;EACA,IAAIlC,CAAC,IAAIT,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG,IAAIT,CAAC,IAAIT,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG,EAAE;IAChE,MAAM2D,IAAI,GAAGT,aAAa,CAAC1D,CAAC,CAAC;IAC7B,IAAIA,CAAC,KAAKmE,IAAI,EAAE;MACd;MACA,OAAO,CAACnE,CAAC,CAAC;IACZ;;IAEA,IAAImE,IAAI,GAAGnE,CAAC,EAAE;MACZ;MACA,MAAMoE,KAAK,GAAGxB,YAAY,CAACuB,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC;MACxD,OAAO,CAACC,KAAK,EAAED,IAAI,CAAC;IACtB,CAAC,MAAM;MACL;MACA,MAAMC,KAAK,GAAGxB,YAAY,CAACuB,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC;MACxD,OAAO,CAACA,IAAI,EAAEC,KAAK,CAAC;IACtB;EACF;;EAEA;EACA,IAAIpE,CAAC,GAAG,EAAE,CAAC,KAAKT,MAAM,CAAC2B,GAAG,CAACgD,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;IACrC,OAAO,CAACrE,MAAM,CAACuC,iBAAiB,EAAE7C,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG,CAAC;EAC5D;;EAEA;EACA,OAAO,CAACX,MAAM,CAACuC,iBAAiB,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiC,mBAAmBA,CAACrE,CAAS,EAAqB;EAChE,IAAIH,MAAM,CAACoC,KAAK,CAACjC,CAAC,CAAC,EAAE;IACnB,OAAO,CAACA,CAAC,CAAC;EACZ;;EAEA;EACA,IAAIA,CAAC,IAAI,CAAC,KAAKT,MAAM,CAAC+B,GAAG,CAAC4C,IAAI,GAAG,CAAC,CAAC,EAAE;IACnC,OAAO,CAACrE,MAAM,CAACqC,iBAAiB,CAAC;EACnC;;EAEA;EACA,IAAIlC,CAAC,GAAGT,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG,EAAE;IAC/B,OAAO,CAAClB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG,EAAEZ,MAAM,CAACqC,iBAAiB,CAAC;EAC5D;;EAEA;EACA,IAAIlC,CAAC,IAAIT,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG,IAAIT,CAAC,IAAIT,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG,EAAE;IAChE,MAAM8D,IAAI,GAAGP,aAAa,CAAC/D,CAAC,CAAC;IAC7B,IAAIA,CAAC,KAAKsE,IAAI,EAAE;MACd;MACA,OAAO,CAACtE,CAAC,CAAC;IACZ;;IAEA,IAAIsE,IAAI,GAAGtE,CAAC,EAAE;MACZ;MACA,MAAMoE,KAAK,GAAGnB,YAAY,CAACqB,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC;MACxD,OAAO,CAACF,KAAK,EAAEE,IAAI,CAAC;IACtB,CAAC,MAAM;MACL;MACA,MAAMF,KAAK,GAAGnB,YAAY,CAACqB,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC;MACxD,OAAO,CAACA,IAAI,EAAEF,KAAK,CAAC;IACtB;EACF;;EAEA;EACA,IAAIpE,CAAC,GAAG,EAAE,CAAC,KAAKT,MAAM,CAAC+B,GAAG,CAAC4C,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;IACrC,OAAO,CAACrE,MAAM,CAACuC,iBAAiB,EAAE7C,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG,CAAC;EAC5D;;EAEA;EACA,OAAO,CAACX,MAAM,CAACuC,iBAAiB,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASmC,KAAKA,CAAC5D,GAAW,EAAE6D,KAA4B,EAAkC;EAC/F,MAAMC,MAAM,GAAG,IAAIhD,WAAW,CAAC,CAAC,CAAC;EACjC,MAAMiD,QAAQ,GAAG,IAAIC,QAAQ,CAACF,MAAM,CAAC;;EAErC;EACA;EACA;EACA,IAAIG,WAAmB,EAAEC,aAAqB,EAAEC,OAAe;EAC/D;EACA;EACA;EACA;EACA;EACA,IAAIC,oBAA4B,EAAEC,0BAAkC;EACpE;EACA,IAAIC,gBAAqC;EACzC;EACA,IAAIC,kBAAgC;;EAEpC,IAAIC,QAAgC;EACpC,IAAIC,WAAmC;;EAEvC,IAAIZ,KAAK,KAAK,KAAK,EAAE;IACnB;IACAI,WAAW,GAAG,CAAC;IACfC,aAAa,GAAG,EAAE;IAClBC,OAAO,GAAG,GAAG;IACb;IACAC,oBAAoB,GAAG,MAAM;IAC7B;IACAC,0BAA0B,GAAG,MAAM;IACnCG,QAAQ,GAAGhE,WAAW;IACtBiE,WAAW,GAAGnE,oBAAoB;IAClC;IACAgE,gBAAgB,GAAGA,CAACpB,CAAS,KAAKa,QAAQ,CAACW,UAAU,CAAC,CAAC,EAAExB,CAAC,EAAE,KAAK,CAAC;IAClEqB,kBAAkB,GAAGA,CAAA,KAAMR,QAAQ,CAACY,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC;EAC1D,CAAC,MAAM,IAAId,KAAK,KAAK,KAAK,EAAE;IAC1B;IACAI,WAAW,GAAG,CAAC;IACfC,aAAa,GAAG,EAAE;IAClBC,OAAO,GAAG,EAAE;IACZ;IACAC,oBAAoB,GAAG,MAAM;IAC7B;IACAC,0BAA0B,GAAG,MAAM;IACnCG,QAAQ,GAAG5D,WAAW;IACtB6D,WAAW,GAAG/D,oBAAoB;IAClC;IACA4D,gBAAgB,GAAGA,CAACpB,CAAS,KAAKxE,UAAU,CAACqF,QAAQ,EAAE,CAAC,EAAEb,CAAC,EAAE,KAAK,CAAC;IACnEqB,kBAAkB,GAAGA,CAAA,KAAM/F,UAAU,CAACuF,QAAQ,EAAE,CAAC,EAAE,KAAK,CAAC;EAC3D,CAAC,MAAM;IACLzF,MAAM,CAACuF,KAAK,KAAK,KAAK,CAAC;IACvB;IACAI,WAAW,GAAG,EAAE;IAChBC,aAAa,GAAG,EAAE;IAClBC,OAAO,GAAG,IAAI;IACd;IACAC,oBAAoB,GAAG,MAAM;IAC7B;IACAC,0BAA0B,GAAG,MAAM;IACnCG,QAAQ,GAAGtF,MAAM,CAACsF,QAAQ;IAC1BC,WAAW,GAAGxE,oBAAoB;IAClC;IACAqE,gBAAgB,GAAGA,CAACpB,CAAS,KAAKa,QAAQ,CAACa,UAAU,CAAC,CAAC,EAAE1B,CAAC,EAAE,KAAK,CAAC;IAClEqB,kBAAkB,GAAGA,CAAA,KAAMR,QAAQ,CAACc,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC;EAC1D;EACA;EACA,MAAMC,yCAAyC,GAAGA,CAAA,KAAM;IACtD;IACAxG,MAAM,CAACkG,QAAQ,CAACD,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAACE,WAAW,CAACF,kBAAkB,CAAC,CAAC,CAAC,CAAC;IAC5E;IACA,MAAMQ,kBAAkB,GAAGhB,QAAQ,CAACiB,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;IACvD;IACA,OAAO,CAAC,CAACD,kBAAkB,GAAGX,oBAAoB,KAAM,EAAE,GAAG,CAAC,GAAGH,WAAY,IAAIE,OAAO;EAC1F,CAAC;EACD;EACA;EACA,MAAMc,8BAA8B,GAAGA,CAAA,KAAM;IAC3C;IACA3G,MAAM,CAACkG,QAAQ,CAACD,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAACE,WAAW,CAACF,kBAAkB,CAAC,CAAC,CAAC,CAAC;IAC5E;IACA,MAAMQ,kBAAkB,GAAGhB,QAAQ,CAACiB,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;IACvD;IACA,MAAME,kBAAkB;IACrBH,kBAAkB,GAAG,CAACX,oBAAoB,GAAIC,0BAA0B;IAC3E;IACAN,QAAQ,CAACoB,SAAS,CAAC,CAAC,EAAED,kBAAkB,EAAE,KAAK,CAAC;EAClD,CAAC;;EAED;EACA,IAAIlF,GAAG,KAAK,CAAC,EAAE;IACb,OAAO,EAAEoF,KAAK,EAAEpF,GAAG,EAAEqF,GAAG,EAAE,CAAC,CAAC,CAAC;EAC/B;EACA;EACA,IAAI,CAACb,QAAQ,CAACxE,GAAG,CAAC,EAAE;IAClB,OAAO,EAAEoF,KAAK,EAAEpF,GAAG,EAAEqF,GAAG,EAAE,CAAC,CAAC,CAAC;EAC/B;;EAEAf,gBAAgB,CAACtE,GAAG,CAAC;EACrB;;EAEA,IAAIqF,GAAG,GAAG,CAAC;EACX;EACA;EACA,IAAIZ,WAAW,CAACF,kBAAkB,CAAC,CAAC,CAAC,EAAE;IACrCD,gBAAgB,CAACC,kBAAkB,CAAC,CAAC,GAAG,CAAC,IAAIL,aAAa,CAAC;IAC3DmB,GAAG,GAAG,CAACnB,aAAa;EACtB;EACA;EACA;EACA;EACA;EACA;EACA;EACAmB,GAAG,IAAIP,yCAAyC,CAAC,CAAC,GAAG,CAAC;EACtD;EACAG,8BAA8B,CAAC,CAAC;;EAEhC,OAAO,EAAEG,KAAK,EAAEb,kBAAkB,CAAC,CAAC,EAAEc,GAAG,CAAC,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAIA,CAACC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAU;EAC5D,IAAI,CAACvG,MAAM,CAACsF,QAAQ,CAACe,CAAC,CAAC,IAAI,CAACrG,MAAM,CAACsF,QAAQ,CAACgB,CAAC,CAAC,EAAE;IAC9C,OAAOtG,MAAM,CAACuD,GAAG;EACnB;;EAEA,IAAK8C,CAAC,IAAI,GAAG,IAAIC,CAAC,IAAI,GAAG,IAAMD,CAAC,IAAI,GAAG,IAAIC,CAAC,IAAI,GAAI,EAAE;IACpD,OAAOC,CAAC,GAAGD,CAAC,GAAG,CAAC,CAAC,GAAGC,CAAC,IAAIF,CAAC;EAC5B;;EAEA,IAAIE,CAAC,KAAK,GAAG,EAAE;IACb,OAAOD,CAAC;EACV;;EAEA,MAAME,CAAC,GAAGH,CAAC,GAAGE,CAAC,IAAID,CAAC,GAAGD,CAAC,CAAC;EACzB,OAAOE,CAAC,GAAG,GAAG,KAAKD,CAAC,GAAGD,CAAC,GAAG/F,IAAI,CAACM,GAAG,CAAC0F,CAAC,EAAEE,CAAC,CAAC,GAAGlG,IAAI,CAACK,GAAG,CAAC2F,CAAC,EAAEE,CAAC,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACJ,CAAS,EAAEC,CAAS,EAAEI,GAAW,EAAEC,KAAa,EAAU;EACnFvH,MAAM,CAACkB,IAAI,CAACsG,KAAK,CAACF,GAAG,CAAC,KAAKA,GAAG,CAAC;EAC/BtH,MAAM,CAACkB,IAAI,CAACsG,KAAK,CAACD,KAAK,CAAC,KAAKA,KAAK,CAAC;;EAEnC;EACAvH,MAAM,CAACsH,GAAG,IAAI,CAAC,CAAC;EAChBtH,MAAM,CAACuH,KAAK,GAAG,CAAC,CAAC;EACjBvH,MAAM,CAACsH,GAAG,GAAGC,KAAK,CAAC;;EAEnB,IAAIA,KAAK,KAAK,CAAC,EAAE;IACf,OAAON,CAAC;EACV;EACA,IAAIK,GAAG,KAAK,CAAC,EAAE;IACb,OAAOL,CAAC;EACV;EACA,IAAIK,GAAG,KAAKC,KAAK,GAAG,CAAC,EAAE;IACrB,OAAOL,CAAC;EACV;;EAEA,MAAM3F,GAAG,GAAGA,CAAC6F,CAAS,EAAEK,CAAS,KAAa;IAC5C,OAAOL,CAAC,GAAGK,CAAC,GAAGL,CAAC,GAAGK,CAAC;EACtB,CAAC;EACD,MAAMjG,GAAG,GAAGA,CAAC4F,CAAS,EAAEK,CAAS,KAAa;IAC5C,OAAOL,CAAC,GAAGK,CAAC,GAAGL,CAAC,GAAGK,CAAC;EACtB,CAAC;;EAED;EACA;EACA;EACA,MAAMC,OAAO,GAAGC,MAAM,CAACL,GAAG,CAAC;EAC3B,MAAMM,SAAS,GAAGD,MAAM,CAACJ,KAAK,CAAC;EAC/B,IAAKN,CAAC,IAAI,EAAE,IAAIC,CAAC,IAAI,EAAE,IAAMD,CAAC,IAAI,EAAE,IAAIC,CAAC,IAAI,EAAG,EAAE;IAChD,OAAQA,CAAC,GAAGQ,OAAO,IAAKE,SAAS,GAAG,EAAE,CAAC,IAAIX,CAAC,GAAIA,CAAC,GAAGS,OAAO,IAAKE,SAAS,GAAG,EAAE,CAAC,CAAC;EAClF;;EAEA,MAAMR,CAAC,GAAGH,CAAC,GAAIC,CAAC,GAAGQ,OAAO,IAAKE,SAAS,GAAG,EAAE,CAAC,GAAIX,CAAC,GAAGS,OAAO,IAAKE,SAAS,GAAG,EAAE,CAAC;EACjF,OAAO,EAAEV,CAAC,GAAGD,CAAC,CAAC,GAAGzF,GAAG,CAAC0F,CAAC,EAAEE,CAAC,CAAC,GAAG7F,GAAG,CAAC2F,CAAC,EAAEE,CAAC,CAAC;AACzC;;AAEA;AACA,OAAO,SAASS,WAAWA,CAACZ,CAAS,EAAEC,CAAS,EAAEY,SAAiB,EAAqB;EACtF,IAAIA,SAAS,IAAI,CAAC,EAAE;IAClB,OAAO,EAAE;EACX;;EAEA;EACA,IAAIA,SAAS,KAAK,CAAC,EAAE;IACnB,OAAO,CAACb,CAAC,CAAC;EACZ;;EAEA,OAAOc,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,SAAS,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAAC,CAAC,KAAInB,IAAI,CAACC,CAAC,EAAEC,CAAC,EAAEiB,CAAC,IAAIL,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;AACtF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,iBAAiBA,CAACnB,CAAS,EAAEC,CAAS,EAAEY,SAAiB,EAAiB;EACxF,IAAIA,SAAS,IAAI,CAAC,EAAE;IAClB,OAAO,EAAE;EACX;;EAEA;EACA,IAAIA,SAAS,KAAK,CAAC,EAAE;IACnB,OAAO,CAACb,CAAC,CAAC;EACZ;;EAEA,OAAOc,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,SAAS,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAAC,CAAC,KAAId,UAAU,CAACJ,CAAC,EAAEC,CAAC,EAAEiB,CAAC,EAAEL,SAAS,CAAC,CAAC;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,WAAWA,CAACpB,CAAS,EAAEC,CAAS,EAAEY,SAAiB,EAAqB;EACtF,MAAMQ,CAAC,GAAG,CAAC;EACX,IAAIR,SAAS,IAAI,CAAC,EAAE;IAClB,OAAO,EAAE;EACX;;EAEA;EACA,IAAIA,SAAS,KAAK,CAAC,EAAE;IACnB,OAAO,CAACb,CAAC,CAAC;EACZ;;EAEA,OAAOc,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,SAAS,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAAC,CAAC,KAAInB,IAAI,CAACC,CAAC,EAAEC,CAAC,EAAEhG,IAAI,CAACqH,GAAG,CAACJ,CAAC,IAAIL,SAAS,GAAG,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC;AACnG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,iBAAiBA,CAACvB,CAAS,EAAEC,CAAS,EAAEY,SAAiB,EAAqB;EAC5F,IAAIA,SAAS,IAAI,CAAC,EAAE;IAClB,OAAO,EAAE;EACX;;EAEA;EACA,IAAIA,SAAS,KAAK,CAAC,EAAE;IACnB,OAAO,CAACb,CAAC,CAAC;EACZ;;EAEA,MAAMqB,CAAC,GAAG,CAAC;EACX,MAAMG,OAAO,GAAG,IAAI;EACpB,MAAMC,gBAAgB,GAAGZ,SAAS,GAAGW,OAAO;;EAE5C,OAAOV,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,SAAS,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAAC,CAAC,KAAI;IAClD,MAAMQ,QAAQ,GAAGzH,IAAI,CAACqH,GAAG,CAACJ,CAAC,IAAIL,SAAS,GAAG,CAAC,CAAC,EAAEQ,CAAC,CAAC,CAAC,CAAC;IACnD,MAAMM,QAAQ,GAAG1H,IAAI,CAACsG,KAAK,CAAC,CAACkB,gBAAgB,GAAG,CAAC,IAAIC,QAAQ,CAAC,CAAC,CAAC;IAChE,OAAOtB,UAAU,CAACJ,CAAC,EAAEC,CAAC,EAAE0B,QAAQ,EAAEF,gBAAgB,CAAC;EACrD,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,cAAcA;AAC5BC,MAKC;;;;;AAAG,EAAEC,OAAO,EAAE,EAAE,EAAEC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAClB;EACfF,MAAM,CAACG,QAAQ,GAAGH,MAAM,CAACG,QAAQ,KAAKC,SAAS,GAAGJ,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,QAAQ;EACnFH,MAAM,CAACK,OAAO,GAAGL,MAAM,CAACK,OAAO,KAAKD,SAAS,GAAGJ,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACK,OAAO;;EAE/E;EACA;EACA;EACA,MAAMC,UAAU,GAAG;EACjB,GAAGvB,WAAW,CAACxH,IAAI,CAAC4B,GAAG,CAACJ,QAAQ,CAACN,GAAG,EAAElB,IAAI,CAAC4B,GAAG,CAACJ,QAAQ,CAACL,GAAG,EAAEsH,MAAM,CAACG,QAAQ,CAAC;EAC7E,GAAGpB,WAAW;IACZxH,IAAI,CAAC4B,GAAG,CAACJ,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAAC4B,GAAG,CAACJ,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACK;EACT,CAAC;EACD;EACA,UAAU;EACV;EACA,CAAC;EACD,GAAGtB,WAAW;IACZxH,IAAI,CAAC4B,GAAG,CAACH,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAAC4B,GAAG,CAACH,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACC;EACT,CAAC;EACD,GAAGlB,WAAW,CAACxH,IAAI,CAAC4B,GAAG,CAACH,QAAQ,CAACP,GAAG,EAAElB,IAAI,CAAC4B,GAAG,CAACH,QAAQ,CAACN,GAAG,EAAEsH,MAAM,CAACE,QAAQ,CAAC,CAC9E;EAACd,GAAG,CAAChH,IAAI,CAACsG,KAAK,CAAC;EACjB,OAAO4B,UAAU,CAAClB,GAAG,CAACzH,mBAAmB,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS4I,sBAAsBA,CAACC,MAAc,EAAEC,GAAW,EAAEC,IAAY,EAAiB;EAC/F,OAAOX,cAAc,CAAC,CAAC,CAACY,MAAM,CAAC,CAAArC,CAAC,KAAIkC,MAAM,KAAK,OAAO,IAAKlC,CAAC,IAAImC,GAAG,IAAInC,CAAC,IAAIoC,IAAK,CAAC;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,cAAcA;AAC5BZ,MAKC;;;;;AAAG,EAAEC,OAAO,EAAE,EAAE,EAAEC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAClB;EACfF,MAAM,CAACG,QAAQ,GAAGH,MAAM,CAACG,QAAQ,KAAKC,SAAS,GAAGJ,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,QAAQ;EACnFH,MAAM,CAACK,OAAO,GAAGL,MAAM,CAACK,OAAO,KAAKD,SAAS,GAAGJ,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACK,OAAO;;EAE/E;EACA;EACA;EACA,MAAMC,UAAU,GAAG;EACjB,GAAGvB,WAAW,CAACxH,IAAI,CAACgC,GAAG,CAACR,QAAQ,CAACN,GAAG,EAAElB,IAAI,CAACgC,GAAG,CAACR,QAAQ,CAACL,GAAG,EAAEsH,MAAM,CAACG,QAAQ,CAAC;EAC7E,GAAGpB,WAAW;IACZxH,IAAI,CAACgC,GAAG,CAACR,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACgC,GAAG,CAACR,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACK;EACT,CAAC;EACD;EACA,MAAM;EACN;EACA,CAAC;EACD,GAAGtB,WAAW;IACZxH,IAAI,CAACgC,GAAG,CAACP,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACgC,GAAG,CAACP,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACC;EACT,CAAC;EACD,GAAGlB,WAAW,CAACxH,IAAI,CAACgC,GAAG,CAACP,QAAQ,CAACP,GAAG,EAAElB,IAAI,CAACgC,GAAG,CAACP,QAAQ,CAACN,GAAG,EAAEsH,MAAM,CAACE,QAAQ,CAAC,CAC9E;EAACd,GAAG,CAAChH,IAAI,CAACsG,KAAK,CAAC;EACjB,OAAO4B,UAAU,CAAClB,GAAG,CAACxH,mBAAmB,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiJ,cAAcA;AAC5Bb,MAKC;;;;;AAAG,EAAEC,OAAO,EAAE,EAAE,EAAEC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAClB;EACfF,MAAM,CAACG,QAAQ,GAAGH,MAAM,CAACG,QAAQ,KAAKC,SAAS,GAAGJ,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,QAAQ;EACnFH,MAAM,CAACK,OAAO,GAAGL,MAAM,CAACK,OAAO,KAAKD,SAAS,GAAGJ,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACK,OAAO;;EAE/E;EACA;EACA;EACA,MAAMC,UAAU,GAAG;EACjB,GAAGhB,iBAAiB,CAAC/H,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACN,GAAG,EAAElB,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACL,GAAG,EAAEsH,MAAM,CAACG,QAAQ,CAAC;EACnF,GAAGb,iBAAiB;IAClB/H,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACK;EACT,CAAC;EACD;EACA,sBAAsB;EACtB;EACA,EAAE;EACF,GAAGf,iBAAiB;IAClB/H,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACC;EACT,CAAC;EACD,GAAGX,iBAAiB,CAAC/H,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACP,GAAG,EAAElB,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACN,GAAG,EAAEsH,MAAM,CAACE,QAAQ,CAAC,CACpF;;EACD,OAAOI,UAAU,CAAClB,GAAG,CAAC1H,mBAAmB,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoJ,qBAAqBA;AACnCC,KAAa;AACbC,GAAW;AACXhB,MAAkF,GAAG;EACnFC,OAAO,EAAE,EAAE;EACXC,QAAQ,EAAE;AACZ,CAAC;AACc;EACfhJ,MAAM;IACJ6J,KAAK,IAAIvJ,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACL,GAAG;IAC/B,sBAAqBqI,KAAM;EAC9B,CAAC;EACD7J,MAAM,CAAC8J,GAAG,IAAIxJ,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACP,GAAG,EAAG,mBAAkBuI,GAAI,8BAA6B,CAAC;;EAE5FhB,MAAM,CAACG,QAAQ,GAAGH,MAAM,CAACG,QAAQ,KAAKC,SAAS,GAAGJ,MAAM,CAACE,QAAQ,GAAGF,MAAM,CAACG,QAAQ;EACnFH,MAAM,CAACK,OAAO,GAAGL,MAAM,CAACK,OAAO,KAAKD,SAAS,GAAGJ,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACK,OAAO;;EAE/E,MAAMY,SAAS,GAAGxJ,mBAAmB,CAACsJ,KAAK,CAAC;EAC5C,MAAMG,OAAO,GAAGzJ,mBAAmB,CAACuJ,GAAG,CAAC;EACxC;EACA;EACA;EACA,MAAMV,UAAU,GAAG;EACjB,GAAGhB,iBAAiB,CAAC2B,SAAS,EAAE1J,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACL,GAAG,EAAEsH,MAAM,CAACG,QAAQ,CAAC;EACvE,GAAGb,iBAAiB;IAClB/H,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACuB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACK;EACT,CAAC;EACD;EACA,sBAAsB;EACtB;EACA,EAAE;EACF,GAAGf,iBAAiB;IAClB/H,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;IAC/BlB,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;IAC/BsH,MAAM,CAACC;EACT,CAAC;EACD,GAAGX,iBAAiB,CAAC/H,IAAI,CAACuB,GAAG,CAACE,QAAQ,CAACP,GAAG,EAAEyI,OAAO,EAAElB,MAAM,CAACE,QAAQ,CAAC,CACtE;;EACD,OAAOI,UAAU,CAAClB,GAAG,CAAC1H,mBAAmB,CAAC;AAC5C;;AAEA;AACA,MAAMyJ,qBAAwC,GAAG;AAC/C3J,MAAM,CAAC4J,GAAG,CAACrI,QAAQ,CAACL,GAAG;AACvBN,IAAI,CAACsG,KAAK,CAAClH,MAAM,CAAC4J,GAAG,CAACrI,QAAQ,CAACL,GAAG,GAAG,CAAC,CAAC;AACvC,CAAC,GAAG;AACJ,CAAC,EAAE;AACH,CAAC,CAAC;AACF,CAAC;AACD,CAAC;AACD,EAAE;AACF,GAAG;AACHN,IAAI,CAACsG,KAAK,CAAClH,MAAM,CAAC4J,GAAG,CAACpI,QAAQ,CAACN,GAAG,GAAG,CAAC,CAAC;AACvClB,MAAM,CAAC4J,GAAG,CAACpI,QAAQ,CAACN,GAAG,CACxB;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS2I,cAAcA,CAAA,EAAsB;EAClD,OAAOF,qBAAqB;AAC9B;;AAEA,MAAMG,gBAAgB,GAAG;EACvB,CAAC,EAAEH,qBAAqB,CAACI,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,CAAC;EACN,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC;EACR,CAAC;EACF,CAAC,EAAEL,qBAAqB,CAACI,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACV,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE,CAAC,CAAC;EACV,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEA,CAAC,CAAC;EACX,CAAC;EACF,CAAC,EAAEL,qBAAqB,CAACI,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACb,CAAC,CAAC,EAAEA,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACb,CAAC,CAAC,EAAE,CAAC,EAAEA,CAAC,EAAE,CAAC,CAAC,CAAC;EACb,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEA,CAAC,CAAC;EACf;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAACC,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOJ,gBAAgB,CAACI,GAAG,CAAC;AAC9B;;AAEA,MAAMC,sBAAsB,GAAG;EAC7B,CAAC,EAAEN,cAAc,CAAC,CAAC,CAACjC,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG,CAAC,CAAC;EACxF,CAAC,EAAE6C,cAAc,CAAC,CAAC,CAACjC,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACxB,CAAC;EACF,CAAC,EAAE6C,cAAc,CAAC,CAAC,CAACjC,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACzB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoD,oBAAoBA,CAACF,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAOC,sBAAsB,CAACD,GAAG,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,YAAYA;AAC1B7B,MAGC;;;AAAG,EAAEhH,QAAQ,EAAE,EAAE,CAAC,CAAC;AACL;EACfgH,MAAM,CAACjH,QAAQ,GAAGiH,MAAM,CAACjH,QAAQ,KAAKqH,SAAS,GAAGJ,MAAM,CAAChH,QAAQ,GAAGgH,MAAM,CAACjH,QAAQ;EACnF,OAAO;EACL,GAAGwG,WAAW,CAAC/H,MAAM,CAAC4J,GAAG,CAACrI,QAAQ,CAACN,GAAG,EAAE,CAAC,CAAC,EAAEuH,MAAM,CAACjH,QAAQ,CAAC;EAC5D,CAAC;EACD,GAAGwG,WAAW,CAAC,CAAC,EAAE/H,MAAM,CAAC4J,GAAG,CAACpI,QAAQ,CAACN,GAAG,EAAEsH,MAAM,CAAChH,QAAQ,CAAC,CAC5D;EAACoG,GAAG,CAAChH,IAAI,CAACsG,KAAK,CAAC;AACnB;;AAEA;AACA,MAAMoD,qBAAwC,GAAG;AAC/C,CAAC;AACD,CAAC;AACD,EAAE;AACF,GAAG;AACH1J,IAAI,CAACsG,KAAK,CAAClH,MAAM,CAACuK,GAAG,CAACrJ,GAAG,GAAG,CAAC,CAAC;AAC9BlB,MAAM,CAACuK,GAAG,CAACrJ,GAAG,CACf;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsJ,cAAcA,CAAA,EAAsB;EAClD,OAAOF,qBAAqB;AAC9B;;AAEA,MAAMG,gBAAgB,GAAG;EACvB,CAAC,EAAEH,qBAAqB,CAACP,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,CAAC;EACN,CAAC,CAAC,EAAEA,CAAC,CAAC;EACP,CAAC;EACF,CAAC,EAAEM,qBAAqB,CAACP,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACT,CAAC,CAAC,EAAEA,CAAC,EAAE,CAAC,CAAC;EACT,CAAC,CAAC,EAAE,CAAC,EAAEA,CAAC,CAAC;EACV,CAAC;EACF,CAAC,EAAEM,qBAAqB,CAACP,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACZ,CAAC,CAAC,EAAEA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACZ,CAAC,CAAC,EAAE,CAAC,EAAEA,CAAC,EAAE,CAAC,CAAC;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEA,CAAC,CAAC;EACb;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,cAAcA,CAACR,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOO,gBAAgB,CAACP,GAAG,CAAC;AAC9B;;AAEA,MAAMS,sBAAsB,GAAG;EAC7B,CAAC,EAAEH,cAAc,CAAC,CAAC,CAAC5C,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG,CAAC,CAAC;EACxF,CAAC,EAAEwD,cAAc,CAAC,CAAC,CAAC5C,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACxB,CAAC;EACF,CAAC,EAAEwD,cAAc,CAAC,CAAC,CAAC5C,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGb,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACb,GAAG;EACzB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS4D,oBAAoBA,CAACV,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAOS,sBAAsB,CAACT,GAAG,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,YAAYA,CAACC,KAAa,GAAG,EAAE,EAAiB;EAC9D,OAAO,CAAC,CAAC,EAAE,GAAG/C,WAAW,CAAC,CAAC,EAAE/H,MAAM,CAACuK,GAAG,CAACrJ,GAAG,EAAE4J,KAAK,CAAC,CAAC,CAAClD,GAAG,CAAChH,IAAI,CAACsG,KAAK,CAAC;AACtE;;AAEA;AACA,MAAM6D,qBAAwC,GAAG;AAC/C/K,MAAM,CAACgL,GAAG,CAACzJ,QAAQ,CAACL,GAAG;AACvBlB,MAAM,CAACgL,GAAG,CAACzJ,QAAQ,CAACL,GAAG,GAAG,EAAE;AAC5B,CAAC,IAAI;AACL,CAAC,GAAG;AACJ,CAAC,EAAE;AACH,EAAE;AACF,EAAE;AACF,GAAG;AACH,IAAI;AACJlB,MAAM,CAACgL,GAAG,CAACxJ,QAAQ,CAACN,GAAG,GAAG,EAAE;AAC5BlB,MAAM,CAACgL,GAAG,CAACxJ,QAAQ,CAACN,GAAG,CACxB;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+J,cAAcA,CAAA,EAAsB;EAClD,OAAOF,qBAAqB;AAC9B;;AAEA,MAAMG,gBAAgB,GAAG;EACvB,CAAC,EAAEH,qBAAqB,CAAChB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,EAAE,CAAC;EACP,CAAC,CAAC,EAAE,EAAEA,CAAC,CAAC;EACT,CAAC;EACF,CAAC,EAAEe,qBAAqB,CAAChB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC;EACZ,CAAC,CAAC,EAAE,EAAEA,CAAC,EAAE,EAAE,CAAC;EACZ,CAAC,EAAE,EAAE,CAAC,EAAE,EAAEA,CAAC,CAAC;EACb,CAAC;EACF,CAAC,EAAEe,qBAAqB,CAAChB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAChB,CAAC,EAAE,EAAEA,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;EAChB,CAAC,EAAE,EAAE,EAAE,EAAEA,CAAC,EAAE,CAAC,EAAE,CAAC;EAChB,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAEA,CAAC,CAAC;EAClB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASmB,cAAcA,CAACjB,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOgB,gBAAgB,CAAChB,GAAG,CAAC;AAC9B;;AAEA,MAAMkB,sBAAsB,GAAG;EAC7B,CAAC,EAAEH,cAAc,CAAC,CAAC,CAACrD,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGR,MAAM,CAACL,GAAG,CAAC;EAC/BA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACR,MAAM,CAACL,GAAG,CAAC;EACjC,CAAC;EACF,CAAC,EAAEiE,cAAc,CAAC,CAAC,CAACrD,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGR,MAAM,CAACL,GAAG,CAAC;EAC/BA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACR,MAAM,CAACL,GAAG,CAAC;EAChCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGR,MAAM,CAACL,GAAG,CAAC;EAChC,CAAC;EACF,CAAC,EAAEiE,cAAc,CAAC,CAAC,CAACrD,GAAG,CAAC,CAACC,CAAC,EAAEb,GAAG,KAAK;EAClCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGR,MAAM,CAACL,GAAG,CAAC;EAC/BA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACR,MAAM,CAACL,GAAG,CAAC;EAChCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAGR,MAAM,CAACL,GAAG,CAAC;EAC/BA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGa,CAAC,GAAG,CAACR,MAAM,CAACL,GAAG,CAAC;EACjC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqE,oBAAoBA,CAACnB,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAOkB,sBAAsB,CAAClB,GAAG,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoB,YAAYA;AAC1B9C,MAGC;;;AAAG,EAAEhH,QAAQ,EAAE,EAAE,CAAC,CAAC;AACL;EACfgH,MAAM,CAACjH,QAAQ,GAAGiH,MAAM,CAACjH,QAAQ,KAAKqH,SAAS,GAAGJ,MAAM,CAAChH,QAAQ,GAAGgH,MAAM,CAACjH,QAAQ;EACnF,OAAO;EACL,GAAG2G,iBAAiB,CAAClI,MAAM,CAACgL,GAAG,CAACzJ,QAAQ,CAACN,GAAG,EAAE,CAAC,EAAE,EAAEuH,MAAM,CAACjH,QAAQ,CAAC;EACnE,EAAE;EACF,GAAG2G,iBAAiB,CAAC,EAAE,EAAElI,MAAM,CAACgL,GAAG,CAACxJ,QAAQ,CAACN,GAAG,EAAEsH,MAAM,CAAChH,QAAQ,CAAC,CACnE;;AACH;;AAEA;AACA,MAAM+J,qBAAwC,GAAG;AAC/CvL,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACN,GAAG;AACvB,CAAC,IAAI;AACL,CAAC,GAAG;AACJ,CAAC,KAAK;AACNjB,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACL,GAAG;AACvBlB,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAAC2B,GAAG,CAACJ,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;AACjC,CAAC,GAAG;AACJ,GAAG;AACHlB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;AACjClB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACP,GAAG;AACvB,KAAK;AACL,GAAG;AACH,IAAI;AACJjB,MAAM,CAAC2B,GAAG,CAACH,QAAQ,CAACN,GAAG,CACxB;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsK,oBAAoBA,CAAA,EAAsB;EACxD,OAAOD,qBAAqB;AAC9B;;AAEA,MAAME,gBAAgB,GAAG;EACvB,CAAC,EAAEF,qBAAqB,CAACxB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,CAAC;EACR,CAAC,CAAC,GAAG,EAAEA,CAAC,CAAC;EACV,CAAC;EACF,CAAC,EAAEuB,qBAAqB,CAACxB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC;EACd,CAAC,CAAC,GAAG,EAAEA,CAAC,EAAE,GAAG,CAAC;EACd,CAAC,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACf,CAAC;EACF,CAAC,EAAEuB,qBAAqB,CAACxB,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAE,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,CAAC;EACnB,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACrB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0B,cAAcA,CAACxB,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOuB,gBAAgB,CAACvB,GAAG,CAAC;AAC9B;;AAEA,MAAMyB,sBAAsB,GAAG;EAC7B,CAAC,EAAEH,oBAAoB,CAAC,CAAC,CAAC5D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC,CAAC;EAC9F,CAAC,EAAEwE,oBAAoB,CAAC,CAAC,CAAC5D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACxB,CAAC;EACF,CAAC,EAAEwE,oBAAoB,CAAC,CAAC,CAAC5D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACzB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS4E,oBAAoBA,CAAC1B,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAOyB,sBAAsB,CAACzB,GAAG,CAAC;AACpC;;AAEA,MAAM2B,sBAAsB,GAAG;EAC7B,CAAC,EAAE;IACD,CAAC,EAAEN,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC9E,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACxB;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC7E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC7E,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAChF,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnF,CAAC;IACF,CAAC,EAAEuE,qBAAqB,CAAC3D,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,CAC1B;;IACF;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8E,oBAAoBA,CAAC9D,CAAS,EAAE+D,CAAS,EAA6B;EACpFrM,MAAM;IACJsI,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC;IAC7B;EACF,CAAC;EACDtI,MAAM;IACJqM,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC;IAC7B;EACF,CAAC;EACD,OAAOF,sBAAsB,CAAC7D,CAAC,CAAC,CAAC+D,CAAC,CAAC;AACrC;;AAEA;AACA,MAAMC,qBAAwC,GAAG;AAC/ChM,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACN,GAAG;AACvB,CAAC,IAAI;AACL,CAAC,GAAG;AACJ,CAAC,KAAK;AACNjB,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACL,GAAG;AACvBlB,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAAC+B,GAAG,CAACR,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;AACjC,CAAC,GAAG;AACJ,GAAG;AACHlB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;AACjClB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACP,GAAG;AACvB,KAAK;AACL,GAAG;AACH,IAAI;AACJjB,MAAM,CAAC+B,GAAG,CAACP,QAAQ,CAACN,GAAG,CACxB;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+K,oBAAoBA,CAAA,EAAsB;EACxD,OAAOD,qBAAqB;AAC9B;;AAEA,MAAME,gBAAgB,GAAG;EACvB,CAAC,EAAEF,qBAAqB,CAACjC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,CAAC;EACR,CAAC,CAAC,GAAG,EAAEA,CAAC,CAAC;EACV,CAAC;EACF,CAAC,EAAEgC,qBAAqB,CAACjC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC;EACd,CAAC,CAAC,GAAG,EAAEA,CAAC,EAAE,GAAG,CAAC;EACd,CAAC,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACf,CAAC;EACF,CAAC,EAAEgC,qBAAqB,CAACjC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAE,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,CAAC;EACnB,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACrB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASmC,cAAcA,CAACjC,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOgC,gBAAgB,CAAChC,GAAG,CAAC;AAC9B;;AAEA,MAAMkC,sBAAsB,GAAG;EAC7B,CAAC,EAAEH,oBAAoB,CAAC,CAAC,CAACrE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC,CAAC;EAC9F,CAAC,EAAEiF,oBAAoB,CAAC,CAAC,CAACrE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACxB,CAAC;EACF,CAAC,EAAEiF,oBAAoB,CAAC,CAAC,CAACrE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACzB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqF,oBAAoBA,CAACnC,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAOkC,sBAAsB,CAAClC,GAAG,CAAC;AACpC;;AAEA,MAAMoC,sBAAsB,GAAG;EAC7B,CAAC,EAAE;IACD,CAAC,EAAEN,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC9E,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACxB;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC7E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC7E,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAChF,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnF,CAAC;IACF,CAAC,EAAEgF,qBAAqB,CAACpE,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,CAC1B;;IACF;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuF,oBAAoBA,CAACvE,CAAS,EAAE+D,CAAS,EAA0B;EACjFrM,MAAM;IACJsI,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC;IAC7B;EACF,CAAC;EACDtI,MAAM;IACJqM,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC;IAC7B;EACF,CAAC;EACD,OAAOO,sBAAsB,CAACtE,CAAC,CAAC,CAAC+D,CAAC,CAAC;AACrC;;AAEA;AACA,MAAMS,qBAAwC,GAAG;AAC/CxM,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACN,GAAG;AACvB,CAAC,IAAI;AACL,CAAC,GAAG;AACJ,CAAC,KAAK;AACNjB,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACL,GAAG;AACvBlB,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAACsB,GAAG,CAACC,QAAQ,CAACuB,SAAS,CAAC5B,GAAG;AACjC,CAAC,GAAG;AACJ,GAAG;AACHlB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC7B,GAAG;AACjCjB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACsB,SAAS,CAAC5B,GAAG;AACjClB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACP,GAAG;AACvB,KAAK;AACL,GAAG;AACH,IAAI;AACJjB,MAAM,CAACsB,GAAG,CAACE,QAAQ,CAACN,GAAG,CACxB;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuL,oBAAoBA,CAAA,EAAsB;EACxD,OAAOD,qBAAqB;AAC9B;;AAEA,MAAME,gBAAgB,GAAG;EACvB,CAAC,EAAEF,qBAAqB,CAACzC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,CAAC;EACR,CAAC,CAAC,GAAG,EAAEA,CAAC,CAAC;EACV,CAAC;EACF,CAAC,EAAEwC,qBAAqB,CAACzC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC;EACd,CAAC,CAAC,GAAG,EAAEA,CAAC,EAAE,GAAG,CAAC;EACd,CAAC,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACf,CAAC;EACF,CAAC,EAAEwC,qBAAqB,CAACzC,OAAO,CAAC,CAAAC,CAAC,KAAI;EACpC,CAACA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;EACnB,CAAC,GAAG,EAAE,GAAG,EAAEA,CAAC,EAAE,CAAC,GAAG,CAAC;EACnB,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAEA,CAAC,CAAC;EACrB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS2C,cAAcA,CAACzC,GAAW,EAAwB;EAChExK,MAAM,CAACwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,EAAE,oDAAoD,CAAC;EACjG,OAAOwC,gBAAgB,CAACxC,GAAG,CAAC;AAC9B;;AAEA,MAAM0C,sBAAsB,GAAG;EAC7B,CAAC,EAAEH,oBAAoB,CAAC,CAAC,CAAC7E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC,CAAC;EAC9F,CAAC,EAAEyF,oBAAoB,CAAC,CAAC,CAAC7E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACxB,CAAC;EACF,CAAC,EAAEyF,oBAAoB,CAAC,CAAC,CAAC7E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;EACxCA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;EACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;EACzB;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS6F,oBAAoBA,CAAC3C,GAAW,EAAwB;EACtExK,MAAM;IACJwK,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,CAAC;IACnC;EACF,CAAC;EACD,OAAO0C,sBAAsB,CAAC1C,GAAG,CAAC;AACpC;;AAEA,MAAM4C,sBAAsB,GAAG;EAC7B,CAAC,EAAE;IACD,CAAC,EAAEN,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC9E,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACvBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACxBA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACxB;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC5E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAC7E,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC7E,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACF;EACH,CAAC;EACD,CAAC,EAAE;IACD,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnD,CAACA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,CAAC,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IACpD,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IAChF,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CAAC;IAC/E,CAACA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,EAAEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAAC;IACnF,CAAC;IACF,CAAC,EAAEwF,qBAAqB,CAAC5E,GAAG,CAAC,CAACoC,CAAC,EAAEhD,GAAG,KAAK;IACvC;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC1B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG,CACzB;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAGhD,GAAG;IACxBA,GAAG,GAAG,EAAE,KAAK,CAAC,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG,CAC3B;;IACD;IACEA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG;IACzBA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAG,CAAChD,GAAG;IAC1BA,GAAG,GAAG,EAAE,KAAK,EAAE,GAAGgD,CAAC,GAAGhD,GAAG,CAC1B;;IACF;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+F,oBAAoBA,CAACC,IAAY,EAAEC,IAAY,EAA6B;EAC1FvN,MAAM;IACJsN,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK,CAAC;IACtC;EACF,CAAC;EACDtN,MAAM;IACJuN,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK,CAAC;IACtC;EACF,CAAC;EACD,OAAOH,sBAAsB,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA;AAC9BC,CAAuB;AACvBC,CAAuB;AACD;EACtB1N,MAAM,CAACyN,CAAC,CAACE,MAAM,GAAG,CAAC,IAAID,CAAC,CAACC,MAAM,GAAG,CAAC,IAAID,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,IAAIF,CAAC,CAAC,CAAC,CAAC,CAACE,MAAM,KAAKD,CAAC,CAACC,MAAM,CAAC;EACnF,MAAMC,OAAO,GAAG,IAAI7F,KAAK,CAAgB0F,CAAC,CAACE,MAAM,CAAC;EAClD,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyF,OAAO,CAACD,MAAM,EAAE,EAAExF,CAAC,EAAE;IACvCyF,OAAO,CAACzF,CAAC,CAAC,GAAG,IAAIJ,KAAK,CAAS2F,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC;EACrD;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,CAACE,MAAM,EAAE,EAAEG,CAAC,EAAE;IACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE,EAAEI,CAAC,EAAE;MACpC,KAAK,IAAIhN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2M,CAAC,CAACC,MAAM,EAAE,EAAE5M,CAAC,EAAE;QACjC6M,OAAO,CAACE,CAAC,CAAC,CAACC,CAAC,CAAC,IAAIN,CAAC,CAACK,CAAC,CAAC,CAAC/M,CAAC,CAAC,GAAG2M,CAAC,CAAC3M,CAAC,CAAC,CAACgN,CAAC,CAAC;MACpC;IACF;EACF;;EAEA,OAAOH,OAAO;AAChB;;AAEA;AACA,OAAO,SAASI,UAAUA,CAACjN,CAAS,EAAEkN,IAAY,EAAU;EAC1D,MAAMC,KAAK,GAAG,EAAE,GAAGD,IAAI;EACvB,OAAQlN,CAAC,IAAImN,KAAK,IAAKA,KAAK;AAC9B;;;;;;AAMA;AACA,OAAO,SAASzJ,aAAaA,CAAC0J,GAAW,EAAU;EACjD,OAAOjN,IAAI,CAACkN,MAAM,CAACD,GAAG,CAAC;AACzB;;AAEA;AACA,OAAO,SAASrJ,aAAaA,CAACqJ,GAAW,EAAU;EACjD,OAAOhO,OAAO,CAACgO,GAAG,CAAC;AACrB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASE,aAAaA,CAACF,GAAW,EAAU;EACjD,IAAIA,GAAG,IAAI7N,MAAM,CAAC4J,GAAG,CAACpI,QAAQ,CAACN,GAAG,EAAE;IAClC,OAAOlB,MAAM,CAAC4J,GAAG,CAACpI,QAAQ,CAACN,GAAG;EAChC;EACA,IAAI2M,GAAG,IAAI7N,MAAM,CAAC4J,GAAG,CAACrI,QAAQ,CAACN,GAAG,EAAE;IAClC,OAAOjB,MAAM,CAAC4J,GAAG,CAACrI,QAAQ,CAACN,GAAG;EAChC;EACA,OAAOL,IAAI,CAACsG,KAAK,CAAC2G,GAAG,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASG,aAAaA,CAACH,GAAW,EAAU;EACjD,IAAIA,GAAG,IAAI7N,MAAM,CAACuK,GAAG,CAACrJ,GAAG,EAAE;IACzB,OAAOlB,MAAM,CAACuK,GAAG,CAACrJ,GAAG;EACvB;EACA,IAAI2M,GAAG,IAAI,CAAC,EAAE;IACZ,OAAO,CAAC;EACV;EACA,OAAOjN,IAAI,CAACsG,KAAK,CAAC2G,GAAG,CAAC;AACxB;;AAEA;AACA;AACA;AACA,OAAO,SAASI,aAAaA,CAACJ,GAAW,EAAU;EACjD,IAAIA,GAAG,IAAI7N,MAAM,CAACgL,GAAG,CAACxJ,QAAQ,CAACN,GAAG,EAAE;IAClC,OAAOlB,MAAM,CAACgL,GAAG,CAACxJ,QAAQ,CAACN,GAAG;EAChC;EACA,IAAI2M,GAAG,IAAI7N,MAAM,CAACgL,GAAG,CAACzJ,QAAQ,CAACN,GAAG,EAAE;IAClC,OAAOjB,MAAM,CAACgL,GAAG,CAACzJ,QAAQ,CAACN,GAAG;EAChC;EACA,OAAO4M,GAAG;AACZ;;AAEA;AACA,OAAO,SAASK,YAAYA,CAACzN,CAAS,EAAW;EAC/C,IAAI,CAACH,MAAM,CAACK,SAAS,CAACF,CAAC,CAAC,EAAE;IACxB,OAAO,KAAK;EACd;EACAf,MAAM,CAAC,CAACe,CAAC,GAAG,CAAC,MAAMA,CAAC,EAAE,2CAA2C,CAAC;EAClE,OAAOA,CAAC,KAAK,CAAC,IAAI,CAACA,CAAC,GAAIA,CAAC,GAAG,CAAE,MAAM,CAAC;AACvC;;AAEA;AACA,OAAO,SAAS0N,GAAGA,CAACxH,CAAS,EAAEC,CAAS,EAAU;EAChDlH,MAAM,CAACY,MAAM,CAACK,SAAS,CAACgG,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,CAAC;EACpCjH,MAAM,CAACY,MAAM,CAACK,SAAS,CAACiG,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,CAAC;;EAEpC,OAAOA,CAAC,KAAK,CAAC,EAAE;IACd,MAAMwH,KAAK,GAAGxH,CAAC;IACfA,CAAC,GAAGD,CAAC,GAAGC,CAAC;IACTD,CAAC,GAAGyH,KAAK;EACX;;EAEA,OAAOzH,CAAC;AACV;;AAEA;AACA,OAAO,SAAS0H,GAAGA,CAAC1H,CAAS,EAAEC,CAAS,EAAU;EAChD,OAAQD,CAAC,GAAGC,CAAC,GAAIuH,GAAG,CAACxH,CAAC,EAAEC,CAAC,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0H,oBAAoBA;AAC3BC,QAAsB;AACtBC,YAA6B;AACZ;EACjB,MAAMC,MAAa,GAAG,EAAE;EACxBF,QAAQ,CAACG,OAAO,CAAC,CAACC,CAAI,KAAK;IACzB,IAAIH,YAAY,CAACnB,MAAM,GAAG,CAAC,EAAE;MAC3BmB,YAAY,CAACE,OAAO,CAAC,CAAC7G,CAAe,KAAK;QACxC4G,MAAM,CAACG,IAAI,CAAC,CAAC,GAAG/G,CAAC,EAAE8G,CAAC,CAAC,CAAC;MACxB,CAAC,CAAC;IACJ,CAAC,MAAM;MACLF,MAAM,CAACG,IAAI,CAAC,CAACD,CAAC,CAAC,CAAC;IAClB;EACF,CAAC,CAAC;EACF,OAAOF,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,gBAAgBA,CAAI,GAAGC,MAAuB,EAAmB;EAC/E,IAAIL,MAAuB,GAAG,EAAE;EAChCK,MAAM,CAACJ,OAAO,CAAC,CAAC7G,CAAe,KAAK;IAClC4G,MAAM,GAAGH,oBAAoB,CAAIzG,CAAC,EAAE4G,MAAM,CAAC;EAC7C,CAAC,CAAC;;EAEF,OAAOA,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,qBAAqBA,CAAIC,KAAmB,EAAmB;EAC7E,IAAIA,KAAK,CAAC3B,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,EAAE;EACX;;EAEA,IAAI2B,KAAK,CAAC3B,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,CAAC2B,KAAK,CAAC;EAChB;;EAEA,IAAIA,KAAK,CAAC3B,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,CAAC2B,KAAK,EAAE,CAACA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACtC;;EAEA,MAAMP,MAAa,GAAG,EAAE;EACxBO,KAAK,CAACN,OAAO,CAAC,CAACO,IAAI,EAAEjI,GAAG,KAAK;IAC3B,MAAMkI,IAAI,GAAGF,KAAK,CAACG,KAAK,CAAC,CAAC,EAAEnI,GAAG,CAAC,CAACoI,MAAM,CAACJ,KAAK,CAACG,KAAK,CAACnI,GAAG,GAAG,CAAC,CAAC,CAAC;IAC7D,MAAMqI,YAAY,GAAGN,qBAAqB,CAACG,IAAI,CAAC;IAChDG,YAAY,CAACX,OAAO,CAAC,CAAAjB,CAAC,KAAI;MACxBgB,MAAM,CAACG,IAAI,CAAC,CAACK,IAAI,EAAE,GAAGxB,CAAC,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF,OAAOgB,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,cAAcA,CAAI9B,CAAkB,EAAO;EACzD,MAAMxF,CAAC,GAAGwF,CAAC,CAACH,MAAM;EAClB,MAAMtB,CAAC,GAAGyB,CAAC,CAAC,CAAC,CAAC,CAACH,MAAM;EACrB3N,MAAM;IACJ8N,CAAC,CAAC+B,KAAK,CAAC,CAAAvH,CAAC,KAAIA,CAAC,CAACqF,MAAM,KAAKtB,CAAC,CAAC;IAC3B;EACH,CAAC;EACD,MAAM0C,MAAW,GAAGhH,KAAK,CAAIO,CAAC,GAAG+D,CAAC,CAAC;EACnC,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,CAAC,EAAEH,CAAC,EAAE,EAAE;IAC1B,KAAK,IAAI2H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,CAAC,EAAEyD,CAAC,EAAE,EAAE;MAC1Bf,MAAM,CAACe,CAAC,GAAG3H,CAAC,GAAGkE,CAAC,CAAC,GAAGyB,CAAC,CAAC3F,CAAC,CAAC,CAAC2H,CAAC,CAAC;IAC7B;EACF;EACA,OAAOf,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgB,gBAAgBA,CAAIhP,CAAe,EAAEuH,CAAS,EAAE+D,CAAS,EAAmB;EAC1FrM,MAAM;IACJsI,CAAC,GAAG,CAAC,IAAI1H,MAAM,CAACK,SAAS,CAACqH,CAAC,CAAC,IAAI+D,CAAC,GAAG,CAAC,IAAIzL,MAAM,CAACK,SAAS,CAACoL,CAAC,CAAC;IAC3D,YAAW/D,CAAE,eAAc+D,CAAE;EAChC,CAAC;EACDrM,MAAM,CAACe,CAAC,CAAC4M,MAAM,KAAKrF,CAAC,GAAG+D,CAAC,EAAG,YAAWtL,CAAC,CAAC4M,MAAO,yBAAwBrF,CAAC,GAAG+D,CAAE,GAAE,CAAC;EACjF,MAAM0C,MAAa,GAAG,CAAC,GAAGhH,KAAK,CAACO,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAA8H,CAAC,KAAI,CAAC,GAAGjI,KAAK,CAACsE,CAAC,CAAC,CAAC,CAAC;EAC3D,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,CAAC,EAAEH,CAAC,EAAE,EAAE;IAC1B,KAAK,IAAI2H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,CAAC,EAAEyD,CAAC,EAAE,EAAE;MAC1Bf,MAAM,CAAC5G,CAAC,CAAC,CAAC2H,CAAC,CAAC,GAAG/O,CAAC,CAAC+O,CAAC,GAAG3H,CAAC,GAAGkE,CAAC,CAAC;IAC7B;EACF;EACA,OAAO0C,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkB,UAAUA,CAAOnC,CAAkB,EAAEoC,EAAmB,EAAmB;EACzF,MAAM5H,CAAC,GAAGwF,CAAC,CAACH,MAAM;EAClB,MAAMtB,CAAC,GAAGyB,CAAC,CAAC,CAAC,CAAC,CAACH,MAAM;EACrB3N,MAAM;IACJ8N,CAAC,CAAC+B,KAAK,CAAC,CAAAvH,CAAC,KAAIA,CAAC,CAACqF,MAAM,KAAKtB,CAAC,CAAC;IAC3B;EACH,CAAC;EACD,MAAM0C,MAAa,GAAG,CAAC,GAAGhH,KAAK,CAACO,CAAC,CAAC,CAAC,CAACJ,GAAG,CAAC,CAAA8H,CAAC,KAAI,CAAC,GAAGjI,KAAK,CAACsE,CAAC,CAAC,CAAC,CAAC;EAC3D,KAAK,IAAIlE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,CAAC,EAAEH,CAAC,EAAE,EAAE;IAC1B,KAAK,IAAI2H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzD,CAAC,EAAEyD,CAAC,EAAE,EAAE;MAC1Bf,MAAM,CAAC5G,CAAC,CAAC,CAAC2H,CAAC,CAAC,GAAGI,EAAE,CAACpC,CAAC,CAAC3F,CAAC,CAAC,CAAC2H,CAAC,CAAC,CAAC;IAC5B;EACF;EACA,OAAOf,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoB,YAAYA,CAAIrC,CAAkB,EAAEoC,EAAyB,EAAW;EACtF,MAAM7D,CAAC,GAAGyB,CAAC,CAAC,CAAC,CAAC,CAACH,MAAM;EACrB3N,MAAM;IACJ8N,CAAC,CAAC+B,KAAK,CAAC,CAAAvH,CAAC,KAAIA,CAAC,CAACqF,MAAM,KAAKtB,CAAC,CAAC;IAC3B;EACH,CAAC;EACD,OAAOyB,CAAC,CAAC+B,KAAK,CAAC,CAAAO,GAAG,KAAIA,GAAG,CAACP,KAAK,CAAC,CAAAQ,EAAE,KAAIH,EAAE,CAACG,EAAE,CAAC,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,EAAqB,EAAEC,EAAqB,EAAE;EAC5E,OAAOD,EAAE,CAACrI,GAAG,CAAC,CAACtD,CAAC,EAAEuD,CAAC,KAAKvD,CAAC,GAAG4L,EAAE,CAACrI,CAAC,CAAC,CAAC;AACpC;;AAEA;AACA;AACA;AACA,OAAO,SAASsI,UAAUA,CAACF,EAAqB,EAAEC,EAAqB,EAAE;EACvE,OAAOD,EAAE,CAACG,MAAM,CAAC,CAACzJ,CAAC,EAAErC,CAAC,EAAEuD,CAAC,KAAKlB,CAAC,GAAGrC,CAAC,GAAG4L,EAAE,CAACrI,CAAC,CAAC,EAAE,CAAC,CAAC;AACjD;;AAEA;AACA,OAAO,SAASwI,SAASA,CAAC/L,CAAS,EAAU;EAC3C,OAAOA,CAAC,GAAG,EAAE,GAAG,CAACA,CAAC,GAAGA,CAAC;AACxB;;AAEA;AACA,OAAO,SAASgM,SAASA,CAAC,GAAGC,IAAc,EAAU;EACnD,OAAOA,IAAI,CAACH,MAAM,CAAC,CAACI,IAAI,EAAEC,GAAG,KAAMA,GAAG,GAAGD,IAAI,GAAGC,GAAG,GAAGD,IAAK,CAAC;AAC9D;;AAEA;AACA,OAAO,SAASE,SAASA,CAAC,GAAGH,IAAc,EAAU;EACnD,OAAOA,IAAI,CAACH,MAAM,CAAC,CAACI,IAAI,EAAEC,GAAG,KAAMA,GAAG,GAAGD,IAAI,GAAGC,GAAG,GAAGD,IAAK,CAAC;AAC9D"}