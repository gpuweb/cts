{"version":3,"file":"math.js","names":["assert","Float16Array","kBit","kValue","f32","f16","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","u32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF64","val","isSubnormalNumberF64","f64","negative","positive","flushSubnormalNumberF32","isSubnormalNumberF32","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","isFiniteF16","nextAfterF64Data","ArrayBuffer","nextAfterF64Int","BigUint64Array","nextAfterF64Float","Float64Array","nextAfterF64","dir","mode","isNaN","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","is_positive","nextAfterF32Data","nextAfterF32Int","Uint32Array","nextAfterF32Float","Float32Array","nextAfterF32","nextAfterF16Data","nextAfterF16Hex","Uint16Array","nextAfterF16Float","nextAfterF16","oneULPF64","target","NaN","max_ulp","before","after","oneULPF32","converted","quantizeToF32","oneULPF16","quantizeToF16","correctlyRoundedF64","correctlyRoundedF32","emax","n_32","other","correctlyRoundedF16","n_16","frexpData","frexpDataU32","frexpDataF32","frexp","fract","exp","lerp","a","b","t","isFinite","x","lerpBigInt","idx","steps","trunc","y","big_idx","BigInt","big_steps","linearRange","num_steps","Array","from","keys","map","i","linearRangeBigInt","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","reinterpretU32AsF32","sourceFilteredF32Range","source","low","high","filter","fullF16Range","reinterpretU16AsF16","fullF64Range","reinterpretU64AsF64","filteredF64Range","begin","end","u64_begin","reinterpretF64AsU64","u64_end","kInterestingI32Values","sparseI32Range","kVectorI32Values","flatMap","f","vectorI32Range","dim","fullI32Range","kInterestingU32Values","sparseU32Range","kVectorU32Values","vectorU32Range","fullU32Range","count","kInterestingF32Values","sparseF32Range","kVectorF32Values","vectorF32Range","kSparseVectorF32Values","sparseVectorF32Range","kSparseMatrixF32Values","sparseMatrixF32Range","r","kInterestingF16Values","sparseF16Range","kVectorF16Values","vectorF16Range","kSparseVectorF16Values","sparseVectorF16Range","kSparseMatrixF16Values","sparseMatrixF16Range","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","num","value","quantizeToI32","quantizeToU32","isPowerOfTwo","gcd","bTemp","lcm","input","buffer","hex","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs","calculatePermutations","head","tail","slice","concat","permutations","flatten2DArray","every","j","unflatten2DArray","_","map2DArray","op"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport {\n  f32,\n  f16,\n  floatBitsToNumber,\n  i32,\n  kFloat16Format,\n  kFloat32Format,\n  u32,\n} from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f64 number, otherwise returns |val| */\nexport function flushSubnormalNumberF64(val: number): number {\n  return isSubnormalNumberF64(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f64 */\nexport function isSubnormalNumberF64(n: number): boolean {\n  return n > kValue.f64.negative.max && n < kValue.f64.positive.min;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/** Should nextAfter calculate towards positive infinity or negative infinity */\nexport type NextDirection = 'positive' | 'negative';\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF64 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF64Data = new ArrayBuffer(8);\nconst nextAfterF64Int = new BigUint64Array(nextAfterF64Data);\nconst nextAfterF64Float = new Float64Array(nextAfterF64Data);\n\n/**\n * @returns the next f64 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF64 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF64 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f64, max f64]\n */\nexport function nextAfterF64(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f64.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f64.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f64.positive.max && val >= kValue.f64.negative.min,\n    `${val} is not in the range of f64`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF64(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f64.positive.min : kValue.f64.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f64.negative.max : kValue.f64.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF64Float[0] = val;\n  const is_positive = (nextAfterF64Int[0] & 0x8000_0000_0000_0000n) === 0n;\n  if (is_positive === (dir === 'positive')) {\n    nextAfterF64Int[0] += 1n;\n  } else {\n    nextAfterF64Int[0] -= 1n;\n  }\n\n  // Checking for overflow\n  if ((nextAfterF64Int[0] & 0x7ff0_0000_0000_0000n) === 0x7ff0_0000_0000_0000n) {\n    if (dir === 'positive') {\n      return kValue.f64.infinity.positive;\n    } else {\n      return kValue.f64.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF64(nextAfterF64Float[0]) : nextAfterF64Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF32 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF32Data = new ArrayBuffer(4);\nconst nextAfterF32Int = new Uint32Array(nextAfterF32Data);\nconst nextAfterF32Float = new Float32Array(nextAfterF32Data);\n\n/**\n * @returns the next f32 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f32.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f32.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of f32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f32.positive.min : kValue.f32.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f32.negative.max : kValue.f32.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF32Float[0] = val; // This quantizes from number (f64) to f32\n  if (\n    (dir === 'positive' && nextAfterF32Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF32Float[0] >= val)\n  ) {\n    // val is either f32 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF32Int[0] & 0x80000000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF32Int[0] += 1;\n    } else {\n      nextAfterF32Int[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF32Int[0] & 0x7f800000) === 0x7f800000) {\n    if (dir === 'positive') {\n      return kValue.f32.infinity.positive;\n    } else {\n      return kValue.f32.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF32(nextAfterF32Float[0]) : nextAfterF32Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF16 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF16Data = new ArrayBuffer(2);\nconst nextAfterF16Hex = new Uint16Array(nextAfterF16Data);\nconst nextAfterF16Float = new Float16Array(nextAfterF16Data);\n\n/**\n * @returns the next f16 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF16 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f16.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f16.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of f16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f16.positive.min : kValue.f16.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f16.negative.max : kValue.f16.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF16Float[0] = val; // This quantizes from number (f64) to f16\n  if (\n    (dir === 'positive' && nextAfterF16Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF16Float[0] >= val)\n  ) {\n    // val is either f16 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF16Hex[0] & 0x8000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF16Hex[0] += 1;\n    } else {\n      nextAfterF16Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF16Hex[0] & 0x7c00) === 0x7c00) {\n    if (dir === 'positive') {\n      return kValue.f16.infinity.positive;\n    } else {\n      return kValue.f16.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF16(nextAfterF16Float[0]) : nextAfterF16Float[0];\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 64-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF64(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF64(target) : target;\n\n  // For values out of bounds for f64 ulp(x) is defined as the\n  // distance between the two nearest f64 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f64.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f64.negative.min\n  ) {\n    return kValue.f64.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f64 representable\n  const before = nextAfterF64(target, 'negative', mode);\n  const after = nextAfterF64(target, 'positive', mode);\n  // Since number is internally a f64, |target| is always f64 representable, so\n  // either before or after will be x\n  return Math.min(target - before, after - target);\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF32(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values out of bounds for f32 ulp(x) is defined as the\n  // distance between the two nearest f32 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f32.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f32.negative.min\n  ) {\n    return kValue.f32.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, 'negative', mode);\n  const after = nextAfterF32(target, 'positive', mode);\n  const converted: number = quantizeToF32(target);\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF16(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF16(target) : target;\n\n  // For values out of bounds for f16 ulp(x) is defined as the\n  // distance between the two nearest f16 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f16.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f16.negative.min\n  ) {\n    return kValue.f16.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f16 representable\n  const before = nextAfterF16(target, 'negative', mode);\n  const after = nextAfterF16(target, 'positive', mode);\n  const converted: number = quantizeToF16(target);\n  if (converted === target) {\n    // |target| is f16 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f16 representable so taking distance of neighbouring f16s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 64-bit floats\n *\n * TS/JS's number type is internally a f64, so the supplied value will be\n * quanitized by definition. The only corner cases occur if a non-finite value\n * is provided, since the valid roundings include the appropriate min or max\n * value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 64-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF64(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f64 range\n  if (n === Number.POSITIVE_INFINITY) {\n    return [kValue.f64.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f64 range\n  if (n === Number.NEGATIVE_INFINITY) {\n    return [Number.NEGATIVE_INFINITY, kValue.f64.negative.min];\n  }\n\n  return [n];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f32.emax + 1) and -(2^(f32.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f32.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f32 finite\n  if (n <= kValue.f32.positive.max && n >= kValue.f32.negative.min) {\n    const n_32 = new Float32Array([n])[0];\n    const converted: number = n_32;\n    if (n === converted) {\n      // n is precisely expressible as a f32, so should not be rounded\n      return [n];\n    }\n\n    if (converted > n) {\n      // n_32 rounded towards +inf, so is after n\n      const other = nextAfterF32(n_32, 'negative', 'no-flush');\n      return [other, converted];\n    } else {\n      // n_32 rounded towards -inf, so is before n\n      const other = nextAfterF32(n_32, 'positive', 'no-flush');\n      return [converted, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f32.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f16.emax + 1) and -(2^(f16.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f16.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f16 finite\n  if (n <= kValue.f16.positive.max && n >= kValue.f16.negative.min) {\n    const n_16 = new Float16Array([n])[0];\n    const converted: number = n_16;\n    if (n === converted) {\n      // n is precisely expressible as a f16, so should not be rounded\n      return [n];\n    }\n\n    if (converted > n) {\n      // n_16 rounded towards +inf, so is after n\n      const other = nextAfterF16(n_16, 'negative', 'no-flush');\n      return [other, converted];\n    } else {\n      // n_16 rounded towards -inf, so is before n\n      const other = nextAfterF16(n_16, 'positive', 'no-flush');\n      return [converted, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f16.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation in frexp\n *\n * This makes frexp non-reentrant due to shared state between calls.\n */\nconst frexpData = new ArrayBuffer(4);\nconst frexpDataU32 = new Uint32Array(frexpData);\nconst frexpDataF32 = new Float32Array(frexpData);\n\n/**\n * Calculates WGSL frexp\n *\n * Splits val into a fraction and an exponent so that\n * val = fraction * 2 ^ exponent.\n * The fraction is 0.0 or its magnitude is in the range [0.5, 1.0).\n *\n * Inspired by golang's implementation of frexp.\n *\n * This code is non-reentrant due to the use of a non-local data buffer and\n * views.\n *\n * @param val the f32 to split\n * @returns the results of splitting val\n */\nexport function frexp(val: number): { fract: number; exp: number } {\n  frexpDataF32[0] = val;\n  // Do not directly use val after this point, so that changes are reflected in\n  // both the f32 and u32 views.\n\n  // Handles 0 and -0\n  if (frexpDataF32[0] === 0) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Covers NaNs, OOB and Infinities\n  if (!isFiniteF32(frexpDataF32[0])) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Normalize if subnormal\n  let exp = 0;\n  if (isSubnormalNumberF32(frexpDataF32[0])) {\n    frexpDataF32[0] = frexpDataF32[0] * (1 << 23);\n    exp = -23;\n  }\n  exp += ((frexpDataU32[0] >> 23) & 0xff) - 126; // shift & mask, minus the bias + 1\n\n  frexpDataU32[0] &= 0x807fffff; // mask the exponent bits\n  frexpDataU32[0] |= 0x3f000000; // extract the mantissa bits\n  const fract = frexpDataF32[0]; // Convert from bits to number\n  return { fract, exp };\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/**\n * Version of lerp that operates on bigint values\n *\n * lerp was not made into a generic or to take in (number|bigint), because that\n * introduces a bunch of complexity overhead related to type differentiation\n */\nexport function lerpBigInt(a: bigint, b: bigint, idx: number, steps: number): bigint {\n  assert(Math.trunc(idx) === idx);\n  assert(Math.trunc(steps) === steps);\n\n  // This constrains t to [0.0, 1.0]\n  assert(idx >= 0);\n  assert(steps > 0);\n  assert(idx < steps);\n\n  if (steps === 1) {\n    return a;\n  }\n  if (idx === 0) {\n    return a;\n  }\n  if (idx === steps - 1) {\n    return b;\n  }\n\n  const min = (x: bigint, y: bigint): bigint => {\n    return x < y ? x : y;\n  };\n  const max = (x: bigint, y: bigint): bigint => {\n    return x > y ? x : y;\n  };\n\n  // For number the variable t is used, there t = idx / (steps - 1),\n  // but that is a fraction on [0, 1], so becomes either 0 or 1 when converted\n  // to bigint, so need to expand things out.\n  const big_idx = BigInt(idx);\n  const big_steps = BigInt(steps);\n  if ((a <= 0n && b >= 0n) || (a >= 0n && b <= 0n)) {\n    return (b * big_idx) / (big_steps - 1n) + (a - (a * big_idx) / (big_steps - 1n));\n  }\n\n  const x = a + (b * big_idx) / (big_steps - 1n) - (a * big_idx) / (big_steps - 1n);\n  return !(b > a) ? max(b, x) : min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): number[] {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * Version of linearRange that operates on bigint values\n *\n * linearRange was not made into a generic or to take in (number|bigint),\n * because that introduces a bunch of complexity overhead related to type\n * differentiation\n */\nexport function linearRangeBigInt(a: bigint, b: bigint, num_steps: number): Array<bigint> {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerpBigInt(a, b, i, num_steps));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): number[] {\n  const c = 2;\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, Math.pow(i / (num_steps - 1), c)));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU32AsF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function sourceFilteredF32Range(source: String, low: number, high: number): Array<number> {\n  return fullF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.subnormal.negative.min,\n      kBit.f16.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f16.subnormal.positive.min,\n      kBit.f16.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU16AsF16);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 64-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f64 range.\n *\n * This function is intended to provide dense coverage of the f64 range, for a minimal list of values to use to cover\n * f64 behaviour, use sparseF64Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF64Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(kBit.f64.negative.min, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.subnormal.negative.min,\n      kBit.f64.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.subnormal.positive.min,\n      kBit.f64.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, kBit.f64.positive.max, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/**\n * @returns an ascending sorted array of f64 values spread over specific range of f64 normal floats\n *\n * Numbers are divided into 4 regions: negative 64-bit normals, negative 64-bit subnormals, positive 64-bit subnormals &\n * positive 64-bit normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the range.\n *\n * @param begin a negative f64 normal float value\n * @param end a positive f64 normal float value\n * @param counts structure param with 4 entries indicating the number of entries\n *               to be generated each region, entries must be 0 or greater.\n */\nexport function filteredF64Range(\n  begin: number,\n  end: number,\n  counts: { neg_norm?: number; neg_sub?: number; pos_sub: number; pos_norm: number } = {\n    pos_sub: 10,\n    pos_norm: 50,\n  }\n): Array<number> {\n  assert(\n    begin <= kValue.f64.negative.max,\n    `Beginning of range ${begin} must be negative f64 normal`\n  );\n  assert(end >= kValue.f64.positive.min, `Ending of range ${end} must be positive f64 normal`);\n\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  const u64_begin = reinterpretF64AsU64(begin);\n  const u64_end = reinterpretF64AsU64(end);\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(u64_begin, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.subnormal.negative.min,\n      kBit.f64.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.subnormal.positive.min,\n      kBit.f64.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, u64_end, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/** Short list of i32 values of interest to test against */\nconst kInterestingI32Values: number[] = [\n  kValue.i32.negative.max,\n  Math.trunc(kValue.i32.negative.max / 2),\n  -256,\n  -10,\n  -1,\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.i32.positive.max / 2),\n  kValue.i32.positive.max,\n];\n\n/** @returns minimal i32 values that cover the entire range of i32 behaviours\n *\n * This is used instead of fullI32Range when the number of test cases being\n * generated is a super linear function of the length of i32 values which is\n * leading to time outs.\n */\nexport function sparseI32Range(): number[] {\n  return kInterestingI32Values;\n}\n\nconst kVectorI32Values = {\n  2: kInterestingI32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n    [f, -1],\n    [-1, f],\n  ]),\n  3: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n    [f, -1, -2],\n    [-1, f, -2],\n    [-1, -2, f],\n  ]),\n  4: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n    [f, -1, -2, -3],\n    [-1, f, -2, -3],\n    [-1, -2, f, -3],\n    [-1, -2, -3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI32Range only accepts dimensions 2, 3, and 4');\n  return kVectorI32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of u32 values of interest to test against */\nconst kInterestingU32Values: number[] = [\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.u32.max / 2),\n  kValue.u32.max,\n];\n\n/** @returns minimal u32 values that cover the entire range of u32 behaviours\n *\n * This is used instead of fullU32Range when the number of test cases being\n * generated is a super linear function of the length of u32 values which is\n * leading to time outs.\n */\nexport function sparseU32Range(): number[] {\n  return kInterestingU32Values;\n}\n\nconst kVectorU32Values = {\n  2: kInterestingU32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n  ]),\n  3: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n  ]),\n  4: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting u32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting u32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting u32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorU32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorU32Range only accepts dimensions 2, 3, and 4');\n  return kVectorU32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: sparseF32Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF32Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n\nconst kSparseMatrixF32Values = {\n  2: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF32Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f32 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF32Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF32Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF32Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF32Values[c][r];\n}\n\n/** Short list of f16 values of interest to test against */\nconst kInterestingF16Values: number[] = [\n  kValue.f16.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f16.negative.max,\n  kValue.f16.subnormal.negative.min,\n  kValue.f16.subnormal.negative.max,\n  0.0,\n  kValue.f16.subnormal.positive.min,\n  kValue.f16.subnormal.positive.max,\n  kValue.f16.positive.min,\n  1.0,\n  10.0,\n  kValue.f16.positive.max,\n];\n\n/** @returns minimal f16 values that cover the entire range of f16 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF16Range when the number of test cases being\n * generated is a super linear function of the length of f16 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f16\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF16Range(): number[] {\n  return kInterestingF16Values;\n}\n\nconst kVectorF16Values = {\n  2: sparseF16Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF16Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF16Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting f16\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f16 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF16Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF16Range only accepts dimensions 2, 3, and 4');\n  return kVectorF16Values[dim];\n}\n\nconst kSparseVectorF16Values = {\n  2: sparseF16Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF16Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF16Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting f16\n * values.\n *\n * This is an even more stripped down version of `vectorF16Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF16 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF16Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF16Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF16Values[dim];\n}\n\nconst kSparseMatrixF16Values = {\n  2: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * f16 values.\n *\n * This is the matrix analogue of `sparseVectorF16Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f16 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF16 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF16Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF16Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF16Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF16Values[c][r];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\nexport interface QuantizeFunc {\n  (num: number): number;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 16-bit floating point value to the input */\nexport function quantizeToF16(num: number): number {\n  return f16(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToU32(num: number): number {\n  return u32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/**\n * @returns the bit representation as a 64-integer, via interpreting the input\n * as a 64-bit float value\n */\nexport function reinterpretF64AsU64(input: number): bigint {\n  return new BigUint64Array(new Float64Array([input]).buffer)[0];\n}\n\n/**\n * @returns a 64-bit float value via interpreting the input as the bit\n * representation as a 64-bit integer\n */\nexport function reinterpretU64AsF64(input: bigint): number {\n  return new Float64Array(new BigUint64Array([input]).buffer)[0];\n}\n\n/**\n * @returns a 32-bit float value via interpreting the input as the bit\n * representation as a 32-bit integer\n */\nexport function reinterpretU32AsF32(input: number): number {\n  return floatBitsToNumber(input, kFloat32Format);\n}\n\n/**\n * @returns a 16-bit float value via interpreting the input as the bit\n * representation as a 16-bit integer\n */\nexport function reinterpretU16AsF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach((i: T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n\n/** @returns all of the permutations of an array\n *\n * Recursively calculates all of the permutations, does not cull duplicate\n * entries.\n *\n * Only feasible for inputs of lengths 5 or so, since the number of permutations\n * is (input.length)!, so will cause the stack to explode for longer inputs.\n *\n * This code could be made iterative using something like\n * SteinhausJohnsonTrotter and additionally turned into a generator to reduce\n * the stack size, but there is still a fundamental combinatorial explosion\n * here that will affect runtime.\n *\n * @param input the array to get permutations of\n */\nexport function calculatePermutations<T>(input: T[]): T[][] {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (input.length === 1) {\n    return [input];\n  }\n\n  if (input.length === 2) {\n    return [input, [input[1], input[0]]];\n  }\n\n  const result: T[][] = [];\n  input.forEach((head, idx) => {\n    const tail = input.slice(0, idx).concat(input.slice(idx + 1));\n    const permutations = calculatePermutations(tail);\n    permutations.forEach(p => {\n      result.push([head, ...p]);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Convert an Array of Arrays to linear array\n *\n * Caller is responsible to retaining the dimensions of the array for later\n * unflattening\n *\n * @param m Matrix to convert\n */\nexport function flatten2DArray<T>(m: T[][]): T[] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to flatten`\n  );\n  const result: T[] = Array<T>(c * r);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[j + i * r] = m[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Convert linear array to an Array of Arrays\n * @param n an array to convert\n * @param c number of elements in the array containing arrays\n * @param r number of elements in the arrays that are contained\n */\nexport function unflatten2DArray<T>(n: T[], c: number, r: number): T[][] {\n  assert(\n    c > 0 && Number.isInteger(c) && r > 0 && Number.isInteger(r),\n    `columns (${c}) and rows (${r}) need to be positive integers`\n  );\n  assert(n.length === c * r, `m.length(${n.length}) should equal c * r (${c * r})`);\n  const result: T[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = n[j + i * r];\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .map over a matrix and return the result\n * The shape of the input and output matrices will be the same\n *\n * @param m input matrix of type T\n * @param op operation that converts an element of type T to one of type S\n * @returns a matrix with elements of type S that are calculated by applying op element by element\n */\nexport function map2DArray<T, S>(m: T[][], op: (input: T) => S): S[][] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  const result: S[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = op(m[i][j]);\n    }\n  }\n  return result;\n}\n"],"mappings":"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"}