{"version":3,"file":"math.js","names":["assert","Float16Array","getFloat16","setFloat16","kBit","kValue","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","u32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF64","val","isSubnormalNumberF64","f64","negative","positive","flushSubnormalNumberF32","isSubnormalNumberF32","f32","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","f16","isFiniteF16","nextAfterF64Data","ArrayBuffer","nextAfterF64Int","BigUint64Array","nextAfterF64Float","Float64Array","nextAfterF64","dir","mode","isNaN","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","is_positive","nextAfterF32Data","nextAfterF32Int","Uint32Array","nextAfterF32Float","Float32Array","nextAfterF32","nextAfterF16Data","nextAfterF16Hex","Uint16Array","nextAfterF16Float","nextAfterF16","oneULPF64","target","NaN","max_ulp","before","after","oneULPF32","converted","quantizeToF32","oneULPF16","quantizeToF16","correctlyRoundedF64","correctlyRoundedF32","emax","n_32","other","correctlyRoundedF16","n_16","frexp","trait","buffer","dataView","DataView","expBitCount","fractBitCount","expBias","expMaskForHigh16Bits","targetExpBitsForHigh16Bits","setFloatToBuffer","getFloatFromBuffer","isFinite","isSubnormal","v","setFloat32","getFloat32","setFloat64","getFloat64","extractUnbiasedExpFromNormalFloatInBuffer","high16BitsAsUint16","getUint16","modifyExpOfNormalFloatInBuffer","modifiedHigh16Bits","setUint16","fract","exp","lerp","a","b","t","x","lerpBigInt","idx","steps","trunc","y","big_idx","BigInt","big_steps","linearRange","num_steps","Array","from","keys","map","i","linearRangeBigInt","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","reinterpretU32AsF32","sourceFilteredF32Range","source","low","high","filter","fullF16Range","reinterpretU16AsF16","fullF64Range","reinterpretU64AsF64","filteredF64Range","begin","end","u64_begin","reinterpretF64AsU64","u64_end","kInterestingI32Values","sparseI32Range","kVectorI32Values","flatMap","f","vectorI32Range","dim","fullI32Range","kInterestingU32Values","sparseU32Range","kVectorU32Values","vectorU32Range","fullU32Range","count","kInterestingF32Values","sparseF32Range","kVectorF32Values","vectorF32Range","kSparseVectorF32Values","sparseVectorF32Range","kSparseMatrixF32Values","sparseMatrixF32Range","r","kInterestingF16Values","sparseF16Range","kVectorF16Values","vectorF16Range","kSparseVectorF16Values","sparseVectorF16Range","kSparseMatrixF16Values","sparseMatrixF16Range","kInterestingF64Values","sparseF64Range","kVectorF64Values","vectorF64Range","kSparseVectorF64Values","sparseVectorF64Range","kSparseMatrixF64Values","sparseMatrixF64Range","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32Data","num","quantizeToF16Data","quantizeToI32","value","quantizeToU32","isPowerOfTwo","gcd","bTemp","lcm","input","hex","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs","calculatePermutations","head","tail","slice","concat","permutations","flatten2DArray","every","j","unflatten2DArray","_","map2DArray","op"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport {\n  Float16Array,\n  getFloat16,\n  setFloat16,\n} from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { floatBitsToNumber, i32, kFloat16Format, kFloat32Format, u32 } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f64 number, otherwise returns |val| */\nexport function flushSubnormalNumberF64(val: number): number {\n  return isSubnormalNumberF64(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f64 */\nexport function isSubnormalNumberF64(n: number): boolean {\n  return n > kValue.f64.negative.max && n < kValue.f64.positive.min;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/** Should nextAfter calculate towards positive infinity or negative infinity */\nexport type NextDirection = 'positive' | 'negative';\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF64 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF64Data = new ArrayBuffer(8);\nconst nextAfterF64Int = new BigUint64Array(nextAfterF64Data);\nconst nextAfterF64Float = new Float64Array(nextAfterF64Data);\n\n/**\n * @returns the next f64 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF64 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF64 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f64, max f64]\n */\nexport function nextAfterF64(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f64.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f64.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f64.positive.max && val >= kValue.f64.negative.min,\n    `${val} is not in the range of f64`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF64(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f64.positive.min : kValue.f64.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f64.negative.max : kValue.f64.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF64Float[0] = val;\n  const is_positive = (nextAfterF64Int[0] & 0x8000_0000_0000_0000n) === 0n;\n  if (is_positive === (dir === 'positive')) {\n    nextAfterF64Int[0] += 1n;\n  } else {\n    nextAfterF64Int[0] -= 1n;\n  }\n\n  // Checking for overflow\n  if ((nextAfterF64Int[0] & 0x7ff0_0000_0000_0000n) === 0x7ff0_0000_0000_0000n) {\n    if (dir === 'positive') {\n      return kValue.f64.positive.infinity;\n    } else {\n      return kValue.f64.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF64(nextAfterF64Float[0]) : nextAfterF64Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF32 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF32Data = new ArrayBuffer(4);\nconst nextAfterF32Int = new Uint32Array(nextAfterF32Data);\nconst nextAfterF32Float = new Float32Array(nextAfterF32Data);\n\n/**\n * @returns the next f32 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f32.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f32.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of f32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f32.positive.min : kValue.f32.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f32.negative.max : kValue.f32.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF32Float[0] = val; // This quantizes from number (f64) to f32\n  if (\n    (dir === 'positive' && nextAfterF32Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF32Float[0] >= val)\n  ) {\n    // val is either f32 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF32Int[0] & 0x80000000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF32Int[0] += 1;\n    } else {\n      nextAfterF32Int[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF32Int[0] & 0x7f800000) === 0x7f800000) {\n    if (dir === 'positive') {\n      return kValue.f32.positive.infinity;\n    } else {\n      return kValue.f32.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF32(nextAfterF32Float[0]) : nextAfterF32Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF16 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF16Data = new ArrayBuffer(2);\nconst nextAfterF16Hex = new Uint16Array(nextAfterF16Data);\nconst nextAfterF16Float = new Float16Array(nextAfterF16Data);\n\n/**\n * @returns the next f16 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF16 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f16.positive.infinity;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f16.negative.infinity;\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of f16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f16.positive.min : kValue.f16.positive.subnormal.min;\n    } else {\n      return mode === 'flush' ? kValue.f16.negative.max : kValue.f16.negative.subnormal.max;\n    }\n  }\n\n  nextAfterF16Float[0] = val; // This quantizes from number (f64) to f16\n  if (\n    (dir === 'positive' && nextAfterF16Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF16Float[0] >= val)\n  ) {\n    // val is either f16 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF16Hex[0] & 0x8000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF16Hex[0] += 1;\n    } else {\n      nextAfterF16Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF16Hex[0] & 0x7c00) === 0x7c00) {\n    if (dir === 'positive') {\n      return kValue.f16.positive.infinity;\n    } else {\n      return kValue.f16.negative.infinity;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF16(nextAfterF16Float[0]) : nextAfterF16Float[0];\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 64-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF64(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF64(target) : target;\n\n  // For values out of bounds for f64 ulp(x) is defined as the\n  // distance between the two nearest f64 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f64.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f64.negative.min\n  ) {\n    return kValue.f64.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f64 representable\n  const before = nextAfterF64(target, 'negative', mode);\n  const after = nextAfterF64(target, 'positive', mode);\n  // Since number is internally a f64, |target| is always f64 representable, so\n  // either before or after will be x\n  return Math.min(target - before, after - target);\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF32(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values out of bounds for f32 ulp(x) is defined as the\n  // distance between the two nearest f32 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f32.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f32.negative.min\n  ) {\n    return kValue.f32.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, 'negative', mode);\n  const after = nextAfterF32(target, 'positive', mode);\n  const converted: number = quantizeToF32(target);\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF16(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF16(target) : target;\n\n  // For values out of bounds for f16 ulp(x) is defined as the\n  // distance between the two nearest f16 representable numbers to the\n  // appropriate edge, which also happens to be the maximum possible ULP.\n  if (\n    target === Number.POSITIVE_INFINITY ||\n    target >= kValue.f16.positive.max ||\n    target === Number.NEGATIVE_INFINITY ||\n    target <= kValue.f16.negative.min\n  ) {\n    return kValue.f16.max_ulp;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f16 representable\n  const before = nextAfterF16(target, 'negative', mode);\n  const after = nextAfterF16(target, 'positive', mode);\n  const converted: number = quantizeToF16(target);\n  if (converted === target) {\n    // |target| is f16 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f16 representable so taking distance of neighbouring f16s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 64-bit floats\n *\n * TS/JS's number type is internally a f64, so the supplied value will be\n * quanitized by definition. The only corner cases occur if a non-finite value\n * is provided, since the valid roundings include the appropriate min or max\n * value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 64-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF64(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f64 range\n  if (n === Number.POSITIVE_INFINITY) {\n    return [kValue.f64.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f64 range\n  if (n === Number.NEGATIVE_INFINITY) {\n    return [Number.NEGATIVE_INFINITY, kValue.f64.negative.min];\n  }\n\n  return [n];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f32.emax + 1) and -(2^(f32.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f32.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f32 finite\n  if (n <= kValue.f32.positive.max && n >= kValue.f32.negative.min) {\n    const n_32 = quantizeToF32(n);\n    if (n === n_32) {\n      // n is precisely expressible as a f32, so should not be rounded\n      return [n];\n    }\n\n    if (n_32 > n) {\n      // n_32 rounded towards +inf, so is after n\n      const other = nextAfterF32(n_32, 'negative', 'no-flush');\n      return [other, n_32];\n    } else {\n      // n_32 rounded towards -inf, so is before n\n      const other = nextAfterF32(n_32, 'positive', 'no-flush');\n      return [n_32, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f32.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of bounds values need to consider how they interact with the overflow\n * rules.\n *  * If a value is OOB but not too far out, an implementation may choose to round\n * to nearest finite value or the correct infinity. This boundary is at\n * 2^(f16.emax + 1) and -(2^(f16.emax + 1)) respectively.\n * Values that are at or beyond these limits must be rounded towards the\n * appropriate infinity.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  if (Number.isNaN(n)) {\n    return [n];\n  }\n\n  // Greater than or equal to the upper overflow boundry\n  if (n >= 2 ** (kValue.f16.emax + 1)) {\n    return [Number.POSITIVE_INFINITY];\n  }\n\n  // OOB, but less than the upper overflow boundary\n  if (n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // f16 finite\n  if (n <= kValue.f16.positive.max && n >= kValue.f16.negative.min) {\n    const n_16 = quantizeToF16(n);\n    if (n === n_16) {\n      // n is precisely expressible as a f16, so should not be rounded\n      return [n];\n    }\n\n    if (n_16 > n) {\n      // n_16 rounded towards +inf, so is after n\n      const other = nextAfterF16(n_16, 'negative', 'no-flush');\n      return [other, n_16];\n    } else {\n      // n_16 rounded towards -inf, so is before n\n      const other = nextAfterF16(n_16, 'positive', 'no-flush');\n      return [n_16, other];\n    }\n  }\n\n  // OOB, but greater the lower overflow boundary\n  if (n > -(2 ** (kValue.f16.emax + 1))) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  // Less than or equal to the lower overflow boundary\n  return [Number.NEGATIVE_INFINITY];\n}\n\n/**\n * Calculates WGSL frexp\n *\n * Splits val into a fraction and an exponent so that\n * val = fraction * 2 ^ exponent.\n * The fraction is 0.0 or its magnitude is in the range [0.5, 1.0).\n *\n * @param val the float to split\n * @param trait the float type, f32 or f16 or f64\n * @returns the results of splitting val\n */\nexport function frexp(val: number, trait: 'f32' | 'f16' | 'f64'): { fract: number; exp: number } {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n\n  // expBitCount and fractBitCount is the bitwidth of exponent and fractional part of the given FP type.\n  // expBias is the bias constant of exponent of the given FP type.\n  // Biased exponent (unsigned integer, i.e. the exponent part of float) = unbiased exponent (signed integer) + expBias.\n  let expBitCount: number, fractBitCount: number, expBias: number;\n  // To handle the exponent bits of given FP types (f16, f32, and f64), considering the highest 16\n  // bits is enough.\n  // expMaskForHigh16Bits indicates the exponent bitfield in the highest 16 bits of the given FP\n  // type, and targetExpBitsForHigh16Bits is the exponent bits that corresponding to unbiased\n  // exponent -1, i.e. the exponent bits when the FP values is in range [0.5, 1.0).\n  let expMaskForHigh16Bits: number, targetExpBitsForHigh16Bits: number;\n  // Helper function that store the given FP value into buffer as the given FP types\n  let setFloatToBuffer: (v: number) => void;\n  // Helper function that read back FP value from buffer as the given FP types\n  let getFloatFromBuffer: () => number;\n\n  let isFinite: (v: number) => boolean;\n  let isSubnormal: (v: number) => boolean;\n\n  if (trait === 'f32') {\n    // f32 bit pattern: s_eeeeeeee_fffffff_ffffffffffffffff\n    expBitCount = 8;\n    fractBitCount = 23;\n    expBias = 127;\n    // The exponent bitmask for high 16 bits of f32.\n    expMaskForHigh16Bits = 0x7f80;\n    // The target exponent bits is equal to those for f32 0.5 = 0x3f000000.\n    targetExpBitsForHigh16Bits = 0x3f00;\n    isFinite = isFiniteF32;\n    isSubnormal = isSubnormalNumberF32;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => dataView.setFloat32(0, v, false);\n    getFloatFromBuffer = () => dataView.getFloat32(0, false);\n  } else if (trait === 'f16') {\n    // f16 bit pattern: s_eeeee_ffffffffff\n    expBitCount = 5;\n    fractBitCount = 10;\n    expBias = 15;\n    // The exponent bitmask for 16 bits of f16.\n    expMaskForHigh16Bits = 0x7c00;\n    // The target exponent bits is equal to those for f16 0.5 = 0x3800.\n    targetExpBitsForHigh16Bits = 0x3800;\n    isFinite = isFiniteF16;\n    isSubnormal = isSubnormalNumberF16;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => setFloat16(dataView, 0, v, false);\n    getFloatFromBuffer = () => getFloat16(dataView, 0, false);\n  } else {\n    assert(trait === 'f64');\n    // f64 bit pattern: s_eeeeeeeeeee_ffff_ffffffffffffffffffffffffffffffffffffffffffffffff\n    expBitCount = 11;\n    fractBitCount = 52;\n    expBias = 1023;\n    // The exponent bitmask for 16 bits of f64.\n    expMaskForHigh16Bits = 0x7ff0;\n    // The target exponent bits is equal to those for f64 0.5 = 0x3fe0_0000_0000_0000.\n    targetExpBitsForHigh16Bits = 0x3fe0;\n    isFinite = Number.isFinite;\n    isSubnormal = isSubnormalNumberF64;\n    // Enforce big-endian so that offset 0 is highest byte.\n    setFloatToBuffer = (v: number) => dataView.setFloat64(0, v, false);\n    getFloatFromBuffer = () => dataView.getFloat64(0, false);\n  }\n  // Helper function that extract the unbiased exponent of the float in buffer.\n  const extractUnbiasedExpFromNormalFloatInBuffer = () => {\n    // Assert the float in buffer is finite normal float.\n    assert(isFinite(getFloatFromBuffer()) && !isSubnormal(getFloatFromBuffer()));\n    // Get the highest 16 bits of float as uint16, which can contain the whole exponent part for both f16, f32, and f64.\n    const high16BitsAsUint16 = dataView.getUint16(0, false);\n    // Return the unbiased exp by masking, shifting and unbiasing.\n    return ((high16BitsAsUint16 & expMaskForHigh16Bits) >> (16 - 1 - expBitCount)) - expBias;\n  };\n  // Helper function that modify the exponent of float in buffer to make it in range [0.5, 1.0).\n  // By setting the unbiased exponent to -1, the fp value will be in range 2**-1 * [1.0, 2.0), i.e. [0.5, 1.0).\n  const modifyExpOfNormalFloatInBuffer = () => {\n    // Assert the float in buffer is finite normal float.\n    assert(isFinite(getFloatFromBuffer()) && !isSubnormal(getFloatFromBuffer()));\n    // Get the highest 16 bits of float as uint16, which contains the whole exponent part for both f16, f32, and f64.\n    const high16BitsAsUint16 = dataView.getUint16(0, false);\n    // Modify the exponent bits.\n    const modifiedHigh16Bits =\n      (high16BitsAsUint16 & ~expMaskForHigh16Bits) | targetExpBitsForHigh16Bits;\n    // Set back to buffer\n    dataView.setUint16(0, modifiedHigh16Bits, false);\n  };\n\n  // +/- 0.0\n  if (val === 0) {\n    return { fract: val, exp: 0 };\n  }\n  // NaN and Inf\n  if (!isFinite(val)) {\n    return { fract: val, exp: 0 };\n  }\n\n  setFloatToBuffer(val);\n  // Don't use val below. Use helper functions working with buffer instead.\n\n  let exp = 0;\n  // Normailze the value if it is subnormal. Increase the exponent by multiplying a subnormal value\n  // with 2**fractBitCount will result in a finite normal FP value of the given FP type.\n  if (isSubnormal(getFloatFromBuffer())) {\n    setFloatToBuffer(getFloatFromBuffer() * 2 ** fractBitCount);\n    exp = -fractBitCount;\n  }\n  // A normal FP value v is represented as v = ((-1)**s)*(2**(unbiased exponent))*f, where f is in\n  // range [1.0, 2.0). By moving a factor 2 from f to exponent, we have\n  // v = ((-1)**s)*(2**(unbiased exponent + 1))*(f / 2), where (f / 2) is in range [0.5, 1.0), so\n  // the exp = (unbiased exponent + 1) and fract = ((-1)**s)*(f / 2) is what we expect to get from\n  // frexp function. Note that fract and v only differs in exponent bitfield as long as v is normal.\n  // Calc the result exp by getting the unbiased float exponent and plus 1.\n  exp += extractUnbiasedExpFromNormalFloatInBuffer() + 1;\n  // Modify the exponent of float in buffer to make it be in range [0.5, 1.0) to get fract.\n  modifyExpOfNormalFloatInBuffer();\n\n  return { fract: getFloatFromBuffer(), exp };\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/**\n * Version of lerp that operates on bigint values\n *\n * lerp was not made into a generic or to take in (number|bigint), because that\n * introduces a bunch of complexity overhead related to type differentiation\n */\nexport function lerpBigInt(a: bigint, b: bigint, idx: number, steps: number): bigint {\n  assert(Math.trunc(idx) === idx);\n  assert(Math.trunc(steps) === steps);\n\n  // This constrains t to [0.0, 1.0]\n  assert(idx >= 0);\n  assert(steps > 0);\n  assert(idx < steps);\n\n  if (steps === 1) {\n    return a;\n  }\n  if (idx === 0) {\n    return a;\n  }\n  if (idx === steps - 1) {\n    return b;\n  }\n\n  const min = (x: bigint, y: bigint): bigint => {\n    return x < y ? x : y;\n  };\n  const max = (x: bigint, y: bigint): bigint => {\n    return x > y ? x : y;\n  };\n\n  // For number the variable t is used, there t = idx / (steps - 1),\n  // but that is a fraction on [0, 1], so becomes either 0 or 1 when converted\n  // to bigint, so need to expand things out.\n  const big_idx = BigInt(idx);\n  const big_steps = BigInt(steps);\n  if ((a <= 0n && b >= 0n) || (a >= 0n && b <= 0n)) {\n    return (b * big_idx) / (big_steps - 1n) + (a - (a * big_idx) / (big_steps - 1n));\n  }\n\n  const x = a + (b * big_idx) / (big_steps - 1n) - (a * big_idx) / (big_steps - 1n);\n  return !(b > a) ? max(b, x) : min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): number[] {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * Version of linearRange that operates on bigint values\n *\n * linearRange was not made into a generic or to take in (number|bigint),\n * because that introduces a bunch of complexity overhead related to type\n * differentiation\n */\nexport function linearRangeBigInt(a: bigint, b: bigint, num_steps: number): Array<bigint> {\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerpBigInt(a, b, i, num_steps));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): number[] {\n  const c = 2;\n  if (num_steps <= 0) {\n    return [];\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, Math.pow(i / (num_steps - 1), c)));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.negative.subnormal.min,\n      kBit.f32.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x80000000,\n    // +0.0\n    0,\n    ...linearRange(\n      kBit.f32.positive.subnormal.min,\n      kBit.f32.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU32AsF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function sourceFilteredF32Range(source: String, low: number, high: number): Array<number> {\n  return fullF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.negative.subnormal.min,\n      kBit.f16.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000,\n    // +0.0\n    0,\n    ...linearRange(\n      kBit.f16.positive.subnormal.min,\n      kBit.f16.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(reinterpretU16AsF16);\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 64-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f64 range.\n *\n * This function is intended to provide dense coverage of the f64 range, for a minimal list of values to use to cover\n * f64 behaviour, use sparseF64Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF64Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(kBit.f64.negative.min, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.negative.subnormal.min,\n      kBit.f64.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000_0000_0000_0000n,\n    // +0.0\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.positive.subnormal.min,\n      kBit.f64.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, kBit.f64.positive.max, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/**\n * @returns an ascending sorted array of f64 values spread over specific range of f64 normal floats\n *\n * Numbers are divided into 4 regions: negative 64-bit normals, negative 64-bit subnormals, positive 64-bit subnormals &\n * positive 64-bit normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f64 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the range.\n *\n * @param begin a negative f64 normal float value\n * @param end a positive f64 normal float value\n * @param counts structure param with 4 entries indicating the number of entries\n *               to be generated each region, entries must be 0 or greater.\n */\nexport function filteredF64Range(\n  begin: number,\n  end: number,\n  counts: { neg_norm?: number; neg_sub?: number; pos_sub: number; pos_norm: number } = {\n    pos_sub: 10,\n    pos_norm: 50,\n  }\n): Array<number> {\n  assert(\n    begin <= kValue.f64.negative.max,\n    `Beginning of range ${begin} must be negative f64 normal`\n  );\n  assert(end >= kValue.f64.positive.min, `Ending of range ${end} must be positive f64 normal`);\n\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  const u64_begin = reinterpretF64AsU64(begin);\n  const u64_end = reinterpretF64AsU64(end);\n  // Generating bit fields first and then converting to f64, so that the spread across the possible f64 values is more\n  // even. Generating against the bounds of f64 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRangeBigInt(u64_begin, kBit.f64.negative.max, counts.neg_norm),\n    ...linearRangeBigInt(\n      kBit.f64.negative.subnormal.min,\n      kBit.f64.negative.subnormal.max,\n      counts.neg_sub\n    ),\n    // -0.0\n    0x8000_0000_0000_0000n,\n    // +0.0\n    0n,\n    ...linearRangeBigInt(\n      kBit.f64.positive.subnormal.min,\n      kBit.f64.positive.subnormal.max,\n      counts.pos_sub\n    ),\n    ...linearRangeBigInt(kBit.f64.positive.min, u64_end, counts.pos_norm),\n  ];\n  return bit_fields.map(reinterpretU64AsF64);\n}\n\n/** Short list of i32 values of interest to test against */\nconst kInterestingI32Values: number[] = [\n  kValue.i32.negative.max,\n  Math.trunc(kValue.i32.negative.max / 2),\n  -256,\n  -10,\n  -1,\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.i32.positive.max / 2),\n  kValue.i32.positive.max,\n];\n\n/** @returns minimal i32 values that cover the entire range of i32 behaviours\n *\n * This is used instead of fullI32Range when the number of test cases being\n * generated is a super linear function of the length of i32 values which is\n * leading to time outs.\n */\nexport function sparseI32Range(): number[] {\n  return kInterestingI32Values;\n}\n\nconst kVectorI32Values = {\n  2: kInterestingI32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n    [f, -1],\n    [-1, f],\n  ]),\n  3: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n    [f, -1, -2],\n    [-1, f, -2],\n    [-1, -2, f],\n  ]),\n  4: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n    [f, -1, -2, -3],\n    [-1, f, -2, -3],\n    [-1, -2, f, -3],\n    [-1, -2, -3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI32Range only accepts dimensions 2, 3, and 4');\n  return kVectorI32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of u32 values of interest to test against */\nconst kInterestingU32Values: number[] = [\n  0,\n  1,\n  10,\n  256,\n  Math.trunc(kValue.u32.max / 2),\n  kValue.u32.max,\n];\n\n/** @returns minimal u32 values that cover the entire range of u32 behaviours\n *\n * This is used instead of fullU32Range when the number of test cases being\n * generated is a super linear function of the length of u32 values which is\n * leading to time outs.\n */\nexport function sparseU32Range(): number[] {\n  return kInterestingU32Values;\n}\n\nconst kVectorU32Values = {\n  2: kInterestingU32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n  ]),\n  3: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n  ]),\n  4: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting u32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting u32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting u32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorU32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorU32Range only accepts dimensions 2, 3, and 4');\n  return kVectorU32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f32.negative.max,\n  kValue.f32.negative.subnormal.min,\n  kValue.f32.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f32.positive.subnormal.min,\n  kValue.f32.positive.subnormal.max,\n  kValue.f32.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: sparseF32Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF32Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n\nconst kSparseMatrixF32Values = {\n  2: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF32Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f32 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF32Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF32Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF32Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF32Values[c][r];\n}\n\n/** Short list of f16 values of interest to test against */\nconst kInterestingF16Values: number[] = [\n  kValue.f16.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f16.negative.max,\n  kValue.f16.negative.subnormal.min,\n  kValue.f16.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f16.positive.subnormal.min,\n  kValue.f16.positive.subnormal.max,\n  kValue.f16.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f16.positive.max,\n];\n\n/** @returns minimal f16 values that cover the entire range of f16 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF16Range when the number of test cases being\n * generated is a super linear function of the length of f16 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f16\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF16Range(): number[] {\n  return kInterestingF16Values;\n}\n\nconst kVectorF16Values = {\n  2: sparseF16Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF16Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF16Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting f16\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f16 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF16Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF16Range only accepts dimensions 2, 3, and 4');\n  return kVectorF16Values[dim];\n}\n\nconst kSparseVectorF16Values = {\n  2: sparseF16Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF16Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF16Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting f16\n * values.\n *\n * This is an even more stripped down version of `vectorF16Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF16 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF16Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF16Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF16Values[dim];\n}\n\nconst kSparseMatrixF16Values = {\n  2: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF16Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF16Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF16Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * f16 values.\n *\n * This is the matrix analogue of `sparseVectorF16Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f16 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF16 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF16Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF16Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF16Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF16Values[c][r];\n}\n\n/** Short list of f64 values of interest to test against */\nconst kInterestingF64Values: number[] = [\n  kValue.f64.negative.min,\n  -10.0,\n  -1.0,\n  -0.125,\n  kValue.f64.negative.max,\n  kValue.f64.negative.subnormal.min,\n  kValue.f64.negative.subnormal.max,\n  -0.0,\n  0.0,\n  kValue.f64.positive.subnormal.min,\n  kValue.f64.positive.subnormal.max,\n  kValue.f64.positive.min,\n  0.125,\n  1.0,\n  10.0,\n  kValue.f64.positive.max,\n];\n\n/** @returns minimal F64 values that cover the entire range of F64 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF64Range when the number of test cases being\n * generated is a super linear function of the length of F64 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of F64\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF64Range(): number[] {\n  return kInterestingF64Values;\n}\n\nconst kVectorF64Values = {\n  2: sparseF64Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF64Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF64Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting F64 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF64Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF64Range only accepts dimensions 2, 3, and 4');\n  return kVectorF64Values[dim];\n}\n\nconst kSparseVectorF64Values = {\n  2: sparseF64Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF64Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF64Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting f64\n * values.\n *\n * This is an even more stripped down version of `vectorF64Range` for when\n * pairs of vectors are being tested.\n * All the interesting floats from sparseF64 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF64Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF64Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF64Values[dim];\n}\n\nconst kSparseMatrixF64Values = {\n  2: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF64Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF64Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF64Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF64Range`, so it is producing a\n * minimal coverage set of matrices that test all the interesting f64 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All the interesting floats from sparseF64 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF64Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF64Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF64Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF64Values[c][r];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\nexport interface QuantizeFunc {\n  (num: number): number;\n}\n\n/** Statically allocate working data, so it doesn't need per-call creation */\nconst quantizeToF32Data = new Float32Array(new ArrayBuffer(4));\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  quantizeToF32Data[0] = num;\n  return quantizeToF32Data[0];\n}\n\n/** Statically allocate working data, so it doesn't need per-call creation */\nconst quantizeToF16Data = new Float16Array(new ArrayBuffer(2));\n\n/** @returns the closest 16-bit floating point value to the input */\nexport function quantizeToF16(num: number): number {\n  quantizeToF16Data[0] = num;\n  return quantizeToF16Data[0];\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToU32(num: number): number {\n  return u32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/**\n * @returns the bit representation as a 64-integer, via interpreting the input\n * as a 64-bit float value\n */\nexport function reinterpretF64AsU64(input: number): bigint {\n  return new BigUint64Array(new Float64Array([input]).buffer)[0];\n}\n\n/**\n * @returns a 64-bit float value via interpreting the input as the bit\n * representation as a 64-bit integer\n */\nexport function reinterpretU64AsF64(input: bigint): number {\n  return new Float64Array(new BigUint64Array([input]).buffer)[0];\n}\n\n/**\n * @returns a 32-bit float value via interpreting the input as the bit\n * representation as a 32-bit integer\n */\nexport function reinterpretU32AsF32(input: number): number {\n  return floatBitsToNumber(input, kFloat32Format);\n}\n\n/**\n * @returns a 16-bit float value via interpreting the input as the bit\n * representation as a 16-bit integer\n */\nexport function reinterpretU16AsF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach((i: T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n\n/** @returns all of the permutations of an array\n *\n * Recursively calculates all of the permutations, does not cull duplicate\n * entries.\n *\n * Only feasible for inputs of lengths 5 or so, since the number of permutations\n * is (input.length)!, so will cause the stack to explode for longer inputs.\n *\n * This code could be made iterative using something like\n * SteinhausJohnsonTrotter and additionally turned into a generator to reduce\n * the stack size, but there is still a fundamental combinatorial explosion\n * here that will affect runtime.\n *\n * @param input the array to get permutations of\n */\nexport function calculatePermutations<T>(input: T[]): T[][] {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (input.length === 1) {\n    return [input];\n  }\n\n  if (input.length === 2) {\n    return [input, [input[1], input[0]]];\n  }\n\n  const result: T[][] = [];\n  input.forEach((head, idx) => {\n    const tail = input.slice(0, idx).concat(input.slice(idx + 1));\n    const permutations = calculatePermutations(tail);\n    permutations.forEach(p => {\n      result.push([head, ...p]);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Convert an Array of Arrays to linear array\n *\n * Caller is responsible to retaining the dimensions of the array for later\n * unflattening\n *\n * @param m Matrix to convert\n */\nexport function flatten2DArray<T>(m: T[][]): T[] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to flatten`\n  );\n  const result: T[] = Array<T>(c * r);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[j + i * r] = m[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Convert linear array to an Array of Arrays\n * @param n an array to convert\n * @param c number of elements in the array containing arrays\n * @param r number of elements in the arrays that are contained\n */\nexport function unflatten2DArray<T>(n: T[], c: number, r: number): T[][] {\n  assert(\n    c > 0 && Number.isInteger(c) && r > 0 && Number.isInteger(r),\n    `columns (${c}) and rows (${r}) need to be positive integers`\n  );\n  assert(n.length === c * r, `m.length(${n.length}) should equal c * r (${c * r})`);\n  const result: T[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = n[j + i * r];\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .map over a matrix and return the result\n * The shape of the input and output matrices will be the same\n *\n * @param m input matrix of type T\n * @param op operation that converts an element of type T to one of type S\n * @returns a matrix with elements of type S that are calculated by applying op element by element\n */\nexport function map2DArray<T, S>(m: T[][], op: (input: T) => S): S[][] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  const result: S[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = op(m[i][j]);\n    }\n  }\n  return result;\n}\n"],"mappings":"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"}