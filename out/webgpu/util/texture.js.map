{"version":3,"file":"texture.js","names":["assert","unreachable","getBlockInfoForTextureFormat","isDepthOrStencilTextureFormat","isDepthTextureFormat","isStencilTextureFormat","getTextureCopyLayout","reifyExtent3D","reifyOrigin3D","kLoadValueFromStorageInfo","r8unorm","storageType","texelType","unpackWGSL","r8uint","r8sint","rg8unorm","rg8uint","rg8sint","rgba8unorm","bgra8unorm","rgba8uint","rgba8sint","rg11b10ufloat","r16float","r16uint","r16sint","rg16float","rg16uint","rg16sint","rgba16float","rgba16uint","rgba16sint","r32float","rgb10a2uint","rgb10a2unorm","depth16unorm","depth32float","stencil8","getDepthStencilOptionsForFormat","format","useFragDepth","discardWithStencil","getCopyBufferToTextureViaRenderCode","srcFormat","dstFormat","info","depthDecl","depthCode","stencilCode","code","dataFormat","s_copyBufferToTextureViaRenderPipelines","WeakMap","copyBufferToTextureViaRender","t","encoder","source","sourceFormat","dest","size","textureFormat","sampleCount","texture","origin","copySize","resourcesToDestroy","device","numBlits","blitCount","stencilWriteMask","id","JSON","stringify","pipelines","get","Map","set","pipeline","module","createShaderModule","createRenderPipeline","label","layout","vertex","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","stencilFront","passOp","primitive","topology","multisample","count","width","bytesPerRow","fullRows","Math","floor","buffer","rows","ceil","srcTexture","createTextureTracked","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","push","copyBufferToTexture","totalPixels","pixelsCopied","pixelsInLastRow","offset","baseMipLevel","mipLevel","l","depthOrArrayLayers","baseArrayLayer","z","mipLevelCount","arrayLayerCount","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","stencilClearValue","stencilLoadOp","stencilStoreOp","depthClearValue","depthLoadOp","depthStoreOp","stencilReadOnly","loadOp","storeOp","setViewport","x","y","height","setPipeline","rowsPerImage","uniforms","Uint32Array","bytesPerBlock","uniformBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","setStencilReference","draw","end","createTextureFromTexelViews","texelViews","desc","length","every","e","viewsFormat","isTextureFormatDifferentThanTexelViewFormat","commandEncoder","createCommandEncoder","mipSize","mipWidth","mipHeight","mipDepthOrArray","dimension","stagingBuffer","createBufferTracked","mappedAtCreation","COPY_SRC","writeTextureData","Uint8Array","getMappedRange","subrectOrigin","subrectSize","unmap","queue","submit","finish","forEach","value","destroy"],"sources":["../../../src/webgpu/util/texture.ts"],"sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\nimport {\n  getBlockInfoForTextureFormat,\n  isDepthOrStencilTextureFormat,\n  isDepthTextureFormat,\n  isStencilTextureFormat,\n} from '../format_info.js';\nimport { GPUTestBase } from '../gpu_test.js';\n\nimport { getTextureCopyLayout } from './texture/layout.js';\nimport { TexelView } from './texture/texel_view.js';\nimport { reifyExtent3D, reifyOrigin3D } from './unions.js';\n\n// Note: For values that are supposedly unused we use 0.123 as a sentinel for\n// float formats and 123 for integer formats. For example, rendering to r8unorm\n// returns (v, 9.123, 0.123, 0.123). Since only v should be used this shouldn't\n// matter but just in case we set it to 123 so it's more likely to cause an\n// issue if something is wrong.\nconst kLoadValueFromStorageInfo: Partial<{\n  [k in GPUTextureFormat]: {\n    storageType: string;\n    texelType: string;\n    unpackWGSL: string;\n  };\n}> = {\n  r8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    return vec4f(unpack4x8unorm(getSrc(byteOffset / 4))[byteOffset % 4], 0.123, 0.123, 0.123)\n  `,\n  },\n  r8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    return vec4u(unpack4xU8(getSrc(byteOffset / 4))[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  r8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    return vec4i(unpack4xI8(getSrc(byteOffset / 4))[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  rg8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    let v = unpack4x8unorm(getSrc(byteOffset / 4));\n    return vec4f(select(v.rg, v.ba, byteOffset % 4 >= 2), 0.123, 0.123)\n  `,\n  },\n  rg8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    let v = unpack4xU8(getSrc(byteOffset / 4));\n    return vec4u(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rg8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    let v = unpack4xI8(getSrc(byteOffset / 4));\n    return vec4i(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rgba8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(getSrc(byteOffset / 4))',\n  },\n  'rgba8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(getSrc(byteOffset / 4));\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.rgb, v.a);\n    `,\n  },\n  bgra8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(getSrc(byteOffset / 4)).bgra',\n  },\n  'bgra8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(getSrc(byteOffset / 4));\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.bgr, v.a);\n    `,\n  },\n  rgba8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: 'return unpack4xU8(getSrc(byteOffset / 4))',\n  },\n  rgba8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: 'return unpack4xI8(getSrc(byteOffset / 4))',\n  },\n  rg11b10ufloat: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `return unpackRG11B10UFloat(getSrc(byteOffset / 4))`,\n  },\n  r16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL:\n      'return vec4f(unpack2x16float(getSrc(byteOffset / 4))[byteOffset % 4 / 2], 0.123, 0.123, 0.123)',\n  },\n  r16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL:\n      'return vec4u(extractBits(getSrc(byteOffset / 4), (byteOffset % 4 / 2 * 16), 16), 123, 123, 123)',\n  },\n  r16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL:\n      'return vec4i(extractBits(getSrc(byteOffset / 4), byteOffset % 4 / 2 * 16, 16), 123, 123, 123)',\n  },\n  rg16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(unpack2x16float(getSrc(byteOffset / 4)), 0.123, 0.123)',\n  },\n  rg16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = getSrc(byteOffset / 4);\n      return vec4u(v & 0xFFFF, v >> 16, 123, 123)\n    `,\n  },\n  rg16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v = getSrc(byteOffset / 4);\n      return vec4i(\n        extractBits(v, 0, 16),\n        extractBits(v, 16, 16),\n        123, 123)\n    `,\n  },\n  rgba16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      return vec4f(\n        unpack2x16float(getSrc(byteOffset / 4)),\n        unpack2x16float(getSrc(byteOffset / 4 + 1)))\n    `,\n  },\n  rgba16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v0 = getSrc(byteOffset / 4);\n      let v1 = getSrc(byteOffset / 4 + 1);\n      return vec4u(v0 & 0xFFFF, v0 >> 16, v1 & 0xFFFF, v1 >> 16)\n    `,\n  },\n  rgba16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v0 = getSrc(byteOffset / 4);\n      let v1 = getSrc(byteOffset / 4 + 1);\n      return vec4i(\n        extractBits(v0, 0, 16),\n        extractBits(v0, 16, 16),\n        extractBits(v1, 0, 16),\n        extractBits(v1, 16, 16),\n      )\n    `,\n  },\n  r32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(getSrc(byteOffset / 4), 0.123, 0.123, 0.123)',\n  },\n  rgb10a2uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = getSrc(byteOffset / 4);\n      return vec4u(\n        extractBits(v, 0, 10),\n        extractBits(v, 10, 10),\n        extractBits(v, 20, 10),\n        extractBits(v, 30, 2),\n      )\n    `,\n  },\n  rgb10a2unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = getSrc(byteOffset / 4);\n      return vec4f(\n        f32(extractBits(v, 0, 10)) / f32(0x3FF),\n        f32(extractBits(v, 10, 10)) / f32(0x3FF),\n        f32(extractBits(v, 20, 10)) / f32(0x3FF),\n        f32(extractBits(v, 30, 2)) / f32(0x3),\n      )\n    `,\n  },\n  depth16unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack2x16unorm(getSrc(byteOffset / 4))[byteOffset % 4 / 2];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n  },\n  depth32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = getSrc(byteOffset / 4);\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n  },\n  stencil8: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      return vec4u(unpack4xU8(getSrc(byteOffset / 4))[byteOffset % 4], 123, 123, 123)\n    `,\n  },\n};\n\nfunction getDepthStencilOptionsForFormat(format: GPUTextureFormat) {\n  // Note: For now we prefer depth over stencil. To fix this would require passing GPUTextureAspect all the way down.\n  return {\n    useFragDepth: isDepthTextureFormat(format),\n    discardWithStencil: isStencilTextureFormat(format) && !isDepthTextureFormat(format),\n  };\n}\n\nfunction getCopyBufferToTextureViaRenderCode(\n  srcFormat: GPUTextureFormat,\n  dstFormat: GPUTextureFormat\n) {\n  const info = kLoadValueFromStorageInfo[srcFormat];\n  assert(!!info);\n  const { storageType, texelType, unpackWGSL } = info;\n  const { useFragDepth, discardWithStencil } = getDepthStencilOptionsForFormat(dstFormat);\n\n  const [depthDecl, depthCode] = useFragDepth\n    ? ['@builtin(frag_depth) d: f32,', 'fs.d = fs.v[0];']\n    : ['', ''];\n\n  const stencilCode = discardWithStencil ? 'if ((fs.v.r & vin.stencilMask) == 0) { discard; }' : '';\n\n  const code = `\n    struct Uniforms {\n      numTexelRows: u32,\n      bytesPerRow: u32,\n      bytesPerSample: u32,\n      sampleCount: u32,\n      offset: u32,\n    };\n\n    struct VSOutput {\n      @builtin(position) pos: vec4f,\n      @location(0) @interpolate(flat, either) sampleIndex: u32,\n      @location(1) @interpolate(flat, either) stencilMask: u32,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n      let points = array(\n        vec2f(0, 0), vec2f(1, 0), vec2f(0, 1), vec2f(1, 1),\n      );\n      let sampleRow = vNdx / 4;\n      let numSampleRows = f32(uni.numTexelRows * uni.sampleCount);\n      let rowOffset = f32(sampleRow) / numSampleRows;\n      let rowMult = 1.0 / numSampleRows;\n      let p = (points[vNdx % 4] * vec2f(1, rowMult) + vec2f(0, rowOffset)) * 2.0 - 1.0;\n      return VSOutput(\n        vec4f(p, 0, 1),\n        uni.sampleCount - sampleRow % uni.sampleCount - 1,\n        1u << iNdx);\n    }\n\n    @group(0) @binding(0) var<uniform> uni: Uniforms;\n    @group(0) @binding(1) var src: texture_2d<${storageType}>;\n\n    // get a u32/i32/f32 from a r32uint/r32sint/r32float as though it was 1d array\n    fn getSrc(offset: u32) -> ${storageType} {\n      let width = textureDimensions(src, 0).x;\n      let x = offset % width;\n      let y = offset / width;\n      return textureLoad(src, vec2u(x, y), 0).r;\n    }\n\n    const kFloat32FormatMantissaBits = 23;\n    const kFloat32FormatBias = 127;\n    fn floatBitsToNumber(\n        rawBits: u32,\n        bitOffset: u32,\n        exponentBits: u32,\n        mantissaBits: u32,\n        bias: u32,\n        signed: bool) -> f32 {\n      let nonSignBits = exponentBits + mantissaBits;\n      let allBits = nonSignBits + select(0u, 1u, signed);\n      let allMask = (1u << allBits) - 1u;\n      let bits = (rawBits >> bitOffset) & allMask;\n      let nonSignBitsMask = (1u << nonSignBits) - 1u;\n      let exponentAndMantissaBits = bits & nonSignBitsMask;\n      let exponentMask = ((1u << exponentBits) - 1u) << mantissaBits;\n      let infinityOrNaN = (bits & exponentMask) == exponentMask;\n      if (infinityOrNaN) {\n        let mantissaMask = (1u << mantissaBits) - 1;\n        let signBit = 1u << nonSignBits;\n        let isNegative = (bits & signBit) != 0;\n        if ((bits & mantissaMask) != 0u) {\n          return 0.0; // NaN (does not exist in WGSL)\n        }\n        if (isNegative) {\n          return f32(-2e38); // NEGATIVE_INFINITY (does not exist in WGSL)\n        } else {\n          return f32(2e38); // POSITIVE_INFINITY (does not exist in WGSL)\n        }\n      }\n      var f32BitsWithWrongBias =\n        exponentAndMantissaBits << (kFloat32FormatMantissaBits - mantissaBits);\n      // add in the sign\n      f32BitsWithWrongBias |= (bits << (31u - nonSignBits)) & 0x80000000u;\n      let numberWithWrongBias = bitcast<f32>(f32BitsWithWrongBias);\n      return numberWithWrongBias * pow(2.0f, f32(kFloat32FormatBias - bias));\n    }\n\n    fn unpackRG11B10UFloat(v: u32) -> vec4f {\n      return vec4f(\n        floatBitsToNumber(v,  0, 5, 6, 15, false),\n        floatBitsToNumber(v, 11, 5, 6, 15, false),\n        floatBitsToNumber(v, 22, 5, 5, 15, false),\n        1\n      );\n    }\n\n    fn unpack(byteOffset: u32) -> ${texelType} {\n      ${unpackWGSL};\n    }\n\n    struct FSOutput {\n      @location(0) v: ${texelType},\n      ${depthDecl}\n    };\n\n    @fragment fn fs(vin: VSOutput) -> FSOutput {\n      let coord = vec2u(vin.pos.xy);\n      let byteOffset =\n        uni.offset +\n        coord.y * uni.bytesPerRow +\n        (coord.x * uni.sampleCount + vin.sampleIndex) * uni.bytesPerSample;\n      var fs: FSOutput;\n      fs.v = unpack(byteOffset);\n      ${depthCode}\n      ${stencilCode}\n      return fs;\n    }\n    `;\n\n  let dataFormat: GPUTextureFormat;\n  switch (storageType) {\n    case 'f32':\n      dataFormat = 'r32float';\n      break;\n    case 'i32':\n      dataFormat = 'r32sint';\n      break;\n    case 'u32':\n      dataFormat = 'r32uint';\n      break;\n    default:\n      unreachable();\n  }\n  return { code, dataFormat };\n}\n\nconst s_copyBufferToTextureViaRenderPipelines = new WeakMap<\n  GPUDevice,\n  Map<string, GPURenderPipeline>\n>();\n\n// This function emulates copyBufferToTexture by by rendering into the texture.\n// This is for formats that can't be copied to directly. depth textures, stencil\n// textures, multisampled textures.\n//\n// For source data it creates an r32uint/r32sint/r32float texture\n// and copies the source buffer into it and then reads the texture\n// as a 1d array. It does this because compat mode might not have\n// storage buffers in fragment shaders.\nfunction copyBufferToTextureViaRender(\n  t: GPUTestBase,\n  encoder: GPUCommandEncoder,\n  source: GPUTexelCopyBufferInfo,\n  sourceFormat: GPUTextureFormat,\n  dest: GPUTexelCopyTextureInfo,\n  size: GPUExtent3D\n) {\n  const { format: textureFormat, sampleCount } = dest.texture;\n  const origin = reifyOrigin3D(dest.origin ?? [0]);\n  const copySize = reifyExtent3D(size);\n  const { useFragDepth, discardWithStencil } = getDepthStencilOptionsForFormat(dest.texture.format);\n  const resourcesToDestroy: (GPUTexture | GPUBuffer)[] = [];\n\n  const { device } = t;\n  const numBlits = discardWithStencil ? 8 : 1;\n  for (let blitCount = 0; blitCount < numBlits; ++blitCount) {\n    const { code, dataFormat } = getCopyBufferToTextureViaRenderCode(\n      sourceFormat,\n      dest.texture.format\n    );\n    const stencilWriteMask = 1 << blitCount;\n    const id = JSON.stringify({\n      textureFormat,\n      sourceFormat,\n      useFragDepth,\n      stencilWriteMask,\n      discardWithStencil,\n      sampleCount,\n      code,\n    });\n    const pipelines =\n      s_copyBufferToTextureViaRenderPipelines.get(device) ?? new Map<string, GPURenderPipeline>();\n    s_copyBufferToTextureViaRenderPipelines.set(device, pipelines);\n    let pipeline = pipelines.get(id);\n    if (!pipeline) {\n      const module = device.createShaderModule({ code });\n      pipeline = device.createRenderPipeline({\n        label: `blitCopyFor-${textureFormat}`,\n        layout: 'auto',\n        vertex: { module },\n        ...(discardWithStencil\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: false,\n                depthCompare: 'always',\n                format: textureFormat,\n                stencilWriteMask,\n                stencilFront: {\n                  passOp: 'replace',\n                },\n              },\n            }\n          : useFragDepth\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'always',\n                format: textureFormat,\n              },\n            }\n          : {\n              fragment: {\n                module,\n                targets: [{ format: textureFormat }],\n              },\n            }),\n        primitive: {\n          topology: 'triangle-strip',\n        },\n        ...(sampleCount > 1 && { multisample: { count: sampleCount } }),\n      });\n      pipelines.set(id, pipeline);\n    }\n\n    const width = 1024;\n    const bytesPerRow = width * 4;\n    const fullRows = Math.floor(source.buffer.size / bytesPerRow);\n    const rows = Math.ceil(source.buffer.size / bytesPerRow);\n    const srcTexture = t.createTextureTracked({\n      format: dataFormat,\n      size: [width, rows],\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    });\n    resourcesToDestroy.push(srcTexture);\n\n    if (fullRows > 0) {\n      encoder.copyBufferToTexture({ buffer: source.buffer, bytesPerRow }, { texture: srcTexture }, [\n        width,\n        fullRows,\n      ]);\n    }\n    if (rows > fullRows) {\n      const totalPixels = source.buffer.size / 4;\n      const pixelsCopied = fullRows * width;\n      const pixelsInLastRow = totalPixels - pixelsCopied;\n      encoder.copyBufferToTexture(\n        {\n          buffer: source.buffer,\n          offset: pixelsCopied * 4,\n          bytesPerRow,\n        },\n        {\n          texture: srcTexture,\n          origin: [0, fullRows],\n        },\n        [pixelsInLastRow, 1]\n      );\n    }\n    const baseMipLevel = dest.mipLevel;\n    for (let l = 0; l < copySize.depthOrArrayLayers; ++l) {\n      const baseArrayLayer = origin.z + l;\n      const mipLevelCount = 1;\n      const arrayLayerCount = 1;\n      const pass = encoder.beginRenderPass(\n        discardWithStencil\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                stencilClearValue: 0,\n                stencilLoadOp: 'load',\n                stencilStoreOp: 'store',\n              },\n            }\n          : useFragDepth\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                depthClearValue: 0,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                stencilReadOnly: true,\n              },\n            }\n          : {\n              colorAttachments: [\n                {\n                  view: dest.texture.createView({\n                    baseMipLevel,\n                    baseArrayLayer,\n                    mipLevelCount,\n                    arrayLayerCount,\n                  }),\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                },\n              ],\n            }\n      );\n      pass.setViewport(origin.x, origin.y, copySize.width, copySize.height, 0, 1);\n      pass.setPipeline(pipeline);\n\n      const info = getBlockInfoForTextureFormat(sourceFormat);\n      const offset =\n        (source.offset ?? 0) + (source.bytesPerRow ?? 0) * (source.rowsPerImage ?? 0) * l;\n      const uniforms = new Uint32Array([\n        copySize.height, //  numTexelRows: u32,\n        source.bytesPerRow!, //  bytesPerRow: u32,\n        info.bytesPerBlock!, //  bytesPerSample: u32,\n        dest.texture.sampleCount, //  sampleCount: u32,\n        offset, //  offset: u32,\n      ]);\n\n      const uniformBuffer = t.makeBufferWithContents(\n        uniforms,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n      );\n      resourcesToDestroy.push(uniformBuffer);\n      const bindGroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: uniformBuffer } },\n          { binding: 1, resource: srcTexture.createView() },\n        ],\n      });\n\n      pass.setBindGroup(0, bindGroup);\n      pass.setStencilReference(0xff);\n      pass.draw(4 * copySize.height * dest.texture.sampleCount, 1, 0, blitCount);\n      pass.end();\n    }\n  }\n\n  return resourcesToDestroy;\n}\n\n/**\n * Creates a mipmapped texture where each mipmap level's (`i`) content is\n * from `texelViews[i]`.\n */\nexport function createTextureFromTexelViews(\n  t: GPUTestBase,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'> & { format?: GPUTextureFormat }\n): GPUTexture {\n  // All texel views must be the same format for mipmaps.\n  assert(texelViews.length > 0 && texelViews.every(e => e.format === texelViews[0].format));\n  const viewsFormat = texelViews[0].format;\n  const textureFormat = desc.format ?? viewsFormat;\n  const isTextureFormatDifferentThanTexelViewFormat = textureFormat !== viewsFormat;\n  const { width, height, depthOrArrayLayers } = reifyExtent3D(desc.size);\n\n  // Create the texture and then initialize each mipmap level separately.\n  const texture = t.createTextureTracked({\n    ...desc,\n    format: textureFormat,\n    usage: desc.usage | GPUTextureUsage.COPY_DST,\n    mipLevelCount: texelViews.length,\n  });\n\n  // Copy the texel view into each mip level layer.\n  const commandEncoder = t.device.createCommandEncoder({ label: 'createTextureFromTexelViews' });\n  const resourcesToDestroy: (GPUTexture | GPUBuffer)[] = [];\n  for (let mipLevel = 0; mipLevel < texelViews.length; mipLevel++) {\n    const {\n      bytesPerRow,\n      rowsPerImage,\n      mipSize: [mipWidth, mipHeight, mipDepthOrArray],\n    } = getTextureCopyLayout(\n      viewsFormat,\n      desc.dimension ?? '2d',\n      [width, height, depthOrArrayLayers],\n      {\n        mipLevel,\n      }\n    );\n\n    // Create a staging buffer to upload the texture mip level contents.\n    const stagingBuffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bytesPerRow * mipHeight * mipDepthOrArray,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n    resourcesToDestroy.push(stagingBuffer);\n\n    // Write the texels into the staging buffer.\n    texelViews[mipLevel].writeTextureData(new Uint8Array(stagingBuffer.getMappedRange()), {\n      bytesPerRow,\n      rowsPerImage: mipHeight,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [mipWidth, mipHeight, mipDepthOrArray],\n      sampleCount: texture.sampleCount,\n    });\n    stagingBuffer.unmap();\n\n    if (\n      isTextureFormatDifferentThanTexelViewFormat ||\n      texture.sampleCount > 1 ||\n      isDepthOrStencilTextureFormat(textureFormat)\n    ) {\n      resourcesToDestroy.push(\n        ...copyBufferToTextureViaRender(\n          t,\n          commandEncoder,\n          { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n          viewsFormat,\n          { texture, mipLevel },\n          [mipWidth, mipHeight, mipDepthOrArray]\n        )\n      );\n    } else {\n      // Copy from the staging buffer into the texture.\n      commandEncoder.copyBufferToTexture(\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    }\n  }\n  t.device.queue.submit([commandEncoder.finish()]);\n\n  // Cleanup temp buffers and textures.\n  resourcesToDestroy.forEach(value => value.destroy());\n\n  return texture;\n}\n"],"mappings":"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AAS,CAAC,GAAGP,YAAY;EACvC,CAAC,8BAA8B,EAAE,iBAAiB,CAAC;EACnD,CAAC,EAAE,EAAE,EAAE,CAAC;;EAEZ,MAAMQ,WAAW,GAAGP,kBAAkB,GAAG,mDAAmD,GAAG,EAAE;;EAEjG,MAAMQ,IAAI,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgDvC,WAAY;AAC5D;AACA;AACA,gCAAgCA,WAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoCC,SAAU;AAC9C,QAAQC,UAAW;AACnB;AACA;AACA;AACA,wBAAwBD,SAAU;AAClC,QAAQmC,SAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQC,SAAU;AAClB,QAAQC,WAAY;AACpB;AACA;AACA,KAAK;;EAEH,IAAIE,UAA4B;EAChC,QAAQxC,WAAW;IACjB,KAAK,KAAK;MACRwC,UAAU,GAAG,UAAU;MACvB;IACF,KAAK,KAAK;MACRA,UAAU,GAAG,SAAS;MACtB;IACF,KAAK,KAAK;MACRA,UAAU,GAAG,SAAS;MACtB;IACF;MACElD,WAAW,CAAC,CAAC;EACjB;EACA,OAAO,EAAEiD,IAAI,EAAEC,UAAU,CAAC,CAAC;AAC7B;;AAEA,MAAMC,uCAAuC,GAAG,IAAIC,OAAO;;;AAGzD,CAAC;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,4BAA4BA;AACnCC,CAAc;AACdC,OAA0B;AAC1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"}