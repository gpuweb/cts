{"version":3,"file":"texture.js","names":["assert","isDepthOrStencilTextureFormat","isDepthTextureFormat","isStencilTextureFormat","kTextureFormatInfo","getTextureCopyLayout","reifyExtent3D","reifyOrigin3D","kLoadValueFromStorageInfo","r8unorm","storageType","texelType","unpackWGSL","r8uint","r8sint","rg8unorm","rg8uint","rg8sint","rgba8unorm","bgra8unorm","rgba8uint","rgba8sint","r16float","r16uint","r16sint","rg16float","rg16uint","rg16sint","rgba16float","rgba16uint","rgba16sint","r32float","rgb10a2uint","rgb10a2unorm","depth16unorm","depth32float","stencil8","getDepthStencilOptionsForFormat","format","useFragDepth","discardWithStencil","getCopyBufferToTextureViaRenderCode","srcFormat","dstFormat","info","depthDecl","depthCode","stencilCode","s_copyBufferToTextureViaRenderPipelines","WeakMap","copyBufferToTextureViaRender","t","encoder","source","sourceFormat","dest","size","textureFormat","sampleCount","texture","origin","copySize","device","numBlits","blitCount","code","stencilWriteMask","id","JSON","stringify","pipelines","get","Map","set","pipeline","module","createShaderModule","createRenderPipeline","label","layout","vertex","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","stencilFront","passOp","primitive","topology","multisample","count","uniforms","Uint32Array","height","bytesPerRow","bytesPerBlock","uniformBuffer","makeBufferWithContents","GPUBufferUsage","COPY_DST","UNIFORM","storageBuffer","createBufferTracked","buffer","usage","STORAGE","copyBufferToBuffer","baseMipLevel","mipLevel","l","depthOrArrayLayers","baseArrayLayer","z","mipLevelCount","arrayLayerCount","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","createView","stencilClearValue","stencilLoadOp","stencilStoreOp","depthClearValue","depthLoadOp","depthStoreOp","stencilReadOnly","loadOp","storeOp","setViewport","x","y","width","setPipeline","offset","rowsPerImage","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","setBindGroup","setStencilReference","draw","end","createTextureFromTexelViews","texelViews","desc","length","every","e","viewsFormat","isTextureFormatDifferentThanTexelViewFormat","createTextureTracked","GPUTextureUsage","commandEncoder","createCommandEncoder","stagingBuffers","mipSize","mipWidth","mipHeight","mipDepthOrArray","dimension","stagingBuffer","mappedAtCreation","COPY_SRC","push","writeTextureData","Uint8Array","getMappedRange","subrectOrigin","subrectSize","unmap","copyBufferToTexture","queue","submit","finish","forEach","value","destroy"],"sources":["../../../src/webgpu/util/texture.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport {\n  isDepthOrStencilTextureFormat,\n  isDepthTextureFormat,\n  isStencilTextureFormat,\n  kTextureFormatInfo,\n} from '../format_info.js';\nimport { GPUTestBase } from '../gpu_test.js';\n\nimport { getTextureCopyLayout } from './texture/layout.js';\nimport { TexelView } from './texture/texel_view.js';\nimport { reifyExtent3D, reifyOrigin3D } from './unions.js';\n\n// Note: For values that are supposedly unused we use 0.123 as a sentinel for\n// float formats and 123 for integer formats. For example, rendering to r8unorm\n// returns (v, 9.123, 0.123, 0.123). Since only v should be used this shouldn't\n// matter but just in case we set it to 123 so it's more likely to cause an\n// issue if something is wrong.\nconst kLoadValueFromStorageInfo: Partial<{\n  [k in GPUTextureFormat]: {\n    storageType: string;\n    texelType: string;\n    unpackWGSL: string;\n  };\n}> = {\n  r8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    return vec4f(unpack4x8unorm(src[byteOffset / 4])[byteOffset % 4], 0.123, 0.123, 0.123)\n  `,\n  },\n  r8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    return vec4u(unpack4xU8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  r8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    return vec4i(unpack4xI8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n  `,\n  },\n  rg8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n    let v = unpack4x8unorm(src[byteOffset / 4]);\n    return vec4f(select(v.rg, v.ba, byteOffset % 4 >= 2), 0.123, 0.123)\n  `,\n  },\n  rg8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n    let v = unpack4xU8(src[byteOffset / 4]);\n    return vec4u(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rg8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n    let v = unpack4xI8(src[byteOffset / 4]);\n    return vec4i(select(v.rg, v.ba, byteOffset % 4 >= 2), 123, 123)\n  `,\n  },\n  rgba8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4])',\n  },\n  'rgba8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.rgb, v.a);\n    `,\n  },\n  bgra8unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return unpack4x8unorm(src[byteOffset / 4]).bgra',\n  },\n  'bgra8unorm-srgb': {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack4x8unorm(src[byteOffset / 4]);\n      let srgb = select(\n        v / 12.92,\n        pow((v + 0.055) / 1.055, vec4f(2.4)),\n        v >= vec4f(0.04045)\n      );\n      return vec4f(srgb.bgr, v.a);\n    `,\n  },\n  rgba8uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: 'return unpack4xU8(src[byteOffset / 4])',\n  },\n  rgba8sint: {\n    storageType: 'u32',\n    texelType: 'vec4i',\n    unpackWGSL: 'return unpack4xI8(src[byteOffset / 4])',\n  },\n  r16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL:\n      'return vec4f(unpack2x16float(src[byteOffset / 4])[byteOffset % 4 / 2], 0.123, 0.123, 0.123)',\n  },\n  r16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL:\n      'return vec4u(extractBits(src[byteOffset / 4], (byteOffset % 4 / 2 * 16), 16), 123, 123, 123)',\n  },\n  r16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL:\n      'return vec4i(extractBits(src[byteOffset / 4], byteOffset % 4 / 2 * 16, 16), 123, 123, 123)',\n  },\n  rg16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(unpack2x16float(src[byteOffset / 4]), 0.123, 0.123)',\n  },\n  rg16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(v & 0xFFFF, v >> 16, 123, 123)\n    `,\n  },\n  rg16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4i(\n        extractBits(v, 0, 16),\n        extractBits(v, 16, 16),\n        123, 123)\n    `,\n  },\n  rgba16float: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      return vec4f(\n        unpack2x16float(src[byteOffset / 4]),\n        unpack2x16float(src[byteOffset / 4 + 1]))\n    `,\n  },\n  rgba16uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4u(v0 & 0xFFFF, v0 >> 16, v1 & 0xFFFF, v1 >> 16)\n    `,\n  },\n  rgba16sint: {\n    storageType: 'i32',\n    texelType: 'vec4i',\n    unpackWGSL: `\n      let v0 = src[byteOffset / 4];\n      let v1 = src[byteOffset / 4 + 1];\n      return vec4i(\n        extractBits(v0, 0, 16),\n        extractBits(v0, 16, 16),\n        extractBits(v1, 0, 16),\n        extractBits(v1, 16, 16),\n      )\n    `,\n  },\n  r32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: 'return vec4f(src[byteOffset / 4], 0.123, 0.123, 0.123)',\n  },\n  rgb10a2uint: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4u(\n        extractBits(v, 0, 10),\n        extractBits(v, 10, 10),\n        extractBits(v, 20, 10),\n        extractBits(v, 30, 2),\n      )\n    `,\n  },\n  rgb10a2unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(\n        f32(extractBits(v, 0, 10)) / f32(0x3FF),\n        f32(extractBits(v, 10, 10)) / f32(0x3FF),\n        f32(extractBits(v, 20, 10)) / f32(0x3FF),\n        f32(extractBits(v, 30, 2)) / f32(0x3),\n      )\n    `,\n  },\n  depth16unorm: {\n    storageType: 'u32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = unpack2x16unorm(src[byteOffset / 4])[byteOffset % 4 / 2];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n  },\n  depth32float: {\n    storageType: 'f32',\n    texelType: 'vec4f',\n    unpackWGSL: `\n      let v = src[byteOffset / 4];\n      return vec4f(v, 0.123, 0.123, 0.123)\n    `,\n  },\n  stencil8: {\n    storageType: 'u32',\n    texelType: 'vec4u',\n    unpackWGSL: `\n      return vec4u(unpack4xU8(src[byteOffset / 4])[byteOffset % 4], 123, 123, 123)\n    `,\n  },\n};\n\nfunction getDepthStencilOptionsForFormat(format: GPUTextureFormat) {\n  // Note: For now we prefer depth over stencil. To fix this would require passing GPUTextureAspect all the way down.\n  return {\n    useFragDepth: isDepthTextureFormat(format),\n    discardWithStencil: isStencilTextureFormat(format) && !isDepthTextureFormat(format),\n  };\n}\n\nfunction getCopyBufferToTextureViaRenderCode(\n  srcFormat: GPUTextureFormat,\n  dstFormat: GPUTextureFormat\n) {\n  const info = kLoadValueFromStorageInfo[srcFormat];\n  assert(!!info);\n  const { storageType, texelType, unpackWGSL } = info;\n  const { useFragDepth, discardWithStencil } = getDepthStencilOptionsForFormat(dstFormat);\n\n  const [depthDecl, depthCode] = useFragDepth\n    ? ['@builtin(frag_depth) d: f32,', 'fs.d = fs.v[0];']\n    : ['', ''];\n\n  const stencilCode = discardWithStencil ? 'if ((fs.v.r & vin.stencilMask) == 0) { discard; }' : '';\n\n  return `\n    struct Uniforms {\n      numTexelRows: u32,\n      bytesPerRow: u32,\n      bytesPerSample: u32,\n      sampleCount: u32,\n    };\n\n    struct VSOutput {\n      @builtin(position) pos: vec4f,\n      @location(0) @interpolate(flat, either) sampleIndex: u32,\n      @location(1) @interpolate(flat, either) stencilMask: u32,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n      let points = array(\n        vec2f(0, 0), vec2f(1, 0), vec2f(0, 1), vec2f(1, 1),\n      );\n      let sampleRow = vNdx / 4;\n      let numSampleRows = f32(uni.numTexelRows * uni.sampleCount);\n      let rowOffset = f32(sampleRow) / numSampleRows;\n      let rowMult = 1.0 / numSampleRows;\n      let p = (points[vNdx % 4] * vec2f(1, rowMult) + vec2f(0, rowOffset)) * 2.0 - 1.0;\n      return VSOutput(\n        vec4f(p, 0, 1),\n        uni.sampleCount - sampleRow % uni.sampleCount - 1,\n        1u << iNdx);\n    }\n\n    @group(0) @binding(0) var<uniform> uni: Uniforms;\n    @group(0) @binding(1) var<storage> src: array<${storageType}>;\n\n    fn unpack(byteOffset: u32) -> ${texelType} {\n      ${unpackWGSL};\n    }\n\n    struct FSOutput {\n      @location(0) v: ${texelType},\n      ${depthDecl}\n    };\n\n    @fragment fn fs(vin: VSOutput) -> FSOutput {\n      let coord = vec2u(vin.pos.xy);\n      let byteOffset =\n        coord.y * uni.bytesPerRow +\n        (coord.x * uni.sampleCount + vin.sampleIndex) * uni.bytesPerSample;\n      var fs: FSOutput;\n      fs.v = unpack(byteOffset);\n      ${depthCode}\n      ${stencilCode}\n      return fs;\n    }\n    `;\n}\n\nconst s_copyBufferToTextureViaRenderPipelines = new WeakMap<\n  GPUDevice,\n  Map<string, GPURenderPipeline>\n>();\n\nfunction copyBufferToTextureViaRender(\n  t: GPUTestBase,\n  encoder: GPUCommandEncoder,\n  source: GPUTexelCopyBufferInfo,\n  sourceFormat: GPUTextureFormat,\n  dest: GPUTexelCopyTextureInfo,\n  size: GPUExtent3D\n) {\n  const { format: textureFormat, sampleCount } = dest.texture;\n  const origin = reifyOrigin3D(dest.origin ?? [0]);\n  const copySize = reifyExtent3D(size);\n  const { useFragDepth, discardWithStencil } = getDepthStencilOptionsForFormat(dest.texture.format);\n\n  const { device } = t;\n  const numBlits = discardWithStencil ? 8 : 1;\n  for (let blitCount = 0; blitCount < numBlits; ++blitCount) {\n    const code = getCopyBufferToTextureViaRenderCode(sourceFormat, dest.texture.format);\n    const stencilWriteMask = 1 << blitCount;\n    const id = JSON.stringify({\n      textureFormat,\n      sourceFormat,\n      useFragDepth,\n      stencilWriteMask,\n      discardWithStencil,\n      sampleCount,\n      code,\n    });\n    const pipelines =\n      s_copyBufferToTextureViaRenderPipelines.get(device) ?? new Map<string, GPURenderPipeline>();\n    s_copyBufferToTextureViaRenderPipelines.set(device, pipelines);\n    let pipeline = pipelines.get(id);\n    if (!pipeline) {\n      const module = device.createShaderModule({ code });\n      pipeline = device.createRenderPipeline({\n        label: `blitCopyFor-${textureFormat}`,\n        layout: 'auto',\n        vertex: { module },\n        ...(discardWithStencil\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: false,\n                depthCompare: 'always',\n                format: textureFormat,\n                stencilWriteMask,\n                stencilFront: {\n                  passOp: 'replace',\n                },\n              },\n            }\n          : useFragDepth\n          ? {\n              fragment: {\n                module,\n                targets: [],\n              },\n              depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: 'always',\n                format: textureFormat,\n              },\n            }\n          : {\n              fragment: {\n                module,\n                targets: [{ format: textureFormat }],\n              },\n            }),\n        primitive: {\n          topology: 'triangle-strip',\n        },\n        ...(sampleCount > 1 && { multisample: { count: sampleCount } }),\n      });\n      pipelines.set(id, pipeline);\n    }\n\n    const info = kTextureFormatInfo[sourceFormat];\n    const uniforms = new Uint32Array([\n      copySize.height, //  numTexelRows: u32,\n      source.bytesPerRow!, //  bytesPerRow: u32,\n      info.bytesPerBlock!, //  bytesPerSample: u32,\n      dest.texture.sampleCount, //  sampleCount: u32,\n    ]);\n    const uniformBuffer = t.makeBufferWithContents(\n      uniforms,\n      GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n    );\n    const storageBuffer = t.createBufferTracked({\n      size: source.buffer.size,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n    });\n    encoder.copyBufferToBuffer(source.buffer, 0, storageBuffer, 0, storageBuffer.size);\n    const baseMipLevel = dest.mipLevel;\n    for (let l = 0; l < copySize.depthOrArrayLayers; ++l) {\n      const baseArrayLayer = origin.z + l;\n      const mipLevelCount = 1;\n      const arrayLayerCount = 1;\n      const pass = encoder.beginRenderPass(\n        discardWithStencil\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                stencilClearValue: 0,\n                stencilLoadOp: 'load',\n                stencilStoreOp: 'store',\n              },\n            }\n          : useFragDepth\n          ? {\n              colorAttachments: [],\n              depthStencilAttachment: {\n                view: dest.texture.createView({\n                  baseMipLevel,\n                  baseArrayLayer,\n                  mipLevelCount,\n                  arrayLayerCount,\n                }),\n                depthClearValue: 0,\n                depthLoadOp: 'clear',\n                depthStoreOp: 'store',\n                stencilReadOnly: true,\n              },\n            }\n          : {\n              colorAttachments: [\n                {\n                  view: dest.texture.createView({\n                    baseMipLevel,\n                    baseArrayLayer,\n                    mipLevelCount,\n                    arrayLayerCount,\n                  }),\n                  loadOp: 'clear',\n                  storeOp: 'store',\n                },\n              ],\n            }\n      );\n      pass.setViewport(origin.x, origin.y, copySize.width, copySize.height, 0, 1);\n      pass.setPipeline(pipeline);\n\n      const offset =\n        (source.offset ?? 0) + (source.bytesPerRow ?? 0) * (source.rowsPerImage ?? 0) * l;\n      const bindGroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: uniformBuffer } },\n          { binding: 1, resource: { buffer: storageBuffer, offset } },\n        ],\n      });\n\n      pass.setBindGroup(0, bindGroup);\n      pass.setStencilReference(0xff);\n      pass.draw(4 * copySize.height * dest.texture.sampleCount, 1, 0, blitCount);\n      pass.end();\n    }\n  }\n}\n\n/**\n * Creates a mipmapped texture where each mipmap level's (`i`) content is\n * from `texelViews[i]`.\n */\nexport function createTextureFromTexelViews(\n  t: GPUTestBase,\n  texelViews: TexelView[],\n  desc: Omit<GPUTextureDescriptor, 'format'> & { format?: GPUTextureFormat }\n): GPUTexture {\n  // All texel views must be the same format for mipmaps.\n  assert(texelViews.length > 0 && texelViews.every(e => e.format === texelViews[0].format));\n  const viewsFormat = texelViews[0].format;\n  const textureFormat = desc.format ?? viewsFormat;\n  const isTextureFormatDifferentThanTexelViewFormat = textureFormat !== viewsFormat;\n  const { width, height, depthOrArrayLayers } = reifyExtent3D(desc.size);\n\n  // Create the texture and then initialize each mipmap level separately.\n  const texture = t.createTextureTracked({\n    ...desc,\n    format: textureFormat,\n    usage: desc.usage | GPUTextureUsage.COPY_DST,\n    mipLevelCount: texelViews.length,\n  });\n\n  // Copy the texel view into each mip level layer.\n  const commandEncoder = t.device.createCommandEncoder();\n  const stagingBuffers = [];\n  for (let mipLevel = 0; mipLevel < texelViews.length; mipLevel++) {\n    const {\n      bytesPerRow,\n      rowsPerImage,\n      mipSize: [mipWidth, mipHeight, mipDepthOrArray],\n    } = getTextureCopyLayout(\n      viewsFormat,\n      desc.dimension ?? '2d',\n      [width, height, depthOrArrayLayers],\n      {\n        mipLevel,\n      }\n    );\n\n    // Create a staging buffer to upload the texture mip level contents.\n    const stagingBuffer = t.createBufferTracked({\n      mappedAtCreation: true,\n      size: bytesPerRow * mipHeight * mipDepthOrArray,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n    stagingBuffers.push(stagingBuffer);\n\n    // Write the texels into the staging buffer.\n    texelViews[mipLevel].writeTextureData(new Uint8Array(stagingBuffer.getMappedRange()), {\n      bytesPerRow,\n      rowsPerImage: mipHeight,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [mipWidth, mipHeight, mipDepthOrArray],\n      sampleCount: texture.sampleCount,\n    });\n    stagingBuffer.unmap();\n\n    if (\n      isTextureFormatDifferentThanTexelViewFormat ||\n      texture.sampleCount > 1 ||\n      isDepthOrStencilTextureFormat(textureFormat)\n    ) {\n      copyBufferToTextureViaRender(\n        t,\n        commandEncoder,\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        viewsFormat,\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    } else {\n      // Copy from the staging buffer into the texture.\n      commandEncoder.copyBufferToTexture(\n        { buffer: stagingBuffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel },\n        [mipWidth, mipHeight, mipDepthOrArray]\n      );\n    }\n  }\n  t.device.queue.submit([commandEncoder.finish()]);\n\n  // Cleanup the staging buffers.\n  stagingBuffers.forEach(value => value.destroy());\n\n  return texture;\n}\n"],"mappings":"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"}