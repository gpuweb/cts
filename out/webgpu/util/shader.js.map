{"version":3,"file":"shader.js","names":["assert","unreachable","kDefaultVertexShaderCode","kDefaultFragmentShaderCode","kFullscreenQuadVertexShaderCode","kPlainTypeInfo","i32","suffix","fractionDigits","u32","f32","getPlainTypeInfo","sampleType","getFragmentShaderCodeWithOutput","outputs","fragDepth","dualSourceBlending","length","value","toFixed","resultStrings","outputStructString","push","i","o","plainType","outputType","v","values","map","n","componentCount","join","kValidShaderStages","getShaderWithEntryPoint","shaderStage","entryPoint","code"],"sources":["../../../src/webgpu/util/shader.ts"],"sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\n\nexport const kDefaultVertexShaderCode = `\n@vertex fn main() -> @builtin(position) vec4<f32> {\n  return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n}\n`;\n\nexport const kDefaultFragmentShaderCode = `\n@fragment fn main() -> @location(0) vec4<f32>  {\n  return vec4<f32>(1.0, 1.0, 1.0, 1.0);\n}`;\n\n// MAINTENANCE_TODO(#3344): deduplicate fullscreen quad shader code.\nexport const kFullscreenQuadVertexShaderCode = `\n  struct VertexOutput {\n    @builtin(position) Position : vec4<f32>\n  };\n\n  @vertex fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n    var pos = array<vec2<f32>, 6>(\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>( 1.0, -1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  1.0));\n\n    var output : VertexOutput;\n    output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n    return output;\n  }\n`;\n\nconst kPlainTypeInfo = {\n  i32: {\n    suffix: '',\n    fractionDigits: 0,\n  },\n  u32: {\n    suffix: 'u',\n    fractionDigits: 0,\n  },\n  f32: {\n    suffix: '',\n    fractionDigits: 4,\n  },\n};\n\n/**\n *\n * @param sampleType sampleType of texture format\n * @returns plain type compatible of the sampleType\n */\nexport function getPlainTypeInfo(sampleType: GPUTextureSampleType): keyof typeof kPlainTypeInfo {\n  switch (sampleType) {\n    case 'sint':\n      return 'i32';\n    case 'uint':\n      return 'u32';\n    case 'float':\n    case 'unfilterable-float':\n    case 'depth':\n      return 'f32';\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Build a fragment shader based on output value and types\n * e.g. write to color target 0 a `vec4<f32>(1.0, 0.0, 1.0, 1.0)` and color target 2 a `vec2<u32>(1, 2)`\n * ```\n * outputs: [\n *   {\n *     values: [1, 0, 1, 1],,\n *     plainType: 'f32',\n *     componentCount: 4,\n *   },\n *   null,\n *   {\n *     values: [1, 2],\n *     plainType: 'u32',\n *     componentCount: 2,\n *   },\n * ]\n * ```\n *\n * return:\n * ```\n * struct Outputs {\n *     @location(0) o1 : vec4<f32>,\n *     @location(2) o3 : vec2<u32>,\n * }\n * @fragment fn main() -> Outputs {\n *     return Outputs(vec4<f32>(1.0, 0.0, 1.0, 1.0), vec4<u32>(1, 2));\n * }\n * ```\n *\n * If fragDepth is given there will be an extra @builtin(frag_depth) output with the specified value assigned.\n *\n * @param outputs the shader outputs for each location attribute\n * @param fragDepth the shader outputs frag_depth value (optional)\n * @returns the fragment shader string\n */\nexport function getFragmentShaderCodeWithOutput(\n  outputs: ({\n    values: readonly number[];\n    plainType: 'i32' | 'u32' | 'f32';\n    componentCount: number;\n  } | null)[],\n  fragDepth: { value: number } | null = null,\n  dualSourceBlending: boolean = false\n): string {\n  if (outputs.length === 0) {\n    if (fragDepth) {\n      return `\n        @fragment fn main() -> @builtin(frag_depth) f32 {\n          return ${fragDepth.value.toFixed(kPlainTypeInfo['f32'].fractionDigits)};\n        }`;\n    }\n    return `\n        @fragment fn main() {\n        }`;\n  }\n\n  const resultStrings = [] as string[];\n  let outputStructString = '';\n\n  if (fragDepth) {\n    resultStrings.push(`${fragDepth.value.toFixed(kPlainTypeInfo['f32'].fractionDigits)}`);\n    outputStructString += `@builtin(frag_depth) depth_out: f32,\\n`;\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    const o = outputs[i];\n    if (o === null) {\n      continue;\n    }\n\n    const plainType = o.plainType;\n    const { suffix, fractionDigits } = kPlainTypeInfo[plainType];\n\n    let outputType;\n    const v = o.values.map(n => n.toFixed(fractionDigits));\n    switch (o.componentCount) {\n      case 1:\n        outputType = plainType;\n        resultStrings.push(`${v[0]}${suffix}`);\n        break;\n      case 2:\n        outputType = `vec2<${plainType}>`;\n        resultStrings.push(`${outputType}(${v[0]}${suffix}, ${v[1]}${suffix})`);\n        break;\n      case 3:\n        outputType = `vec3<${plainType}>`;\n        resultStrings.push(`${outputType}(${v[0]}${suffix}, ${v[1]}${suffix}, ${v[2]}${suffix})`);\n        break;\n      case 4:\n        outputType = `vec4<${plainType}>`;\n        resultStrings.push(\n          `${outputType}(${v[0]}${suffix}, ${v[1]}${suffix}, ${v[2]}${suffix}, ${v[3]}${suffix})`\n        );\n        break;\n      default:\n        unreachable();\n    }\n\n    if (dualSourceBlending) {\n      assert(i === 0 && outputs.length === 1);\n      outputStructString += `\n          @location(0) @blend_src(0) o0 : ${outputType},\n          @location(0) @blend_src(1) o0_blend : ${outputType},\n      `;\n      resultStrings.push(resultStrings[0]);\n      break;\n    } else {\n      outputStructString += `@location(${i}) o${i} : ${outputType},\\n`;\n    }\n  }\n\n  return `\n    ${dualSourceBlending ? 'enable dual_source_blending;' : ''}\n\n    struct Outputs {\n      ${outputStructString}\n    }\n\n    @fragment fn main() -> Outputs {\n        return Outputs(${resultStrings.join(',')});\n    }`;\n}\n\nexport const kValidShaderStages = ['compute', 'vertex', 'fragment'] as const;\nexport type TValidShaderStage = (typeof kValidShaderStages)[number];\nexport type TShaderStage = TValidShaderStage | 'empty';\n\n/**\n * Return a foo shader of the given stage with the given entry point\n * @param shaderStage\n * @param entryPoint\n * @returns the shader string\n */\nexport function getShaderWithEntryPoint(shaderStage: TShaderStage, entryPoint: string): string {\n  let code;\n  switch (shaderStage) {\n    case 'compute': {\n      code = `@compute @workgroup_size(1) fn ${entryPoint}() {}`;\n      break;\n    }\n    case 'vertex': {\n      code = `\n      @vertex fn ${entryPoint}() -> @builtin(position) vec4<f32> {\n        return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      }`;\n      break;\n    }\n    case 'fragment': {\n      code = `\n      @fragment fn ${entryPoint}() -> @location(0) vec4<f32> {\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      }`;\n      break;\n    }\n    case 'empty':\n    default: {\n      code = '';\n      break;\n    }\n  }\n  return code;\n}\n"],"mappings":"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"}