{"version":3,"file":"array.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kValidCases","i32","u32","f32","f16","bool","vec2u","vec3i","vec4f","array","struct","mat2x2f","mat4x4h","atomicu","atomici","literal_count","literali_count","literalu_count","const_count","const_expr_count1","const_expr_count2","const_expr_func","override_count","override_expr1","override_expr2","override_zero","override_neg","same_const_value1","same_const_value2","same_const_value3","same_override","same_rta","shadow","trailing_comma1","trailing_comma2","alias_element","test","desc","params","u","combine","fn","t","code","case","skipIf","indexOf","hasLanguageFeature","expectCompileResult","kInvalidCases","f16_without_enable","texture","sampler","runtime_nested","override_nested","override_nested_struct","zero_size","negative_size","const_zero","const_neg","float_size","incompatible_overrides","incompatible_size","incompatible_element","incompatible_rta","incompatible_override_element","override_function","override_private","override_uniform","override_storage","missing_r_template","missing_l_template","missing_type","bad_type","missing_l_template_rta","missing_r_template_rta","bad_size","inline_struct"],"sources":["../../../../../src/webgpu/shader/validation/types/array.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for array types\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kValidCases = {\n  // Basic element types.\n  i32: `alias T = array<i32>;`,\n  u32: `alias T = array<u32>;`,\n  f32: `alias T = array<f32>;`,\n  f16: `enable f16;\\nalias T = array<f16>;`,\n  bool: `alias T = array<bool>;`,\n\n  // Composite elements\n  vec2u: `alias T = array<vec2u>;`,\n  vec3i: `alias T = array<vec3i>;`,\n  vec4f: `alias T = array<vec4f>;`,\n  array: `alias T = array<array<u32, 4>>;`,\n  struct: `struct S { x : u32 }\\nalias T = array<S>;`,\n  mat2x2f: `alias T = array<mat2x2f>;`,\n  mat4x4h: `enable f16;\\nalias T = array<mat4x4h>;`,\n\n  // Atomic elements\n  atomicu: `alias T = array<atomic<u32>>;`,\n  atomici: `alias T = array<atomic<i32>>;`,\n\n  // Count expressions\n  literal_count: `alias T = array<u32, 4>;`,\n  literali_count: `alias T = array<u32, 4i>;`,\n  literalu_count: `alias T = array<u32, 4u>;`,\n  const_count: `const x = 8;\\nalias T = array<u32, x>;`,\n  const_expr_count1: `alias T = array<u32, 1 + 3>;`,\n  const_expr_count2: `const x = 4;\\nalias T = array<u32, x * 2>;`,\n  const_expr_func: `alias T = array<u32, max(1,2)>;`,\n  override_count: `override x : u32;\\nalias T = array<u32, x>;`,\n  override_expr1: `override x = 2;\\nalias T = array<u32, vec2(x,x).x>;`,\n  override_expr2: `override x = 1;\\nalias T = array<u32, x + 1>;`,\n  override_zero: `override x = 0;\\nalias T = array<u32, x>;`,\n  override_neg: `override x = -1;\\nalias T = array<u32, x>;`,\n\n  // Same array types\n  same_const_value1: `\n    const x = 8;\n    const y = 8;\n    var<private> v : array<u32, x> = array<u32, y>();`,\n  same_const_value2: `\n    const x = 8;\n    var<private> v : array<u32, x> = array<u32, 8>();`,\n  same_const_value3: `\n    var<private> v : array<u32, 8i> = array<u32, 8u>();`,\n  same_override: `\n    requires unrestricted_pointer_parameters;\n    override x : u32;\n    var<workgroup> v : array<u32, x>;\n    fn bar(p : ptr<workgroup, array<u32, x>>) { }\n    fn foo() { bar(&v); }`,\n  same_rta: `\n    requires unrestricted_pointer_parameters;\n    @group(0) @binding(0) var<storage> x : array<u32>;\n    fn foo(p : ptr<storage, array<u32>>) { }\n    fn bar() { foo(&x); }`,\n\n  // Shadow\n  shadow: `alias array = vec2f;`,\n\n  trailing_comma1: `alias T = array<u32,4,>;`,\n  trailing_comma2: `alias T = array<u32,>;`,\n\n  alias_element: `alias T = u32; alias U = array<T>;`,\n};\n\ng.test('valid')\n  .desc('Valid array type tests')\n  .params(u => u.combine('case', keysOf(kValidCases)))\n  .fn(t => {\n    const code = kValidCases[t.params.case];\n    t.skipIf(\n      code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n      'Test requires unrestricted_pointer_parameters'\n    );\n    t.expectCompileResult(true, code);\n  });\n\nconst kInvalidCases = {\n  f16_without_enable: `alias T = array<f16>;`,\n  texture: `alias T = array<texture_2d<f32>, 4>;`,\n  sampler: `alias T = array<sampler>;`,\n  runtime_nested: `alias T = array<array<u32>, 4>;`,\n  override_nested: `\n    override x : u32;\n    alias T = array<array<u32, x>, 4>;`,\n  override_nested_struct: `\n    override x : u32;\n    struct T { x : array<u32, x> }`,\n  zero_size: `alias T = array<u32, 0>;`,\n  negative_size: `alias T = array<u32, 1 - 2>;`,\n  const_zero: `const x = 0;\\nalias T = array<u32, x>;`,\n  const_neg: `const x = 1;\\nconst y = 2;\\nalias T = array<u32, x - y>;`,\n  float_size: `alias T = array<u32, max(1f, 2f)>;`,\n  incompatible_overrides: `\n    requires unrestricted_pointer_parameters;\n    override x = 8;\n    override y = 8;\n    var<workgroup> v : array<u32, x>\n    fn bar(p : ptr<workgroup, array<u32 y>>) { }\n    fn foo() { bar(&v); }`,\n  incompatible_size: `\n    var<private> x : array<u32, 4>;\n    fn foo(a : array<u32, 2>) { }\n    fn bar() { foo(x); }`,\n  incompatible_element: `\n    const x : array<i32, 4> = array(1,2,3,4);\n    var<private> y : array<u32, 4>  = x;`,\n  incompatible_rta: `\n    requires unrestricted_pointer_parameters;\n    @group(0) @binding(0) var<storage> x : array<u32>;\n    fn foo(p : ptr<storage, array<i32>>) { }\n    fn bar() { foo(&x); }`,\n  incompatible_override_element: `\n    requires unrestricted_pointer_parameters;\n    override x : i32;\n    var<workgroup> v : array<u32, v>;\n    fn bar(p : ptr<workgroup, array<i32 c>>) { }\n    fn foo() { bar(&v); }`,\n  override_function: `\n    override x : i32;\n    fn foo() { var v : array<u32, x>; }`,\n  override_private: `\n    override x : u32;\n    var<private> v : array<u32, x>;`,\n  override_uniform: `\n    override x : u32;\n    @group(0) @binding(0) var<uniform> v : array<u32, x>;`,\n  override_storage: `\n    override x : u32;\n    @group(0) @binding(0) var<storage> v : array<u32, x>;`,\n\n  // Parsing failures\n  missing_r_template: `alias T = array<u32, 4;`,\n  missing_l_template: `alias T = arrayu32,4>;`,\n  missing_type: `alias T = array<4>;`,\n  bad_type: `alias T = array<bad_type, 4>;`,\n  missing_l_template_rta: `alias T = arrayu32>;`,\n  missing_r_template_rta: `alias T = array<u32;`,\n  bad_size: `alias T = array<u32,u32>;`,\n  inline_struct: `alias T = array<struct S { x : u32 }, 4>;`,\n};\n\ng.test('invalid')\n  .desc('Invalid array type tests')\n  .params(u => u.combine('case', keysOf(kInvalidCases)))\n  .fn(t => {\n    const code = kInvalidCases[t.params.case];\n    t.skipIf(\n      code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n      'Test requires unrestricted_pointer_parameters'\n    );\n    t.expectCompileResult(false, code);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SAASC,MAAM,QAAQ,wCAAwC;AAC/D,SAASC,oBAAoB,QAAQ,8BAA8B;;AAEnE,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,oBAAoB,CAAC;;AAEpD,MAAME,WAAW,GAAG;EAClB;EACAC,GAAG,EAAG,uBAAsB;EAC5BC,GAAG,EAAG,uBAAsB;EAC5BC,GAAG,EAAG,uBAAsB;EAC5BC,GAAG,EAAG,oCAAmC;EACzCC,IAAI,EAAG,wBAAuB;;EAE9B;EACAC,KAAK,EAAG,yBAAwB;EAChCC,KAAK,EAAG,yBAAwB;EAChCC,KAAK,EAAG,yBAAwB;EAChCC,KAAK,EAAG,iCAAgC;EACxCC,MAAM,EAAG,2CAA0C;EACnDC,OAAO,EAAG,2BAA0B;EACpCC,OAAO,EAAG,wCAAuC;;EAEjD;EACAC,OAAO,EAAG,+BAA8B;EACxCC,OAAO,EAAG,+BAA8B;;EAExC;EACAC,aAAa,EAAG,0BAAyB;EACzCC,cAAc,EAAG,2BAA0B;EAC3CC,cAAc,EAAG,2BAA0B;EAC3CC,WAAW,EAAG,wCAAuC;EACrDC,iBAAiB,EAAG,8BAA6B;EACjDC,iBAAiB,EAAG,4CAA2C;EAC/DC,eAAe,EAAG,iCAAgC;EAClDC,cAAc,EAAG,6CAA4C;EAC7DC,cAAc,EAAG,qDAAoD;EACrEC,cAAc,EAAG,+CAA8C;EAC/DC,aAAa,EAAG,2CAA0C;EAC1DC,YAAY,EAAG,4CAA2C;;EAE1D;EACAC,iBAAiB,EAAG;AACtB;AACA;AACA,sDAAsD;EACpDC,iBAAiB,EAAG;AACtB;AACA,sDAAsD;EACpDC,iBAAiB,EAAG;AACtB,wDAAwD;EACtDC,aAAa,EAAG;AAClB;AACA;AACA;AACA;AACA,0BAA0B;EACxBC,QAAQ,EAAG;AACb;AACA;AACA;AACA,0BAA0B;;EAExB;EACAC,MAAM,EAAG,sBAAqB;;EAE9BC,eAAe,EAAG,0BAAyB;EAC3CC,eAAe,EAAG,wBAAuB;;EAEzCC,aAAa,EAAG;AAClB,CAAC;;AAEDpC,CAAC,CAACqC,IAAI,CAAC,OAAO,CAAC;AACZC,IAAI,CAAC,wBAAwB,CAAC;AAC9BC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAE3C,MAAM,CAACG,WAAW,CAAC,CAAC,CAAC;AACnDyC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAG3C,WAAW,CAAC0C,CAAC,CAACJ,MAAM,CAACM,IAAI,CAAC;EACvCF,CAAC,CAACG,MAAM;IACNF,IAAI,CAACG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAACJ,CAAC,CAACK,kBAAkB,CAAC,iCAAiC,CAAC;IAC7F;EACF,CAAC;EACDL,CAAC,CAACM,mBAAmB,CAAC,IAAI,EAAEL,IAAI,CAAC;AACnC,CAAC,CAAC;;AAEJ,MAAMM,aAAa,GAAG;EACpBC,kBAAkB,EAAG,uBAAsB;EAC3CC,OAAO,EAAG,sCAAqC;EAC/CC,OAAO,EAAG,2BAA0B;EACpCC,cAAc,EAAG,iCAAgC;EACjDC,eAAe,EAAG;AACpB;AACA,uCAAuC;EACrCC,sBAAsB,EAAG;AAC3B;AACA,mCAAmC;EACjCC,SAAS,EAAG,0BAAyB;EACrCC,aAAa,EAAG,8BAA6B;EAC7CC,UAAU,EAAG,wCAAuC;EACpDC,SAAS,EAAG,0DAAyD;EACrEC,UAAU,EAAG,oCAAmC;EAChDC,sBAAsB,EAAG;AAC3B;AACA;AACA;AACA;AACA;AACA,0BAA0B;EACxBC,iBAAiB,EAAG;AACtB;AACA;AACA,yBAAyB;EACvBC,oBAAoB,EAAG;AACzB;AACA,yCAAyC;EACvCC,gBAAgB,EAAG;AACrB;AACA;AACA;AACA,0BAA0B;EACxBC,6BAA6B,EAAG;AAClC;AACA;AACA;AACA;AACA,0BAA0B;EACxBC,iBAAiB,EAAG;AACtB;AACA,wCAAwC;EACtCC,gBAAgB,EAAG;AACrB;AACA,oCAAoC;EAClCC,gBAAgB,EAAG;AACrB;AACA,0DAA0D;EACxDC,gBAAgB,EAAG;AACrB;AACA,0DAA0D;;EAExD;EACAC,kBAAkB,EAAG,yBAAwB;EAC7CC,kBAAkB,EAAG,wBAAuB;EAC5CC,YAAY,EAAG,qBAAoB;EACnCC,QAAQ,EAAG,+BAA8B;EACzCC,sBAAsB,EAAG,sBAAqB;EAC9CC,sBAAsB,EAAG,sBAAqB;EAC9CC,QAAQ,EAAG,2BAA0B;EACrCC,aAAa,EAAG;AAClB,CAAC;;AAED9E,CAAC,CAACqC,IAAI,CAAC,SAAS,CAAC;AACdC,IAAI,CAAC,0BAA0B,CAAC;AAChCC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAE3C,MAAM,CAACoD,aAAa,CAAC,CAAC,CAAC;AACrDR,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAGM,aAAa,CAACP,CAAC,CAACJ,MAAM,CAACM,IAAI,CAAC;EACzCF,CAAC,CAACG,MAAM;IACNF,IAAI,CAACG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAACJ,CAAC,CAACK,kBAAkB,CAAC,iCAAiC,CAAC;IAC7F;EACF,CAAC;EACDL,CAAC,CAACM,mBAAmB,CAAC,KAAK,EAAEL,IAAI,CAAC;AACpC,CAAC,CAAC"}