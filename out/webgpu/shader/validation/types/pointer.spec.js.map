{"version":3,"file":"pointer.spec.js","names":["description","makeTestGroup","keysOf","kAccessModeInfo","kAddressSpaceInfo","pointerType","explicitSpaceExpander","accessModeExpander","getVarDeclShader","supportsWrite","ShaderValidationTest","g","test","desc","params","u","combine","fn","t","code","aspace","comma","expectCompileResult","success","access","kTypeCases","bool","type","storable","u32","i32","f32","f16","vec2u","vec3i","vec4f","vec2_bool","vec3h","mat2x2f","mat3x4h","atomic_u32","atomic_i32","array_sized_u32","array_sized_vec4f","array_sized_S","array_runtime_u32","array_runtime_S","array_runtime_atomic_u32","array_override_u32","struct_S","struct_T","ptr_function_u32","ptr_workgroup_bool","sampler","texture_2d","alias","reference","testcase","case","includes","kNonHandleAddressSpaces","filter","as","specURL","expand","prog","ok","ptrStoreType","typePart","inferPtrType","storeType","i","spellAccessMode","addressSpace","accessMode","kStoreTypeNotInstantiable","ptr","privateAtomic","functionAtomic","uniformAtomic","workgroupRTArray","uniformRTArray","privateRTArray","functionRTArray","RTArrayNotLast","nestedRTArray"],"sources":["../../../../../src/webgpu/shader/validation/types/pointer.spec.ts"],"sourcesContent":["export const description = 'Test pointer type validation';\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { AddressSpace, kAccessModeInfo, kAddressSpaceInfo } from '../../types.js';\nimport {\n  pointerType,\n  explicitSpaceExpander,\n  accessModeExpander,\n  getVarDeclShader,\n  supportsWrite,\n  ShaderStage,\n} from '../decl/util.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('missing_type')\n  .desc('Test that pointer types require an element type')\n  .params(u =>\n    u\n      .combine('aspace', ['function', 'private', 'workgroup', 'storage', 'uniform'] as const)\n      .combine('comma', ['', ','] as const)\n  )\n  .fn(t => {\n    const code = `alias T = ptr<${t.params.aspace}${t.params.comma}>;`;\n    t.expectCompileResult(false, code);\n  });\n\ng.test('address_space')\n  .desc('Test address spaces in pointer type parameterization')\n  .params(u =>\n    u\n      .combine('aspace', [\n        'function',\n        'private',\n        'workgroup',\n        'storage',\n        'uniform',\n        'handle',\n        'bad_aspace',\n      ] as const)\n      .combine('comma', ['', ','] as const)\n  )\n  .fn(t => {\n    const code = `alias T = ptr<${t.params.aspace}, u32${t.params.comma}>;`;\n    const success = t.params.aspace !== 'handle' && t.params.aspace !== 'bad_aspace';\n    t.expectCompileResult(success, code);\n  });\n\ng.test('access_mode')\n  .desc('Test access mode in pointer type parameterization')\n  .params(u =>\n    u\n      .combine('aspace', ['function', 'private', 'storage', 'uniform', 'workgroup'] as const)\n      .combine('access', ['read', 'write', 'read_write'] as const)\n      .combine('comma', ['', ','] as const)\n  )\n  .fn(t => {\n    // Default access mode is tested above.\n    const code = `alias T = ptr<${t.params.aspace}, u32, ${t.params.access}${t.params.comma}>;`;\n    const success = t.params.aspace === 'storage' && t.params.access !== 'write';\n    t.expectCompileResult(success, code);\n  });\n\ninterface TypeCase {\n  type: string;\n  storable: boolean;\n  f16?: boolean;\n  aspace?: string;\n}\n\nconst kTypeCases: Record<string, TypeCase> = {\n  // Scalars\n  bool: { type: `bool`, storable: true, aspace: 'function' },\n  u32: { type: `u32`, storable: true },\n  i32: { type: `i32`, storable: true },\n  f32: { type: `f32`, storable: true },\n  f16: { type: `f16`, storable: true, f16: true },\n\n  // Vectors\n  vec2u: { type: `vec2u`, storable: true },\n  vec3i: { type: `vec3i`, storable: true },\n  vec4f: { type: `vec4f`, storable: true },\n  vec2_bool: { type: `vec2<bool>`, storable: true, aspace: 'workgroup' },\n  vec3h: { type: `vec3h`, storable: true, f16: true },\n\n  // Matrices\n  mat2x2f: { type: `mat2x2f`, storable: true },\n  mat3x4h: { type: `mat3x4h`, storable: true, f16: true },\n\n  // Atomics\n  atomic_u32: { type: `atomic<u32>`, storable: true },\n  atomic_i32: { type: `atomic<i32>`, storable: true },\n\n  // Arrays\n  array_sized_u32: { type: `array<u32, 4>`, storable: true },\n  array_sized_vec4f: { type: `array<vec4f, 16>`, storable: true },\n  array_sized_S: { type: `array<S, 2>`, storable: true },\n  array_runtime_u32: { type: `array<u32>`, storable: true },\n  array_runtime_S: { type: `array<S>`, storable: true },\n  array_runtime_atomic_u32: { type: `array<atomic<u32>>`, storable: true },\n  array_override_u32: { type: `array<u32, o>`, storable: true, aspace: 'workgroup' },\n\n  // Structs\n  struct_S: { type: `S`, storable: true },\n  struct_T: { type: `T`, storable: true },\n\n  // Pointers\n  ptr_function_u32: { type: `ptr<function, u32>`, storable: false },\n  ptr_workgroup_bool: { type: `ptr<workgroup, bool>`, storable: false },\n\n  // Sampler (while storable, can only be in the handle address space)\n  sampler: { type: `sampler`, storable: false },\n\n  // Texture (while storable, can only be in the handle address space)\n  texture_2d: { type: `texture_2d<f32>`, storable: false },\n\n  // Alias\n  alias: { type: `u32_alias`, storable: true },\n\n  // Reference\n  reference: { type: `ref<function, u32>`, storable: false, aspace: 'function' },\n};\n\ng.test('type')\n  .desc('Tests that pointee type must be storable')\n  .params(u => u.combine('case', keysOf(kTypeCases)))\n  .fn(t => {\n    const testcase = kTypeCases[t.params.case];\n    const aspace = testcase.aspace ?? 'storage';\n    const access = testcase.type.includes('atomic') ? ', read_write' : '';\n    const code = `${testcase.f16 ? 'enable f16;' : ''}\n    override o : u32;\n    struct S { x : u32 }\n    struct T { s : array<S> }\n    alias u32_alias = u32;\n    alias Type = ptr<${aspace}, ${testcase.type}${access}>;`;\n    t.expectCompileResult(testcase.storable, code);\n  });\n\n// Address spaces that can hold an i32 variable.\nconst kNonHandleAddressSpaces = keysOf(kAddressSpaceInfo).filter(\n  as => as !== 'handle'\n) as AddressSpace[];\n\ng.test('let_ptr_explicit_type_matches_var')\n  .desc(\n    'Let-declared pointer with explicit type initialized from var with same address space and access mode'\n  )\n  .specURL('https://w3.org/TR#ref-ptr-types')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      // Vary the store type.\n      .combine('ptrStoreType', ['i32', 'u32'])\n  )\n  .fn(t => {\n    // Match the address space and access mode.\n    const prog = getVarDeclShader(t.params, `let p: ${pointerType(t.params)} = &x;`);\n    const ok = t.params.ptrStoreType === 'i32'; // The store type matches the variable's store type.\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('let_ptr_reads')\n  .desc('Validate reading via ptr when permitted by access mode')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      .combine('inferPtrType', [false, true])\n      .combine('ptrStoreType', ['i32'])\n  )\n  .fn(t => {\n    // Try reading through the pointer.\n    const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n    const prog = getVarDeclShader(t.params, `let p${typePart} = &x; let read = *p;`);\n    const ok = true; // We can always read.\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('let_ptr_writes')\n  .desc('Validate writing via ptr when permitted by access mode')\n  .specURL('https://w3.org/TR#ref-ptr-types')\n  .params(u =>\n    u // Generate non-handle variables in all valid permutations of address space and access mode.\n      .combine('addressSpace', kNonHandleAddressSpaces)\n      .expand('explicitSpace', explicitSpaceExpander)\n      .combine('explicitAccess', [false, true])\n      .expand('accessMode', accessModeExpander)\n      .combine('stage', ['compute' as ShaderStage]) // Only need to check compute shaders\n      .combine('inferPtrType', [false, true])\n      .combine('ptrStoreType', ['i32'])\n  )\n  .fn(t => {\n    // Try writing through the pointer.\n    const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n    const prog = getVarDeclShader(t.params, `let p${typePart} = &x; *p = 42;`);\n    const ok = supportsWrite(t.params);\n\n    t.expectCompileResult(ok, prog);\n  });\n\ng.test('ptr_handle_space_invalid').fn(t => {\n  t.expectCompileResult(false, 'alias p = ptr<handle,u32>;');\n});\n\ng.test('ptr_bad_store_type')\n  .params(u => u.combine('storeType', ['undeclared', 'clamp', '1']))\n  .fn(t => {\n    t.expectCompileResult(false, `alias p = ptr<private,${t.params.storeType}>;`);\n  });\n\ng.test('ptr_address_space_never_uses_access_mode')\n  .params(u =>\n    u\n      .combine(\n        'addressSpace',\n        keysOf(kAddressSpaceInfo).filter(i => kAddressSpaceInfo[i].spellAccessMode === 'never')\n      )\n      .combine('accessMode', keysOf(kAccessModeInfo))\n  )\n  .fn(t => {\n    const prog = `alias pty = ptr<${t.params.addressSpace},u32,;${t.params.accessMode}>;`;\n    t.expectCompileResult(false, prog);\n  });\n\nconst kStoreTypeNotInstantiable: Record<string, string> = {\n  ptr: 'alias p = ptr<storage,ptr<private,i32>>;',\n  privateAtomic: 'alias p = ptr<private,atomic<u32>>;',\n  functionAtomic: 'alias p = ptr<function,atomic<u32>>;',\n  uniformAtomic: 'alias p = ptr<uniform,atomic<u32>>;',\n  workgroupRTArray: 'alias p = ptr<workgroup,array<i32>>;',\n  uniformRTArray: 'alias p = ptr<uniform,array<i32>>;',\n  privateRTArray: 'alias p = ptr<private,array<i32>>;',\n  functionRTArray: 'alias p = ptr<function,array<i32>>;',\n  RTArrayNotLast: 'struct S { a: array<i32>, b: i32 } alias p = ptr<storage,S>;',\n  nestedRTArray: 'struct S { a: array<i32>, b: i32 } struct { s: S } alias p = ptr<storage,T>;',\n} as const;\n\ng.test('ptr_not_instantiable')\n  .desc(\n    'Validate that ptr type must correspond to a variable that could be declared somewhere; test bad cases'\n  )\n  .params(u => u.combine('case', keysOf(kStoreTypeNotInstantiable)))\n  .fn(t => {\n    t.expectCompileResult(false, kStoreTypeNotInstantiable[t.params.case]);\n  });\n"],"mappings":"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"}