{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/generic.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","vertex_attr","target_stage","fragment_attr","compute_attr","code","expectCompileResult"],"mappings":"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","sourcesContent":["export const description = `Validation tests for general usage of entry point IO`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('missing_attribute_on_param')\n  .desc(`Test that an entry point without an IO attribute on one of its parameters is rejected.`)\n  .params(u =>\n    u.combine('target_stage', ['', 'vertex', 'fragment', 'compute'] as const).beginSubcases()\n  )\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n    const code = `\n@stage(vertex)\nfn vert_main(@location(0) a : f32,\n             ${vertex_attr}  b : f32,\n@             location(2) c : f32) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@stage(fragment)\nfn frag_main(@location(0)  a : f32,\n             ${fragment_attr} b : f32,\n@             location(2)  c : f32) {\n}\n\n@stage(compute) @workgroup_size(1)\nfn comp_main(@builtin(global_invocation_id) a : vec3<u32>,\n             ${compute_attr}                   b : vec3<u32>,\n             @builtin(local_invocation_id)  c : vec3<u32>) {\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_param_struct')\n  .desc(\n    `Test that an entry point struct parameter without an IO attribute on one of its members is rejected.`\n  )\n  .params(u =>\n    u.combine('target_stage', ['', 'vertex', 'fragment', 'compute'] as const).beginSubcases()\n  )\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n    const code = `\nstruct VertexInputs {\n  @location(0) a : f32,\n  ${vertex_attr}  b : f32,\n@  location(2) c : f32,\n};\nstruct FragmentInputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\nstruct ComputeInputs {\n  @builtin(global_invocation_id) a : vec3<u32>,\n  ${compute_attr}                   b : vec3<u32>,\n  @builtin(local_invocation_id)  c : vec3<u32>,\n};\n\n@stage(vertex)\nfn vert_main(inputs : VertexInputs) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@stage(fragment)\nfn frag_main(inputs : FragmentInputs) {\n}\n\n@stage(compute) @workgroup_size(1)\nfn comp_main(inputs : ComputeInputs) {\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_return_type')\n  .desc(`Test that an entry point without an IO attribute on its return type is rejected.`)\n  .params(u => u.combine('target_stage', ['', 'vertex', 'fragment'] as const).beginSubcases())\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@builtin(position)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(0)';\n    const code = `\n@stage(vertex)\nfn vert_main() -> ${vertex_attr} vec4<f32> {\n  return vec4<f32>();\n}\n\n@stage(fragment)\nfn frag_main() -> ${fragment_attr} vec4<f32> {\n  return vec4<f32>();\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('missing_attribute_on_return_type_struct')\n  .desc(\n    `Test that an entry point struct return type without an IO attribute on one of its members is rejected.`\n  )\n  .params(u => u.combine('target_stage', ['', 'vertex', 'fragment'] as const).beginSubcases())\n  .fn(t => {\n    const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n    const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n    const code = `\nstruct VertexOutputs {\n  @location(0)       a : f32,\n  ${vertex_attr}        b : f32,\n  @builtin(position) c : vec4<f32>,\n};\nstruct FragmentOutputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\n\n@stage(vertex)\nfn vert_main() -> VertexOutputs {\n  return VertexOutputs();\n}\n\n@stage(fragment)\nfn frag_main() -> FragmentOutputs {\n  return FragmentOutputs();\n}\n`;\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n"],"file":"generic.spec.js"}