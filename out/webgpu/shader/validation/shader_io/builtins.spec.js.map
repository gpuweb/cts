{"version":3,"sources":["../../../../../src/webgpu/shader/validation/shader_io/builtins.spec.ts"],"names":["description","makeTestGroup","ShaderValidationTest","generateShader","g","kBuiltins","name","stage","io","type","kTestTypes","test","desc","params","u","combineWithParams","combine","beginSubcases","fn","t","code","attribute","target_stage","target_io","use_struct","expectation","some","x","expectCompileResult","target_type","p1","first","p2","second","s1a","s1b","s2a","s2b","ra","rb","firstIsRet","secondIsRet"],"mappings":"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","sourcesContent":["export const description = `Validation tests for entry point built-in variables`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { generateShader } from './util.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// List of all built-in variables and their stage, in|out usage, and type.\n// Taken from table in Section 15:\n// https://www.w3.org/TR/2021/WD-WGSL-20211013/#builtin-variables\nexport const kBuiltins = [\n  { name: 'vertex_index', stage: 'vertex', io: 'in', type: 'u32' },\n  { name: 'instance_index', stage: 'vertex', io: 'in', type: 'u32' },\n  { name: 'position', stage: 'vertex', io: 'out', type: 'vec4<f32>' },\n  { name: 'position', stage: 'fragment', io: 'in', type: 'vec4<f32>' },\n  { name: 'front_facing', stage: 'fragment', io: 'in', type: 'bool' },\n  { name: 'local_invocation_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'local_invocation_index', stage: 'compute', io: 'in', type: 'u32' },\n  { name: 'global_invocation_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'workgroup_id', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'num_workgroups', stage: 'compute', io: 'in', type: 'vec3<u32>' },\n  { name: 'sample_index', stage: 'fragment', io: 'in', type: 'u32' },\n  { name: 'sample_mask', stage: 'fragment', io: 'in', type: 'u32' },\n  { name: 'sample_mask', stage: 'fragment', io: 'out', type: 'u32' },\n] as const;\n\n// List of types to test against.\nconst kTestTypes = [\n  'bool',\n  'u32',\n  'i32',\n  'f32',\n  'vec2<bool>',\n  'vec2<u32>',\n  'vec2<i32>',\n  'vec2<f32>',\n  'vec3<bool>',\n  'vec3<u32>',\n  'vec3<i32>',\n  'vec3<f32>',\n  'vec4<bool>',\n  'vec4<u32>',\n  'vec4<i32>',\n  'vec4<f32>',\n  'mat2x2<f32>',\n  'mat2x3<f32>',\n  'mat2x4<f32>',\n  'mat3x2<f32>',\n  'mat3x3<f32>',\n  'mat3x4<f32>',\n  'mat4x2<f32>',\n  'mat4x3<f32>',\n  'mat4x4<f32>',\n  'atomic<u32>',\n  'atomic<i32>',\n  'array<bool,4>',\n  'array<u32,4>',\n  'array<i32,4>',\n  'array<f32,4>',\n  'MyStruct',\n] as const;\n\ng.test('stage_inout')\n  .desc(\n    `Test that each @builtin]] attribute is validated against the required stage and in/out usage for that built-in variable.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .combine('target_stage', ['vertex', 'fragment', 'compute'] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = generateShader({\n      attribute: `@builtin(${t.params.name})`,\n      type: t.params.type,\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to pass iff the built-in table contains an entry that matches.\n    const expectation = kBuiltins.some(\n      x =>\n        x.name === t.params.name &&\n        x.stage === t.params.target_stage &&\n        x.io === t.params.target_io &&\n        x.type === t.params.type\n    );\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('type')\n  .desc(\n    `Test that each @builtin]] attribute is validated against the required type of that built-in variable.`\n  )\n  .params(u =>\n    u\n      .combineWithParams(kBuiltins)\n      .combine('use_struct', [true, false] as const)\n      .combine('target_type', kTestTypes)\n      .beginSubcases()\n  )\n  .fn(t => {\n    let code = '';\n\n    if (t.params.target_type === 'MyStruct') {\n      // Generate a struct that contains the correct built-in type.\n      code += 'struct MyStruct {\\n';\n      code += `  value : ${t.params.type}\\n`;\n      code += '};\\n\\n';\n    }\n\n    code += generateShader({\n      attribute: `@builtin(${t.params.name})`,\n      type: t.params.target_type,\n      stage: t.params.stage,\n      io: t.params.io,\n      use_struct: t.params.use_struct,\n    });\n\n    // Expect to pass iff the built-in table contains an entry that matches.\n    const expectation = kBuiltins.some(\n      x =>\n        x.name === t.params.name &&\n        x.stage === t.params.stage &&\n        x.io === t.params.io &&\n        x.type === t.params.target_type\n    );\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('nesting')\n  .desc(`Test validation of nested built-in variables`)\n  .params(u =>\n    u\n      .combine('target_stage', ['fragment', ''] as const)\n      .combine('target_io', ['in', 'out'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    // Generate a struct that contains a sample_mask builtin, nested inside another struct.\n    let code = `\n    struct Inner {\n      @builtin(sample_mask) value : u32\n    };\n    struct Outer {\n      inner : Inner\n    };`;\n\n    code += generateShader({\n      attribute: '',\n      type: 'Outer',\n      stage: t.params.target_stage,\n      io: t.params.target_io,\n      use_struct: false,\n    });\n\n    // Expect to pass only if the struct is not used for entry point IO.\n    t.expectCompileResult(t.params.target_stage === '', code);\n  });\n\ng.test('duplicates')\n  .desc(`Test that duplicated built-in variables are validated.`)\n  .params(u =>\n    u\n      // Place two @builtin(sample_mask) attributes onto the entry point function.\n      // We use `sample_mask` as it is valid as both an input and output for the same entry point.\n      // The function:\n      // - has two non-struct parameters (`p1` and `p2`)\n      // - has two struct parameters each with two members (`s1{a,b}` and `s2{a,b}`)\n      // - returns a struct with two members (`ra` and `rb`)\n      // By default, all of these variables will have unique @location() attributes.\n      .combine('first', ['p1', 's1a', 's2a', 'ra'] as const)\n      .combine('second', ['p2', 's1b', 's2b', 'rb'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const p1 =\n      t.params.first === 'p1' ? '@builtin(sample_mask)' : '@location(1) @interpolate(flat)';\n    const p2 =\n      t.params.second === 'p2' ? '@builtin(sample_mask)' : '@location(2) @interpolate(flat)';\n    const s1a =\n      t.params.first === 's1a' ? '@builtin(sample_mask)' : '@location(3) @interpolate(flat)';\n    const s1b =\n      t.params.second === 's1b' ? '@builtin(sample_mask)' : '@location(4) @interpolate(flat)';\n    const s2a =\n      t.params.first === 's2a' ? '@builtin(sample_mask)' : '@location(5) @interpolate(flat)';\n    const s2b =\n      t.params.second === 's2b' ? '@builtin(sample_mask)' : '@location(6) @interpolate(flat)';\n    const ra =\n      t.params.first === 'ra' ? '@builtin(sample_mask)' : '@location(1) @interpolate(flat)';\n    const rb =\n      t.params.second === 'rb' ? '@builtin(sample_mask)' : '@location(2) @interpolate(flat)';\n    const code = `\n    struct S1 {\n      ${s1a} a : u32,\n      ${s1b} b : u32,\n    };\n    struct S2 {\n      ${s2a} a : u32,\n      ${s2b} b : u32,\n    };\n    struct R {\n      ${ra} a : u32,\n      ${rb} b : u32,\n    };\n    @stage(fragment)\n    fn main(${p1} p1 : u32,\n            ${p2} p2 : u32,\n            s1 : S1,\n            s2 : S2,\n            ) -> R {\n      return R();\n    }\n    `;\n\n    // The test should fail if both @builtin(sample_mask) attributes are on the input parameters\n    // or structures, or it they are both on the output struct. Otherwise it should pass.\n    const firstIsRet = t.params.first === 'ra';\n    const secondIsRet = t.params.second === 'rb';\n    const expectation = firstIsRet !== secondIsRet;\n    t.expectCompileResult(expectation, code);\n  });\n\ng.test('missing_vertex_position')\n  .desc(`Test that vertex shaders are required to output @builtin(position).`)\n  .params(u =>\n    u\n      .combine('use_struct', [true, false] as const)\n      .combine('attribute', ['@builtin(position)', '@location(0)'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = `\n    struct S {\n      ${t.params.attribute} value : vec4<f32>\n    };\n\n    @stage(vertex)\n    fn main() -> ${t.params.use_struct ? 'S' : `${t.params.attribute} vec4<f32>`} {\n      return ${t.params.use_struct ? 'S' : 'vec4<f32>'}();\n    }\n    `;\n\n    // Expect to pass only when using @builtin(position).\n    t.expectCompileResult(t.params.attribute === '@builtin(position)', code);\n  });\n"],"file":"builtins.spec.js"}