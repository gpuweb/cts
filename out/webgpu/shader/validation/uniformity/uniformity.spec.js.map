{"version":3,"file":"uniformity.spec.js","names":["description","makeTestGroup","keysOf","unreachable","ShaderValidationTest","LoopCase","compileShouldSucceed","g","kCollectiveOps","op","stage","kConditions","cond","expectation","generateCondition","condition","generateOp","kStatementCases","name","code","verdict","kStatementNames","map","sc","kStatementDict","Object","fromEntries","generateConditionalStatement","condition_name","op_name","snippet","replace","replaceAll","test","desc","params","u","combine","beginSubcases","combineWithParams","fn","t","startsWith","skipIfLanguageFeatureNotSupported","statement","expectCompileResult","requires_uniformity","condition_is_uniform","kUniformSubgroupOps","kSubgroupOps","test_code","scope","is_uniform","includes","hasLanguageFeature","kFragmentBuiltinValues","builtin","type","beforeAllSubcases","skipIf","isCompatibility","enable","kComputeBuiltinValues","uniform","expect","generatePointerCheck","check","kPointerCases","address_uniform_literal","address_uniform_value","address_nonuniform_value","address_uniform_chain","address_nonuniform_chain1","address_nonuniform_chain2","wg_uniform_load_is_uniform","wg_uniform_load_atomic_is_uniform","contents_scalar_uniform1","contents_scalar_uniform2","contents_scalar_uniform3","contents_scalar_nonuniform1","contents_scalar_nonuniform2","contents_scalar_alias_uniform","contents_scalar_alias_nonuniform1","contents_scalar_alias_nonuniform2","contents_scalar_alias_nonuniform3","contents_scalar_alias_nonuniform4","contents_scalar_alias_nonuniform5","contents_array_uniform_index","contents_array_nonuniform_index1","contents_array_nonuniform_index2","contents_array_nonuniform_index3","contents_struct_uniform","contents_struct_nonuniform1","contents_struct_nonuniform2","contents_struct_nonuniform3","contents_struct_chain_uniform","contents_struct_chain_nonuniform1","contents_struct_chain_nonuniform2","contents_struct_chain_nonuniform3","contents_lhs_ref_pointer_deref1","contents_lhs_ref_pointer_deref1a","contents_lhs_ref_pointer_deref2","contents_lhs_ref_pointer_deref2a","contents_lhs_ref_pointer_deref3","contents_lhs_ref_pointer_deref3a","contents_lhs_ref_pointer_deref4","contents_lhs_ref_pointer_deref4a","contents_lhs_ref_pointer_deref4b","contents_lhs_ref_pointer_deref4c","contents_lhs_ref_pointer_deref4d","contents_lhs_ref_pointer_deref4e","contents_lhs_pointer_deref2","needs_deref_sugar","contents_lhs_pointer_deref2a","contents_lhs_pointer_deref3","contents_lhs_pointer_deref3a","contents_lhs_pointer_deref4","contents_lhs_pointer_deref4a","contents_lhs_pointer_deref4b","contents_lhs_pointer_deref4c","contents_lhs_pointer_deref4d","contents_lhs_pointer_deref4e","contents_rhs_pointer_deref1","contents_rhs_pointer_deref1a","contents_rhs_pointer_deref2","contents_rhs_pointer_swizzle_uniform","contents_rhs_pointer_swizzle_non_uniform","testcase","case","with_check","without_check","expectedUniformity","init","kFuncVarCases","no_assign","typename","typedecl","assignment","simple_uniform","simple_nonuniform","compound_assign_uniform","compound_assign_nonuniform","unreachable_uniform","unreachable_nonuniform","if_no_else_uniform","if_no_else_nonuniform","if_no_then_uniform","if_no_then_nonuniform","if_else_uniform","if_else_nonuniform","if_else_split","if_unreachable_else_none","if_unreachable_else_uniform","if_unreachable_else_nonuniform","if_unreachable_then_none","if_unreachable_then_uniform","if_unreachable_then_nonuniform","if_nonescaping_nonuniform","loop_body_depends_on_continuing_uniform","loop_body_depends_on_continuing_nonuniform","loop_body_uniform","loop_body_nonuniform","loop_body_nonuniform_cond","loop_unreachable_continuing","loop_continuing_from_body_uniform","loop_continuing_from_body_nonuniform","loop_continuing_from_body_split1","loop_continuing_from_body_split2","loop_continuing_from_body_split3","loop_continuing_from_body_split4","loop_continuing_from_body_split5","loop_in_loop_with_continue_uniform","loop_in_loop_with_continue_nonuniform","after_loop_with_uniform_break_uniform","after_loop_with_uniform_break_nonuniform","after_loop_with_nonuniform_break","after_loop_with_uniform_breaks","switch_uniform_case","switch_nonuniform_case","after_switch_all_uniform","after_switch_some_assign","after_switch_nonuniform","after_switch_with_break_nonuniform1","after_switch_with_break_nonuniform2","for_loop_uniform_body","for_loop_nonuniform_body","for_loop_uniform_body_no_condition","for_loop_nonuniform_body_no_condition","for_loop_uniform_increment","for_loop_nonuniform_increment","for_loop_uniform_init","for_loop_nonuniform_init","while_loop_uniform_body","while_loop_nonuniform_body","partial_assignment_uniform","partial_assignment_nonuniform","partial_assignment_all_members_uniform","partial_assignment_all_members_nonuniform","partial_assignment_single_element_struct_uniform","partial_assignment_single_element_struct_nonuniform","partial_assignment_single_element_array_uniform","partial_assignment_single_element_array_nonuniform","nested1","nested2","kVarInit","no_init","nonuniform","func_case","result","kShortCircuitExpressionCases","or_uniform_uniform","or_uniform_nonuniform","or_nonuniform_uniform","or_nonuniform_nonuniform","or_uniform_first_nonuniform","or_uniform_second_nonuniform","and_uniform_uniform","and_uniform_nonuniform","and_nonuniform_uniform","and_nonuniform_nonuniform","and_uniform_first_nonuniform","and_uniform_second_nonuniform","kPointerParamCases","pointer_uniform_passthrough_value","function","call","pointer_nonuniform_passthrough_value","pointer_store_uniform_value","pointer_store_nonuniform_value","pointer_depends_on_nonpointer_param_uniform","pointer_depends_on_nonpointer_param_nonuniform","pointer_depends_on_pointer_param_uniform","pointer_depends_on_pointer_param_nonuniform","pointer_codependent1","pointer_codependent2","pointer_codependent3","pointer_codependent4","uniform_param_uniform_assignment","uniform_param_nonuniform_assignment","nonuniform_param_uniform_assignment","nonuniform_param_nonuniform_assignment","required_uniform_success","required_uniform_failure","uniform_conditional_call_assign_uniform","uniform_conditional_call_assign_nonuniform1","uniform_conditional_call_assign_nonuniform2","nonuniform_conditional_call_assign_uniform","pointer_case","res","kExpressionCases","literal","uniform_index","nonuniform_index1","nonuniform_index2","uniform_struct","nonuniform_struct","kBinOps","plus","minus","times","div","rem","and","or","xor","shl","shr","less","lessequal","greater","greaterequal","equal","notequal","e1","e2","e","kFunctionCases","uniform_result","nonuniform_result","nonuniform_return_is_uniform_after_call","uniform_passthrough_parameter","nonuniform_passthrough_parameter","combined_parameters1","combined_parameters2","combined_parameters3","combined_parameters4","uniform_parameter_cf_after_nonuniform_expr","required_uniform_function_call_in_uniform_cf","required_uniform_function_call_in_nonuniform_cf","required_uniform_function_call_in_nonuniform_cf2","required_uniform_function_call_depends_on_uniform_param","required_uniform_function_call_depends_on_nonuniform_param","dpdx_nonuniform_result","dpdy_nonuniform_result","dpdxCoarse_nonuniform_result","dpdyCoarse_nonuniform_result","dpdxFine_nonuniform_result","dpdyFine_nonuniform_result","fwidth_nonuniform_result","fwidthCoarse_nonuniform_result","fwidthFine_nonuniform_result","textureSample_nonuniform_result","textureSampleBias_nonuniform_result","textureSampleCompare_nonuniform_result","textureDimensions_uniform_input_uniform_result","textureGather_uniform_input_uniform_result","textureGatherCompare_uniform_input_uniform_result","textureLoad_uniform_input_uniform_result","textureNumLayers_uniform_input_uniform_result","textureNumLevels_uniform_input_uniform_result","textureNumSamples_uniform_input_uniform_result","textureSampleLevel_uniform_input_uniform_result","textureSampleGrad_uniform_input_uniform_result","textureSampleCompareLevel_uniform_input_uniform_result","textureSampleBaseClampToEdge_uniform_input_uniform_result","min_uniform_input_uniform_result","value_constructor_uniform_input_uniform_result","wgsl"],"sources":["../../../../../src/webgpu/shader/validation/uniformity/uniformity.spec.ts"],"sourcesContent":["export const description = `Validation tests for uniformity analysis`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nimport { Snippet, LoopCase, compileShouldSucceed } from './snippet.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kCollectiveOps = [\n  { op: 'control_case_compute', stage: 'compute' },\n  { op: 'control_case_fragment', stage: 'fragment' },\n  { op: 'textureSample', stage: 'fragment' },\n  { op: 'textureSampleBias', stage: 'fragment' },\n  { op: 'textureSampleCompare', stage: 'fragment' },\n  { op: 'dpdx', stage: 'fragment' },\n  { op: 'dpdxCoarse', stage: 'fragment' },\n  { op: 'dpdxFine', stage: 'fragment' },\n  { op: 'dpdy', stage: 'fragment' },\n  { op: 'dpdyCoarse', stage: 'fragment' },\n  { op: 'dpdyFine', stage: 'fragment' },\n  { op: 'fwidth', stage: 'fragment' },\n  { op: 'fwidthCoarse', stage: 'fragment' },\n  { op: 'fwidthFine', stage: 'fragment' },\n  { op: 'storageBarrier', stage: 'compute' },\n  { op: 'textureBarrier', stage: 'compute' },\n  { op: 'workgroupBarrier', stage: 'compute' },\n  { op: 'workgroupUniformLoad', stage: 'compute' },\n];\n\nconst kConditions = [\n  { cond: 'uniform_storage_ro', expectation: true },\n  { cond: 'nonuniform_storage_ro', expectation: false },\n  { cond: 'nonuniform_storage_rw', expectation: false },\n  { cond: 'nonuniform_builtin', expectation: false },\n  { cond: 'uniform_literal', expectation: true },\n  { cond: 'uniform_const', expectation: true },\n  { cond: 'uniform_override', expectation: true },\n  { cond: 'uniform_let', expectation: true },\n  { cond: 'nonuniform_let', expectation: false },\n  { cond: 'uniform_or', expectation: true },\n  { cond: 'nonuniform_or1', expectation: false },\n  { cond: 'nonuniform_or2', expectation: false },\n  { cond: 'uniform_and', expectation: true },\n  { cond: 'nonuniform_and1', expectation: false },\n  { cond: 'nonuniform_and2', expectation: false },\n  { cond: 'uniform_func_var', expectation: true },\n  { cond: 'nonuniform_func_var', expectation: false },\n  { cond: 'storage_texture_ro', expectation: true },\n  { cond: 'storage_texture_rw', expectation: false },\n];\n\nfunction generateCondition(condition: string): string {\n  switch (condition) {\n    case 'uniform_storage_ro': {\n      return `ro_buffer[0] == 0`;\n    }\n    case 'nonuniform_storage_ro': {\n      return `ro_buffer[priv_var[0]] == 0`;\n    }\n    case 'nonuniform_storage_rw': {\n      return `rw_buffer[0] == 0`;\n    }\n    case 'nonuniform_builtin': {\n      return `p.x == 0`;\n    }\n    case 'uniform_literal': {\n      return `false`;\n    }\n    case 'uniform_const': {\n      return `c`;\n    }\n    case 'uniform_override': {\n      return `o == 0`;\n    }\n    case 'uniform_let': {\n      return `u_let == 0`;\n    }\n    case 'nonuniform_let': {\n      return `n_let == 0`;\n    }\n    case 'uniform_or': {\n      return `u_let == 0 || uniform_buffer.y > 1`;\n    }\n    case 'nonuniform_or1': {\n      return `u_let == 0 || n_let == 0`;\n    }\n    case 'nonuniform_or2': {\n      return `n_let == 0 || u_let == 0`;\n    }\n    case 'uniform_and': {\n      return `u_let == 0 && uniform_buffer.y > 1`;\n    }\n    case 'nonuniform_and1': {\n      return `u_let == 0 && n_let == 0`;\n    }\n    case 'nonuniform_and2': {\n      return `n_let == 0 && u_let == 0`;\n    }\n    case 'uniform_func_var': {\n      return `u_f == 0`;\n    }\n    case 'nonuniform_func_var': {\n      return `n_f == 0`;\n    }\n    case 'storage_texture_ro': {\n      return `textureLoad(ro_storage_texture, vec2()).x == 0`;\n    }\n    case 'storage_texture_rw': {\n      return `textureLoad(rw_storage_texture, vec2()).x == 0`;\n    }\n    case 'control_case': {\n      return 'true';\n    }\n    case 'subgroupAdd':\n    case 'subgroupInclusiveAdd':\n    case 'subgroupExclusiveAdd':\n    case 'subgroupMul':\n    case 'subgroupInclusiveMul':\n    case 'subgroupExclusiveMul':\n    case 'subgroupMax':\n    case 'subgroupMin':\n    case 'subgroupAnd':\n    case 'subgroupOr':\n    case 'subgroupXor':\n    case 'subgroupBroadcastFirst':\n    case 'quadSwapX':\n    case 'quadSwapY':\n    case 'quadSwapDiagonal': {\n      return `${condition}(0) == 0`;\n    }\n    case 'subgroupAll':\n    case 'subgroupAny': {\n      return `${condition}(false)`;\n    }\n    case 'subgroupBallot': {\n      return `${condition}(false).x == 0`;\n    }\n    case 'subgroupElect': {\n      return `${condition}()`;\n    }\n    case 'subgroupBroadcast':\n    case 'subgroupShuffle':\n    case 'subgroupShuffleUp':\n    case 'subgroupShuffleDown':\n    case 'subgroupShuffleXor':\n    case 'quadBroadcast': {\n      return `${condition}(0, 0) == 0`;\n    }\n    default: {\n      unreachable(`Unhandled condition`);\n    }\n  }\n}\n\nfunction generateOp(op: string): string {\n  switch (op) {\n    case 'control_case':\n    case 'control_case_compute':\n    case 'control_case_fragment': {\n      return ``;\n    }\n    case 'textureSample': {\n      return `let x = ${op}(tex, s, vec2(0,0));\\n`;\n    }\n    case 'textureSampleBias': {\n      return `let x = ${op}(tex, s, vec2(0,0), 0);\\n`;\n    }\n    case 'textureSampleCompare': {\n      return `let x = ${op}(tex_depth, s_comp, vec2(0,0), 0);\\n`;\n    }\n    case 'storageBarrier':\n    case 'textureBarrier':\n    case 'workgroupBarrier': {\n      return `${op}();\\n`;\n    }\n    case 'workgroupUniformLoad': {\n      return `let x = ${op}(&wg);`;\n    }\n    case 'dpdx':\n    case 'dpdxCoarse':\n    case 'dpdxFine':\n    case 'dpdy':\n    case 'dpdyCoarse':\n    case 'dpdyFine':\n    case 'fwidth':\n    case 'fwidthCoarse':\n    case 'fwidthFine': {\n      return `let x = ${op}(0);\\n`;\n    }\n    case 'subgroupAdd':\n    case 'subgroupInclusiveAdd':\n    case 'subgroupExclusiveAdd':\n    case 'subgroupMul':\n    case 'subgroupInclusiveMul':\n    case 'subgroupExclusiveMul':\n    case 'subgroupMax':\n    case 'subgroupMin':\n    case 'subgroupAnd':\n    case 'subgroupOr':\n    case 'subgroupXor':\n    case 'subgroupBroadcastFirst':\n    case 'quadSwapX':\n    case 'quadSwapY':\n    case 'quadSwapDiagonal':\n      return `let x = ${op}(0);\\n`;\n    case 'subgroupAll':\n    case 'subgroupAny':\n    case 'subgroupBallot':\n      return `let x = ${op}(false);\\n`;\n    case 'subgroupElect':\n      return `let x = ${op}();\\n`;\n    case 'subgroupBroadcast':\n    case 'subgroupShuffle':\n    case 'subgroupShuffleUp':\n    case 'subgroupShuffleDown':\n    case 'subgroupShuffleXor':\n    case 'quadBroadcast':\n      return `let x = ${op}(0, 0);\\n`;\n    default: {\n      unreachable(`Unhandled op`);\n    }\n  }\n}\n\nconst kStatementCases = [\n  // Basic non-loop cases.\n  {\n    name: 'if',\n    code: 'if <cond> { <op> }',\n    verdict: 'sensitive',\n  },\n  {\n    name: 'switch',\n    code: `\n          switch u32(<cond>) {\n            case 0: {\n              <op>\n            }\n            default: { }\n          }`,\n    verdict: 'sensitive',\n  },\n\n  // Loops\n\n  // loop without continuing\n  //   op before the interruption\n  LoopCase('loop-op-always-break', 'permit'),\n  LoopCase('loop-op-cond-break', 'sensitive'),\n  LoopCase('loop-op-always-return', 'permit'),\n  LoopCase('loop-op-cond-return', 'sensitive'),\n  LoopCase('loop-unif-break-op-always-continue', 'permit'),\n  LoopCase('loop-unif-break-op-cond-continue', 'sensitive'),\n\n  //   op after the interruption\n  LoopCase('loop-always-break-op', 'permit'),\n  LoopCase('loop-cond-break-op', 'sensitive'),\n  LoopCase('loop-always-return-op', 'permit'),\n  LoopCase('loop-cond-return-op', 'sensitive'),\n  LoopCase('loop-unif-break-always-continue-op', 'permit'),\n  LoopCase('loop-unif-break-cond-continue-op', 'sensitive'),\n\n  //   op after the end of the loop\n  //   Without a return, any non-uniformity introduced in the\n  //   loop is resolved by the end of the loop.\n  LoopCase('loop-always-break-end-op', 'permit'),\n  LoopCase('loop-unif-break-end-op', 'permit'),\n  LoopCase('loop-cond-break-end-op', 'permit'),\n  LoopCase('loop-always-return-end-op', 'permit'),\n  LoopCase('loop-cond-return-end-op', 'permit'), // the loop can only return\n  LoopCase('loop-unif-break-always-continue-end-op', 'permit'),\n  LoopCase('loop-unif-break-cond-continue-end-op', 'permit'),\n\n  // loop with continuing block\n  //   op before the interruption before continuing\n  LoopCase('loop-op-always-break-continuing', 'permit'),\n  LoopCase('loop-op-unif-break-continuing', 'permit'),\n  LoopCase('loop-op-cond-break-continuing', 'sensitive'),\n  LoopCase('loop-op-always-return-continuing', 'permit'),\n  LoopCase('loop-op-cond-return-continuing', 'sensitive'),\n  LoopCase('loop-unif-break-op-always-continue-continuing', 'permit'),\n  //  non re-convergence at the continuing block.\n  LoopCase('loop-unif-break-op-cond-continue-continuing', 'sensitive'),\n\n  //   op in body, interruption in continiuing\n  //     The only permitted interruption in the continuing block\n  //     is cond-break.\n  LoopCase('loop-op-continuing-cond-break', 'sensitive'),\n\n  //   interruption in body, op in continuing\n  LoopCase('loop-always-break-continuing-op', 'permit'),\n  LoopCase('loop-cond-break-continuing-op', 'sensitive'),\n  LoopCase('loop-always-return-continuing-op', 'permit'),\n  LoopCase('loop-cond-return-continuing-op', 'sensitive'),\n\n  //   op and interruption in continuing\n  LoopCase('loop-continuing-op-cond-break', 'sensitive'),\n\n  //   interruption in body, op after end\n  LoopCase('loop-always-break-continuing-end-op', 'permit'),\n  LoopCase('loop-cond-break-continuing-end-op', 'permit'),\n  LoopCase('loop-always-return-continuing-end-op', 'permit'),\n  LoopCase('loop-cond-return-continuing-end-op', 'permit'), // the looop can only return\n  LoopCase('loop-unif-break-always-continue-continuing-end-op', 'permit'),\n  LoopCase('loop-unif-break-cond-continue-continuing-end-op', 'permit'),\n\n  //   interruption in continuing, op after end\n  LoopCase('loop-continuing-cond-break-end-op', 'permit'),\n  LoopCase('loop-always-break-continuing-cond-break-end-op', 'permit'),\n  LoopCase('loop-always-return-continuing-cond-break-end-op', 'permit'),\n\n  // Unconditional for\n  //   interruption then op\n  LoopCase('for-always-break-op', 'permit'),\n  LoopCase('for-cond-break-op', 'sensitive'),\n  LoopCase('for-always-return-op', 'permit'),\n  LoopCase('for-cond-return-op', 'sensitive'),\n  LoopCase('for-unif-unif-break-always-continue-op', 'permit'),\n  LoopCase('for-unif-unif-break-cond-continue-op', 'sensitive'),\n  //   op then interruption\n  LoopCase('for-op-always-break', 'permit'),\n  LoopCase('for-op-cond-break', 'sensitive'),\n  LoopCase('for-op-always-return', 'permit'),\n  LoopCase('for-op-cond-return', 'sensitive'),\n  LoopCase('for-op-unif-break-always-continue', 'permit'),\n  LoopCase('for-op-unif-break-cond-continue', 'sensitive'),\n\n  // For with uniform condition\n  LoopCase('for-unif-op', 'permit'),\n  //   interruption, then op\n  LoopCase('for-unif-always-break-op', 'permit'),\n  LoopCase('for-unif-cond-break-op', 'sensitive'),\n  LoopCase('for-unif-always-return-op', 'permit'),\n  LoopCase('for-unif-cond-return-op', 'sensitive'),\n  LoopCase('for-unif-always-continue-op', 'permit'),\n  LoopCase('for-unif-cond-continue-op', 'sensitive'),\n  //   op, then interruption\n  LoopCase('for-unif-op-always-break', 'permit'),\n  LoopCase('for-unif-op-cond-break', 'sensitive'),\n  LoopCase('for-unif-op-always-return', 'permit'),\n  LoopCase('for-unif-op-cond-return', 'sensitive'),\n  LoopCase('for-unif-op-always-continue', 'permit'),\n  LoopCase('for-unif-op-cond-continue', 'sensitive'),\n  //   interruption, then op after loop\n  LoopCase('for-unif-end-op', 'permit'),\n  LoopCase('for-unif-always-break-end-op', 'permit'),\n  LoopCase('for-unif-cond-break-end-op', 'permit'),\n  LoopCase('for-unif-always-return-end-op', 'permit'),\n  LoopCase('for-unif-cond-return-end-op', 'sensitive'),\n  LoopCase('for-unif-always-continue-end-op', 'permit'),\n  LoopCase('for-unif-cond-continue-end-op', 'permit'),\n\n  // For with non-uniform condition\n  LoopCase('for-nonunif-op', 'forbid'),\n  //   interruption, then op\n  LoopCase('for-nonunif-always-break-op', 'permit'),\n  LoopCase('for-nonunif-cond-break-op', 'forbid'),\n  LoopCase('for-nonunif-always-return-op', 'permit'),\n  LoopCase('for-nonunif-cond-return-op', 'forbid'),\n  LoopCase('for-nonunif-always-continue-op', 'permit'),\n  LoopCase('for-nonunif-cond-continue-op', 'forbid'),\n  //   op, then interruption\n  LoopCase('for-nonunif-op-always-break', 'forbid'),\n  LoopCase('for-nonunif-op-cond-break', 'forbid'),\n  LoopCase('for-nonunif-op-always-return', 'forbid'),\n  LoopCase('for-nonunif-op-cond-return', 'forbid'),\n  LoopCase('for-nonunif-op-always-continue', 'forbid'),\n  LoopCase('for-nonunif-op-cond-continue', 'forbid'),\n  //   interruption, then op after loop\n  LoopCase('for-nonunif-end-op', 'permit'),\n  LoopCase('for-nonunif-always-break-end-op', 'permit'),\n  LoopCase('for-nonunif-cond-break-end-op', 'permit'),\n  LoopCase('for-nonunif-always-return-end-op', 'forbid'),\n  LoopCase('for-nonunif-cond-return-end-op', 'forbid'),\n  LoopCase('for-nonunif-always-continue-end-op', 'permit'),\n  LoopCase('for-nonunif-cond-continue-end-op', 'permit'),\n\n  // While with uniform condition\n  LoopCase('while-unif-op', 'permit'),\n  //   interruption, then op\n  LoopCase('while-unif-always-break-op', 'permit'),\n  LoopCase('while-unif-cond-break-op', 'sensitive'),\n  LoopCase('while-unif-always-return-op', 'permit'),\n  LoopCase('while-unif-cond-return-op', 'sensitive'),\n  LoopCase('while-unif-always-continue-op', 'permit'),\n  LoopCase('while-unif-cond-continue-op', 'sensitive'),\n  //   op, then interruption\n  LoopCase('while-unif-op-always-break', 'permit'),\n  LoopCase('while-unif-op-cond-break', 'sensitive'),\n  LoopCase('while-unif-op-always-return', 'permit'),\n  LoopCase('while-unif-op-cond-return', 'sensitive'),\n  LoopCase('while-unif-op-always-continue', 'permit'),\n  LoopCase('while-unif-op-cond-continue', 'sensitive'),\n  //   interruption, then op after loop\n  LoopCase('while-unif-end-op', 'permit'),\n  LoopCase('while-unif-always-break-end-op', 'permit'),\n  LoopCase('while-unif-cond-break-end-op', 'permit'),\n  LoopCase('while-unif-always-return-end-op', 'permit'),\n  LoopCase('while-unif-cond-return-end-op', 'sensitive'),\n  LoopCase('while-unif-always-continue-end-op', 'permit'),\n  LoopCase('while-unif-cond-continue-end-op', 'permit'),\n\n  // While with non-uniform condition\n  LoopCase('while-nonunif-op', 'forbid'),\n  //   interruption, then op\n  LoopCase('while-nonunif-always-break-op', 'permit'),\n  LoopCase('while-nonunif-cond-break-op', 'forbid'),\n  LoopCase('while-nonunif-always-return-op', 'permit'),\n  LoopCase('while-nonunif-cond-return-op', 'forbid'),\n  LoopCase('while-nonunif-always-continue-op', 'permit'),\n  LoopCase('while-nonunif-cond-continue-op', 'forbid'),\n  //   op, then interruption\n  LoopCase('while-nonunif-op-always-break', 'forbid'),\n  LoopCase('while-nonunif-op-cond-break', 'forbid'),\n  LoopCase('while-nonunif-op-always-return', 'forbid'),\n  LoopCase('while-nonunif-op-cond-return', 'forbid'),\n  LoopCase('while-nonunif-op-always-continue', 'forbid'),\n  LoopCase('while-nonunif-op-cond-continue', 'forbid'),\n  //   interruption, then op after loop\n  LoopCase('while-nonunif-end-op', 'permit'),\n  LoopCase('while-nonunif-always-break-end-op', 'permit'),\n  LoopCase('while-nonunif-cond-break-end-op', 'permit'),\n  LoopCase('while-nonunif-always-return-end-op', 'forbid'),\n  LoopCase('while-nonunif-cond-return-end-op', 'forbid'),\n  LoopCase('while-nonunif-always-continue-end-op', 'permit'),\n  LoopCase('while-nonunif-cond-continue-end-op', 'permit'),\n];\n\nconst kStatementNames = kStatementCases.map(sc => sc.name);\ntype StatementName = (typeof kStatementNames)[number];\n// Lookup table by statement name\nconst kStatementDict = Object.fromEntries(kStatementCases.map(sc => [sc.name, sc])) as Record<\n  StatementName,\n  Snippet\n>;\n\nfunction generateConditionalStatement(\n  name: StatementName,\n  condition_name: string,\n  op_name: string\n): Snippet {\n  const cond = generateCondition(condition_name);\n  const op = generateOp(op_name);\n  const snippet = kStatementDict[name];\n  let code = snippet.code;\n  code = code\n    .replace('<op>', op)\n    .replace('<cond>', cond)\n    .replaceAll('<uniform_cond>', generateCondition('uniform_storage_ro'))\n    .replaceAll('<nonuniform_cond>', generateCondition('nonuniform_storage_ro'));\n  return { name, code, verdict: snippet.verdict };\n}\n\ng.test('basics')\n  .desc(`Test collective operations in simple uniform or non-uniform control flow.`)\n  .params(u =>\n    u\n      .combine('statement', kStatementNames)\n      .beginSubcases()\n      .combineWithParams(kConditions)\n      .combineWithParams(kCollectiveOps)\n  )\n  .fn(t => {\n    if (t.params.op === 'textureBarrier' || t.params.cond.startsWith('storage_texture')) {\n      t.skipIfLanguageFeatureNotSupported('readonly_and_readwrite_storage_textures');\n    }\n\n    let code = `\n @group(0) @binding(0) var s : sampler;\n @group(0) @binding(1) var s_comp : sampler_comparison;\n @group(0) @binding(2) var tex : texture_2d<f32>;\n @group(0) @binding(3) var tex_depth : texture_depth_2d;\n\n @group(1) @binding(0) var<storage, read> ro_buffer : array<f32, 4>;\n @group(1) @binding(1) var<storage, read_write> rw_buffer : array<f32, 4>;\n @group(1) @binding(2) var<uniform> uniform_buffer : vec4<f32>;\n\n @group(2) @binding(0) var ro_storage_texture : texture_storage_2d<rgba8unorm, read>;\n @group(2) @binding(1) var rw_storage_texture : texture_storage_2d<rgba8unorm, read_write>;\n\n var<private> priv_var : array<u32, 4> = array(0,0,0,0);\n\n const c = false;\n override o : f32;\n`;\n\n    if (t.params.stage === 'compute') {\n      code += `var<workgroup> wg : f32;\\n`;\n      code += ` @workgroup_size(16, 1, 1)`;\n    }\n    code += `@${t.params.stage}`;\n    code += `\\nfn main(`;\n    if (t.params.stage === 'compute') {\n      code += `@builtin(global_invocation_id) p : vec3<u32>`;\n    } else {\n      code += `@builtin(position) p : vec4<f32>`;\n    }\n    code += `) {\n  let u_let = uniform_buffer.x;\n  let n_let = rw_buffer[0];\n  var u_f = uniform_buffer.z;\n  var n_f = rw_buffer[1];\n`;\n\n    // Simple control statement containing the op.\n    const snippet = generateConditionalStatement(t.params.statement, t.params.cond, t.params.op);\n    code += snippet.code;\n\n    code += `\\n}\\n`;\n\n    t.expectCompileResult(\n      compileShouldSucceed({\n        requires_uniformity: !t.params.op.startsWith('control_case'),\n        condition_is_uniform: t.params.expectation,\n        verdict: snippet.verdict,\n      }),\n      code\n    );\n  });\n\nconst kUniformSubgroupOps: readonly string[] = [\n  'subgroupAdd',\n  'subgroupMul',\n  'subgroupMax',\n  'subgroupMin',\n  'subgroupAll',\n  'subgroupAny',\n  'subgroupAnd',\n  'subgroupOr',\n  'subgroupXor',\n  'subgroupBallot',\n  'subgroupBroadcast',\n  'subgroupBroadcastFirst',\n] as const;\n\nconst kSubgroupOps: readonly string[] = [\n  'control_case',\n  'subgroupInclusiveAdd',\n  'subgroupExclusiveAdd',\n  'subgroupInclusiveMul',\n  'subgroupExclusiveMul',\n  'subgroupElect',\n  'subgroupShuffle',\n  'subgroupShuffleUp',\n  'subgroupShuffleDown',\n  'subgroupShuffleXor',\n  'quadBroadcast',\n  'quadSwapX',\n  'quadSwapY',\n  'quadSwapDiagonal',\n  ...kUniformSubgroupOps,\n] as const;\n\ng.test('basics,subgroups')\n  .desc(`Test subgroup operations in simple uniform or non-uniform control flow.`)\n  .params(u =>\n    u\n      .combine('statement', kStatementNames)\n      .beginSubcases()\n      .combineWithParams(kConditions)\n      .combine('op', kSubgroupOps)\n      .combine('stage', ['compute', 'fragment'] as const)\n  )\n  .fn(t => {\n    let code = `\n enable subgroups;\n\n @group(0) @binding(0) var s : sampler;\n @group(0) @binding(1) var s_comp : sampler_comparison;\n @group(0) @binding(2) var tex : texture_2d<f32>;\n @group(0) @binding(3) var tex_depth : texture_depth_2d;\n\n @group(1) @binding(0) var<storage, read> ro_buffer : array<f32, 4>;\n @group(1) @binding(1) var<storage, read_write> rw_buffer : array<f32, 4>;\n @group(1) @binding(2) var<uniform> uniform_buffer : vec4<f32>;\n\n @group(2) @binding(0) var ro_storage_texture : texture_storage_2d<rgba8unorm, read>;\n @group(2) @binding(1) var rw_storage_texture : texture_storage_2d<rgba8unorm, read_write>;\n\n var<private> priv_var : array<u32, 4> = array(0,0,0,0);\n\n const c = false;\n override o : f32;\n`;\n\n    if (t.params.stage === 'compute') {\n      code += `var<workgroup> wg : f32;\\n`;\n      code += ` @workgroup_size(16, 1, 1)`;\n    }\n    code += `@${t.params.stage}`;\n    code += `\\nfn main(`;\n    if (t.params.stage === 'compute') {\n      code += `@builtin(global_invocation_id) p : vec3<u32>`;\n    } else {\n      code += `@builtin(position) p : vec4<f32>`;\n    }\n    code += `) {\n      let u_let = uniform_buffer.x;\n      let n_let = rw_buffer[0];\n      var u_f = uniform_buffer.z;\n      var n_f = rw_buffer[1];\n    `;\n\n    // Simple control statement containing the op.\n    const snippet = generateConditionalStatement(t.params.statement, t.params.cond, t.params.op);\n    code += snippet.code;\n\n    code += `\\n}\\n`;\n\n    t.expectCompileResult(\n      compileShouldSucceed({\n        requires_uniformity: !t.params.op.startsWith('control_case'),\n        condition_is_uniform: t.params.expectation,\n        verdict: snippet.verdict,\n      }),\n      code\n    );\n  });\n\ng.test('uniform_subgroup_ops')\n  .desc(`Test subgroup operations that are uniform with subgroup uniformity.`)\n  .params(u => u.combine('op', kSubgroupOps).combine('scope', ['workgroup', 'subgroup'] as const))\n  .fn(t => {\n    const test_code =\n      t.params.scope === 'workgroup' ? 'workgroupBarrier();' : '_ = subgroupAny(true);';\n    const code = `\nenable subgroups;\nfn foo() {\n  if ${generateCondition(t.params.op)} {\n    ${test_code}\n  }\n}`;\n\n    const is_uniform =\n      kUniformSubgroupOps.includes(t.params.op) &&\n      t.hasLanguageFeature('subgroup_uniformity') &&\n      t.params.scope === 'subgroup';\n    t.expectCompileResult(\n      compileShouldSucceed({\n        requires_uniformity: !t.params.op.startsWith('control_case'),\n        condition_is_uniform: is_uniform,\n        verdict: 'sensitive',\n      }),\n      code\n    );\n  });\n\nconst kFragmentBuiltinValues = [\n  {\n    builtin: `position`,\n    type: `vec4<f32>`,\n  },\n  {\n    builtin: `front_facing`,\n    type: `bool`,\n  },\n  {\n    builtin: `sample_index`,\n    type: `u32`,\n  },\n  {\n    builtin: `sample_mask`,\n    type: `u32`,\n  },\n  {\n    builtin: `subgroup_invocation_id`,\n    type: `u32`,\n  },\n  {\n    builtin: `subgroup_size`,\n    type: `u32`,\n  },\n  {\n    builtin: `primitive_id`,\n    type: `u32`,\n  },\n];\n\ng.test('fragment_builtin_values')\n  .desc(`Test uniformity of fragment built-in values`)\n  .params(u => u.combineWithParams(kFragmentBuiltinValues).beginSubcases())\n  .beforeAllSubcases(t => {\n    t.skipIf(\n      t.isCompatibility && ['sample_index', 'sample_mask'].includes(t.params.builtin),\n      'compatibility mode does not support sample_index or sample_mask'\n    );\n  })\n  .fn(t => {\n    let cond = ``;\n    switch (t.params.type) {\n      case `u32`:\n      case `i32`:\n      case `f32`: {\n        cond = `p > 0`;\n        break;\n      }\n      case `vec4<u32>`:\n      case `vec4<i32>`:\n      case `vec4<f32>`: {\n        cond = `p.x > 0`;\n        break;\n      }\n      case `bool`: {\n        cond = `p`;\n        break;\n      }\n      default: {\n        unreachable(`Unhandled type`);\n      }\n    }\n    let enable = '';\n    if (t.params.builtin.includes('subgroup')) {\n      enable = 'enable subgroups;\\n';\n    } else if (t.params.builtin === 'primitive_id') {\n      enable = 'enable chromium_experimental_primitive_id;\\n';\n    }\n\n    const code = `\n${enable}\n@group(0) @binding(0) var s : sampler;\n@group(0) @binding(1) var tex : texture_2d<f32>;\n\n@fragment\nfn main(@builtin(${t.params.builtin}) p : ${t.params.type}) {\n  if ${cond} {\n    let texel = textureSample(tex, s, vec2<f32>(0,0));\n  }\n}\n`;\n\n    t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    t.expectCompileResult(false, code);\n  });\n\nconst kComputeBuiltinValues = [\n  {\n    builtin: `local_invocation_id`,\n    type: `vec3<f32>`,\n    uniform: false,\n  },\n  {\n    builtin: `local_invocation_index`,\n    type: `u32`,\n    uniform: false,\n  },\n  {\n    builtin: `global_invocation_id`,\n    type: `vec3<u32>`,\n    uniform: false,\n  },\n  {\n    builtin: `workgroup_id`,\n    type: `vec3<u32>`,\n    uniform: true,\n  },\n  {\n    builtin: `num_workgroups`,\n    type: `vec3<u32>`,\n    uniform: true,\n  },\n  {\n    builtin: `subgroup_invocation_id`,\n    type: `u32`,\n    uniform: false,\n  },\n  {\n    builtin: `subgroup_size`,\n    type: `u32`,\n    uniform: true,\n  },\n  {\n    builtin: `subgroup_id`,\n    type: `u32`,\n    uniform: false,\n  },\n  {\n    builtin: `num_subgroups`,\n    type: `u32`,\n    uniform: true,\n  },\n];\n\ng.test('compute_builtin_values')\n  .desc(`Test uniformity of compute built-in values`)\n  .params(u =>\n    u\n      .combineWithParams(kComputeBuiltinValues)\n      .beginSubcases()\n      .combine('scope', ['workgroup', 'subgroup'] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.builtin === `subgroup_id` || t.params.builtin === `num_subgroups`) {\n      t.skipIfLanguageFeatureNotSupported('subgroup_id');\n    }\n    if (t.params.scope === 'subgroup') {\n      t.skipIfLanguageFeatureNotSupported('subgroup_uniformity');\n    }\n  })\n  .fn(t => {\n    let cond = ``;\n    switch (t.params.type) {\n      case `u32`:\n      case `i32`:\n      case `f32`: {\n        cond = `p > 0`;\n        break;\n      }\n      case `vec3<u32>`:\n      case `vec3<i32>`:\n      case `vec3<f32>`: {\n        cond = `p.x > 0`;\n        break;\n      }\n      case `bool`: {\n        cond = `p`;\n        break;\n      }\n      default: {\n        unreachable(`Unhandled type`);\n      }\n    }\n    const enable =\n      t.params.builtin.includes('subgroup') || t.params.scope === 'subgroup'\n        ? 'enable subgroups;'\n        : '';\n    const op = t.params.scope === 'workgroup' ? 'workgroupBarrier()' : '_ = subgroupAny(true)';\n    const code = `\n${enable}\n@compute @workgroup_size(16,1,1)\nfn main(@builtin(${t.params.builtin}) p : ${t.params.type}) {\n  if ${cond} {\n    ${op};\n  }\n}\n`;\n\n    const expect =\n      t.params.uniform || (t.params.builtin === 'subgroup_id' && t.params.scope === 'subgroup');\n    t.expectCompileResult(expect, code);\n  });\n\nfunction generatePointerCheck(check: string): string {\n  if (check === `address`) {\n    return `let tmp = workgroupUniformLoad(ptr);`;\n  } else {\n    // check === `contents`\n    return `if test_val > 0 {\n      workgroupBarrier();\n    }`;\n  }\n}\n\ninterface PointerCase {\n  code: string;\n  check: 'address' | 'contents';\n  uniform: boolean | 'never';\n  needs_deref_sugar?: boolean;\n}\n\nconst kPointerCases: Record<string, PointerCase> = {\n  address_uniform_literal: {\n    code: `let ptr = &wg_array[0];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_uniform_value: {\n    code: `let ptr = &wg_array[uniform_value];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_nonuniform_value: {\n    code: `let ptr = &wg_array[nonuniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  address_uniform_chain: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[uniform_value];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_nonuniform_chain1: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[nonuniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[uniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  address_nonuniform_chain2: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[nonuniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  wg_uniform_load_is_uniform: {\n    code: `let test_val = workgroupUniformLoad(&wg_scalar);`,\n    check: `contents`,\n    uniform: true,\n  },\n  wg_uniform_load_atomic_is_uniform: {\n    code: `let ptr = &wg_atomic;`,\n    check: `address`,\n    uniform: true,\n  },\n  contents_scalar_uniform1: {\n    code: `let ptr = &func_scalar;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_uniform2: {\n    code: `func_scalar = nonuniform_value;\n    let ptr = &func_scalar;\n    func_scalar = 0;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_uniform3: {\n    code: `let ptr = &func_scalar;\n    func_scalar = nonuniform_value;\n    func_scalar = uniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_nonuniform1: {\n    code: `func_scalar = nonuniform_value;\n    let ptr = &func_scalar;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_nonuniform2: {\n    code: `let ptr = &func_scalar;\n    *ptr = nonuniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_uniform: {\n    code: `let p = &func_scalar;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_alias_nonuniform1: {\n    code: `func_scalar = nonuniform_value;\n    let p = &func_scalar;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform2: {\n    code: `let p = &func_scalar;\n    *p = nonuniform_value;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform3: {\n    code: `let p = &func_scalar;\n    let ptr = p;\n    *p = nonuniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform4: {\n    code: `let p = &func_scalar;\n    func_scalar = nonuniform_value;\n    let test_val = *p;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform5: {\n    code: `let p = &func_scalar;\n    *p = nonuniform_value;\n    let test_val = func_scalar;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_uniform_index: {\n    code: `let ptr = &func_array[uniform_value];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_array_nonuniform_index1: {\n    code: `let ptr = &func_array[nonuniform_value];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_nonuniform_index2: {\n    code: `let ptr = &func_array[lid.x];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_nonuniform_index3: {\n    code: `let ptr = &func_array[gid.x];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_uniform: {\n    code: `let p1 = &func_struct.x[uniform_value].x[uniform_value].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_struct_nonuniform1: {\n    code: `let p1 = &func_struct.x[nonuniform_value].x[uniform_value].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_nonuniform2: {\n    code: `let p1 = &func_struct.x[uniform_value].x[gid.x].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_nonuniform3: {\n    code: `let p1 = &func_struct.x[uniform_value].x[uniform_value].x[lid.y];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_uniform: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_struct_chain_nonuniform1: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[nonuniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_nonuniform2: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[gid.x];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_nonuniform3: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[lid.y];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref1: {\n    code: `*&func_scalar = uniform_value;\n    let test_val = func_scalar;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_lhs_ref_pointer_deref1a: {\n    code: `*&func_scalar = nonuniform_value;\n    let test_val = func_scalar;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref2: {\n    code: `*&(func_array[nonuniform_value]) = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref2a: {\n    code: `(func_array[nonuniform_value]) = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref3: {\n    code: `*&(func_array[needs_uniform(uniform_value)]) = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_lhs_ref_pointer_deref3a: {\n    code: `*&(func_array[needs_uniform(nonuniform_value)]) = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: 'never',\n  },\n  contents_lhs_ref_pointer_deref4: {\n    code: `*&((*&(func_struct.x[uniform_value])).x[uniform_value].x[uniform_value]) = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_lhs_ref_pointer_deref4a: {\n    code: `*&((*&(func_struct.x[uniform_value])).x[uniform_value].x[uniform_value]) = nonuniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref4b: {\n    code: `*&((*&(func_struct.x[uniform_value])).x[uniform_value].x[nonuniform_value]) = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref4c: {\n    code: `*&((*&(func_struct.x[uniform_value])).x[nonuniform_value]).x[uniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref4d: {\n    code: `*&((*&(func_struct.x[nonuniform_value])).x[uniform_value].x)[uniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_lhs_ref_pointer_deref4e: {\n    code: `*&((*&(func_struct.x[uniform_value])).x[needs_uniform(nonuniform_value)].x[uniform_value]) = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: 'never',\n  },\n\n  // The following cases require the 'pointer_composite_access' language feature.\n  contents_lhs_pointer_deref2: {\n    code: `(&func_array)[uniform_value] = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: true,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref2a: {\n    code: `(&func_array)[nonuniform_value] = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref3: {\n    code: `(&func_array)[needs_uniform(uniform_value)] = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: true,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref3a: {\n    code: `(&func_array)[needs_uniform(nonuniform_value)] = uniform_value;\n    let test_val = func_array[0];`,\n    check: `contents`,\n    uniform: 'never',\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4: {\n    code: `(&((&(func_struct.x[uniform_value])).x[uniform_value]).x)[uniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: true,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4a: {\n    code: `(&((&(func_struct.x[uniform_value])).x[uniform_value]).x)[uniform_value] = nonuniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4b: {\n    code: `(&((&(func_struct.x[uniform_value])).x)[uniform_value]).x[nonuniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4c: {\n    code: `(&((&(func_struct.x[uniform_value])).x[nonuniform_value]).x)[uniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4d: {\n    code: `(&((&(func_struct.x[nonuniform_value])).x[uniform_value]).x)[uniform_value] = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_lhs_pointer_deref4e: {\n    code: `(&((&(func_struct.x[uniform_value])).x)[needs_uniform(nonuniform_value)].x[uniform_value]) = uniform_value;\n    let test_val = func_struct.x[0].x[0].x[0];`,\n    check: `contents`,\n    uniform: 'never',\n    needs_deref_sugar: true,\n  },\n  contents_rhs_pointer_deref1: {\n    code: `let test_val = (&func_array)[uniform_value];`,\n    check: `contents`,\n    uniform: true,\n    needs_deref_sugar: true,\n  },\n  contents_rhs_pointer_deref1a: {\n    code: `let test_val = (&func_array)[nonuniform_value];`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n  contents_rhs_pointer_deref2: {\n    code: `let test_val = (&func_array)[needs_uniform(nonuniform_value)];`,\n    check: `contents`,\n    uniform: `never`,\n    needs_deref_sugar: true,\n  },\n  contents_rhs_pointer_swizzle_uniform: {\n    code: `func_vector = vec4(uniform_value);\n    let test_val = dot((&func_vector).yw, vec2());`,\n    check: `contents`,\n    uniform: true,\n    needs_deref_sugar: true,\n  },\n  contents_rhs_pointer_swizzle_non_uniform: {\n    code: `func_vector = vec4(nonuniform_value);\n    let test_val = dot((&func_vector).yw, vec2());`,\n    check: `contents`,\n    uniform: false,\n    needs_deref_sugar: true,\n  },\n};\n\ng.test('pointers')\n  .desc(`Test pointer uniformity (contents and addresses)`)\n  .params(u => u.combine('case', keysOf(kPointerCases)).beginSubcases())\n  .fn(t => {\n    const testcase = kPointerCases[t.params.case];\n    const code = `\nvar<workgroup> wg_scalar : u32;\nvar<workgroup> wg_array : array<u32, 16>;\nvar<workgroup> wg_atomic : atomic<u32>;\n\nstruct Inner {\n  x : array<u32, 4>\n}\nstruct Middle {\n  x : array<Inner, 4>\n}\nstruct Outer {\n  x : array<Middle, 4>\n}\nvar<workgroup> wg_struct : Outer;\n\n@group(0) @binding(0)\nvar<storage> uniform_value : u32;\n@group(0) @binding(1)\nvar<storage, read_write> nonuniform_value : u32;\n\nfn needs_uniform(val : u32) -> u32{\n  if val == 0 {\n    workgroupBarrier();\n  }\n  return val;\n}\n\n@compute @workgroup_size(16, 1, 1)\nfn main(@builtin(local_invocation_id) lid : vec3<u32>,\n        @builtin(global_invocation_id) gid : vec3<u32>) {\n  var func_scalar : u32;\n  var func_vector : vec4u;\n  var func_array : array<u32, 16>;\n  var func_struct : Outer;\n\n  ${testcase.code}\n`;\n\n    const with_check =\n      code +\n      `\n${generatePointerCheck(testcase.check)}\n}`;\n\n    if (testcase.needs_deref_sugar === true) {\n      t.skipIfLanguageFeatureNotSupported('pointer_composite_access');\n    }\n    // Explicitly check false to distinguish from never.\n    if (testcase.uniform === false) {\n      const without_check = code + `}\\n`;\n      t.expectCompileResult(true, without_check);\n    }\n    t.expectCompileResult(testcase.uniform === true, with_check);\n  });\n\nfunction expectedUniformity(uniform: string, init: string): boolean {\n  if (uniform === `always`) {\n    return true;\n  } else if (uniform === `init`) {\n    return init === `no_init` || init === `uniform`;\n  }\n\n  // uniform == `never` (or unknown values)\n  return false;\n}\n\nconst kFuncVarCases = {\n  no_assign: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: ``,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  simple_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x = uniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  simple_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x = nonuniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  compound_assign_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x += uniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  compound_assign_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x -= nonuniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  unreachable_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  unreachable_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_no_then_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_then_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      x = uniform_value[1];\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    } else {\n      x = nonuniform_value[1];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_else_split: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_unreachable_else_none: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_unreachable_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_unreachable_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_unreachable_then_none: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_unreachable_then_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    } else {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_unreachable_then_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_nonescaping_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  loop_body_depends_on_continuing_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if x > 0 {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n      continuing {\n        x = uniform_value[0];\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `init`,\n  },\n  loop_body_depends_on_continuing_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if x > 0 {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n      continuing {\n        x = nonuniform_value[0];\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_body_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = uniform_value[0];\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  loop_body_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = nonuniform_value[0];\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  loop_body_nonuniform_cond: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      // The analysis doesn't recognize the content of the value.\n      x = uniform_value[0];\n      continuing {\n        break if nonuniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  loop_unreachable_continuing: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  loop_continuing_from_body_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = uniform_value[0];\n      continuing  {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_continuing_from_body_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = nonuniform_value[0];\n      continuing  {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split1: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `init`,\n  },\n  loop_continuing_from_body_split2: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = nonuniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split3: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[1];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_continuing_from_body_split4: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[1];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split5: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    // The analysis doesn't recognize that uniform_value[0] is assignment on all paths.\n    uniform: `never`,\n  },\n  loop_in_loop_with_continue_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      loop {\n        x = nonuniform_value[0];\n        if nonuniform_cond {\n          break;\n        }\n        continue;\n      }\n      x = uniform_value[0];\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_in_loop_with_continue_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      loop {\n        x = uniform_value[0];\n        if uniform_cond {\n          break;\n        }\n        continue;\n      }\n      x = nonuniform_value[0];\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  after_loop_with_uniform_break_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  after_loop_with_uniform_break_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = nonuniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_loop_with_nonuniform_break: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_loop_with_uniform_breaks: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n      } else {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  switch_uniform_case: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n      }\n      default {\n      }\n    }`,\n    cond: `true`, // override default check\n    uniform: `init`,\n  },\n  switch_nonuniform_case: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch nonuniform_val {\n      case 0 {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n      }\n      default {\n      }\n    }`,\n    cond: `true`, // override default check\n    uniform: `never`,\n  },\n  after_switch_all_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n        x = uniform_value[2];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  after_switch_some_assign: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  after_switch_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n        x = nonuniform_value[0];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_switch_with_break_nonuniform1: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      default {\n        if uniform_cond {\n          x = uniform_value[0];\n          break;\n        }\n        x = nonuniform_value[0];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_switch_with_break_nonuniform2: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      default {\n        x = uniform_value[0];\n        if uniform_cond {\n          x = nonuniform_value[0];\n          break;\n        }\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; i < 10; i += 1) {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  for_loop_nonuniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; i < 10; i += 1) {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_body_no_condition: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; ; i += 1) {\n      x = uniform_value[0];\n      if uniform_cond {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  for_loop_nonuniform_body_no_condition: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; ; i += 1) {\n      x = nonuniform_value[0];\n      if uniform_cond {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_increment: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (; uniform_cond; x += uniform_value[0]) {\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  for_loop_nonuniform_increment: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (; uniform_cond; x += nonuniform_value[0]) {\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_init: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (x = uniform_value[0]; uniform_cond; ) {\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  for_loop_nonuniform_init: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (x = nonuniform_value[0]; uniform_cond;) {\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  while_loop_uniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `while uniform_cond {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  while_loop_nonuniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `while uniform_cond {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_all_members_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;\n    x.y = uniform_value[1].y;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_all_members_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;\n    x.y = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_single_element_struct_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_single_element_struct_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_single_element_array_uniform: {\n    typename: `array<u32, 1>`,\n    typedecl: ``,\n    assignment: `x[0] = uniform_value[0][0];`,\n    cond: `x[0] > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_single_element_array_nonuniform: {\n    typename: `array<u32, 1>`,\n    typedecl: ``,\n    assignment: `x[0] = nonuniform_value[0][0];`,\n    cond: `x[0] > 0`,\n    uniform: `never`,\n  },\n  nested1: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `for (; uniform_cond; ) {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n        x.y = nonuniform_value[0].y;\n      } else {\n        if uniform_cond {\n          continue;\n        }\n        x = uniform_value[1];\n      }\n    }`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  nested2: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `for (; uniform_cond; ) {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n        x.y = nonuniform_value[0].y;\n      } else {\n        if nonuniform_cond {\n          continue;\n        }\n        x = uniform_value[1];\n      }\n    }`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n};\n\nconst kVarInit = {\n  no_init: ``,\n  uniform: `= uniform_value[3];`,\n  nonuniform: `= nonuniform_value[3];`,\n};\n\ng.test('function_variables')\n  .desc(`Test uniformity of function variables`)\n  .params(u => u.combine('case', keysOf(kFuncVarCases)).combine('init', keysOf(kVarInit)))\n  .fn(t => {\n    const func_case = kFuncVarCases[t.params.case];\n    const code = `\n${func_case.typedecl}\n\n@group(0) @binding(0)\nvar<storage> uniform_value : array<${func_case.typename}, 4>;\n@group(0) @binding(1)\nvar<storage, read_write> nonuniform_value : array<${func_case.typename}, 4>;\n\n@group(1) @binding(0)\nvar t : texture_2d<f32>;\n@group(1) @binding(1)\nvar s : sampler;\n\nvar<private> nonuniform_cond : bool = true;\nconst uniform_cond : bool = true;\nvar<private> nonuniform_val : u32 = 0;\nconst uniform_val : u32 = 0;\n\n@fragment\nfn main() {\n  var x : ${func_case.typename} ${kVarInit[t.params.init]};\n\n  ${func_case.assignment}\n\n  if ${func_case.cond} {\n    let tmp = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const result = expectedUniformity(func_case.uniform, t.params.init);\n    if (!result) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(result, code);\n  });\n\nconst kShortCircuitExpressionCases = {\n  or_uniform_uniform: {\n    code: `\n      let x = uniform_cond || uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: true,\n  },\n  or_uniform_nonuniform: {\n    code: `\n      let x = uniform_cond || nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_nonuniform_uniform: {\n    code: `\n      let x = nonuniform_cond || uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_nonuniform_nonuniform: {\n    code: `\n      let x = nonuniform_cond || nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_uniform_first_nonuniform: {\n    code: `\n      let x = textureSample(t, s, vec2f(0,0)).x == 0 || nonuniform_cond;\n    `,\n    uniform: true,\n  },\n  or_uniform_second_nonuniform: {\n    code: `\n      let x = nonuniform_cond || textureSample(t, s, vec2f(0,0)).x == 0;\n    `,\n    uniform: false,\n  },\n  and_uniform_uniform: {\n    code: `\n      let x = uniform_cond && uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: true,\n  },\n  and_uniform_nonuniform: {\n    code: `\n      let x = uniform_cond && nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_nonuniform_uniform: {\n    code: `\n      let x = nonuniform_cond && uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_nonuniform_nonuniform: {\n    code: `\n      let x = nonuniform_cond && nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_uniform_first_nonuniform: {\n    code: `\n      let x = textureSample(t, s, vec2f(0,0)).x == 0 && nonuniform_cond;\n    `,\n    uniform: true,\n  },\n  and_uniform_second_nonuniform: {\n    code: `\n      let x = nonuniform_cond && textureSample(t, s, vec2f(0,0)).x == 0;\n    `,\n    uniform: false,\n  },\n};\n\nconst kPointerParamCases = {\n  pointer_uniform_passthrough_value: {\n    function: `fn foo(p : ptr<function, u32>) -> u32 {\n      return *p;\n    }`,\n    call: `var x = uniform_values[0];\n    let call = foo(&x);`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  pointer_nonuniform_passthrough_value: {\n    function: `fn foo(p : ptr<function, u32>) -> u32 {\n      return *p;\n    }`,\n    call: `var x = uniform_values[0];\n    let call = foo(&x);`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  pointer_store_uniform_value: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = uniform_values[0];\n    }`,\n    call: `var x = nonuniform_values[0];\n    foo(&x);`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  pointer_store_nonuniform_value: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = nonuniform_values[0];\n    }`,\n    call: `var x = uniform_values[0];\n    foo(&x);`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n  pointer_depends_on_nonpointer_param_uniform: {\n    function: `fn foo(p : ptr<function, u32>, x : u32) {\n      *p = x;\n    }`,\n    call: `var x = nonuniform_values[0];\n    foo(&x, uniform_values[0]);`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  pointer_depends_on_nonpointer_param_nonuniform: {\n    function: `fn foo(p : ptr<function, u32>, x : u32) {\n      *p = x;\n    }`,\n    call: `var x = uniform_values[0];\n    foo(&x, nonuniform_values[0]);`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n  pointer_depends_on_pointer_param_uniform: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      *p = *q;\n    }`,\n    call: `var x = nonuniform_values[0];\n    var y = uniform_values[0];\n    foo(&x, &y);`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  pointer_depends_on_pointer_param_nonuniform: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      *p = *q;\n    }`,\n    call: `var x = uniform_values[0];\n    var y = nonuniform_values[0];\n    foo(&x, &y);`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n  pointer_codependent1: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      if *p > 0 {\n        *p = *q;\n      } else {\n        *q++;\n      }\n    }`,\n    call: `var x = uniform_values[0];\n    var y = uniform_values[1];\n    foo(&x, &y);\n    let a = x + y;`,\n    cond: `a > 0`,\n    uniform: true,\n  },\n  pointer_codependent2: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      if *p > 0 {\n        *p = *q;\n      } else {\n        *q++;\n      }\n    }`,\n    call: `var x = uniform_values[0];\n    var y = nonuniform_values[1];\n    foo(&x, &y);\n    let a = x + y;`,\n    cond: `a > 0`,\n    uniform: false,\n  },\n  pointer_codependent3: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      if *p > 0 {\n        *p = *q;\n      } else {\n        *q++;\n      }\n    }`,\n    call: `var x = nonuniform_values[0];\n    var y = uniform_values[1];\n    foo(&x, &y);\n    let a = x + y;`,\n    cond: `a > 0`,\n    uniform: false,\n  },\n  pointer_codependent4: {\n    function: `fn foo(p : ptr<function, u32>, q : ptr<function, u32>) {\n      if *p > 0 {\n        *p = *q;\n      } else {\n        *q++;\n      }\n    }`,\n    call: `var x = nonuniform_values[0];\n    var y = nonuniform_values[1];\n    foo(&x, &y);\n    let a = x + y;`,\n    cond: `a > 0`,\n    uniform: false,\n  },\n  uniform_param_uniform_assignment: {\n    function: `fn foo(p : ptr<function, array<u32, 2>>, idx : u32) {\n      (*p)[idx] = uniform_values[0];\n    }`,\n    call: `var x = array(uniform_values[0], uniform_values[1]);\n    foo(&x, uniform_values[3]);`,\n    cond: `x[0] > 0`,\n    uniform: true,\n  },\n  uniform_param_nonuniform_assignment: {\n    function: `fn foo(p : ptr<function, array<u32, 2>>, idx : u32) {\n      (*p)[idx] = nonuniform_values[0];\n    }`,\n    call: `var x = array(uniform_values[0], uniform_values[1]);\n    foo(&x, uniform_values[3]);`,\n    cond: `x[0] > 0`,\n    uniform: false,\n  },\n  nonuniform_param_uniform_assignment: {\n    function: `fn foo(p : ptr<function, array<u32, 2>>, idx : u32) {\n      (*p)[idx] = uniform_values[0];\n    }`,\n    call: `var x = array(uniform_values[0], uniform_values[1]);\n    foo(&x, u32(clamp(pos.x, 0, 1)));`,\n    cond: `x[0] > 0`,\n    uniform: false,\n  },\n  nonuniform_param_nonuniform_assignment: {\n    function: `fn foo(p : ptr<function, array<u32, 2>>, idx : u32) {\n      (*p)[idx] = nonuniform_values[0];\n    }`,\n    call: `var x = array(uniform_values[0], uniform_values[1]);\n    foo(&x, u32(clamp(pos.x, 0, 1)));`,\n    cond: `x[0] > 0`,\n    uniform: false,\n  },\n  required_uniform_success: {\n    function: `fn foo(p : ptr<function, u32>) {\n      if *p > 0 {\n        let tmp = textureSample(t,s,vec2f(0,0));\n      }\n    }`,\n    call: `var x = uniform_values[0];\n    foo(&x);`,\n    cond: `uniform_cond`,\n    uniform: true,\n  },\n  required_uniform_failure: {\n    function: `fn foo(p : ptr<function, u32>) {\n      if *p > 0 {\n        let tmp = textureSample(t,s,vec2f(0,0));\n      }\n    }`,\n    call: `var x = nonuniform_values[0];\n    foo(&x);`,\n    cond: `uniform_cond`,\n    uniform: false,\n  },\n  uniform_conditional_call_assign_uniform: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = uniform_values[0];\n    }`,\n    call: `var x = uniform_values[1];\n    if uniform_cond {\n      foo(&x);\n    }`,\n    cond: `x > 0`,\n    uniform: true,\n  },\n  uniform_conditional_call_assign_nonuniform1: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = nonuniform_values[0];\n    }`,\n    call: `var x = uniform_values[1];\n    if uniform_cond {\n      foo(&x);\n    }`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n  uniform_conditional_call_assign_nonuniform2: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = uniform_values[0];\n    }`,\n    call: `var x = nonuniform_values[1];\n    if uniform_cond {\n      foo(&x);\n    }`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n  nonuniform_conditional_call_assign_uniform: {\n    function: `fn foo(p : ptr<function, u32>) {\n      *p = uniform_values[0];\n    }`,\n    call: `var x = uniform_values[1];\n    if nonuniform_cond {\n      foo(&x);\n    }`,\n    cond: `x > 0`,\n    uniform: false,\n  },\n};\n\ng.test('function_pointer_parameters')\n  .desc(`Test functions and calls with pointer parameters`)\n  .params(u => u.combine('case', keysOf(kPointerParamCases)))\n  .fn(t => {\n    const pointer_case = kPointerParamCases[t.params.case];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n\nconst uniform_cond = true;\nvar<private> nonuniform_cond = true;\n\n@group(1) @binding(0)\nvar<storage> uniform_values : array<u32, 4>;\n@group(1) @binding(1)\nvar<storage, read_write> nonuniform_values : array<u32, 4>;\n\n${pointer_case.function}\n\n@fragment\nfn main(@builtin(position) pos : vec4f) {\n  ${pointer_case.call}\n\n  if ${pointer_case.cond} {\n    let tmp = textureSample(t,s,vec2f(0,0));\n  }\n}\n`;\n\n    const res = pointer_case.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\ng.test('short_circuit_expressions')\n  .desc(`Test uniformity of expressions`)\n  .params(u => u.combine('case', keysOf(kShortCircuitExpressionCases)))\n  .fn(t => {\n    const testcase = kShortCircuitExpressionCases[t.params.case];\n    const code = `\n@group(1) @binding(0)\nvar t : texture_2d<f32>;\n@group(1) @binding(1)\nvar s : sampler;\n\nconst uniform_cond = true;\nvar<private> nonuniform_cond = false;\n\n@fragment\nfn main() {\n  ${testcase.code}\n}\n`;\n\n    const res = testcase.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\nconst kExpressionCases = {\n  literal: {\n    code: `1u`,\n    uniform: true,\n  },\n  uniform: {\n    code: `uniform_val`,\n    uniform: true,\n  },\n  nonuniform: {\n    code: `nonuniform_val`,\n    uniform: false,\n  },\n  uniform_index: {\n    code: `uniform_value[uniform_val]`,\n    uniform: true,\n  },\n  nonuniform_index1: {\n    code: `uniform_value[nonuniform_val]`,\n    uniform: false,\n  },\n  nonuniform_index2: {\n    code: `nonuniform_value[uniform_val]`,\n    uniform: false,\n  },\n  uniform_struct: {\n    code: `uniform_struct.x`,\n    uniform: true,\n  },\n  nonuniform_struct: {\n    code: `nonuniform_struct.x`,\n    uniform: false,\n  },\n};\n\nconst kBinOps = {\n  plus: {\n    code: '+',\n    test: '> 0',\n  },\n  minus: {\n    code: '-',\n    test: '> 0',\n  },\n  times: {\n    code: '*',\n    test: '> 0',\n  },\n  div: {\n    code: '/',\n    test: '> 0',\n  },\n  rem: {\n    code: '%',\n    test: '> 0',\n  },\n  and: {\n    code: '&',\n    test: '> 0',\n  },\n  or: {\n    code: '|',\n    test: '> 0',\n  },\n  xor: {\n    code: '^',\n    test: '> 0',\n  },\n  shl: {\n    code: '<<',\n    test: '> 0',\n  },\n  shr: {\n    code: '>>',\n    test: '> 0',\n  },\n  less: {\n    code: '<',\n    test: '',\n  },\n  lessequal: {\n    code: '<=',\n    test: '',\n  },\n  greater: {\n    code: '>',\n    test: '',\n  },\n  greaterequal: {\n    code: '>=',\n    test: '',\n  },\n  equal: {\n    code: '==',\n    test: '',\n  },\n  notequal: {\n    code: '!=',\n    test: '',\n  },\n};\n\ng.test('binary_expressions')\n  .desc(`Test uniformity of binary expressions`)\n  .params(u =>\n    u\n      .combine('e1', keysOf(kExpressionCases))\n      .combine('e2', keysOf(kExpressionCases))\n      .beginSubcases()\n      .combine('op', keysOf(kBinOps))\n  )\n  .fn(t => {\n    const e1 = kExpressionCases[t.params.e1];\n    const e2 = kExpressionCases[t.params.e2];\n    const op = kBinOps[t.params.op];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n\nstruct S {\n  x : u32\n}\n\nconst uniform_struct = S(1);\nvar<private> nonuniform_struct = S(1);\n\nconst uniform_value : array<u32, 2> = array(1,1);\nvar<private> nonuniform_value : array<u32, 2> = array(1,1);\n\nconst uniform_val : u32 = 1;\nvar<private> nonuniform_val : u32 = 1;\n\n@fragment\nfn main() {\n  let tmp = ${e1.code} ${op.code} ${e2.code};\n  if tmp ${op.test} {\n    let res = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const res = e1.uniform && e2.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\ng.test('unary_expressions')\n  .desc(`Test uniformity of uniary expressions`)\n  .params(u =>\n    u\n      .combine('e', keysOf(kExpressionCases))\n      .combine('op', ['!b_tmp', '~i_tmp > 0', '-i32(i_tmp) > 0'] as const)\n  )\n  .fn(t => {\n    const e = kExpressionCases[t.params.e];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n\nstruct S {\n  x : i32\n}\n\nconst uniform_struct = S(1);\nvar<private> nonuniform_struct = S(1);\n\nconst uniform_value : array<i32, 2> = array(1,1);\nvar<private> nonuniform_value : array<i32, 2> = array(1,1);\n\nconst uniform_val : i32 = 1;\nvar<private> nonuniform_val : i32 = 1;\n\n@fragment\nfn main() {\n  let i_tmp = ${e.code};\n  let b_tmp = bool(i_tmp);\n  let tmp = ${t.params.op};\n  if tmp {\n    let res = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const res = e.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\nconst kFunctionCases = {\n  uniform_result: {\n    function: `fn foo() -> u32 {\n      return uniform_values[0];\n    }`,\n    call: `let call = foo();`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  nonuniform_result: {\n    function: `fn foo() -> u32 {\n      return nonuniform_values[0];\n    }`,\n    call: `let call = foo();`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  nonuniform_return_is_uniform_after_call: {\n    function: `fn foo() {\n      if nonuniform_values[0] > 0 {\n        return;\n      } else {\n        return;\n      }\n    }`,\n    call: `foo();`,\n    cond: `uniform_cond`,\n    uniform: true,\n  },\n  uniform_passthrough_parameter: {\n    function: `fn foo(x : u32) -> u32 {\n      return x;\n    }`,\n    call: `let call = foo(uniform_values[0]);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  nonuniform_passthrough_parameter: {\n    function: `fn foo(x : u32) -> u32 {\n      return x;\n    }`,\n    call: `let call = foo(nonuniform_values[0]);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  combined_parameters1: {\n    function: `fn foo(x : u32, y : u32) -> u32 {\n      return x + y;\n    }`,\n    call: `let call = foo(uniform_values[0], uniform_values[1]);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  combined_parameters2: {\n    function: `fn foo(x : u32, y : u32) -> u32 {\n      return x + y;\n    }`,\n    call: `let call = foo(nonuniform_values[0], uniform_values[1]);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  combined_parameters3: {\n    function: `fn foo(x : u32, y : u32) -> u32 {\n      return x + y;\n    }`,\n    call: `let call = foo(uniform_values[0], nonuniform_values[1]);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  combined_parameters4: {\n    function: `fn foo(x : u32, y : u32) -> u32 {\n      return x + y;\n    }`,\n    call: `let call = foo(nonuniform_values[0], nonuniform_values[1]);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  uniform_parameter_cf_after_nonuniform_expr: {\n    function: `fn foo(x : bool, y : vec4f) -> f32 {\n      return select(0, y.x, x);\n    }`,\n    call: `let call = foo(nonuniform_cond || uniform_cond, textureSample(t,s,vec2f(0,0)));`,\n    cond: `uniform_cond`,\n    uniform: true,\n  },\n  required_uniform_function_call_in_uniform_cf: {\n    function: `fn foo() -> vec4f {\n      return textureSample(t,s,vec2f(0,0));\n    }`,\n    call: `if uniform_cond {\n      let call = foo();\n    }`,\n    cond: `uniform_cond`,\n    uniform: true,\n  },\n  required_uniform_function_call_in_nonuniform_cf: {\n    function: `fn foo() -> vec4f {\n      return textureSample(t,s,vec2f(0,0));\n    }`,\n    call: `if nonuniform_cond {\n      let call = foo();\n    }`,\n    cond: `uniform_cond`,\n    uniform: false,\n  },\n  required_uniform_function_call_in_nonuniform_cf2: {\n    function: `@diagnostic(warning, derivative_uniformity)\n    fn foo() -> vec4f {\n      return textureSample(t,s,vec2f(0,0));\n    }`,\n    call: `if nonuniform_cond {\n      let call = foo();\n      let sample = textureSample(t,s,vec2f(0,0));\n    }`,\n    cond: `uniform_cond`,\n    uniform: false,\n  },\n  required_uniform_function_call_depends_on_uniform_param: {\n    function: `fn foo(x : bool) -> vec4f {\n      if x {\n        return textureSample(t,s,vec2f(0,0));\n      }\n      return vec4f(0);\n    }`,\n    call: `let call = foo(uniform_cond);`,\n    cond: `uniform_cond`,\n    uniform: true,\n  },\n  required_uniform_function_call_depends_on_nonuniform_param: {\n    function: `fn foo(x : bool) -> vec4f {\n      if x {\n        return textureSample(t,s,vec2f(0,0));\n      }\n      return vec4f(0);\n    }`,\n    call: `let call = foo(nonuniform_cond);`,\n    cond: `uniform_cond`,\n    uniform: false,\n  },\n  dpdx_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdx(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  dpdy_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdy(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  dpdxCoarse_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdxCoarse(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  dpdyCoarse_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdyCoarse(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  dpdxFine_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdxFine(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  dpdyFine_nonuniform_result: {\n    function: ``,\n    call: `let call = dpdyFine(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  fwidth_nonuniform_result: {\n    function: ``,\n    call: `let call = fwidth(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  fwidthCoarse_nonuniform_result: {\n    function: ``,\n    call: `let call = fwidthCoarse(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  fwidthFine_nonuniform_result: {\n    function: ``,\n    call: `let call = fwidthFine(1);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  textureSample_nonuniform_result: {\n    function: ``,\n    call: `let call = textureSample(t,s,vec2f(0,0));`,\n    cond: `call.x > 0`,\n    uniform: false,\n  },\n  textureSampleBias_nonuniform_result: {\n    function: ``,\n    call: `let call = textureSampleBias(t,s,vec2f(0,0), 0);`,\n    cond: `call.x > 0`,\n    uniform: false,\n  },\n  textureSampleCompare_nonuniform_result: {\n    function: ``,\n    call: `let call = textureSampleCompare(td,sd,vec2f(0,0), 0);`,\n    cond: `call > 0`,\n    uniform: false,\n  },\n  textureDimensions_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureDimensions(t);`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureGather_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureGather(0,t,s,vec2f(0,0));`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureGatherCompare_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureGatherCompare(td,sd,vec2f(0,0), 0);`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureLoad_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureLoad(t,vec2u(0,0),0);`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureNumLayers_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureNumLayers(ta);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  textureNumLevels_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureNumLevels(t);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  textureNumSamples_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureNumSamples(ts);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  textureSampleLevel_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureSampleLevel(t,s,vec2f(0,0),0);`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureSampleGrad_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureSampleGrad(t,s,vec2f(0,0),vec2f(0,0),vec2f(0,0));`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  textureSampleCompareLevel_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureSampleCompareLevel(td,sd,vec2f(0,0), 0);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  textureSampleBaseClampToEdge_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = textureSampleBaseClampToEdge(t,s,vec2f(0,0));`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n  min_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = min(0,0);`,\n    cond: `call > 0`,\n    uniform: true,\n  },\n  value_constructor_uniform_input_uniform_result: {\n    function: ``,\n    call: `let call = vec2u(0,0);`,\n    cond: `call.x > 0`,\n    uniform: true,\n  },\n};\n\ng.test('functions')\n  .desc(`Test uniformity of function calls (non-pointer parameters)`)\n  .params(u => u.combine('case', keysOf(kFunctionCases)))\n  .fn(t => {\n    const func_case = kFunctionCases[t.params.case];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n@group(0) @binding(2)\nvar td : texture_depth_2d;\n@group(0) @binding(3)\nvar sd : sampler_comparison;\n@group(0) @binding(4)\nvar ta : texture_2d_array<f32>;\n@group(0) @binding(5)\nvar ts : texture_multisampled_2d<f32>;\n\nconst uniform_cond = true;\nvar<private> nonuniform_cond = true;\n\n@group(1) @binding(0)\nvar<storage> uniform_values : array<u32, 4>;\n@group(1) @binding(1)\nvar<storage, read_write> nonuniform_values : array<u32, 4>;\n\n${func_case.function}\n\n@fragment\nfn main() {\n  ${func_case.call}\n\n  if ${func_case.cond} {\n    let tmp = textureSample(t,s,vec2f(0,0));\n  }\n}\n`;\n\n    const res = func_case.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\ng.test('subgroups,parameters')\n  .desc('Test subgroup operations that require a uniform parameter')\n  .params(u =>\n    u\n      .combine('op', ['subgroupShuffleUp', 'subgroupShuffleDown', 'subgroupShuffleXor'] as const)\n      .combine('uniform', [false, true] as const)\n  )\n  .fn(t => {\n    const wgsl = `\nenable subgroups;\n\nvar<private> non_uniform : u32 = 0;\n\n@group(0) @binding(0)\nvar<storage> uniform : u32;\n\n@compute @workgroup_size(16,1,1)\nfn main() {\n  let x = ${t.params.op}(non_uniform, ${t.params.uniform ? 'uniform' : 'non_uniform'});\n}`;\n\n    t.expectCompileResult(t.params.uniform, wgsl);\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI,0CAAyC,CAErE,SAASC,aAAa,QAAQ,4CAA4C;AAC1E,SAASC,MAAM,QAAQ,wCAAwC;AAC/D,SAASC,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,oBAAoB,QAAQ,8BAA8B;;AAEnE,SAAkBC,QAAQ,EAAEC,oBAAoB,QAAQ,cAAc;;AAEtE,OAAO,MAAMC,CAAC,GAAGN,aAAa,CAACG,oBAAoB,CAAC;;AAEpD,MAAMI,cAAc,GAAG;AACrB,EAAEC,EAAE,EAAE,sBAAsB,EAAEC,KAAK,EAAE,SAAS,CAAC,CAAC;AAChD,EAAED,EAAE,EAAE,uBAAuB,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AAClD,EAAED,EAAE,EAAE,eAAe,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC1C,EAAED,EAAE,EAAE,mBAAmB,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC9C,EAAED,EAAE,EAAE,sBAAsB,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACjD,EAAED,EAAE,EAAE,MAAM,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACjC,EAAED,EAAE,EAAE,YAAY,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACvC,EAAED,EAAE,EAAE,UAAU,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACrC,EAAED,EAAE,EAAE,MAAM,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACjC,EAAED,EAAE,EAAE,YAAY,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACvC,EAAED,EAAE,EAAE,UAAU,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACrC,EAAED,EAAE,EAAE,QAAQ,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACnC,EAAED,EAAE,EAAE,cAAc,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACzC,EAAED,EAAE,EAAE,YAAY,EAAEC,KAAK,EAAE,UAAU,CAAC,CAAC;AACvC,EAAED,EAAE,EAAE,gBAAgB,EAAEC,KAAK,EAAE,SAAS,CAAC,CAAC;AAC1C,EAAED,EAAE,EAAE,gBAAgB,EAAEC,KAAK,EAAE,SAAS,CAAC,CAAC;AAC1C,EAAED,EAAE,EAAE,kBAAkB,EAAEC,KAAK,EAAE,SAAS,CAAC,CAAC;AAC5C,EAAED,EAAE,EAAE,sBAAsB,EAAEC,KAAK,EAAE,SAAS,CAAC,CAAC,CACjD;;;AAED,MAAMC,WAAW,GAAG;AAClB,EAAEC,IAAI,EAAE,oBAAoB,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AACjD,EAAED,IAAI,EAAE,uBAAuB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AACrD,EAAED,IAAI,EAAE,uBAAuB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AACrD,EAAED,IAAI,EAAE,oBAAoB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAClD,EAAED,IAAI,EAAE,iBAAiB,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC9C,EAAED,IAAI,EAAE,eAAe,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC5C,EAAED,IAAI,EAAE,kBAAkB,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC/C,EAAED,IAAI,EAAE,aAAa,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC1C,EAAED,IAAI,EAAE,gBAAgB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAC9C,EAAED,IAAI,EAAE,YAAY,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AACzC,EAAED,IAAI,EAAE,gBAAgB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAC9C,EAAED,IAAI,EAAE,gBAAgB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAC9C,EAAED,IAAI,EAAE,aAAa,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC1C,EAAED,IAAI,EAAE,iBAAiB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAC/C,EAAED,IAAI,EAAE,iBAAiB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AAC/C,EAAED,IAAI,EAAE,kBAAkB,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AAC/C,EAAED,IAAI,EAAE,qBAAqB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC;AACnD,EAAED,IAAI,EAAE,oBAAoB,EAAEC,WAAW,EAAE,IAAI,CAAC,CAAC;AACjD,EAAED,IAAI,EAAE,oBAAoB,EAAEC,WAAW,EAAE,KAAK,CAAC,CAAC,CACnD;;;AAED,SAASC,iBAAiBA,CAACC,SAAiB,EAAU;EACpD,QAAQA,SAAS;IACf,KAAK,oBAAoB,CAAE;QACzB,OAAQ,mBAAkB;MAC5B;IACA,KAAK,uBAAuB,CAAE;QAC5B,OAAQ,6BAA4B;MACtC;IACA,KAAK,uBAAuB,CAAE;QAC5B,OAAQ,mBAAkB;MAC5B;IACA,KAAK,oBAAoB,CAAE;QACzB,OAAQ,UAAS;MACnB;IACA,KAAK,iBAAiB,CAAE;QACtB,OAAQ,OAAM;MAChB;IACA,KAAK,eAAe,CAAE;QACpB,OAAQ,GAAE;MACZ;IACA,KAAK,kBAAkB,CAAE;QACvB,OAAQ,QAAO;MACjB;IACA,KAAK,aAAa,CAAE;QAClB,OAAQ,YAAW;MACrB;IACA,KAAK,gBAAgB,CAAE;QACrB,OAAQ,YAAW;MACrB;IACA,KAAK,YAAY,CAAE;QACjB,OAAQ,oCAAmC;MAC7C;IACA,KAAK,gBAAgB,CAAE;QACrB,OAAQ,0BAAyB;MACnC;IACA,KAAK,gBAAgB,CAAE;QACrB,OAAQ,0BAAyB;MACnC;IACA,KAAK,aAAa,CAAE;QAClB,OAAQ,oCAAmC;MAC7C;IACA,KAAK,iBAAiB,CAAE;QACtB,OAAQ,0BAAyB;MACnC;IACA,KAAK,iBAAiB,CAAE;QACtB,OAAQ,0BAAyB;MACnC;IACA,KAAK,kBAAkB,CAAE;QACvB,OAAQ,UAAS;MACnB;IACA,KAAK,qBAAqB,CAAE;QAC1B,OAAQ,UAAS;MACnB;IACA,KAAK,oBAAoB,CAAE;QACzB,OAAQ,gDAA+C;MACzD;IACA,KAAK,oBAAoB,CAAE;QACzB,OAAQ,gDAA+C;MACzD;IACA,KAAK,cAAc,CAAE;QACnB,OAAO,MAAM;MACf;IACA,KAAK,aAAa;IAClB,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,aAAa;IAClB,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,wBAAwB;IAC7B,KAAK,WAAW;IAChB,KAAK,WAAW;IAChB,KAAK,kBAAkB,CAAE;QACvB,OAAQ,GAAEA,SAAU,UAAS;MAC/B;IACA,KAAK,aAAa;IAClB,KAAK,aAAa,CAAE;QAClB,OAAQ,GAAEA,SAAU,SAAQ;MAC9B;IACA,KAAK,gBAAgB,CAAE;QACrB,OAAQ,GAAEA,SAAU,gBAAe;MACrC;IACA,KAAK,eAAe,CAAE;QACpB,OAAQ,GAAEA,SAAU,IAAG;MACzB;IACA,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,eAAe,CAAE;QACpB,OAAQ,GAAEA,SAAU,aAAY;MAClC;IACA,QAAS;QACPZ,WAAW,CAAE,qBAAoB,CAAC;MACpC;EACF;AACF;;AAEA,SAASa,UAAUA,CAACP,EAAU,EAAU;EACtC,QAAQA,EAAE;IACR,KAAK,cAAc;IACnB,KAAK,sBAAsB;IAC3B,KAAK,uBAAuB,CAAE;QAC5B,OAAQ,EAAC;MACX;IACA,KAAK,eAAe,CAAE;QACpB,OAAQ,WAAUA,EAAG,wBAAuB;MAC9C;IACA,KAAK,mBAAmB,CAAE;QACxB,OAAQ,WAAUA,EAAG,2BAA0B;MACjD;IACA,KAAK,sBAAsB,CAAE;QAC3B,OAAQ,WAAUA,EAAG,sCAAqC;MAC5D;IACA,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,kBAAkB,CAAE;QACvB,OAAQ,GAAEA,EAAG,OAAM;MACrB;IACA,KAAK,sBAAsB,CAAE;QAC3B,OAAQ,WAAUA,EAAG,QAAO;MAC9B;IACA,KAAK,MAAM;IACX,KAAK,YAAY;IACjB,KAAK,UAAU;IACf,KAAK,MAAM;IACX,KAAK,YAAY;IACjB,KAAK,UAAU;IACf,KAAK,QAAQ;IACb,KAAK,cAAc;IACnB,KAAK,YAAY,CAAE;QACjB,OAAQ,WAAUA,EAAG,QAAO;MAC9B;IACA,KAAK,aAAa;IAClB,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,aAAa;IAClB,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,wBAAwB;IAC7B,KAAK,WAAW;IAChB,KAAK,WAAW;IAChB,KAAK,kBAAkB;MACrB,OAAQ,WAAUA,EAAG,QAAO;IAC9B,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,gBAAgB;MACnB,OAAQ,WAAUA,EAAG,YAAW;IAClC,KAAK,eAAe;MAClB,OAAQ,WAAUA,EAAG,OAAM;IAC7B,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,eAAe;MAClB,OAAQ,WAAUA,EAAG,WAAU;IACjC,QAAS;QACPN,WAAW,CAAE,cAAa,CAAC;MAC7B;EACF;AACF;;AAEA,MAAMc,eAAe,GAAG;AACtB;AACA;EACEC,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE,oBAAoB;EAC1BC,OAAO,EAAE;AACX,CAAC;AACD;EACEF,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA,YAAY;EACRC,OAAO,EAAE;AACX,CAAC;;AAED;;AAEA;AACA;AACAf,QAAQ,CAAC,sBAAsB,EAAE,QAAQ,CAAC;AAC1CA,QAAQ,CAAC,oBAAoB,EAAE,WAAW,CAAC;AAC3CA,QAAQ,CAAC,uBAAuB,EAAE,QAAQ,CAAC;AAC3CA,QAAQ,CAAC,qBAAqB,EAAE,WAAW,CAAC;AAC5CA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC;AACxDA,QAAQ,CAAC,kCAAkC,EAAE,WAAW,CAAC;;AAEzD;AACAA,QAAQ,CAAC,sBAAsB,EAAE,QAAQ,CAAC;AAC1CA,QAAQ,CAAC,oBAAoB,EAAE,WAAW,CAAC;AAC3CA,QAAQ,CAAC,uBAAuB,EAAE,QAAQ,CAAC;AAC3CA,QAAQ,CAAC,qBAAqB,EAAE,WAAW,CAAC;AAC5CA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC;AACxDA,QAAQ,CAAC,kCAAkC,EAAE,WAAW,CAAC;;AAEzD;AACA;AACA;AACAA,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC;AAC9CA,QAAQ,CAAC,wBAAwB,EAAE,QAAQ,CAAC;AAC5CA,QAAQ,CAAC,wBAAwB,EAAE,QAAQ,CAAC;AAC5CA,QAAQ,CAAC,2BAA2B,EAAE,QAAQ,CAAC;AAC/CA,QAAQ,CAAC,yBAAyB,EAAE,QAAQ,CAAC,EAAE;AAC/CA,QAAQ,CAAC,wCAAwC,EAAE,QAAQ,CAAC;AAC5DA,QAAQ,CAAC,sCAAsC,EAAE,QAAQ,CAAC;;AAE1D;AACA;AACAA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,+BAA+B,EAAE,WAAW,CAAC;AACtDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,gCAAgC,EAAE,WAAW,CAAC;AACvDA,QAAQ,CAAC,+CAA+C,EAAE,QAAQ,CAAC;AACnE;AACAA,QAAQ,CAAC,6CAA6C,EAAE,WAAW,CAAC;;AAEpE;AACA;AACA;AACAA,QAAQ,CAAC,+BAA+B,EAAE,WAAW,CAAC;;AAEtD;AACAA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,+BAA+B,EAAE,WAAW,CAAC;AACtDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,gCAAgC,EAAE,WAAW,CAAC;;AAEvD;AACAA,QAAQ,CAAC,+BAA+B,EAAE,WAAW,CAAC;;AAEtD;AACAA,QAAQ,CAAC,qCAAqC,EAAE,QAAQ,CAAC;AACzDA,QAAQ,CAAC,mCAAmC,EAAE,QAAQ,CAAC;AACvDA,QAAQ,CAAC,sCAAsC,EAAE,QAAQ,CAAC;AAC1DA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC,EAAE;AAC1DA,QAAQ,CAAC,mDAAmD,EAAE,QAAQ,CAAC;AACvEA,QAAQ,CAAC,iDAAiD,EAAE,QAAQ,CAAC;;AAErE;AACAA,QAAQ,CAAC,mCAAmC,EAAE,QAAQ,CAAC;AACvDA,QAAQ,CAAC,gDAAgD,EAAE,QAAQ,CAAC;AACpEA,QAAQ,CAAC,iDAAiD,EAAE,QAAQ,CAAC;;AAErE;AACA;AACAA,QAAQ,CAAC,qBAAqB,EAAE,QAAQ,CAAC;AACzCA,QAAQ,CAAC,mBAAmB,EAAE,WAAW,CAAC;AAC1CA,QAAQ,CAAC,sBAAsB,EAAE,QAAQ,CAAC;AAC1CA,QAAQ,CAAC,oBAAoB,EAAE,WAAW,CAAC;AAC3CA,QAAQ,CAAC,wCAAwC,EAAE,QAAQ,CAAC;AAC5DA,QAAQ,CAAC,sCAAsC,EAAE,WAAW,CAAC;AAC7D;AACAA,QAAQ,CAAC,qBAAqB,EAAE,QAAQ,CAAC;AACzCA,QAAQ,CAAC,mBAAmB,EAAE,WAAW,CAAC;AAC1CA,QAAQ,CAAC,sBAAsB,EAAE,QAAQ,CAAC;AAC1CA,QAAQ,CAAC,oBAAoB,EAAE,WAAW,CAAC;AAC3CA,QAAQ,CAAC,mCAAmC,EAAE,QAAQ,CAAC;AACvDA,QAAQ,CAAC,iCAAiC,EAAE,WAAW,CAAC;;AAExD;AACAA,QAAQ,CAAC,aAAa,EAAE,QAAQ,CAAC;AACjC;AACAA,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC;AAC9CA,QAAQ,CAAC,wBAAwB,EAAE,WAAW,CAAC;AAC/CA,QAAQ,CAAC,2BAA2B,EAAE,QAAQ,CAAC;AAC/CA,QAAQ,CAAC,yBAAyB,EAAE,WAAW,CAAC;AAChDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,WAAW,CAAC;AAClD;AACAA,QAAQ,CAAC,0BAA0B,EAAE,QAAQ,CAAC;AAC9CA,QAAQ,CAAC,wBAAwB,EAAE,WAAW,CAAC;AAC/CA,QAAQ,CAAC,2BAA2B,EAAE,QAAQ,CAAC;AAC/CA,QAAQ,CAAC,yBAAyB,EAAE,WAAW,CAAC;AAChDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,WAAW,CAAC;AAClD;AACAA,QAAQ,CAAC,iBAAiB,EAAE,QAAQ,CAAC;AACrCA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC;AAChDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,6BAA6B,EAAE,WAAW,CAAC;AACpDA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;;AAEnD;AACAA,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC;AACpC;AACAA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,QAAQ,CAAC;AAC/CA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC;AAChDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClD;AACAA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,QAAQ,CAAC;AAC/CA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC;AAChDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClD;AACAA,QAAQ,CAAC,oBAAoB,EAAE,QAAQ,CAAC;AACxCA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC;AACxDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;;AAEtD;AACAA,QAAQ,CAAC,eAAe,EAAE,QAAQ,CAAC;AACnC;AACAA,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC;AAChDA,QAAQ,CAAC,0BAA0B,EAAE,WAAW,CAAC;AACjDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,WAAW,CAAC;AAClDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,6BAA6B,EAAE,WAAW,CAAC;AACpD;AACAA,QAAQ,CAAC,4BAA4B,EAAE,QAAQ,CAAC;AAChDA,QAAQ,CAAC,0BAA0B,EAAE,WAAW,CAAC;AACjDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,2BAA2B,EAAE,WAAW,CAAC;AAClDA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,6BAA6B,EAAE,WAAW,CAAC;AACpD;AACAA,QAAQ,CAAC,mBAAmB,EAAE,QAAQ,CAAC;AACvCA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,+BAA+B,EAAE,WAAW,CAAC;AACtDA,QAAQ,CAAC,mCAAmC,EAAE,QAAQ,CAAC;AACvDA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;;AAErD;AACAA,QAAQ,CAAC,kBAAkB,EAAE,QAAQ,CAAC;AACtC;AACAA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpD;AACAA,QAAQ,CAAC,+BAA+B,EAAE,QAAQ,CAAC;AACnDA,QAAQ,CAAC,6BAA6B,EAAE,QAAQ,CAAC;AACjDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpDA,QAAQ,CAAC,8BAA8B,EAAE,QAAQ,CAAC;AAClDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,gCAAgC,EAAE,QAAQ,CAAC;AACpD;AACAA,QAAQ,CAAC,sBAAsB,EAAE,QAAQ,CAAC;AAC1CA,QAAQ,CAAC,mCAAmC,EAAE,QAAQ,CAAC;AACvDA,QAAQ,CAAC,iCAAiC,EAAE,QAAQ,CAAC;AACrDA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC;AACxDA,QAAQ,CAAC,kCAAkC,EAAE,QAAQ,CAAC;AACtDA,QAAQ,CAAC,sCAAsC,EAAE,QAAQ,CAAC;AAC1DA,QAAQ,CAAC,oCAAoC,EAAE,QAAQ,CAAC,CACzD;;;AAED,MAAMgB,eAAe,GAAGJ,eAAe,CAACK,GAAG,CAAC,CAAAC,EAAE,KAAIA,EAAE,CAACL,IAAI,CAAC;;AAE1D;AACA,MAAMM,cAAc,GAAGC,MAAM,CAACC,WAAW,CAACT,eAAe,CAACK,GAAG,CAAC,CAAAC,EAAE,KAAI,CAACA,EAAE,CAACL,IAAI,EAAEK,EAAE,CAAC,CAAC,CAGjF;;;;;AAED,SAASI,4BAA4BA;AACnCT,IAAmB;AACnBU,cAAsB;AACtBC,OAAe;AACN;EACT,MAAMjB,IAAI,GAAGE,iBAAiB,CAACc,cAAc,CAAC;EAC9C,MAAMnB,EAAE,GAAGO,UAAU,CAACa,OAAO,CAAC;EAC9B,MAAMC,OAAO,GAAGN,cAAc,CAACN,IAAI,CAAC;EACpC,IAAIC,IAAI,GAAGW,OAAO,CAACX,IAAI;EACvBA,IAAI,GAAGA,IAAI;EACRY,OAAO,CAAC,MAAM,EAAEtB,EAAE,CAAC;EACnBsB,OAAO,CAAC,QAAQ,EAAEnB,IAAI,CAAC;EACvBoB,UAAU,CAAC,gBAAgB,EAAElB,iBAAiB,CAAC,oBAAoB,CAAC,CAAC;EACrEkB,UAAU,CAAC,mBAAmB,EAAElB,iBAAiB,CAAC,uBAAuB,CAAC,CAAC;EAC9E,OAAO,EAAEI,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEU,OAAO,CAACV,OAAO,CAAC,CAAC;AACjD;;AAEAb,CAAC,CAAC0B,IAAI,CAAC,QAAQ,CAAC;AACbC,IAAI,CAAE,2EAA0E,CAAC;AACjFC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,WAAW,EAAEhB,eAAe,CAAC;AACrCiB,aAAa,CAAC,CAAC;AACfC,iBAAiB,CAAC5B,WAAW,CAAC;AAC9B4B,iBAAiB,CAAC/B,cAAc;AACrC,CAAC;AACAgC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAIA,CAAC,CAACN,MAAM,CAAC1B,EAAE,KAAK,gBAAgB,IAAIgC,CAAC,CAACN,MAAM,CAACvB,IAAI,CAAC8B,UAAU,CAAC,iBAAiB,CAAC,EAAE;IACnFD,CAAC,CAACE,iCAAiC,CAAC,yCAAyC,CAAC;EAChF;;EAEA,IAAIxB,IAAI,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;EAEG,IAAIsB,CAAC,CAACN,MAAM,CAACzB,KAAK,KAAK,SAAS,EAAE;IAChCS,IAAI,IAAK,4BAA2B;IACpCA,IAAI,IAAK,4BAA2B;EACtC;EACAA,IAAI,IAAK,IAAGsB,CAAC,CAACN,MAAM,CAACzB,KAAM,EAAC;EAC5BS,IAAI,IAAK,YAAW;EACpB,IAAIsB,CAAC,CAACN,MAAM,CAACzB,KAAK,KAAK,SAAS,EAAE;IAChCS,IAAI,IAAK,8CAA6C;EACxD,CAAC,MAAM;IACLA,IAAI,IAAK,kCAAiC;EAC5C;EACAA,IAAI,IAAK;AACb;AACA;AACA;AACA;AACA,CAAC;;EAEG;EACA,MAAMW,OAAO,GAAGH,4BAA4B,CAACc,CAAC,CAACN,MAAM,CAACS,SAAS,EAAEH,CAAC,CAACN,MAAM,CAACvB,IAAI,EAAE6B,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAAC;EAC5FU,IAAI,IAAIW,OAAO,CAACX,IAAI;;EAEpBA,IAAI,IAAK,OAAM;;EAEfsB,CAAC,CAACI,mBAAmB;IACnBvC,oBAAoB,CAAC;MACnBwC,mBAAmB,EAAE,CAACL,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAACiC,UAAU,CAAC,cAAc,CAAC;MAC5DK,oBAAoB,EAAEN,CAAC,CAACN,MAAM,CAACtB,WAAW;MAC1CO,OAAO,EAAEU,OAAO,CAACV;IACnB,CAAC,CAAC;IACFD;EACF,CAAC;AACH,CAAC,CAAC;;AAEJ,MAAM6B,mBAAsC,GAAG;AAC7C,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,YAAY;AACZ,aAAa;AACb,gBAAgB;AAChB,mBAAmB;AACnB,wBAAwB,CAChB;;;AAEV,MAAMC,YAA+B,GAAG;AACtC,cAAc;AACd,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,eAAe;AACf,iBAAiB;AACjB,mBAAmB;AACnB,qBAAqB;AACrB,oBAAoB;AACpB,eAAe;AACf,WAAW;AACX,WAAW;AACX,kBAAkB;AAClB,GAAGD,mBAAmB,CACd;;;AAEVzC,CAAC,CAAC0B,IAAI,CAAC,kBAAkB,CAAC;AACvBC,IAAI,CAAE,yEAAwE,CAAC;AAC/EC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,WAAW,EAAEhB,eAAe,CAAC;AACrCiB,aAAa,CAAC,CAAC;AACfC,iBAAiB,CAAC5B,WAAW,CAAC;AAC9B0B,OAAO,CAAC,IAAI,EAAEY,YAAY,CAAC;AAC3BZ,OAAO,CAAC,OAAO,EAAE,CAAC,SAAS,EAAE,UAAU,CAAU;AACtD,CAAC;AACAG,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAItB,IAAI,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;EAEG,IAAIsB,CAAC,CAACN,MAAM,CAACzB,KAAK,KAAK,SAAS,EAAE;IAChCS,IAAI,IAAK,4BAA2B;IACpCA,IAAI,IAAK,4BAA2B;EACtC;EACAA,IAAI,IAAK,IAAGsB,CAAC,CAACN,MAAM,CAACzB,KAAM,EAAC;EAC5BS,IAAI,IAAK,YAAW;EACpB,IAAIsB,CAAC,CAACN,MAAM,CAACzB,KAAK,KAAK,SAAS,EAAE;IAChCS,IAAI,IAAK,8CAA6C;EACxD,CAAC,MAAM;IACLA,IAAI,IAAK,kCAAiC;EAC5C;EACAA,IAAI,IAAK;AACb;AACA;AACA;AACA;AACA,KAAK;;EAED;EACA,MAAMW,OAAO,GAAGH,4BAA4B,CAACc,CAAC,CAACN,MAAM,CAACS,SAAS,EAAEH,CAAC,CAACN,MAAM,CAACvB,IAAI,EAAE6B,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAAC;EAC5FU,IAAI,IAAIW,OAAO,CAACX,IAAI;;EAEpBA,IAAI,IAAK,OAAM;;EAEfsB,CAAC,CAACI,mBAAmB;IACnBvC,oBAAoB,CAAC;MACnBwC,mBAAmB,EAAE,CAACL,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAACiC,UAAU,CAAC,cAAc,CAAC;MAC5DK,oBAAoB,EAAEN,CAAC,CAACN,MAAM,CAACtB,WAAW;MAC1CO,OAAO,EAAEU,OAAO,CAACV;IACnB,CAAC,CAAC;IACFD;EACF,CAAC;AACH,CAAC,CAAC;;AAEJZ,CAAC,CAAC0B,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI,CAAE,qEAAoE,CAAC;AAC3EC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,IAAI,EAAEY,YAAY,CAAC,CAACZ,OAAO,CAAC,OAAO,EAAE,CAAC,WAAW,EAAE,UAAU,CAAU,CAAC,CAAC;AAC/FG,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMS,SAAS;EACbT,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,WAAW,GAAG,qBAAqB,GAAG,wBAAwB;EACnF,MAAMhC,IAAI,GAAI;AAClB;AACA;AACA,OAAOL,iBAAiB,CAAC2B,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAAE;AACtC,MAAMyC,SAAU;AAChB;AACA,EAAE;;EAEE,MAAME,UAAU;EACdJ,mBAAmB,CAACK,QAAQ,CAACZ,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAAC;EACzCgC,CAAC,CAACa,kBAAkB,CAAC,qBAAqB,CAAC;EAC3Cb,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,UAAU;EAC/BV,CAAC,CAACI,mBAAmB;IACnBvC,oBAAoB,CAAC;MACnBwC,mBAAmB,EAAE,CAACL,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAACiC,UAAU,CAAC,cAAc,CAAC;MAC5DK,oBAAoB,EAAEK,UAAU;MAChChC,OAAO,EAAE;IACX,CAAC,CAAC;IACFD;EACF,CAAC;AACH,CAAC,CAAC;;AAEJ,MAAMoC,sBAAsB,GAAG;AAC7B;EACEC,OAAO,EAAG,UAAS;EACnBC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,cAAa;EACvBC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,cAAa;EACvBC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,aAAY;EACtBC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,wBAAuB;EACjCC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,eAAc;EACxBC,IAAI,EAAG;AACT,CAAC;AACD;EACED,OAAO,EAAG,cAAa;EACvBC,IAAI,EAAG;AACT,CAAC,CACF;;;AAEDlD,CAAC,CAAC0B,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,IAAI,CAAE,6CAA4C,CAAC;AACnDC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACG,iBAAiB,CAACgB,sBAAsB,CAAC,CAACjB,aAAa,CAAC,CAAC,CAAC;AACxEoB,iBAAiB,CAAC,CAAAjB,CAAC,KAAI;EACtBA,CAAC,CAACkB,MAAM;IACNlB,CAAC,CAACmB,eAAe,IAAI,CAAC,cAAc,EAAE,aAAa,CAAC,CAACP,QAAQ,CAACZ,CAAC,CAACN,MAAM,CAACqB,OAAO,CAAC;IAC/E;EACF,CAAC;AACH,CAAC,CAAC;AACDhB,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAI7B,IAAI,GAAI,EAAC;EACb,QAAQ6B,CAAC,CAACN,MAAM,CAACsB,IAAI;IACnB,KAAM,KAAI;IACV,KAAM,KAAI;IACV,KAAM,KAAI,CAAE;QACV7C,IAAI,GAAI,OAAM;QACd;MACF;IACA,KAAM,WAAU;IAChB,KAAM,WAAU;IAChB,KAAM,WAAU,CAAE;QAChBA,IAAI,GAAI,SAAQ;QAChB;MACF;IACA,KAAM,MAAK,CAAE;QACXA,IAAI,GAAI,GAAE;QACV;MACF;IACA,QAAS;QACPT,WAAW,CAAE,gBAAe,CAAC;MAC/B;EACF;EACA,IAAI0D,MAAM,GAAG,EAAE;EACf,IAAIpB,CAAC,CAACN,MAAM,CAACqB,OAAO,CAACH,QAAQ,CAAC,UAAU,CAAC,EAAE;IACzCQ,MAAM,GAAG,qBAAqB;EAChC,CAAC,MAAM,IAAIpB,CAAC,CAACN,MAAM,CAACqB,OAAO,KAAK,cAAc,EAAE;IAC9CK,MAAM,GAAG,8CAA8C;EACzD;;EAEA,MAAM1C,IAAI,GAAI;AAClB,EAAE0C,MAAO;AACT;AACA;AACA;AACA;AACA,mBAAmBpB,CAAC,CAACN,MAAM,CAACqB,OAAQ,SAAQf,CAAC,CAACN,MAAM,CAACsB,IAAK;AAC1D,OAAO7C,IAAK;AACZ;AACA;AACA;AACA,CAAC;;EAEG6B,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EAC/EsB,CAAC,CAACI,mBAAmB,CAAC,KAAK,EAAE1B,IAAI,CAAC;AACpC,CAAC,CAAC;;AAEJ,MAAM2C,qBAAqB,GAAG;AAC5B;EACEN,OAAO,EAAG,qBAAoB;EAC9BC,IAAI,EAAG,WAAU;EACjBM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,wBAAuB;EACjCC,IAAI,EAAG,KAAI;EACXM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,sBAAqB;EAC/BC,IAAI,EAAG,WAAU;EACjBM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,cAAa;EACvBC,IAAI,EAAG,WAAU;EACjBM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,gBAAe;EACzBC,IAAI,EAAG,WAAU;EACjBM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,wBAAuB;EACjCC,IAAI,EAAG,KAAI;EACXM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,eAAc;EACxBC,IAAI,EAAG,KAAI;EACXM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,aAAY;EACtBC,IAAI,EAAG,KAAI;EACXM,OAAO,EAAE;AACX,CAAC;AACD;EACEP,OAAO,EAAG,eAAc;EACxBC,IAAI,EAAG,KAAI;EACXM,OAAO,EAAE;AACX,CAAC,CACF;;;AAEDxD,CAAC,CAAC0B,IAAI,CAAC,wBAAwB,CAAC;AAC7BC,IAAI,CAAE,4CAA2C,CAAC;AAClDC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEG,iBAAiB,CAACuB,qBAAqB,CAAC;AACxCxB,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,OAAO,EAAE,CAAC,WAAW,EAAE,UAAU,CAAU;AACxD,CAAC;AACAqB,iBAAiB,CAAC,CAAAjB,CAAC,KAAI;EACtB,IAAIA,CAAC,CAACN,MAAM,CAACqB,OAAO,KAAM,aAAY,IAAIf,CAAC,CAACN,MAAM,CAACqB,OAAO,KAAM,eAAc,EAAE;IAC9Ef,CAAC,CAACE,iCAAiC,CAAC,aAAa,CAAC;EACpD;EACA,IAAIF,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,UAAU,EAAE;IACjCV,CAAC,CAACE,iCAAiC,CAAC,qBAAqB,CAAC;EAC5D;AACF,CAAC,CAAC;AACDH,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAI7B,IAAI,GAAI,EAAC;EACb,QAAQ6B,CAAC,CAACN,MAAM,CAACsB,IAAI;IACnB,KAAM,KAAI;IACV,KAAM,KAAI;IACV,KAAM,KAAI,CAAE;QACV7C,IAAI,GAAI,OAAM;QACd;MACF;IACA,KAAM,WAAU;IAChB,KAAM,WAAU;IAChB,KAAM,WAAU,CAAE;QAChBA,IAAI,GAAI,SAAQ;QAChB;MACF;IACA,KAAM,MAAK,CAAE;QACXA,IAAI,GAAI,GAAE;QACV;MACF;IACA,QAAS;QACPT,WAAW,CAAE,gBAAe,CAAC;MAC/B;EACF;EACA,MAAM0D,MAAM;EACVpB,CAAC,CAACN,MAAM,CAACqB,OAAO,CAACH,QAAQ,CAAC,UAAU,CAAC,IAAIZ,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,UAAU;EAClE,mBAAmB;EACnB,EAAE;EACR,MAAM1C,EAAE,GAAGgC,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,WAAW,GAAG,oBAAoB,GAAG,uBAAuB;EAC1F,MAAMhC,IAAI,GAAI;AAClB,EAAE0C,MAAO;AACT;AACA,mBAAmBpB,CAAC,CAACN,MAAM,CAACqB,OAAQ,SAAQf,CAAC,CAACN,MAAM,CAACsB,IAAK;AAC1D,OAAO7C,IAAK;AACZ,MAAMH,EAAG;AACT;AACA;AACA,CAAC;;EAEG,MAAMuD,MAAM;EACVvB,CAAC,CAACN,MAAM,CAAC4B,OAAO,IAAKtB,CAAC,CAACN,MAAM,CAACqB,OAAO,KAAK,aAAa,IAAIf,CAAC,CAACN,MAAM,CAACgB,KAAK,KAAK,UAAW;EAC3FV,CAAC,CAACI,mBAAmB,CAACmB,MAAM,EAAE7C,IAAI,CAAC;AACrC,CAAC,CAAC;;AAEJ,SAAS8C,oBAAoBA,CAACC,KAAa,EAAU;EACnD,IAAIA,KAAK,KAAM,SAAQ,EAAE;IACvB,OAAQ,sCAAqC;EAC/C,CAAC,MAAM;IACL;IACA,OAAQ;AACZ;AACA,MAAM;EACJ;AACF;;;;;;;;;AASA,MAAMC,aAA0C,GAAG;EACjDC,uBAAuB,EAAE;IACvBjD,IAAI,EAAG,yBAAwB;IAC/B+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDM,qBAAqB,EAAE;IACrBlD,IAAI,EAAG,qCAAoC;IAC3C+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDO,wBAAwB,EAAE;IACxBnD,IAAI,EAAG,wCAAuC;IAC9C+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDQ,qBAAqB,EAAE;IACrBpD,IAAI,EAAG;AACX;AACA;AACA,qCAAqC;IACjC+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDS,yBAAyB,EAAE;IACzBrD,IAAI,EAAG;AACX;AACA;AACA,qCAAqC;IACjC+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDU,yBAAyB,EAAE;IACzBtD,IAAI,EAAG;AACX;AACA;AACA,wCAAwC;IACpC+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDW,0BAA0B,EAAE;IAC1BvD,IAAI,EAAG,kDAAiD;IACxD+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDY,iCAAiC,EAAE;IACjCxD,IAAI,EAAG,uBAAsB;IAC7B+C,KAAK,EAAG,SAAQ;IAChBH,OAAO,EAAE;EACX,CAAC;EACDa,wBAAwB,EAAE;IACxBzD,IAAI,EAAG;AACX,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDc,wBAAwB,EAAE;IACxB1D,IAAI,EAAG;AACX;AACA;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDe,wBAAwB,EAAE;IACxB3D,IAAI,EAAG;AACX;AACA;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDgB,2BAA2B,EAAE;IAC3B5D,IAAI,EAAG;AACX;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDiB,2BAA2B,EAAE;IAC3B7D,IAAI,EAAG;AACX;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDkB,6BAA6B,EAAE;IAC7B9D,IAAI,EAAG;AACX;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDmB,iCAAiC,EAAE;IACjC/D,IAAI,EAAG;AACX;AACA;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDoB,iCAAiC,EAAE;IACjChE,IAAI,EAAG;AACX;AACA;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDqB,iCAAiC,EAAE;IACjCjE,IAAI,EAAG;AACX;AACA;AACA,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDsB,iCAAiC,EAAE;IACjClE,IAAI,EAAG;AACX;AACA,uBAAuB;IACnB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDuB,iCAAiC,EAAE;IACjCnE,IAAI,EAAG;AACX;AACA,gCAAgC;IAC5B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDwB,4BAA4B,EAAE;IAC5BpE,IAAI,EAAG;AACX,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDyB,gCAAgC,EAAE;IAChCrE,IAAI,EAAG;AACX,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD0B,gCAAgC,EAAE;IAChCtE,IAAI,EAAG;AACX,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD2B,gCAAgC,EAAE;IAChCvE,IAAI,EAAG;AACX,yBAAyB;IACrB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD4B,uBAAuB,EAAE;IACvBxE,IAAI,EAAG;AACX,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD6B,2BAA2B,EAAE;IAC3BzE,IAAI,EAAG;AACX,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD8B,2BAA2B,EAAE;IAC3B1E,IAAI,EAAG;AACX,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD+B,2BAA2B,EAAE;IAC3B3E,IAAI,EAAG;AACX,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDgC,6BAA6B,EAAE;IAC7B5E,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDiC,iCAAiC,EAAE;IACjC7E,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDkC,iCAAiC,EAAE;IACjC9E,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDmC,iCAAiC,EAAE;IACjC/E,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA,wBAAwB;IACpB+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDoC,+BAA+B,EAAE;IAC/BhF,IAAI,EAAG;AACX,gCAAgC;IAC5B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDqC,gCAAgC,EAAE;IAChCjF,IAAI,EAAG;AACX,gCAAgC;IAC5B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDsC,+BAA+B,EAAE;IAC/BlF,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDuC,gCAAgC,EAAE;IAChCnF,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDwC,+BAA+B,EAAE;IAC/BpF,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACDyC,gCAAgC,EAAE;IAChCrF,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD0C,+BAA+B,EAAE;IAC/BtF,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD2C,gCAAgC,EAAE;IAChCvF,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD4C,gCAAgC,EAAE;IAChCxF,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD6C,gCAAgC,EAAE;IAChCzF,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD8C,gCAAgC,EAAE;IAChC1F,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;EACD+C,gCAAgC,EAAE;IAChC3F,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE;EACX,CAAC;;EAED;EACAgD,2BAA2B,EAAE;IAC3B5F,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,IAAI;IACbiD,iBAAiB,EAAE;EACrB,CAAC;EACDC,4BAA4B,EAAE;IAC5B9F,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDE,2BAA2B,EAAE;IAC3B/F,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,IAAI;IACbiD,iBAAiB,EAAE;EACrB,CAAC;EACDG,4BAA4B,EAAE;IAC5BhG,IAAI,EAAG;AACX,kCAAkC;IAC9B+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,OAAO;IAChBiD,iBAAiB,EAAE;EACrB,CAAC;EACDI,2BAA2B,EAAE;IAC3BjG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,IAAI;IACbiD,iBAAiB,EAAE;EACrB,CAAC;EACDK,4BAA4B,EAAE;IAC5BlG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDM,4BAA4B,EAAE;IAC5BnG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDO,4BAA4B,EAAE;IAC5BpG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDQ,4BAA4B,EAAE;IAC5BrG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDS,4BAA4B,EAAE;IAC5BtG,IAAI,EAAG;AACX,+CAA+C;IAC3C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,OAAO;IAChBiD,iBAAiB,EAAE;EACrB,CAAC;EACDU,2BAA2B,EAAE;IAC3BvG,IAAI,EAAG,8CAA6C;IACpD+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,IAAI;IACbiD,iBAAiB,EAAE;EACrB,CAAC;EACDW,4BAA4B,EAAE;IAC5BxG,IAAI,EAAG,iDAAgD;IACvD+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB,CAAC;EACDY,2BAA2B,EAAE;IAC3BzG,IAAI,EAAG,gEAA+D;IACtE+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAG,OAAM;IAChBiD,iBAAiB,EAAE;EACrB,CAAC;EACDa,oCAAoC,EAAE;IACpC1G,IAAI,EAAG;AACX,mDAAmD;IAC/C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,IAAI;IACbiD,iBAAiB,EAAE;EACrB,CAAC;EACDc,wCAAwC,EAAE;IACxC3G,IAAI,EAAG;AACX,mDAAmD;IAC/C+C,KAAK,EAAG,UAAS;IACjBH,OAAO,EAAE,KAAK;IACdiD,iBAAiB,EAAE;EACrB;AACF,CAAC;;AAEDzG,CAAC,CAAC0B,IAAI,CAAC,UAAU,CAAC;AACfC,IAAI,CAAE,kDAAiD,CAAC;AACxDC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAACiE,aAAa,CAAC,CAAC,CAAC7B,aAAa,CAAC,CAAC,CAAC;AACrEE,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMsF,QAAQ,GAAG5D,aAAa,CAAC1B,CAAC,CAACN,MAAM,CAAC6F,IAAI,CAAC;EAC7C,MAAM7G,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI4G,QAAQ,CAAC5G,IAAK;AAClB,CAAC;;EAEG,MAAM8G,UAAU;EACd9G,IAAI;EACH;AACP,EAAE8C,oBAAoB,CAAC8D,QAAQ,CAAC7D,KAAK,CAAE;AACvC,EAAE;;EAEE,IAAI6D,QAAQ,CAACf,iBAAiB,KAAK,IAAI,EAAE;IACvCvE,CAAC,CAACE,iCAAiC,CAAC,0BAA0B,CAAC;EACjE;EACA;EACA,IAAIoF,QAAQ,CAAChE,OAAO,KAAK,KAAK,EAAE;IAC9B,MAAMmE,aAAa,GAAG/G,IAAI,GAAI,KAAI;IAClCsB,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAEqF,aAAa,CAAC;EAC5C;EACAzF,CAAC,CAACI,mBAAmB,CAACkF,QAAQ,CAAChE,OAAO,KAAK,IAAI,EAAEkE,UAAU,CAAC;AAC9D,CAAC,CAAC;;AAEJ,SAASE,kBAAkBA,CAACpE,OAAe,EAAEqE,IAAY,EAAW;EAClE,IAAIrE,OAAO,KAAM,QAAO,EAAE;IACxB,OAAO,IAAI;EACb,CAAC,MAAM,IAAIA,OAAO,KAAM,MAAK,EAAE;IAC7B,OAAOqE,IAAI,KAAM,SAAQ,IAAIA,IAAI,KAAM,SAAQ;EACjD;;EAEA;EACA,OAAO,KAAK;AACd;;AAEA,MAAMC,aAAa,GAAG;EACpBC,SAAS,EAAE;IACTC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,EAAC;IACd7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD2E,cAAc,EAAE;IACdH,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,uBAAsB;IACnC7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD4E,iBAAiB,EAAE;IACjBJ,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,0BAAyB;IACtC7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD6E,uBAAuB,EAAE;IACvBL,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,wBAAuB;IACpC7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD8E,0BAA0B,EAAE;IAC1BN,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,2BAA0B;IACvC7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD+E,mBAAmB,EAAE;IACnBP,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDgF,sBAAsB,EAAE;IACtBR,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDiF,kBAAkB,EAAE;IAClBT,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDkF,qBAAqB,EAAE;IACrBV,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDmF,kBAAkB,EAAE;IAClBX,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDoF,qBAAqB,EAAE;IACrBZ,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDqF,eAAe,EAAE;IACfb,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDsF,kBAAkB,EAAE;IAClBd,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDuF,aAAa,EAAE;IACbf,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDwF,wBAAwB,EAAE;IACxBhB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDyF,2BAA2B,EAAE;IAC3BjB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD0F,8BAA8B,EAAE;IAC9BlB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD2F,wBAAwB,EAAE;IACxBnB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD4F,2BAA2B,EAAE;IAC3BpB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD6F,8BAA8B,EAAE;IAC9BrB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD8F,yBAAyB,EAAE;IACzBtB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD+F,uCAAuC,EAAE;IACvCvB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDgG,0CAA0C,EAAE;IAC1CxB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDiG,iBAAiB,EAAE;IACjBzB,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDkG,oBAAoB,EAAE;IACpB1B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDmG,yBAAyB,EAAE;IACzB3B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDoG,2BAA2B,EAAE;IAC3B5B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDqG,iCAAiC,EAAE;IACjC7B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDsG,oCAAoC,EAAE;IACpC9B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDuG,gCAAgC,EAAE;IAChC/B,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDwG,gCAAgC,EAAE;IAChChC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDyG,gCAAgC,EAAE;IAChCjC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACD0G,gCAAgC,EAAE;IAChClC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACD2G,gCAAgC,EAAE;IAChCnC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACd;IACAmD,OAAO,EAAG;EACZ,CAAC;EACD4G,kCAAkC,EAAE;IAClCpC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACD6G,qCAAqC,EAAE;IACrCrC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACD8G,qCAAqC,EAAE;IACrCtC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD+G,wCAAwC,EAAE;IACxCvC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDgH,gCAAgC,EAAE;IAChCxC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDiH,8BAA8B,EAAE;IAC9BzC,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDkH,mBAAmB,EAAE;IACnB1C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDmH,sBAAsB,EAAE;IACtB3C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,MAAK,EAAE;IACdmD,OAAO,EAAG;EACZ,CAAC;EACDoH,wBAAwB,EAAE;IACxB5C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDqH,wBAAwB,EAAE;IACxB7C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDsH,uBAAuB,EAAE;IACvB9C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDuH,mCAAmC,EAAE;IACnC/C,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDwH,mCAAmC,EAAE;IACnChD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDyH,qBAAqB,EAAE;IACrBjD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD0H,wBAAwB,EAAE;IACxBlD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD2H,kCAAkC,EAAE;IAClCnD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD4H,qCAAqC,EAAE;IACrCpD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD6H,0BAA0B,EAAE;IAC1BrD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD8H,6BAA6B,EAAE;IAC7BtD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACD+H,qBAAqB,EAAE;IACrBvD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDgI,wBAAwB,EAAE;IACxBxD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDiI,uBAAuB,EAAE;IACvBzD,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDkI,0BAA0B,EAAE;IAC1B1D,QAAQ,EAAG,KAAI;IACfC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG;AACjB;AACA,MAAM;IACF7H,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAG;EACZ,CAAC;EACDmI,0BAA0B,EAAE;IAC1B3D,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG,2BAA0B;IACvC7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDoI,6BAA6B,EAAE;IAC7B5D,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG,8BAA6B;IAC1C7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDqI,sCAAsC,EAAE;IACtC7D,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG;AACjB,8BAA8B;IAC1B7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDsI,yCAAyC,EAAE;IACzC9D,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG;AACjB,8BAA8B;IAC1B7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDuI,gDAAgD,EAAE;IAChD/D,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,UAAU,EAAG,2BAA0B;IACvC7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDwI,mDAAmD,EAAE;IACnDhE,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,UAAU,EAAG,8BAA6B;IAC1C7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACDyI,+CAA+C,EAAE;IAC/CjE,QAAQ,EAAG,eAAc;IACzBC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,6BAA4B;IACzC7H,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAG;EACZ,CAAC;EACD0I,kDAAkD,EAAE;IAClDlE,QAAQ,EAAG,eAAc;IACzBC,QAAQ,EAAG,EAAC;IACZC,UAAU,EAAG,gCAA+B;IAC5C7H,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAG;EACZ,CAAC;EACD2I,OAAO,EAAE;IACPnE,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ,CAAC;EACD4I,OAAO,EAAE;IACPpE,QAAQ,EAAG,OAAM;IACjBC,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,UAAU,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;IACF7H,IAAI,EAAG,SAAQ;IACfmD,OAAO,EAAG;EACZ;AACF,CAAC;;AAED,MAAM6I,QAAQ,GAAG;EACfC,OAAO,EAAG,EAAC;EACX9I,OAAO,EAAG,qBAAoB;EAC9B+I,UAAU,EAAG;AACf,CAAC;;AAEDvM,CAAC,CAAC0B,IAAI,CAAC,oBAAoB,CAAC;AACzBC,IAAI,CAAE,uCAAsC,CAAC;AAC7CC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAACmI,aAAa,CAAC,CAAC,CAAChG,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAAC0M,QAAQ,CAAC,CAAC,CAAC;AACvFpK,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMsK,SAAS,GAAG1E,aAAa,CAAC5F,CAAC,CAACN,MAAM,CAAC6F,IAAI,CAAC;EAC9C,MAAM7G,IAAI,GAAI;AAClB,EAAE4L,SAAS,CAACvE,QAAS;AACrB;AACA;AACA,qCAAqCuE,SAAS,CAACxE,QAAS;AACxD;AACA,oDAAoDwE,SAAS,CAACxE,QAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYwE,SAAS,CAACxE,QAAS,IAAGqE,QAAQ,CAACnK,CAAC,CAACN,MAAM,CAACiG,IAAI,CAAE;AAC1D;AACA,IAAI2E,SAAS,CAACtE,UAAW;AACzB;AACA,OAAOsE,SAAS,CAACnM,IAAK;AACtB;AACA;AACA;AACA,CAAC;;EAEG,MAAMoM,MAAM,GAAG7E,kBAAkB,CAAC4E,SAAS,CAAChJ,OAAO,EAAEtB,CAAC,CAACN,MAAM,CAACiG,IAAI,CAAC;EACnE,IAAI,CAAC4E,MAAM,EAAE;IACXvK,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAACmK,MAAM,EAAE7L,IAAI,CAAC;AACrC,CAAC,CAAC;;AAEJ,MAAM8L,4BAA4B,GAAG;EACnCC,kBAAkB,EAAE;IAClB/L,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDoJ,qBAAqB,EAAE;IACrBhM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDqJ,qBAAqB,EAAE;IACrBjM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDsJ,wBAAwB,EAAE;IACxBlM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDuJ,2BAA2B,EAAE;IAC3BnM,IAAI,EAAG;AACX;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDwJ,4BAA4B,EAAE;IAC5BpM,IAAI,EAAG;AACX;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACDyJ,mBAAmB,EAAE;IACnBrM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACD0J,sBAAsB,EAAE;IACtBtM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACD2J,sBAAsB,EAAE;IACtBvM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACD4J,yBAAyB,EAAE;IACzBxM,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACD6J,4BAA4B,EAAE;IAC5BzM,IAAI,EAAG;AACX;AACA,KAAK;IACD4C,OAAO,EAAE;EACX,CAAC;EACD8J,6BAA6B,EAAE;IAC7B1M,IAAI,EAAG;AACX;AACA,KAAK;IACD4C,OAAO,EAAE;EACX;AACF,CAAC;;AAED,MAAM+J,kBAAkB,GAAG;EACzBC,iCAAiC,EAAE;IACjCC,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,wBAAwB;IACpBrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDmK,oCAAoC,EAAE;IACpCF,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,wBAAwB;IACpBrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDoK,2BAA2B,EAAE;IAC3BH,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,aAAa;IACTrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDqK,8BAA8B,EAAE;IAC9BJ,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,aAAa;IACTrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDsK,2CAA2C,EAAE;IAC3CL,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,gCAAgC;IAC5BrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDuK,8CAA8C,EAAE;IAC9CN,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,mCAAmC;IAC/BrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDwK,wCAAwC,EAAE;IACxCP,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA,iBAAiB;IACbrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDyK,2CAA2C,EAAE;IAC3CR,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA,iBAAiB;IACbrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACD0K,oBAAoB,EAAE;IACpBT,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,mBAAmB;IACfrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACD2K,oBAAoB,EAAE;IACpBV,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,mBAAmB;IACfrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACD4K,oBAAoB,EAAE;IACpBX,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,mBAAmB;IACfrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACD6K,oBAAoB,EAAE;IACpBZ,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,mBAAmB;IACfrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACD8K,gCAAgC,EAAE;IAChCb,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,gCAAgC;IAC5BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD+K,mCAAmC,EAAE;IACnCd,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,gCAAgC;IAC5BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDgL,mCAAmC,EAAE;IACnCf,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,sCAAsC;IAClCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDiL,sCAAsC,EAAE;IACtChB,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX,sCAAsC;IAClCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDkL,wBAAwB,EAAE;IACxBjB,QAAQ,EAAG;AACf;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX,aAAa;IACTrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDmL,wBAAwB,EAAE;IACxBlB,QAAQ,EAAG;AACf;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX,aAAa;IACTrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDoL,uCAAuC,EAAE;IACvCnB,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,MAAM;IACFrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDqL,2CAA2C,EAAE;IAC3CpB,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,MAAM;IACFrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDsL,2CAA2C,EAAE;IAC3CrB,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,MAAM;IACFrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX,CAAC;EACDuL,0CAA0C,EAAE;IAC1CtB,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,MAAM;IACFrN,IAAI,EAAG,OAAM;IACbmD,OAAO,EAAE;EACX;AACF,CAAC;;AAEDxD,CAAC,CAAC0B,IAAI,CAAC,6BAA6B,CAAC;AAClCC,IAAI,CAAE,kDAAiD,CAAC;AACxDC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAAC4N,kBAAkB,CAAC,CAAC,CAAC;AAC1DtL,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM8M,YAAY,GAAGzB,kBAAkB,CAACrL,CAAC,CAACN,MAAM,CAAC6F,IAAI,CAAC;EACtD,MAAM7G,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEoO,YAAY,CAACvB,QAAS;AACxB;AACA;AACA;AACA,IAAIuB,YAAY,CAACtB,IAAK;AACtB;AACA,OAAOsB,YAAY,CAAC3O,IAAK;AACzB;AACA;AACA;AACA,CAAC;;EAEG,MAAM4O,GAAG,GAAGD,YAAY,CAACxL,OAAO;EAChC,IAAI,CAACyL,GAAG,EAAE;IACR/M,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAAC2M,GAAG,EAAErO,IAAI,CAAC;AAClC,CAAC,CAAC;;AAEJZ,CAAC,CAAC0B,IAAI,CAAC,2BAA2B,CAAC;AAChCC,IAAI,CAAE,gCAA+B,CAAC;AACtCC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAAC+M,4BAA4B,CAAC,CAAC,CAAC;AACpEzK,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMsF,QAAQ,GAAGkF,4BAA4B,CAACxK,CAAC,CAACN,MAAM,CAAC6F,IAAI,CAAC;EAC5D,MAAM7G,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI4G,QAAQ,CAAC5G,IAAK;AAClB;AACA,CAAC;;EAEG,MAAMqO,GAAG,GAAGzH,QAAQ,CAAChE,OAAO;EAC5B,IAAI,CAACyL,GAAG,EAAE;IACR/M,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAAC2M,GAAG,EAAErO,IAAI,CAAC;AAClC,CAAC,CAAC;;AAEJ,MAAMsO,gBAAgB,GAAG;EACvBC,OAAO,EAAE;IACPvO,IAAI,EAAG,IAAG;IACV4C,OAAO,EAAE;EACX,CAAC;EACDA,OAAO,EAAE;IACP5C,IAAI,EAAG,aAAY;IACnB4C,OAAO,EAAE;EACX,CAAC;EACD+I,UAAU,EAAE;IACV3L,IAAI,EAAG,gBAAe;IACtB4C,OAAO,EAAE;EACX,CAAC;EACD4L,aAAa,EAAE;IACbxO,IAAI,EAAG,4BAA2B;IAClC4C,OAAO,EAAE;EACX,CAAC;EACD6L,iBAAiB,EAAE;IACjBzO,IAAI,EAAG,+BAA8B;IACrC4C,OAAO,EAAE;EACX,CAAC;EACD8L,iBAAiB,EAAE;IACjB1O,IAAI,EAAG,+BAA8B;IACrC4C,OAAO,EAAE;EACX,CAAC;EACD+L,cAAc,EAAE;IACd3O,IAAI,EAAG,kBAAiB;IACxB4C,OAAO,EAAE;EACX,CAAC;EACDgM,iBAAiB,EAAE;IACjB5O,IAAI,EAAG,qBAAoB;IAC3B4C,OAAO,EAAE;EACX;AACF,CAAC;;AAED,MAAMiM,OAAO,GAAG;EACdC,IAAI,EAAE;IACJ9O,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDiO,KAAK,EAAE;IACL/O,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDkO,KAAK,EAAE;IACLhP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDmO,GAAG,EAAE;IACHjP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDoO,GAAG,EAAE;IACHlP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDqO,GAAG,EAAE;IACHnP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDsO,EAAE,EAAE;IACFpP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDuO,GAAG,EAAE;IACHrP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACDwO,GAAG,EAAE;IACHtP,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR,CAAC;EACDyO,GAAG,EAAE;IACHvP,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR,CAAC;EACD0O,IAAI,EAAE;IACJxP,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACD2O,SAAS,EAAE;IACTzP,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR,CAAC;EACD4O,OAAO,EAAE;IACP1P,IAAI,EAAE,GAAG;IACTc,IAAI,EAAE;EACR,CAAC;EACD6O,YAAY,EAAE;IACZ3P,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR,CAAC;EACD8O,KAAK,EAAE;IACL5P,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR,CAAC;EACD+O,QAAQ,EAAE;IACR7P,IAAI,EAAE,IAAI;IACVc,IAAI,EAAE;EACR;AACF,CAAC;;AAED1B,CAAC,CAAC0B,IAAI,CAAC,oBAAoB,CAAC;AACzBC,IAAI,CAAE,uCAAsC,CAAC;AAC7CC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAEnC,MAAM,CAACuP,gBAAgB,CAAC,CAAC;AACvCpN,OAAO,CAAC,IAAI,EAAEnC,MAAM,CAACuP,gBAAgB,CAAC,CAAC;AACvCnN,aAAa,CAAC,CAAC;AACfD,OAAO,CAAC,IAAI,EAAEnC,MAAM,CAAC8P,OAAO,CAAC;AAClC,CAAC;AACAxN,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMwO,EAAE,GAAGxB,gBAAgB,CAAChN,CAAC,CAACN,MAAM,CAAC8O,EAAE,CAAC;EACxC,MAAMC,EAAE,GAAGzB,gBAAgB,CAAChN,CAAC,CAACN,MAAM,CAAC+O,EAAE,CAAC;EACxC,MAAMzQ,EAAE,GAAGuP,OAAO,CAACvN,CAAC,CAACN,MAAM,CAAC1B,EAAE,CAAC;EAC/B,MAAMU,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc8P,EAAE,CAAC9P,IAAK,IAAGV,EAAE,CAACU,IAAK,IAAG+P,EAAE,CAAC/P,IAAK;AAC5C,WAAWV,EAAE,CAACwB,IAAK;AACnB;AACA;AACA;AACA,CAAC;;EAEG,MAAMuN,GAAG,GAAGyB,EAAE,CAAClN,OAAO,IAAImN,EAAE,CAACnN,OAAO;EACpC,IAAI,CAACyL,GAAG,EAAE;IACR/M,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAAC2M,GAAG,EAAErO,IAAI,CAAC;AAClC,CAAC,CAAC;;AAEJZ,CAAC,CAAC0B,IAAI,CAAC,mBAAmB,CAAC;AACxBC,IAAI,CAAE,uCAAsC,CAAC;AAC7CC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,GAAG,EAAEnC,MAAM,CAACuP,gBAAgB,CAAC,CAAC;AACtCpN,OAAO,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE,YAAY,EAAE,iBAAiB,CAAU;AACvE,CAAC;AACAG,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAM0O,CAAC,GAAG1B,gBAAgB,CAAChN,CAAC,CAACN,MAAM,CAACgP,CAAC,CAAC;EACtC,MAAMhQ,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgBgQ,CAAC,CAAChQ,IAAK;AACvB;AACA,cAAcsB,CAAC,CAACN,MAAM,CAAC1B,EAAG;AAC1B;AACA;AACA;AACA;AACA,CAAC;;EAEG,MAAM+O,GAAG,GAAG2B,CAAC,CAACpN,OAAO;EACrB,IAAI,CAACyL,GAAG,EAAE;IACR/M,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAAC2M,GAAG,EAAErO,IAAI,CAAC;AAClC,CAAC,CAAC;;AAEJ,MAAMiQ,cAAc,GAAG;EACrBC,cAAc,EAAE;IACdrD,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,mBAAkB;IACzBrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDuN,iBAAiB,EAAE;IACjBtD,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,mBAAkB;IACzBrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDwN,uCAAuC,EAAE;IACvCvD,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG,QAAO;IACdrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDyN,6BAA6B,EAAE;IAC7BxD,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,oCAAmC;IAC1CrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD0N,gCAAgC,EAAE;IAChCzD,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,uCAAsC;IAC7CrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD2N,oBAAoB,EAAE;IACpB1D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,uDAAsD;IAC7DrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD4N,oBAAoB,EAAE;IACpB3D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,0DAAyD;IAChErN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD6N,oBAAoB,EAAE;IACpB5D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,0DAAyD;IAChErN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD8N,oBAAoB,EAAE;IACpB7D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,6DAA4D;IACnErN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD+N,0CAA0C,EAAE;IAC1C9D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG,iFAAgF;IACvFrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDgO,4CAA4C,EAAE;IAC5C/D,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA,MAAM;IACFrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDiO,+CAA+C,EAAE;IAC/ChE,QAAQ,EAAG;AACf;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA,MAAM;IACFrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDkO,gDAAgD,EAAE;IAChDjE,QAAQ,EAAG;AACf;AACA;AACA,MAAM;IACFC,IAAI,EAAG;AACX;AACA;AACA,MAAM;IACFrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDmO,uDAAuD,EAAE;IACvDlE,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG,+BAA8B;IACrCrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDoO,0DAA0D,EAAE;IAC1DnE,QAAQ,EAAG;AACf;AACA;AACA;AACA;AACA,MAAM;IACFC,IAAI,EAAG,kCAAiC;IACxCrN,IAAI,EAAG,cAAa;IACpBmD,OAAO,EAAE;EACX,CAAC;EACDqO,sBAAsB,EAAE;IACtBpE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,qBAAoB;IAC3BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDsO,sBAAsB,EAAE;IACtBrE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,qBAAoB;IAC3BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDuO,4BAA4B,EAAE;IAC5BtE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,2BAA0B;IACjCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDwO,4BAA4B,EAAE;IAC5BvE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,2BAA0B;IACjCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDyO,0BAA0B,EAAE;IAC1BxE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,yBAAwB;IAC/BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD0O,0BAA0B,EAAE;IAC1BzE,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,yBAAwB;IAC/BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD2O,wBAAwB,EAAE;IACxB1E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,uBAAsB;IAC7BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD4O,8BAA8B,EAAE;IAC9B3E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,6BAA4B;IACnCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD6O,4BAA4B,EAAE;IAC5B5E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,2BAA0B;IACjCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD8O,+BAA+B,EAAE;IAC/B7E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,2CAA0C;IACjDrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACD+O,mCAAmC,EAAE;IACnC9E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,kDAAiD;IACxDrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDgP,sCAAsC,EAAE;IACtC/E,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,uDAAsD;IAC7DrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDiP,8CAA8C,EAAE;IAC9ChF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,kCAAiC;IACxCrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDkP,0CAA0C,EAAE;IAC1CjF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,6CAA4C;IACnDrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDmP,iDAAiD,EAAE;IACjDlF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,uDAAsD;IAC7DrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDoP,wCAAwC,EAAE;IACxCnF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,yCAAwC;IAC/CrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDqP,6CAA6C,EAAE;IAC7CpF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,kCAAiC;IACxCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDsP,6CAA6C,EAAE;IAC7CrF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,iCAAgC;IACvCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDuP,8CAA8C,EAAE;IAC9CtF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,mCAAkC;IACzCrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACDwP,+CAA+C,EAAE;IAC/CvF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,kDAAiD;IACxDrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACDyP,8CAA8C,EAAE;IAC9CxF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,qEAAoE;IAC3ErN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACD0P,sDAAsD,EAAE;IACtDzF,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,4DAA2D;IAClErN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD2P,yDAAyD,EAAE;IACzD1F,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,0DAAyD;IAChErN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX,CAAC;EACD4P,gCAAgC,EAAE;IAChC3F,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,sBAAqB;IAC5BrN,IAAI,EAAG,UAAS;IAChBmD,OAAO,EAAE;EACX,CAAC;EACD6P,8CAA8C,EAAE;IAC9C5F,QAAQ,EAAG,EAAC;IACZC,IAAI,EAAG,wBAAuB;IAC9BrN,IAAI,EAAG,YAAW;IAClBmD,OAAO,EAAE;EACX;AACF,CAAC;;AAEDxD,CAAC,CAAC0B,IAAI,CAAC,WAAW,CAAC;AAChBC,IAAI,CAAE,4DAA2D,CAAC;AAClEC,MAAM,CAAC,CAAAC,CAAC,KAAIA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAEnC,MAAM,CAACkR,cAAc,CAAC,CAAC,CAAC;AACtD5O,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMsK,SAAS,GAAGqE,cAAc,CAAC3O,CAAC,CAACN,MAAM,CAAC6F,IAAI,CAAC;EAC/C,MAAM7G,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE4L,SAAS,CAACiB,QAAS;AACrB;AACA;AACA;AACA,IAAIjB,SAAS,CAACkB,IAAK;AACnB;AACA,OAAOlB,SAAS,CAACnM,IAAK;AACtB;AACA;AACA;AACA,CAAC;;EAEG,MAAM4O,GAAG,GAAGzC,SAAS,CAAChJ,OAAO;EAC7B,IAAI,CAACyL,GAAG,EAAE;IACR/M,CAAC,CAACI,mBAAmB,CAAC,IAAI,EAAG,2CAA0C,GAAG1B,IAAI,CAAC;EACjF;EACAsB,CAAC,CAACI,mBAAmB,CAAC2M,GAAG,EAAErO,IAAI,CAAC;AAClC,CAAC,CAAC;;AAEJZ,CAAC,CAAC0B,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI,CAAC,2DAA2D,CAAC;AACjEC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,mBAAmB,EAAE,qBAAqB,EAAE,oBAAoB,CAAU,CAAC;AAC1FA,OAAO,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,IAAI,CAAU;AAC9C,CAAC;AACAG,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMoR,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAYpR,CAAC,CAACN,MAAM,CAAC1B,EAAG,iBAAgBgC,CAAC,CAACN,MAAM,CAAC4B,OAAO,GAAG,SAAS,GAAG,aAAc;AACrF,EAAE;;EAEEtB,CAAC,CAACI,mBAAmB,CAACJ,CAAC,CAACN,MAAM,CAAC4B,OAAO,EAAE8P,IAAI,CAAC;AAC/C,CAAC,CAAC"}