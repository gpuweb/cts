{"version":3,"file":"snippet.js","names":["description","assert","unreachable","compileShouldSucceed","requires_uniformity","condition_is_uniform","verdict","specToCode","spec","matches","match","prefix","parts","end_parts","kind","rest","push","in_continuing","length","current_len","elem","unshift","join","LoopCase","name","code"],"sources":["../../../../../src/webgpu/shader/validation/uniformity/snippet.ts"],"sourcesContent":["export const description = 'Utilities for generating code snippets for uniformity tests';\n\nimport { assert, unreachable } from '../../../../common/util/util.js';\n\nexport type Verdict =\n  // sensitive: fail uniformity analysis if and only if\n  //  - the condition is non-uniform, and\n  //  - the operation requires uniformity\n  | 'sensitive'\n\n  // forbid: fail uniformity analysis if and only if\n  //  - the operation requires uniformity\n  | 'forbid'\n\n  // permit: always passes uniformity analysis\n  | 'permit';\n\nexport function compileShouldSucceed({\n  requires_uniformity,\n  condition_is_uniform,\n  verdict,\n}: {\n  requires_uniformity: boolean;\n  condition_is_uniform: boolean;\n  verdict: Verdict;\n}): boolean {\n  switch (verdict) {\n    case 'sensitive':\n      return !requires_uniformity || condition_is_uniform;\n    case 'forbid':\n      return !requires_uniformity;\n    case 'permit':\n      return true;\n  }\n}\n\nexport type Snippet = {\n  // A unique name for the case.\n  name: string;\n  // A WGSL code sippet that optionally embeds items to replaced later:\n  //   - '<op>', an operation that does or does not require uniformity.\n  //   - '<cond>', a condition which will be uniform or non-uniform\n  code: string;\n  // What is the verdict for this code snippet, after substitution of\n  // the operation and condition.\n  verdict: Verdict;\n};\n\n// We use a small domain-specific language that converts a\n// string into a code snippet.\n//\n// NOTE: If you're confused about this scheme, see the unit tests\n// in src/unittests/uniformity_snippet.spec.ts.  Run them\n// with `npm run unittest`.\n//\n// We process the name from left to right\n// using the following component naming scheme:\n//  <kind-of-loop>, always appears first\n//    'loop'\n//    'for', for-loop with without a condition\n//    'for-unif', for-loop with a uniform loop condition\n//    'for-nonunif', for-loop with a non-uniform loop condition\n//    'while-unif', while-loop with uniform loop condition\n//    'while-nonunif', while-loop with non-uniform loop condition\n// The next components are listed in order they appear in the code.\n//  <interrupt> :\n//    always-break, cond-break,\n//    always-return, cond-return,\n//    always-continue, cond-continue,\n//    The 'cond' variations will use a condition, either uniform\n//    or non-uniform, to be substituted later.\n//  'unif-break': a loop break with uniform loop condition, used\n//    to avoid rejection due to infinite loop checks.\n//  'op':\n//  'continuing': indicates start of continuing block\n//  'end': indicates end of the loop\n\ntype LoopKind = 'loop' | 'for' | 'for-unif' | 'for-nonunif' | 'while-unif' | 'while-nonunif';\n\n// Expand a loop case spec to its shader code\nexport function specToCode(spec: string): string {\n  let matches = spec.match('^(loop|for-unif|for-nonunif|for|while-unif|while-nonunif)-(.*)');\n  assert(matches !== null, `invalid spec string: ${spec}`);\n\n  let prefix = '  ';\n  const parts = [];\n  const end_parts = [prefix, '}\\n']; // closing brace\n\n  const kind = matches[1] as LoopKind;\n  let rest = matches[2];\n  parts.push(prefix);\n  switch (kind) {\n    case 'loop':\n      parts.push('loop {');\n      break;\n    case 'for':\n      parts.push('for (;;) {');\n      break;\n    case 'for-unif':\n      parts.push(`for (;<uniform_cond>;) {`);\n      break;\n    case 'for-nonunif':\n      parts.push(`for (;<nonuniform_cond>;) {`);\n      break;\n    case 'while-unif':\n      parts.push(`while (<uniform_cond>) {`);\n      break;\n    case 'while-nonunif':\n      parts.push(`while (<nonuniform_cond>) {`);\n      break;\n  }\n  parts.push('\\n');\n\n  let in_continuing = false;\n  prefix = '    ';\n  while (rest.length > 0) {\n    const current_len = rest.length;\n    matches = rest.match(\n      '^(op|continuing|end|unif-break|always-break|cond-break|unif-break|always-return|cond-return|always-continue|cond-continue)(-|$)(.*)'\n    );\n    assert(matches !== null, `invalid spec string: ${spec}`);\n    const elem = matches[1];\n    rest = matches[3];\n    assert(rest.length < current_len, `pattern is not shrinking: '${rest}', from ${spec}`);\n    switch (elem) {\n      case 'op':\n        parts.push(prefix, '<op>\\n'); // to be replaced later.\n        break;\n      case 'end': // end the loop\n        if (in_continuing) {\n          prefix = '    ';\n        }\n        prefix = '  ';\n        parts.push(...end_parts);\n        end_parts.length = 0;\n        in_continuing = false;\n        break;\n      case 'continuing':\n        parts.push(prefix, 'continuing {\\n');\n        end_parts.unshift(prefix, '}\\n');\n        in_continuing = true;\n        prefix = '      ';\n        break;\n      case 'unif-break':\n        assert(!in_continuing);\n        parts.push(prefix, `if <uniform_cond> {break;}\\n`);\n        break;\n      case 'always-break':\n        assert(!in_continuing);\n        parts.push(prefix, 'break;\\n');\n        break;\n      case 'cond-break':\n        if (in_continuing) {\n          parts.push(prefix, `break if <cond>;\\n`);\n        } else {\n          parts.push(prefix, `if <cond> {break;}\\n`);\n        }\n        break;\n      case 'always-return':\n        assert(!in_continuing);\n        parts.push(prefix, 'return;\\n');\n        break;\n      case 'cond-return':\n        assert(!in_continuing);\n        parts.push(prefix, `if <cond> {return;}\\n`);\n        break;\n      case 'always-continue':\n        assert(!in_continuing);\n        parts.push(prefix, 'continue;\\n');\n        break;\n      case 'cond-continue':\n        assert(!in_continuing);\n        parts.push(prefix, `if <cond> {continue;}\\n`);\n        break;\n      default:\n        unreachable(`invalid loop case spec ${spec}`);\n    }\n  }\n  parts.push(...end_parts);\n  return parts.join('');\n}\n\n// Creates a Snippet from a loop spec string and a verdict.\nexport function LoopCase(spec: string, verdict: Verdict): Snippet {\n  return { name: spec, verdict, code: specToCode(spec) };\n}\n"],"mappings":"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"}