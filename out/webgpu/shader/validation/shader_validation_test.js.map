{"version":3,"file":"shader_validation_test.js","names":["keysOf","AllFeaturesMaxLimitsGPUTest","UniqueFeaturesOrLimitsGPUTest","kEnables","f16","subgroups","clip_distances","kEnableREs","Object","entries","map","enableName","feature","re","RegExp","skipIfCodeNeedsFeatureAndDeviceDoesNotHaveFeature","t","code","test","skipIfDeviceDoesNotHaveFeature","ShaderValidationTest","expectCompileResult","expectedResult","options","autoSkipIfFeatureNotAvailable","shaderModule","expectGPUError","device","createShaderModule","error","Error","eventualAsyncExpectation","compilationInfo","getCompilationInfo","messagesLog","messages","m","lineNum","linePos","type","message","join","some","rec","validationFailed","debug","expectCompileWarning","expectWarning","expectPipelineResult","args","phonies","statements","undefined","push","constants","c","reference","createComputePipeline","layout","compute","module","entryPoint","wrapInEntryPoint","enabledExtensions","enableDirectives","x","UniqueFeaturesAndLimitsShaderValidationTest"],"sources":["../../../../src/webgpu/shader/validation/shader_validation_test.ts"],"sourcesContent":["import { keysOf } from '../../../common/util/data_tables.js';\nimport {\n  AllFeaturesMaxLimitsGPUTest,\n  GPUTest,\n  UniqueFeaturesOrLimitsGPUTest,\n} from '../../gpu_test.js';\n\nconst kEnables: Record<string, GPUFeatureName> = {\n  f16: 'shader-f16',\n  subgroups: 'subgroups' as GPUFeatureName,\n  clip_distances: 'clip-distances' as GPUFeatureName,\n};\n\n/**\n * Note: These regular expressions are not meant to be perfect. This is not production code expecting\n * to work with any WGSL passed by a user. It's only test code for working with WGSL written\n * in the CTS. A CTS test for which these regular expressions don't work should use a different set of\n * testing functions or options that don't use these regular expressions.\n */\nconst kEnableREs = Object.entries(kEnables).map(([enableName, feature]) => {\n  return {\n    re: new RegExp(`\\\\benable\\\\s+(?:\\\\s*\\\\w+\\\\s*,)*\\\\s*${enableName}\\\\s*(?:,\\\\s*\\\\w+)*\\\\s*;`),\n    feature,\n  };\n});\n\n/**\n * Note: This function is not meant to be perfect. This is not production code expecting\n * to work with any WGSL passed by a user. It's only test code for working with WGSL written\n * in the CTS. A CTS test for which this check doesn't work can choose a different set of\n * testing functions or options that don't take this path.\n */\nfunction skipIfCodeNeedsFeatureAndDeviceDoesNotHaveFeature(t: GPUTest, code: string) {\n  for (const { re, feature } of kEnableREs) {\n    if (re.test(code)) {\n      t.skipIfDeviceDoesNotHaveFeature(feature);\n    }\n  }\n}\n\n/**\n * Base fixture for WGSL shader validation tests.\n */\nexport class ShaderValidationTest extends AllFeaturesMaxLimitsGPUTest {\n  /**\n   * Add a test expectation for whether a createShaderModule call succeeds or not.\n   * Note: skips test if 'enable X' exists in code and X's corresponding feature does not exist on device\n   * unless you pass in autoSkipIfFeatureNotAvailable: false.\n   *\n   * @example\n   * ```ts\n   * t.expectCompileResult(true, `wgsl code`); // Expect success\n   * t.expectCompileResult(false, `wgsl code`); // Expect validation error with any error string\n   * ```\n   */\n  expectCompileResult(\n    expectedResult: boolean,\n    code: string,\n    options?: { autoSkipIfFeatureNotAvailable?: boolean } // defaults to true\n  ) {\n    if (options?.autoSkipIfFeatureNotAvailable !== false) {\n      skipIfCodeNeedsFeatureAndDeviceDoesNotHaveFeature(this, code);\n    }\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      expectedResult !== true\n    );\n\n    const error = new Error();\n    this.eventualAsyncExpectation(async () => {\n      const compilationInfo = await shaderModule!.getCompilationInfo();\n\n      // MAINTENANCE_TODO: Pretty-print error messages with source context.\n      const messagesLog =\n        compilationInfo.messages\n          .map(m => `${m.lineNum}:${m.linePos}: ${m.type}: ${m.message}`)\n          .join('\\n') +\n        '\\n\\n---- shader ----\\n' +\n        code;\n\n      if (compilationInfo.messages.some(m => m.type === 'error')) {\n        if (expectedResult) {\n          error.message = `Unexpected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `Found expected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      } else {\n        if (!expectedResult) {\n          error.message = `Missing expected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `No compilationInfo 'error' messages, as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a test expectation for whether a createShaderModule call issues a warning.\n   *\n   * @example\n   * ```ts\n   * t.expectCompileWarning(true, `wgsl code`); // Expect compile success and any warning message\n   * t.expectCompileWarning(false, `wgsl code`); // Expect compile success and no warning messages\n   * ```\n   */\n  expectCompileWarning(expectWarning: boolean, code: string) {\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      false\n    );\n\n    const error = new Error();\n    this.eventualAsyncExpectation(async () => {\n      const compilationInfo = await shaderModule!.getCompilationInfo();\n\n      // MAINTENANCE_TODO: Pretty-print error messages with source context.\n      const messagesLog = compilationInfo.messages\n        .map(m => `${m.lineNum}:${m.linePos}: ${m.type}: ${m.message}`)\n        .join('\\n');\n\n      if (compilationInfo.messages.some(m => m.type === 'warning')) {\n        if (expectWarning) {\n          error.message = `No 'warning' message as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        } else {\n          error.message = `Missing expected compilationInfo 'warning' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        }\n      } else {\n        if (expectWarning) {\n          error.message = `Missing expected 'warning' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `Found a 'warning' message as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a test expectation for whether a createComputePipeline call succeeds or not.\n   * Note: skips test if 'enable X' exists in code and X's corresponding feature does not exist on device\n   * unless you pass in autoSkipIfFeatureNotAvailable: false\n   */\n  expectPipelineResult(args: {\n    // True if the pipeline should build without error\n    expectedResult: boolean;\n    // The WGSL shader code\n    code: string;\n    // Pipeline overridable constants\n    constants?: Record<string, GPUPipelineConstantValue>;\n    // List of additional module-scope variable the entrypoint needs to reference\n    reference?: string[];\n    // List of additional statements to insert in the entry point.\n    statements?: string[];\n    // Skip tests when WGSL code has 'enable X' and feature for 'X' is not available on device\n    autoSkipIfFeatureNotAvailable?: boolean; // defaults to true. You must set to false to turn this off.\n  }) {\n    const phonies: Array<string> = [];\n\n    if (args.statements !== undefined) {\n      phonies.push(...args.statements);\n    }\n    if (args.constants !== undefined) {\n      phonies.push(...keysOf(args.constants).map(c => `_ = ${c};`));\n    }\n    if (args.reference !== undefined) {\n      phonies.push(...args.reference.map(c => `_ = ${c};`));\n    }\n\n    const code =\n      args.code +\n      `\n@compute @workgroup_size(1)\nfn main() {\n  ${phonies.join('\\n')}\n}`;\n\n    if (args.autoSkipIfFeatureNotAvailable !== false) {\n      skipIfCodeNeedsFeatureAndDeviceDoesNotHaveFeature(this, code);\n    }\n\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      false\n    );\n\n    this.expectGPUError(\n      'validation',\n      () => {\n        this.device.createComputePipeline({\n          layout: 'auto',\n          compute: { module: shaderModule!, entryPoint: 'main', constants: args.constants },\n        });\n      },\n      !args.expectedResult\n    );\n  }\n\n  /**\n   * Wraps the code fragment into an entry point.\n   *\n   * @example\n   * ```ts\n   * t.wrapInEntryPoint(`var i = 0;`);\n   * ```\n   */\n  wrapInEntryPoint(code: string, enabledExtensions: string[] = []) {\n    const enableDirectives = enabledExtensions.map(x => `enable ${x};`).join('\\n      ');\n\n    return `\n      ${enableDirectives}\n\n      @compute @workgroup_size(1)\n      fn main() {\n        ${code}\n      }`;\n  }\n}\n\n// MAINTENANCE_TODO: Merge this with implementation above.\n// NOTE: These things should probably not inherit. There is no relationship between\n// these functions and a test. They could just as easily take a GPUTest as the first\n// argument and then the all the problems associated with inheritance would disappear.\nexport class UniqueFeaturesAndLimitsShaderValidationTest extends UniqueFeaturesOrLimitsGPUTest {\n  /**\n   * Add a test expectation for whether a createShaderModule call succeeds or not.\n   *\n   * @example\n   * ```ts\n   * t.expectCompileResult(true, `wgsl code`); // Expect success\n   * t.expectCompileResult(false, `wgsl code`); // Expect validation error with any error string\n   * ```\n   */\n  expectCompileResult(expectedResult: boolean, code: string) {\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      expectedResult !== true\n    );\n\n    const error = new Error();\n    this.eventualAsyncExpectation(async () => {\n      const compilationInfo = await shaderModule!.getCompilationInfo();\n\n      // MAINTENANCE_TODO: Pretty-print error messages with source context.\n      const messagesLog =\n        compilationInfo.messages\n          .map(m => `${m.lineNum}:${m.linePos}: ${m.type}: ${m.message}`)\n          .join('\\n') +\n        '\\n\\n---- shader ----\\n' +\n        code;\n\n      if (compilationInfo.messages.some(m => m.type === 'error')) {\n        if (expectedResult) {\n          error.message = `Unexpected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `Found expected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      } else {\n        if (!expectedResult) {\n          error.message = `Missing expected compilationInfo 'error' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `No compilationInfo 'error' messages, as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a test expectation for whether a createShaderModule call issues a warning.\n   *\n   * @example\n   * ```ts\n   * t.expectCompileWarning(true, `wgsl code`); // Expect compile success and any warning message\n   * t.expectCompileWarning(false, `wgsl code`); // Expect compile success and no warning messages\n   * ```\n   */\n  expectCompileWarning(expectWarning: boolean, code: string) {\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      false\n    );\n\n    const error = new Error();\n    this.eventualAsyncExpectation(async () => {\n      const compilationInfo = await shaderModule!.getCompilationInfo();\n\n      // MAINTENANCE_TODO: Pretty-print error messages with source context.\n      const messagesLog = compilationInfo.messages\n        .map(m => `${m.lineNum}:${m.linePos}: ${m.type}: ${m.message}`)\n        .join('\\n');\n\n      if (compilationInfo.messages.some(m => m.type === 'warning')) {\n        if (expectWarning) {\n          error.message = `No 'warning' message as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        } else {\n          error.message = `Missing expected compilationInfo 'warning' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        }\n      } else {\n        if (expectWarning) {\n          error.message = `Missing expected 'warning' message.\\n` + messagesLog;\n          this.rec.validationFailed(error);\n        } else {\n          error.message = `Found a 'warning' message as expected.\\n` + messagesLog;\n          this.rec.debug(error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a test expectation for whether a createComputePipeline call succeeds or not.\n   */\n  expectPipelineResult(args: {\n    // True if the pipeline should build without error\n    expectedResult: boolean;\n    // The WGSL shader code\n    code: string;\n    // Pipeline overridable constants\n    constants?: Record<string, GPUPipelineConstantValue>;\n    // List of additional module-scope variable the entrypoint needs to reference\n    reference?: string[];\n    // List of additional statements to insert in the entry point.\n    statements?: string[];\n  }) {\n    const phonies: Array<string> = [];\n\n    if (args.statements !== undefined) {\n      phonies.push(...args.statements);\n    }\n    if (args.constants !== undefined) {\n      phonies.push(...keysOf(args.constants).map(c => `_ = ${c};`));\n    }\n    if (args.reference !== undefined) {\n      phonies.push(...args.reference.map(c => `_ = ${c};`));\n    }\n\n    const code =\n      args.code +\n      `\n@compute @workgroup_size(1)\nfn main() {\n  ${phonies.join('\\n')}\n}`;\n\n    let shaderModule: GPUShaderModule;\n    this.expectGPUError(\n      'validation',\n      () => {\n        shaderModule = this.device.createShaderModule({ code });\n      },\n      false\n    );\n\n    this.expectGPUError(\n      'validation',\n      () => {\n        this.device.createComputePipeline({\n          layout: 'auto',\n          compute: { module: shaderModule!, entryPoint: 'main', constants: args.constants },\n        });\n      },\n      !args.expectedResult\n    );\n  }\n\n  /**\n   * Wraps the code fragment into an entry point.\n   *\n   * @example\n   * ```ts\n   * t.wrapInEntryPoint(`var i = 0;`);\n   * ```\n   */\n  wrapInEntryPoint(code: string, enabledExtensions: string[] = []) {\n    const enableDirectives = enabledExtensions.map(x => `enable ${x};`).join('\\n      ');\n\n    return `\n      ${enableDirectives}\n\n      @compute @workgroup_size(1)\n      fn main() {\n        ${code}\n      }`;\n  }\n}\n"],"mappings":"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"}