{"version":3,"file":"bitwise_complement.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","kAllScalarsAndVectors","scalarTypeOf","Type","ShaderValidationTest","g","kScalarAndVectorTypes","test","desc","params","u","combine","beginSubcases","fn","t","type","elementTy","hasF16","f16","code","create","wgsl","expectCompileResult","abstractInt","i32","u32","includes","kInvalidTypes","mat2x2f","expr","control","e","array","ptr","atomic","texture","sampler","struct"],"sources":["../../../../../../src/webgpu/shader/validation/expression/unary/bitwise_complement.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for bitwise complement expressions.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport { kAllScalarsAndVectors, scalarTypeOf, Type } from '../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector')\n  .desc(\n    `\n  Validates that scalar and vector bitwise complement expressions are only accepted for integers.\n  `\n  )\n  .params(u => u.combine('type', keysOf(kScalarAndVectorTypes)).beginSubcases())\n  .fn(t => {\n    const type = kScalarAndVectorTypes[t.params.type];\n    const elementTy = scalarTypeOf(type);\n    const hasF16 = elementTy === Type.f16;\n    const code = `\n${hasF16 ? 'enable f16;' : ''}\nconst rhs = ${type.create(0).wgsl()};\nconst foo = ~rhs;\n`;\n\n    t.expectCompileResult([Type.abstractInt, Type.i32, Type.u32].includes(elementTy), code);\n  });\n\ninterface InvalidTypeConfig {\n  // An expression that produces a value of the target type.\n  expr: string;\n  // A function that converts an expression of the target type into a valid complement operand.\n  control: (x: string) => string;\n}\nconst kInvalidTypes: Record<string, InvalidTypeConfig> = {\n  mat2x2f: {\n    expr: 'm',\n    control: e => `i32(${e}[0][0])`,\n  },\n\n  array: {\n    expr: 'arr',\n    control: e => `${e}[0]`,\n  },\n\n  ptr: {\n    expr: '(&u)',\n    control: e => `*${e}`,\n  },\n\n  atomic: {\n    expr: 'a',\n    control: e => `atomicLoad(&${e})`,\n  },\n\n  texture: {\n    expr: 't',\n    control: e => `i32(textureLoad(${e}, vec2(), 0).x)`,\n  },\n\n  sampler: {\n    expr: 's',\n    control: e => `i32(textureSampleLevel(t, ${e}, vec2(), 0).x)`,\n  },\n\n  struct: {\n    expr: 'str',\n    control: e => `${e}.u`,\n  },\n};\n\ng.test('invalid_types')\n  .desc(\n    `\n  Validates that bitwise complement expressions are never accepted for non-scalar and non-vector types.\n  `\n  )\n  .params(u =>\n    u.combine('type', keysOf(kInvalidTypes)).combine('control', [true, false]).beginSubcases()\n  )\n  .fn(t => {\n    const type = kInvalidTypes[t.params.type];\n    const expr = t.params.control ? type.control(type.expr) : type.expr;\n    const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { u : u32 }\n\nvar<private> u : u32;\nvar<private> m : mat2x2f;\nvar<private> arr : array<u32, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ~${expr};\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n"],"mappings":"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"}