{"version":3,"file":"address_of_and_indirection.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kAddressSpaces","kAccessModes","kStorageTypes","kCompositeTypes","kDerefTypes","deref_address_of_identifier","wgsl","requires_pointer_composite_access","deref_pointer","address_of_identifier","pointer","test","desc","params","u","combine","filter","t","storageType","addressSpace","derefType","beforeAllSubcases","selectDeviceOrSkipTestCase","requiredFeatures","fn","isLocal","deref","commaAccessMode","accessMode","varDecl","expectCompileResult","beginSubcases","compositeType","shouldPass","hasLanguageFeature","kInvalidCases","address_of_let","address_of_texture","address_of_sampler","address_of_function","address_of_vector_elem_via_member","address_of_vector_elem_via_index","address_of_matrix_elem","deref_non_pointer","case"],"sources":["../../../../../../src/webgpu/shader/validation/expression/unary/address_of_and_indirection.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for unary address-of and indirection (dereference)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kAddressSpaces = ['function', 'private', 'workgroup', 'uniform', 'storage'];\nconst kAccessModes = ['read', 'read_write'];\nconst kStorageTypes = ['bool', 'u32', 'i32', 'f32', 'f16'];\nconst kCompositeTypes = ['array', 'struct', 'vec', 'mat'];\nconst kDerefTypes = {\n  deref_address_of_identifier: {\n    wgsl: `(*(&a))`,\n    requires_pointer_composite_access: false,\n  },\n  deref_pointer: {\n    wgsl: `(*p)`,\n    requires_pointer_composite_access: false,\n  },\n  address_of_identifier: {\n    wgsl: `(&a)`,\n    requires_pointer_composite_access: true,\n  },\n  pointer: {\n    wgsl: `p`,\n    requires_pointer_composite_access: true,\n  },\n};\n\ng.test('basic')\n  .desc(\n    `Validates address-of (&) every supported variable type, ensuring the type is correct by\n    assigning to an explicitly typed pointer. Also validates dereferencing the reference,\n    ensuring the type is correct by assigning to an explicitly typed variable.`\n  )\n  .params(u =>\n    u\n      .combine('addressSpace', kAddressSpaces)\n      .combine('accessMode', kAccessModes)\n      .combine('storageType', kStorageTypes)\n      .combine('derefType', keysOf(kDerefTypes))\n      .filter(t => {\n        if (t.storageType === 'bool') {\n          return t.addressSpace === 'function' || t.addressSpace === 'private';\n        }\n        return true;\n      })\n      .filter(t => {\n        // This test does not test composite access\n        return !kDerefTypes[t.derefType].requires_pointer_composite_access;\n      })\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.storageType === 'f16') {\n      t.selectDeviceOrSkipTestCase({ requiredFeatures: ['shader-f16'] });\n    }\n  })\n  .fn(t => {\n    const isLocal = t.params.addressSpace === 'function';\n    const deref = kDerefTypes[t.params.derefType];\n    // Only specify access mode for storage buffers\n    const commaAccessMode = t.params.addressSpace === 'storage' ? `, ${t.params.accessMode}` : '';\n\n    let varDecl = '';\n    if (t.params.addressSpace === 'uniform' || t.params.addressSpace === 'storage') {\n      varDecl += '@group(0) @binding(0) ';\n    }\n    varDecl += `var<${t.params.addressSpace}${commaAccessMode}> a : VarType;`;\n\n    const wgsl = `\n      ${t.params.storageType === 'f16' ? 'enable f16;' : ''}\n\n      alias VarType = ${t.params.storageType};\n      alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n\n      ${isLocal ? '' : varDecl}\n\n      fn foo() {\n        ${isLocal ? varDecl : ''}\n        let p : PtrType = &a;\n        var deref : VarType = ${deref.wgsl};\n      }\n    `;\n\n    t.expectCompileResult(true, wgsl);\n  });\n\ng.test('composite')\n  .desc(\n    `Validates address-of (&) every supported variable type for composite types, ensuring the type\n    is correct by assigning to an explicitly typed pointer. Also validates dereferencing the\n    reference followed by member/index access, ensuring the type is correct by assigning to an\n    explicitly typed variable.`\n  )\n  .params(u =>\n    u\n      .combine('addressSpace', kAddressSpaces)\n      .combine('compositeType', kCompositeTypes)\n      .combine('storageType', kStorageTypes)\n      .beginSubcases()\n      .combine('derefType', keysOf(kDerefTypes))\n      .combine('accessMode', kAccessModes)\n      .filter(t => {\n        if (t.storageType === 'bool') {\n          return t.addressSpace === 'function' || t.addressSpace === 'private';\n        }\n        return true;\n      })\n      .filter(t => {\n        if (t.compositeType === 'mat') {\n          return t.storageType === 'f32' || t.storageType === 'f16';\n        }\n        return true;\n      })\n  )\n  .beforeAllSubcases(t => {\n    if (t.params.storageType === 'f16') {\n      t.selectDeviceOrSkipTestCase({ requiredFeatures: ['shader-f16'] });\n    }\n  })\n  .fn(t => {\n    const isLocal = t.params.addressSpace === 'function';\n    const deref = kDerefTypes[t.params.derefType];\n    // Only specify access mode for storage buffers\n    const commaAccessMode = t.params.addressSpace === 'storage' ? `, ${t.params.accessMode}` : '';\n\n    let varDecl = '';\n    if (t.params.addressSpace === 'uniform' || t.params.addressSpace === 'storage') {\n      varDecl += '@group(0) @binding(0) ';\n    }\n    varDecl += `var<${t.params.addressSpace}${commaAccessMode}> a : VarType;`;\n\n    let wgsl = `\n          ${t.params.storageType === 'f16' ? 'enable f16;' : ''}`;\n\n    switch (t.params.compositeType) {\n      case 'array':\n        wgsl += `\n          struct S { @align(16) member : ${t.params.storageType} }\n          alias VarType = array<S, 10>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref : ${t.params.storageType} = ${deref.wgsl}[0].member;\n          }`;\n        break;\n      case 'struct':\n        wgsl += `\n          struct S { member : ${t.params.storageType} }\n          alias VarType = S;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref : ${t.params.storageType} = ${deref.wgsl}.member;\n          }`;\n        break;\n      case 'vec':\n        wgsl += `\n          alias VarType = vec3<${t.params.storageType}>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref_member : ${t.params.storageType} = ${deref.wgsl}.x;\n            var deref_index : ${t.params.storageType} = ${deref.wgsl}[0];\n          }`;\n        break;\n      case 'mat':\n        wgsl += `\n          alias VarType = mat2x3<${t.params.storageType}>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref_vec : vec3<${t.params.storageType}> = ${deref.wgsl}[0];\n            var deref_elem : ${t.params.storageType} = ${deref.wgsl}[0][0];\n          }`;\n        break;\n    }\n\n    let shouldPass = true;\n    if (\n      kDerefTypes[t.params.derefType].requires_pointer_composite_access &&\n      !t.hasLanguageFeature('pointer_composite_access')\n    ) {\n      shouldPass = false;\n    }\n\n    t.expectCompileResult(shouldPass, wgsl);\n  });\n\nconst kInvalidCases = {\n  address_of_let: `\n    let a = 1;\n    let p = &a;`,\n  address_of_texture: `\n    let p = &t;`,\n  address_of_sampler: `\n    let p = &s;`,\n  address_of_function: `\n    let p = &func;`,\n  address_of_vector_elem_via_member: `\n    var a : vec3<f32>();\n    let p = &a.x;`,\n  address_of_vector_elem_via_index: `\n    var a : vec3<f32>();\n    let p = &a[0];`,\n  address_of_matrix_elem: `\n    var a : mat2x3<f32>();\n    let p = &a[0][0];`,\n  deref_non_pointer: `\n    var a = 1;\n    let p = *a;\n  `,\n};\ng.test('invalid')\n  .desc('Test invalid cases of unary address-of and dereference')\n  .params(u => u.combine('case', keysOf(kInvalidCases)))\n  .fn(t => {\n    const wgsl = `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n      fn func() {}\n      fn main() {\n        ${kInvalidCases[t.params.case]}\n      }\n    `;\n    t.expectCompileResult(false, wgsl);\n  });\n"],"mappings":"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"}