{"version":3,"file":"short_circuiting_and_or.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","kAllScalarsAndVectors","ScalarType","scalarTypeOf","Type","ShaderValidationTest","g","kScalarAndVectorTypes","test","desc","params","u","combine","filter","value","startsWith","beginSubcases","fn","t","lhs","rhs","lhsElement","rhsElement","hasF16","f16","code","create","wgsl","op","valid","bool","expectCompileResult","kInvalidTypes","mat2x2f","expr","control","e","array","ptr","atomic","texture","sampler","struct","type","kLhsForShortCircuit","kInvalidRhsExpressions","overflow","div_zero_i32","div_zero_f32","builtin","short_circuit","code_entry","constants","expectPipelineResult","expectedResult","statements","reference","op_a","op_b","op_a_or","op_b_or","cond_a_val","cond_b_val","evals_rhs","kInvalidArrayCounts","negative","sqrt_neg1","nested","a_val","b_val","cond_val"],"sources":["../../../../../../src/webgpu/shader/validation/expression/binary/short_circuiting_and_or.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for short-circuiting && and || expressions.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport {\n  kAllScalarsAndVectors,\n  ScalarType,\n  scalarTypeOf,\n  Type,\n} from '../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector')\n  .desc(\n    `\n  Validates that scalar and vector short-circuiting operators are only accepted for scalar booleans.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('lhs', keysOf(kScalarAndVectorTypes))\n      .combine(\n        'rhs',\n        // Skip vec3 and vec4 on the RHS to keep the number of subcases down.\n        keysOf(kScalarAndVectorTypes).filter(\n          value => !(value.startsWith('vec3') || value.startsWith('vec4'))\n        )\n      )\n      .beginSubcases()\n  )\n  .fn(t => {\n    const lhs = kScalarAndVectorTypes[t.params.lhs];\n    const rhs = kScalarAndVectorTypes[t.params.rhs];\n    const lhsElement = scalarTypeOf(lhs);\n    const rhsElement = scalarTypeOf(rhs);\n    const hasF16 = lhsElement === Type.f16 || rhsElement === Type.f16;\n    const code = `\n${hasF16 ? 'enable f16;' : ''}\nconst lhs = ${lhs.create(0).wgsl()};\nconst rhs = ${rhs.create(0).wgsl()};\nconst foo = lhs ${t.params.op} rhs;\n`;\n\n    // Determine if the types are compatible.\n    let valid = false;\n    if (lhs instanceof ScalarType && rhs instanceof ScalarType) {\n      valid = lhsElement === Type.bool && rhsElement === Type.bool;\n    }\n\n    t.expectCompileResult(valid, code);\n  });\n\ninterface InvalidTypeConfig {\n  // An expression that produces a value of the target type.\n  expr: string;\n  // A function that converts an expression of the target type into a valid boolean operand.\n  control: (x: string) => string;\n}\nconst kInvalidTypes: Record<string, InvalidTypeConfig> = {\n  mat2x2f: {\n    expr: 'm',\n    control: e => `bool(${e}[0][0])`,\n  },\n\n  array: {\n    expr: 'arr',\n    control: e => `${e}[0]`,\n  },\n\n  ptr: {\n    expr: '(&b)',\n    control: e => `*${e}`,\n  },\n\n  atomic: {\n    expr: 'a',\n    control: e => `bool(atomicLoad(&${e}))`,\n  },\n\n  texture: {\n    expr: 't',\n    control: e => `bool(textureLoad(${e}, vec2(), 0).x)`,\n  },\n\n  sampler: {\n    expr: 's',\n    control: e => `bool(textureSampleLevel(t, ${e}, vec2(), 0).x)`,\n  },\n\n  struct: {\n    expr: 'str',\n    control: e => `${e}.b`,\n  },\n};\n\ng.test('invalid_types')\n  .desc(\n    `\n  Validates that short-circuiting expressions are never accepted for non-scalar and non-vector types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('type', keysOf(kInvalidTypes))\n      .combine('control', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const type = kInvalidTypes[t.params.type];\n    const expr = t.params.control ? type.control(type.expr) : type.expr;\n    const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { b : bool }\n\nvar<private> b : bool;\nvar<private> m : mat2x2f;\nvar<private> arr : array<bool, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${expr} ${t.params.op} ${expr};\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n\n// A map from operator to the value of the LHS that will cause short-circuiting.\nconst kLhsForShortCircuit: Record<string, boolean> = {\n  '&&': false,\n  '||': true,\n};\n\n// A list of expressions that are invalid unless guarded by a short-circuiting expression.\nconst kInvalidRhsExpressions: Record<string, string> = {\n  overflow: 'i32(1<<thirty_one) < 0',\n  div_zero_i32: '(1 / zero_i32) == 0',\n  div_zero_f32: '(one_f32 / 0) == 0',\n  builtin: 'sqrt(-one_f32) == 0',\n};\n\ng.test('invalid_rhs_const')\n  .desc(\n    `\n  Validates that a short-circuiting expression with a const-expression LHS guards the evaluation of its RHS expression.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('rhs', keysOf(kInvalidRhsExpressions))\n      .combine('short_circuit', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    let lhs = kLhsForShortCircuit[t.params.op];\n    if (!t.params.short_circuit) {\n      lhs = !lhs;\n    }\n    const code = `\nconst thirty_one = 31u;\nconst zero_i32 = 0i;\nconst one_f32 = 1.0f;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${lhs} ${t.params.op} ${kInvalidRhsExpressions[t.params.rhs]};\n}\n`;\n\n    t.expectCompileResult(t.params.short_circuit, code);\n  });\n\ng.test('invalid_rhs_fn_override')\n  .desc(\n    `\nValidates that a short-circuiting expression in functions with a override-expression LHS guards the evaluation of its RHS expression.\n`\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('rhs', keysOf(kInvalidRhsExpressions))\n      .combine('short_circuit', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    let lhs = kLhsForShortCircuit[t.params.op];\n    if (!t.params.short_circuit) {\n      lhs = !lhs;\n    }\n    const code = `\noverride cond : bool;\noverride thirty_one = 31u;\noverride zero_i32 = 0i;\noverride one_f32 = 1.0f;`;\n    const code_entry = `let foo = cond ${t.params.op} ${kInvalidRhsExpressions[t.params.rhs]};`;\n    const constants: Record<string, number> = {};\n    constants['cond'] = lhs ? 1 : 0;\n    t.expectPipelineResult({\n      expectedResult: t.params.short_circuit,\n      code,\n      constants,\n      statements: [code_entry],\n    });\n  });\n\ng.test('invalid_rhs_override')\n  .desc(\n    `\n  Validates that a short-circuiting expression with an override-expression LHS guards the evaluation of its RHS expression.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('rhs', keysOf(kInvalidRhsExpressions))\n      .combine('short_circuit', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    let lhs = kLhsForShortCircuit[t.params.op];\n    if (!t.params.short_circuit) {\n      lhs = !lhs;\n    }\n    const code = `\noverride cond : bool;\noverride zero_i32 = 0i;\noverride one_f32 = 1.0f;\noverride thirty_one = 31u;\noverride foo = cond ${t.params.op} ${kInvalidRhsExpressions[t.params.rhs]};\n`;\n\n    const constants: Record<string, number> = {};\n    constants['cond'] = lhs ? 1 : 0;\n    t.expectPipelineResult({\n      expectedResult: t.params.short_circuit,\n      code,\n      constants,\n      reference: ['foo'],\n    });\n  });\n\ng.test('nested_invalid_rhs_override')\n  .desc(\n    `\n  Validates that nested short-circuiting expressions with an override-expression LHS guards the evaluation of its RHS expression.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op_a', ['&&', '||'])\n      .combine('op_b', ['&&', '||'])\n      .combine('cond_a_val', [false, true])\n      .combine('cond_b_val', [false, true])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const code = `\noverride cond_a : bool;\noverride cond_b : bool;\noverride zero_i32 = 0i;\n`;\n    const code_entry = `let foo = (cond_a ${t.params.op_a}  cond_b ) ${t.params.op_b}   (1 / zero_i32) == 0;`;\n    const op_a_or = kLhsForShortCircuit[t.params.op_a];\n    const op_b_or = kLhsForShortCircuit[t.params.op_b];\n    const constants: Record<string, number> = {};\n    constants['cond_a'] = t.params.cond_a_val ? 1 : 0;\n    constants['cond_b'] = t.params.cond_b_val ? 1 : 0;\n    const lhs = op_a_or\n      ? t.params.cond_a_val || t.params.cond_b_val\n      : t.params.cond_a_val && t.params.cond_b_val;\n    const evals_rhs = op_b_or ? !lhs : lhs;\n    t.expectPipelineResult({\n      expectedResult: !evals_rhs,\n      code,\n      constants,\n      statements: [code_entry],\n    });\n  });\n\n// A list of expressions that are invalid unless guarded by a short-circuiting expression.\n// The control case will use `value = 10`, the failure case will use `value = 1`.\nconst kInvalidArrayCounts: Record<string, string> = {\n  negative: 'value - 2',\n  sqrt_neg1: 'u32(sqrt(value - 2))',\n  nested: '10 + array<i32, value - 2>()[0]',\n};\n\ng.test('invalid_array_count_on_rhs')\n  .desc(\n    `\n  Validates that an invalid array count expression is not guarded by a short-circuiting expression.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', ['&&', '||'])\n      .combine('rhs', keysOf(kInvalidArrayCounts))\n      .combine('control', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const lhs = t.params.op === '&&' ? 'false' : 'true';\n    const code = `\nconst value = ${t.params.control ? '10' : '1'};\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${lhs} ${t.params.op} array<bool, ${kInvalidArrayCounts[t.params.rhs]}>()[0];\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n\ng.test('array_override')\n  .desc(\n    `\n  Validates that override initializing expressions works in conjunction with arrays\n  `\n  )\n  .params(u =>\n    u.combine('op', ['&&', '||']).combine('a_val', [0, 1]).combine('b_val', [0, 1]).beginSubcases()\n  )\n  .fn(t => {\n    const code = `\noverride a_val:i32;\noverride b_val:i32;\noverride bad_size = (a_val - 10);\noverride good_size = (b_val + 10);\nvar<workgroup> zero_array:array<i32, select(bad_size, good_size, a_val == 1 ${t.params.op} b_val == 1 )>;\n`;\n    const code_entry = `let foo = zero_array[0];`;\n    const op_a_or = kLhsForShortCircuit[t.params.op];\n    const constants: Record<string, number> = {};\n    constants['a_val'] = t.params.a_val;\n    constants['b_val'] = t.params.b_val;\n    const cond_val = op_a_or\n      ? t.params.a_val === 1 || t.params.b_val === 1\n      : t.params.a_val === 1 && t.params.b_val === 1;\n\n    t.expectPipelineResult({\n      expectedResult: cond_val,\n      code,\n      constants,\n      statements: [code_entry],\n    });\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,+CAA+C;AAC7E,SAASC,MAAM,EAAEC,eAAe,QAAQ,2CAA2C;AACnF;EACEC,qBAAqB;EACrBC,UAAU;EACVC,YAAY;EACZC,IAAI;AACC,gCAAgC;AACvC,SAASC,oBAAoB,QAAQ,iCAAiC;;AAEtE,OAAO,MAAMC,CAAC,GAAGR,aAAa,CAACO,oBAAoB,CAAC;;AAEpD;AACA,MAAME,qBAAqB,GAAGP,eAAe,CAACC,qBAAqB,CAAC;;AAEpEK,CAAC,CAACE,IAAI,CAAC,eAAe,CAAC;AACpBC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,KAAK,EAAEb,MAAM,CAACQ,qBAAqB,CAAC,CAAC;AAC7CK,OAAO;EACN,KAAK;EACL;EACAb,MAAM,CAACQ,qBAAqB,CAAC,CAACM,MAAM;IAClC,CAAAC,KAAK,KAAI,EAAEA,KAAK,CAACC,UAAU,CAAC,MAAM,CAAC,IAAID,KAAK,CAACC,UAAU,CAAC,MAAM,CAAC;EACjE;AACF,CAAC;AACAC,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,GAAG,GAAGZ,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACS,GAAG,CAAC;EAC/C,MAAMC,GAAG,GAAGb,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACU,GAAG,CAAC;EAC/C,MAAMC,UAAU,GAAGlB,YAAY,CAACgB,GAAG,CAAC;EACpC,MAAMG,UAAU,GAAGnB,YAAY,CAACiB,GAAG,CAAC;EACpC,MAAMG,MAAM,GAAGF,UAAU,KAAKjB,IAAI,CAACoB,GAAG,IAAIF,UAAU,KAAKlB,IAAI,CAACoB,GAAG;EACjE,MAAMC,IAAI,GAAI;AAClB,EAAEF,MAAM,GAAG,aAAa,GAAG,EAAG;AAC9B,cAAcJ,GAAG,CAACO,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE;AACnC,cAAcP,GAAG,CAACM,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAE;AACnC,kBAAkBT,CAAC,CAACR,MAAM,CAACkB,EAAG;AAC9B,CAAC;;EAEG;EACA,IAAIC,KAAK,GAAG,KAAK;EACjB,IAAIV,GAAG,YAAYjB,UAAU,IAAIkB,GAAG,YAAYlB,UAAU,EAAE;IAC1D2B,KAAK,GAAGR,UAAU,KAAKjB,IAAI,CAAC0B,IAAI,IAAIR,UAAU,KAAKlB,IAAI,CAAC0B,IAAI;EAC9D;;EAEAZ,CAAC,CAACa,mBAAmB,CAACF,KAAK,EAAEJ,IAAI,CAAC;AACpC,CAAC,CAAC;;;;;;;;AAQJ,MAAMO,aAAgD,GAAG;EACvDC,OAAO,EAAE;IACPC,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAAAC,CAAC,KAAK,QAAOA,CAAE;EAC1B,CAAC;;EAEDC,KAAK,EAAE;IACLH,IAAI,EAAE,KAAK;IACXC,OAAO,EAAEA,CAAAC,CAAC,KAAK,GAAEA,CAAE;EACrB,CAAC;;EAEDE,GAAG,EAAE;IACHJ,IAAI,EAAE,MAAM;IACZC,OAAO,EAAEA,CAAAC,CAAC,KAAK,IAAGA,CAAE;EACtB,CAAC;;EAEDG,MAAM,EAAE;IACNL,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAAAC,CAAC,KAAK,oBAAmBA,CAAE;EACtC,CAAC;;EAEDI,OAAO,EAAE;IACPN,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAAAC,CAAC,KAAK,oBAAmBA,CAAE;EACtC,CAAC;;EAEDK,OAAO,EAAE;IACPP,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAAAC,CAAC,KAAK,8BAA6BA,CAAE;EAChD,CAAC;;EAEDM,MAAM,EAAE;IACNR,IAAI,EAAE,KAAK;IACXC,OAAO,EAAEA,CAAAC,CAAC,KAAK,GAAEA,CAAE;EACrB;AACF,CAAC;;AAED9B,CAAC,CAACE,IAAI,CAAC,eAAe,CAAC;AACpBC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,MAAM,EAAEb,MAAM,CAACiC,aAAa,CAAC,CAAC;AACtCpB,OAAO,CAAC,SAAS,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACjCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMyB,IAAI,GAAGX,aAAa,CAACd,CAAC,CAACR,MAAM,CAACiC,IAAI,CAAC;EACzC,MAAMT,IAAI,GAAGhB,CAAC,CAACR,MAAM,CAACyB,OAAO,GAAGQ,IAAI,CAACR,OAAO,CAACQ,IAAI,CAACT,IAAI,CAAC,GAAGS,IAAI,CAACT,IAAI;EACnE,MAAMT,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAcS,IAAK,IAAGhB,CAAC,CAACR,MAAM,CAACkB,EAAG,IAAGM,IAAK;AAC1C;AACA,CAAC;;EAEGhB,CAAC,CAACa,mBAAmB,CAACb,CAAC,CAACR,MAAM,CAACyB,OAAO,EAAEV,IAAI,CAAC;AAC/C,CAAC,CAAC;;AAEJ;AACA,MAAMmB,mBAA4C,GAAG;EACnD,IAAI,EAAE,KAAK;EACX,IAAI,EAAE;AACR,CAAC;;AAED;AACA,MAAMC,sBAA8C,GAAG;EACrDC,QAAQ,EAAE,wBAAwB;EAClCC,YAAY,EAAE,qBAAqB;EACnCC,YAAY,EAAE,oBAAoB;EAClCC,OAAO,EAAE;AACX,CAAC;;AAED3C,CAAC,CAACE,IAAI,CAAC,mBAAmB,CAAC;AACxBC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,KAAK,EAAEb,MAAM,CAAC8C,sBAAsB,CAAC,CAAC;AAC9CjC,OAAO,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAIC,GAAG,GAAGyB,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAACkB,EAAE,CAAC;EAC1C,IAAI,CAACV,CAAC,CAACR,MAAM,CAACwC,aAAa,EAAE;IAC3B/B,GAAG,GAAG,CAACA,GAAG;EACZ;EACA,MAAMM,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAcN,GAAI,IAAGD,CAAC,CAACR,MAAM,CAACkB,EAAG,IAAGiB,sBAAsB,CAAC3B,CAAC,CAACR,MAAM,CAACU,GAAG,CAAE;AACzE;AACA,CAAC;;EAEGF,CAAC,CAACa,mBAAmB,CAACb,CAAC,CAACR,MAAM,CAACwC,aAAa,EAAEzB,IAAI,CAAC;AACrD,CAAC,CAAC;;AAEJnB,CAAC,CAACE,IAAI,CAAC,yBAAyB,CAAC;AAC9BC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,KAAK,EAAEb,MAAM,CAAC8C,sBAAsB,CAAC,CAAC;AAC9CjC,OAAO,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAIC,GAAG,GAAGyB,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAACkB,EAAE,CAAC;EAC1C,IAAI,CAACV,CAAC,CAACR,MAAM,CAACwC,aAAa,EAAE;IAC3B/B,GAAG,GAAG,CAACA,GAAG;EACZ;EACA,MAAMM,IAAI,GAAI;AAClB;AACA;AACA;AACA,yBAAyB;EACrB,MAAM0B,UAAU,GAAI,kBAAiBjC,CAAC,CAACR,MAAM,CAACkB,EAAG,IAAGiB,sBAAsB,CAAC3B,CAAC,CAACR,MAAM,CAACU,GAAG,CAAE,GAAE;EAC3F,MAAMgC,SAAiC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC,MAAM,CAAC,GAAGjC,GAAG,GAAG,CAAC,GAAG,CAAC;EAC/BD,CAAC,CAACmC,oBAAoB,CAAC;IACrBC,cAAc,EAAEpC,CAAC,CAACR,MAAM,CAACwC,aAAa;IACtCzB,IAAI;IACJ2B,SAAS;IACTG,UAAU,EAAE,CAACJ,UAAU;EACzB,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEJ7C,CAAC,CAACE,IAAI,CAAC,sBAAsB,CAAC;AAC3BC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,KAAK,EAAEb,MAAM,CAAC8C,sBAAsB,CAAC,CAAC;AAC9CjC,OAAO,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,IAAIC,GAAG,GAAGyB,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAACkB,EAAE,CAAC;EAC1C,IAAI,CAACV,CAAC,CAACR,MAAM,CAACwC,aAAa,EAAE;IAC3B/B,GAAG,GAAG,CAACA,GAAG;EACZ;EACA,MAAMM,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA,sBAAsBP,CAAC,CAACR,MAAM,CAACkB,EAAG,IAAGiB,sBAAsB,CAAC3B,CAAC,CAACR,MAAM,CAACU,GAAG,CAAE;AAC1E,CAAC;;EAEG,MAAMgC,SAAiC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC,MAAM,CAAC,GAAGjC,GAAG,GAAG,CAAC,GAAG,CAAC;EAC/BD,CAAC,CAACmC,oBAAoB,CAAC;IACrBC,cAAc,EAAEpC,CAAC,CAACR,MAAM,CAACwC,aAAa;IACtCzB,IAAI;IACJ2B,SAAS;IACTI,SAAS,EAAE,CAAC,KAAK;EACnB,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEJlD,CAAC,CAACE,IAAI,CAAC,6BAA6B,CAAC;AAClCC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7BA,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7BA,OAAO,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACpCA,OAAO,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACpCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMO,IAAI,GAAI;AAClB;AACA;AACA;AACA,CAAC;EACG,MAAM0B,UAAU,GAAI,qBAAoBjC,CAAC,CAACR,MAAM,CAAC+C,IAAK,cAAavC,CAAC,CAACR,MAAM,CAACgD,IAAK,yBAAwB;EACzG,MAAMC,OAAO,GAAGf,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAAC+C,IAAI,CAAC;EAClD,MAAMG,OAAO,GAAGhB,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAACgD,IAAI,CAAC;EAClD,MAAMN,SAAiC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC,QAAQ,CAAC,GAAGlC,CAAC,CAACR,MAAM,CAACmD,UAAU,GAAG,CAAC,GAAG,CAAC;EACjDT,SAAS,CAAC,QAAQ,CAAC,GAAGlC,CAAC,CAACR,MAAM,CAACoD,UAAU,GAAG,CAAC,GAAG,CAAC;EACjD,MAAM3C,GAAG,GAAGwC,OAAO;EACfzC,CAAC,CAACR,MAAM,CAACmD,UAAU,IAAI3C,CAAC,CAACR,MAAM,CAACoD,UAAU;EAC1C5C,CAAC,CAACR,MAAM,CAACmD,UAAU,IAAI3C,CAAC,CAACR,MAAM,CAACoD,UAAU;EAC9C,MAAMC,SAAS,GAAGH,OAAO,GAAG,CAACzC,GAAG,GAAGA,GAAG;EACtCD,CAAC,CAACmC,oBAAoB,CAAC;IACrBC,cAAc,EAAE,CAACS,SAAS;IAC1BtC,IAAI;IACJ2B,SAAS;IACTG,UAAU,EAAE,CAACJ,UAAU;EACzB,CAAC,CAAC;AACJ,CAAC,CAAC;;AAEJ;AACA;AACA,MAAMa,mBAA2C,GAAG;EAClDC,QAAQ,EAAE,WAAW;EACrBC,SAAS,EAAE,sBAAsB;EACjCC,MAAM,EAAE;AACV,CAAC;;AAED7D,CAAC,CAACE,IAAI,CAAC,4BAA4B,CAAC;AACjCC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC;AACEC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3BA,OAAO,CAAC,KAAK,EAAEb,MAAM,CAACiE,mBAAmB,CAAC,CAAC;AAC3CpD,OAAO,CAAC,SAAS,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACjCI,aAAa,CAAC;AACnB,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMC,GAAG,GAAGD,CAAC,CAACR,MAAM,CAACkB,EAAE,KAAK,IAAI,GAAG,OAAO,GAAG,MAAM;EACnD,MAAMH,IAAI,GAAI;AAClB,gBAAgBP,CAAC,CAACR,MAAM,CAACyB,OAAO,GAAG,IAAI,GAAG,GAAI;AAC9C;AACA;AACA;AACA,cAAchB,GAAI,IAAGD,CAAC,CAACR,MAAM,CAACkB,EAAG,gBAAeoC,mBAAmB,CAAC9C,CAAC,CAACR,MAAM,CAACU,GAAG,CAAE;AAClF;AACA,CAAC;;EAEGF,CAAC,CAACa,mBAAmB,CAACb,CAAC,CAACR,MAAM,CAACyB,OAAO,EAAEV,IAAI,CAAC;AAC/C,CAAC,CAAC;;AAEJnB,CAAC,CAACE,IAAI,CAAC,gBAAgB,CAAC;AACrBC,IAAI;EACF;AACL;AACA;AACE,CAAC;AACAC,MAAM,CAAC,CAAAC,CAAC;AACPA,CAAC,CAACC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACI,aAAa,CAAC;AAChG,CAAC;AACAC,EAAE,CAAC,CAAAC,CAAC,KAAI;EACP,MAAMO,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA,8EAA8EP,CAAC,CAACR,MAAM,CAACkB,EAAG;AAC1F,CAAC;EACG,MAAMuB,UAAU,GAAI,0BAAyB;EAC7C,MAAMQ,OAAO,GAAGf,mBAAmB,CAAC1B,CAAC,CAACR,MAAM,CAACkB,EAAE,CAAC;EAChD,MAAMwB,SAAiC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC,OAAO,CAAC,GAAGlC,CAAC,CAACR,MAAM,CAAC0D,KAAK;EACnChB,SAAS,CAAC,OAAO,CAAC,GAAGlC,CAAC,CAACR,MAAM,CAAC2D,KAAK;EACnC,MAAMC,QAAQ,GAAGX,OAAO;EACpBzC,CAAC,CAACR,MAAM,CAAC0D,KAAK,KAAK,CAAC,IAAIlD,CAAC,CAACR,MAAM,CAAC2D,KAAK,KAAK,CAAC;EAC5CnD,CAAC,CAACR,MAAM,CAAC0D,KAAK,KAAK,CAAC,IAAIlD,CAAC,CAACR,MAAM,CAAC2D,KAAK,KAAK,CAAC;;EAEhDnD,CAAC,CAACmC,oBAAoB,CAAC;IACrBC,cAAc,EAAEgB,QAAQ;IACxB7C,IAAI;IACJ2B,SAAS;IACTG,UAAU,EAAE,CAACJ,UAAU;EACzB,CAAC,CAAC;AACJ,CAAC,CAAC"}