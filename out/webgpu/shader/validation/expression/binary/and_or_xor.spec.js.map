{"version":3,"file":"and_or_xor.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","concreteTypeOf","isAbstractType","isConvertible","isIntegerType","kAllScalarsAndVectors","scalarTypeOf","Type","ShaderValidationTest","resultType","g","kOperators","and","op","supportsBool","or","xor","kScalarAndVectorTypes","test","desc","params","u","combine","filter","value","startsWith","beginSubcases","fn","t","lhs","rhs","lhsElement","rhsElement","hasBool","bool","hasF16","f16","resType","canConvertScalarToVector","resTypeIsTypeable","code","compound_assignment","create","wgsl","valid","expectCompileResult","kInvalidTypes","mat2x2f","expr","control","e","array","ptr","atomic","texture","sampler","struct","type"],"sources":["../../../../../../src/webgpu/shader/validation/expression/binary/and_or_xor.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for logical and bitwise and/or/xor expressions.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport {\n  concreteTypeOf,\n  isAbstractType,\n  isConvertible,\n  isIntegerType,\n  kAllScalarsAndVectors,\n  scalarTypeOf,\n  Type,\n} from '../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nimport { resultType } from './result_type.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of operators and a flag for whether they support boolean values or not.\nconst kOperators = {\n  and: { op: '&', supportsBool: true },\n  or: { op: '|', supportsBool: true },\n  xor: { op: '^', supportsBool: false },\n};\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector')\n  .desc(\n    `\n  Validates that scalar and vector expressions are only accepted for bool or compatible integer types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('lhs', keysOf(kScalarAndVectorTypes))\n      .combine(\n        'rhs',\n        // Skip vec3 and vec4 on the RHS to keep the number of subcases down.\n        // vec3 + vec3 and vec4 + vec4 is tested in execution tests.\n        keysOf(kScalarAndVectorTypes).filter(\n          value => !(value.startsWith('vec3') || value.startsWith('vec4'))\n        )\n      )\n      .combine('compound_assignment', [false, true] as const)\n      .beginSubcases()\n      .combine('op', keysOf(kOperators))\n  )\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const lhs = kScalarAndVectorTypes[t.params.lhs];\n    const rhs = kScalarAndVectorTypes[t.params.rhs];\n    const lhsElement = scalarTypeOf(lhs);\n    const rhsElement = scalarTypeOf(rhs);\n    const hasBool = lhsElement === Type.bool || rhsElement === Type.bool;\n    const hasF16 = lhsElement === Type.f16 || rhsElement === Type.f16;\n    const resType =\n      (isIntegerType(lhsElement) && isIntegerType(rhsElement)) || (hasBool && op.supportsBool)\n        ? resultType({ lhs, rhs, canConvertScalarToVector: false })\n        : null;\n    const resTypeIsTypeable = resType && !isAbstractType(scalarTypeOf(resType));\n    const code = t.params.compound_assignment\n      ? `\n${hasF16 ? 'enable f16;' : ''}\nfn f() {\n  var foo = ${lhs.create(0).wgsl()};\n  foo ${op.op}= ${rhs.create(0).wgsl()};\n}\n`\n      : `\n${hasF16 ? 'enable f16;' : ''}\nconst lhs = ${lhs.create(0).wgsl()};\nconst rhs = ${rhs.create(0).wgsl()};\nconst foo ${resTypeIsTypeable ? `: ${resType}` : ''} = lhs ${op.op} rhs;\n`;\n\n    let valid = resType !== null;\n    if (valid && t.params.compound_assignment) {\n      valid = valid && isConvertible(resType!, concreteTypeOf(lhs));\n    }\n\n    t.expectCompileResult(valid, code);\n  });\n\ninterface InvalidTypeConfig {\n  // An expression that produces a value of the target type.\n  expr: string;\n  // A function that converts an expression of the target type into a valid integer operand.\n  control: (x: string) => string;\n}\nconst kInvalidTypes: Record<string, InvalidTypeConfig> = {\n  mat2x2f: {\n    expr: 'm',\n    control: e => `i32(${e}[0][0])`,\n  },\n\n  array: {\n    expr: 'arr',\n    control: e => `${e}[0]`,\n  },\n\n  ptr: {\n    expr: '(&u)',\n    control: e => `*${e}`,\n  },\n\n  atomic: {\n    expr: 'a',\n    control: e => `atomicLoad(&${e})`,\n  },\n\n  texture: {\n    expr: 't',\n    control: e => `i32(textureLoad(${e}, vec2(), 0).x)`,\n  },\n\n  sampler: {\n    expr: 's',\n    control: e => `i32(textureSampleLevel(t, ${e}, vec2(), 0).x)`,\n  },\n\n  struct: {\n    expr: 'str',\n    control: e => `${e}.u`,\n  },\n};\n\ng.test('invalid_types')\n  .desc(\n    `\n  Validates that expressions are never accepted for non-scalar and non-vector types.\n  `\n  )\n  .params(u =>\n    u\n      .combine('op', keysOf(kOperators))\n      .combine('type', keysOf(kInvalidTypes))\n      .combine('control', [true, false])\n      .beginSubcases()\n  )\n  .fn(t => {\n    const op = kOperators[t.params.op];\n    const type = kInvalidTypes[t.params.type];\n    const expr = t.params.control ? type.control(type.expr) : type.expr;\n    const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { u : u32 }\n\nvar<private> u : u32;\nvar<private> m : mat2x2f;\nvar<private> arr : array<i32, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${expr} ${op.op} ${expr};\n}\n`;\n\n    t.expectCompileResult(t.params.control, code);\n  });\n"],"mappings":"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"}