{"version":3,"file":"structure.spec.js","names":["description","makeTestGroup","ShaderValidationTest","g","test","desc","params","u","combine","fn","t","code","decl","expectCompileResult","types","i","length","beforeAllSubcases","selectDeviceOrSkipTestCase"],"sources":["../../../../../../src/webgpu/shader/validation/expression/access/structure.spec.ts"],"sourcesContent":["export const description = `\nValidation tests for structure access expressions.\n\n* Correct result type\n* Identifier matching\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('identifier_mismatch')\n  .desc('Tests that the member identifier must match a member in the declaration')\n  .params(u => u.combine('decl', ['value', 'ref'] as const))\n  .fn(t => {\n    const code = `\n    struct S {\n      x : u32\n    }\n    fn foo() {\n      ${t.params.decl === 'value' ? 'let' : 'var'} v : S = S();\n      _ = v.y;\n    }`;\n    t.expectCompileResult(false, code);\n  });\n\ng.test('shadowed_member')\n  .desc('Tests that other declarations do not interfere with member determination')\n  .params(u => u.combine('decl', ['value', 'ref'] as const))\n  .fn(t => {\n    const code = `\n    struct S {\n      x : u32\n    }\n    fn foo() {\n      var x : i32;\n      ${t.params.decl === 'value' ? 'let' : 'var'} v : S = S();\n      let tmp : u32 = v.x;\n    }`;\n    t.expectCompileResult(true, code);\n  });\n\ng.test('result_type')\n  .desc('Tests correct result types are returned')\n  .params(u => u.combine('decl', ['value', 'ref'] as const))\n  .fn(t => {\n    const types = [\n      'i32',\n      'u32',\n      'f32',\n      'bool',\n      'array<u32, 4>',\n      'array<T, 2>',\n      'vec2f',\n      'vec3u',\n      'vec4i',\n      'mat2x2f',\n      'T',\n    ];\n    let code = `\n    struct T {\n      a : f32\n    }\n    struct S {\\n`;\n\n    for (let i = 0; i < types.length; i++) {\n      code += `m${i} : ${types[i]},\\n`;\n    }\n\n    code += `}\n    fn foo() {\n      var x : i32;\n      ${t.params.decl === 'value' ? 'let' : 'var'} v : S = S();\\n`;\n\n    for (let i = 0; i < types.length; i++) {\n      code += `let tmp${i} : ${types[i]} = v.m${i};\\n`;\n    }\n\n    code += `}`;\n    t.expectCompileResult(true, code);\n  });\n\ng.test('result_type_f16')\n  .desc('Tests correct type is returned for f16')\n  .params(u => u.combine('decl', ['value', 'ref'] as const))\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  })\n  .fn(t => {\n    const code = `\n    enable f16;\n    struct S {\n      x : f16\n    }\n    fn foo() {\n      ${t.params.decl === 'value' ? 'let' : 'var'} v : S = S();\n      let tmp : f16 = v.x;\n    }`;\n    t.expectCompileResult(true, code);\n  });\n\ng.test('result_type_runtime_array')\n  .desc('Tests correct type is returned for runtime arrays')\n  .fn(t => {\n    const code = `\n    struct S {\n      x : array<u32>\n    }\n    @group(0) @binding(0) var<storage> v : S;\n    fn foo() {\n      let tmp : u32 = v.x[0];\n      let tmp_ptr : ptr<storage, array<u32>> = &v.x;\n    }`;\n    t.expectCompileResult(true, code);\n  });\n"],"mappings":"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"}