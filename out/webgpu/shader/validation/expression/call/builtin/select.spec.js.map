{"version":3,"file":"select.spec.js","names":["builtin","description","makeTestGroup","keysOf","objectsToRecord","Type","concreteTypeOf","isConvertible","kAllScalarsAndVectors","ShaderValidationTest","validateConstOrOverrideBuiltinEval","g","kArgumentTypes","test","desc","params","u","combine","fn","t","type1","type2","returnType","undefined","create","bool","type","i32","kTests","valid","src","pass","alias","u32","f32","f16","mixed_aint_afloat","mixed_i32_u32","vec_bool","vec2_bool_implicit","vec3_bool_implicit","vec_i32","vec_u32","vec_f32","vec_f16","matrix","atomic","array","array_runtime","struct","enumerant","ptr","ptr_deref","sampler","texture","no_args","too_few_args","too_many_args","use_it","use","expectCompileResult","enables","includes","code"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/select.spec.ts"],"sourcesContent":["const builtin = 'select';\nexport const description = `\nValidation tests for the ${builtin}() builtin.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../../common/util/data_tables.js';\nimport {\n  Type,\n  concreteTypeOf,\n  isConvertible,\n  kAllScalarsAndVectors,\n} from '../../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nimport { validateConstOrOverrideBuiltinEval } from './const_override_validation.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kArgumentTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('argument_types_1_and_2')\n  .desc(\n    `\nValidates that scalar and vector arguments are not rejected by ${builtin}() for args 1 and 2\n`\n  )\n  .params(u => u.combine('type1', keysOf(kArgumentTypes)).combine('type2', keysOf(kArgumentTypes)))\n  .fn(t => {\n    const type1 = kArgumentTypes[t.params.type1];\n    const type2 = kArgumentTypes[t.params.type2];\n    // First and second arg must be the same or one convertible to the other.\n    // Note that we specify a concrete return type even if both args are abstract.\n    const returnType = isConvertible(type1, type2)\n      ? concreteTypeOf(type2)\n      : isConvertible(type2, type1)\n      ? concreteTypeOf(type1)\n      : undefined;\n    validateConstOrOverrideBuiltinEval(\n      t,\n      builtin,\n      /* expectedResult */ returnType !== undefined,\n      [type1.create(0), type2.create(0), Type.bool.create(0)],\n      'constant',\n      returnType\n    );\n  });\n\ng.test('argument_types_3')\n  .desc(\n    `\nValidates that third argument must be bool for ${builtin}()\n`\n  )\n  .params(u => u.combine('type', keysOf(kArgumentTypes)))\n  .fn(t => {\n    const type = kArgumentTypes[t.params.type];\n    validateConstOrOverrideBuiltinEval(\n      t,\n      builtin,\n      /* expectedResult */ type === Type.bool,\n      [Type.i32.create(0), Type.i32.create(0), type.create(0)],\n      'constant',\n      /*return_type*/ Type.i32\n    );\n  });\n\nconst kTests = {\n  valid: {\n    src: `_ = ${builtin}(1, 2, true);`,\n    pass: true,\n  },\n  alias: {\n    src: `_ = ${builtin}(i32_alias(1), i32_alias(2), bool_alias(true));`,\n    pass: true,\n  },\n  bool: {\n    src: `_ = ${builtin}(false, false, true);`,\n    pass: true,\n  },\n  i32: {\n    src: `_ = ${builtin}(1i, 1i, true);`,\n    pass: true,\n  },\n  u32: {\n    src: `_ = ${builtin}(1u, 1u, true);`,\n    pass: true,\n  },\n  f32: {\n    src: `_ = ${builtin}(1.0f, 1.0f, true);`,\n    pass: true,\n  },\n  f16: {\n    src: `_ = ${builtin}(1.0h, 1.0h, true);`,\n    pass: true,\n  },\n  mixed_aint_afloat: {\n    src: `_ = ${builtin}(1, 1.0, true);`,\n    pass: true,\n  },\n  mixed_i32_u32: {\n    src: `_ = ${builtin}(1i, 1u, true);`,\n    pass: false,\n  },\n  vec_bool: {\n    src: `_ = ${builtin}(vec2<bool>(false, true), vec2<bool>(false, true), true);`,\n    pass: true,\n  },\n  vec2_bool_implicit: {\n    src: `_ = ${builtin}(vec2(false, true), vec2(false, true), true);`,\n    pass: true,\n  },\n  vec3_bool_implicit: {\n    src: `_ = ${builtin}(vec3(false), vec3(true), true);`,\n    pass: true,\n  },\n  vec_i32: {\n    src: `_ = ${builtin}(vec2<i32>(1, 1), vec2<i32>(1, 1), true);`,\n    pass: true,\n  },\n  vec_u32: {\n    src: `_ = ${builtin}(vec2<u32>(1, 1), vec2<u32>(1, 1), true);`,\n    pass: true,\n  },\n  vec_f32: {\n    src: `_ = ${builtin}(vec2<f32>(1, 1), vec2<f32>(1, 1), true);`,\n    pass: true,\n  },\n  vec_f16: {\n    src: `_ = ${builtin}(vec2<f16>(1, 1), vec2<f16>(1, 1), true);`,\n    pass: true,\n  },\n  matrix: {\n    src: `_ = ${builtin}(mat2x2(1, 1, 1, 1), mat2x2(1, 1, 1, 1), true);`,\n    pass: false,\n  },\n  atomic: {\n    src: ` _ = ${builtin}(a, a, true);`,\n    pass: false,\n  },\n  array: {\n    src: `var a: array<bool, 5>;\n            _ = ${builtin}(a, a, true);`,\n    pass: false,\n  },\n  array_runtime: {\n    src: `_ = ${builtin}(k.arry, k.arry, true);`,\n    pass: false,\n  },\n  struct: {\n    src: `var a: A;\n            _ = ${builtin}(a, a, true);`,\n    pass: false,\n  },\n  enumerant: {\n    src: `_ = ${builtin}(read_write, read_write, true);`,\n    pass: false,\n  },\n  ptr: {\n    src: `var<function> a = true;\n            let p: ptr<function, bool> = &a;\n            _ = ${builtin}(p, p, true);`,\n    pass: false,\n  },\n  ptr_deref: {\n    src: `var<function> a = true;\n            let p: ptr<function, bool> = &a;\n            _ = ${builtin}(*p, *p, true);`,\n    pass: true,\n  },\n  sampler: {\n    src: `_ = ${builtin}(s, s, true);`,\n    pass: false,\n  },\n  texture: {\n    src: `_ = ${builtin}(t, t, true);`,\n    pass: false,\n  },\n  no_args: {\n    src: `_ = ${builtin}();`,\n    pass: false,\n  },\n  too_few_args: {\n    src: `_ = ${builtin}(1, true);`,\n    pass: false,\n  },\n  too_many_args: {\n    src: `_ = ${builtin}(1, 1, 1, true);`,\n    pass: false,\n  },\n};\n\ng.test('must_use')\n  .desc(`Result of ${builtin} must be used`)\n  .params(u => u.combine('use', [true, false]))\n  .fn(t => {\n    const use_it = t.params.use ? '_ = ' : '';\n    t.expectCompileResult(t.params.use, `fn f() { ${use_it}${builtin}(1, 2, true); }`);\n  });\n\ng.test('arguments')\n  .desc(`Test that ${builtin} is validated correctly.`)\n  .params(u => u.combine('test', keysOf(kTests)))\n  .fn(t => {\n    const src = kTests[t.params.test].src;\n    const enables = t.params.test.includes('f16') ? 'enable f16;' : '';\n    const code = `\n  ${enables}\n  alias bool_alias = bool;\n  alias i32_alias = i32;\n\n  @group(0) @binding(0) var s: sampler;\n  @group(0) @binding(1) var t: texture_2d<f32>;\n\n  var<workgroup> a: atomic<u32>;\n\n  struct A {\n    i: bool,\n  }\n  struct B {\n    arry: array<u32>,\n  }\n  @group(0) @binding(3) var<storage> k: B;\n\n  @vertex\n  fn main() -> @builtin(position) vec4<f32> {\n    ${src}\n    return vec4<f32>(.4, .2, .3, .1);\n  }`;\n    t.expectCompileResult(kTests[t.params.test].pass, code);\n  });\n"],"mappings":"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"}