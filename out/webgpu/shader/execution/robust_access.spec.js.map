{"version":3,"file":"robust_access.spec.js","names":["description","makeTestGroup","assert","Float16Array","AllFeaturesMaxLimitsGPUTest","align","generateTypes","supportedScalarTypes","supportsAtomics","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","enables","stage","testSource","layout","testBindings","dynamicOffsets","GPUShaderStage","COMPUTE","constantsBuffer","createBufferTracked","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","device","createShaderModule","code","pipeline","createComputePipelineAsync","compute","entryPoint","group","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f16","f32","Float32Array","BYTES_PER_ELEMENT","fill","test","desc","params","u","combineWithParams","addressSpace","storageMode","access","dynamicOffset","containerType","shadowingMode","expand","p","beginSubcases","expandWithParams","fn","isAtomic","baseType","_kTypeInfo","skipIfDeviceDoesNotHaveFeature","undefined","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","testGroupBGLEntires","alignment","qualifiers","push","visibility","hasDynamicOffset","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","arrayLength","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprZeroElement","elementBaseType","exprElement","suffices","accessSuffixes","exprLoadElement","conditions","map","x","c","forEach","moduleScopeShadowDecls","functionScopeShadowDecls","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray"],"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"sourcesContent":["export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { Float16Array } from '../../../external/petamoriken/float16/float16.js';\nimport { AllFeaturesMaxLimitsGPUTest, GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport { generateTypes, supportedScalarTypes, supportsAtomics } from '../types.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nasync function runShaderTest(\n  t: GPUTest,\n  enables: string,\n  stage: GPUShaderStageFlags,\n  testSource: string,\n  layout: GPUPipelineLayout,\n  testBindings: GPUBindGroupEntry[],\n  dynamicOffsets?: number[]\n): Promise<void> {\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.createBufferTracked({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.createBufferTracked({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const source = `${enables}\nstruct Constants {\n  zero: u32\n};\n@group(1) @binding(0) var<uniform> constants: Constants;\n\nstruct Result {\n  value: u32\n};\n@group(1) @binding(1) var<storage, read_write> result: Result;\n\n${testSource}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = constants.zero; // Ensure constants buffer is statically-accessed\n  result.value = runTest();\n}`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = await t.device.createComputePipelineAsync({\n    layout,\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n      { binding: 0, resource: { buffer: constantsBuffer } },\n      { binding: 1, resource: { buffer: resultBuffer } },\n    ],\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings,\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup, dynamicOffsets);\n  pass.setBindGroup(1, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\n  array: ArrayBuffer,\n  type: 'u32' | 'i32' | 'f16' | 'f32',\n  { zeroByteStart, zeroByteCount }: { zeroByteStart: number; zeroByteCount: number }\n) {\n  const constructor = { u32: Uint32Array, i32: Int32Array, f16: Float16Array, f32: Float32Array }[\n    type\n  ];\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\n\ng.test('linear_memory')\n  .desc(\n    `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n    TODO: Adjust test logic to support array of f16 in the uniform address space\n  `\n  )\n  .params(u =>\n    u\n      .combineWithParams([\n        { addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: false },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'read',\n          dynamicOffset: false,\n        },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: false,\n        },\n        { addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: true },\n        { addressSpace: 'storage', storageMode: 'read_write', access: 'read', dynamicOffset: true },\n        {\n          addressSpace: 'storage',\n          storageMode: 'read_write',\n          access: 'write',\n          dynamicOffset: true,\n        },\n        { addressSpace: 'uniform', access: 'read', dynamicOffset: false },\n        { addressSpace: 'uniform', access: 'read', dynamicOffset: true },\n        { addressSpace: 'private', access: 'read' },\n        { addressSpace: 'private', access: 'write' },\n        { addressSpace: 'function', access: 'read' },\n        { addressSpace: 'function', access: 'write' },\n        { addressSpace: 'workgroup', access: 'read' },\n        { addressSpace: 'workgroup', access: 'write' },\n      ] as const)\n      .combineWithParams([\n        { containerType: 'array' },\n        { containerType: 'matrix' },\n        { containerType: 'vector' },\n      ] as const)\n      .combineWithParams([\n        { shadowingMode: 'none' },\n        { shadowingMode: 'module-scope' },\n        { shadowingMode: 'function-scope' },\n      ])\n      .expand('isAtomic', p => (supportsAtomics(p) ? [false, true] : [false]))\n      .expand('baseType', supportedScalarTypes)\n      .beginSubcases()\n      .expandWithParams(generateTypes)\n  )\n  .fn(async t => {\n    const {\n      addressSpace,\n      storageMode,\n      access,\n      dynamicOffset,\n      isAtomic,\n      containerType,\n      baseType,\n      type,\n      shadowingMode,\n      _kTypeInfo,\n    } = t.params;\n    if (baseType === 'f16') {\n      t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    }\n\n    assert(_kTypeInfo !== undefined, 'not an indexable type');\n    assert('arrayLength' in _kTypeInfo);\n\n    let usesCanary = false;\n    let globalSource = '';\n    let testFunctionSource = '';\n    const testBufferSize = 512;\n    const bufferBindingOffset = 256;\n    /** Undefined if no buffer binding is needed */\n    let bufferBindingSize: number | undefined = undefined;\n\n    // Declare the data that will be accessed to check robust access, as a buffer or a struct\n    // in the global scope or inside the test function itself.\n    const structDecl = `\nstruct S {\n  startCanary: array<u32, 10>,\n  data: ${type},\n  endCanary: array<u32, 10>,\n};`;\n\n    const testGroupBGLEntires: GPUBindGroupLayoutEntry[] = [];\n    switch (addressSpace) {\n      case 'uniform':\n      case 'storage':\n        {\n          assert(_kTypeInfo.layout !== undefined);\n          const layout = _kTypeInfo.layout;\n          bufferBindingSize = align(layout.size, layout.alignment);\n          const qualifiers = addressSpace === 'storage' ? `storage, ${storageMode}` : addressSpace;\n          globalSource += `\nstruct TestData {\n  data: ${type},\n};\n@group(0) @binding(0) var<${qualifiers}> s: TestData;`;\n\n          testGroupBGLEntires.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type:\n                addressSpace === 'uniform'\n                  ? 'uniform'\n                  : storageMode === 'read'\n                  ? 'read-only-storage'\n                  : 'storage',\n              hasDynamicOffset: dynamicOffset,\n            },\n          });\n        }\n        break;\n\n      case 'private':\n      case 'workgroup':\n        usesCanary = true;\n        globalSource += structDecl;\n        globalSource += `var<${addressSpace}> s: S;`;\n        break;\n\n      case 'function':\n        usesCanary = true;\n        globalSource += structDecl;\n        testFunctionSource += 'var s: S;';\n        break;\n    }\n\n    // Build the test function that will do the tests.\n\n    // If we use a local canary declared in the shader, initialize it.\n    if (usesCanary) {\n      testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    s.startCanary[i] = 0xFFFFFFFFu;\n    s.endCanary[i] = 0xFFFFFFFFu;\n  }`;\n    }\n\n    /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n    const nextErrorReturnValue = (() => {\n      let errorReturnValue = 0x1000;\n      return () => {\n        ++errorReturnValue;\n        return `0x${errorReturnValue.toString(16)}u`;\n      };\n    })();\n\n    // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n    for (const indexSigned of [false, true]) {\n      const indicesToTest = indexSigned\n        ? [\n            // Exactly in bounds (should be OK)\n            '0',\n            `${_kTypeInfo.arrayLength} - 1`,\n            // Exactly out of bounds\n            '-1',\n            `${_kTypeInfo.arrayLength}`,\n            // Far out of bounds\n            '-1000000',\n            '1000000',\n            `${kMinI32}`,\n            `${kMaxI32}`,\n          ]\n        : [\n            // Exactly in bounds (should be OK)\n            '0u',\n            `${_kTypeInfo.arrayLength}u - 1u`,\n            // Exactly out of bounds\n            `${_kTypeInfo.arrayLength}u`,\n            // Far out of bounds\n            '1000000u',\n            `${kMaxU32}u`,\n            `${kMaxI32}u`,\n          ];\n\n      const indexTypeLiteral = indexSigned ? '0' : '0u';\n      const indexTypeCast = indexSigned ? 'i32' : 'u32';\n      for (const exprIndexAddon of [\n        '', // No addon\n        ` + ${indexTypeLiteral}`, // Add a literal 0\n        ` + ${indexTypeCast}(constants.zero)`, // Add a uniform 0\n      ]) {\n        // Produce the accesses to the variable.\n        for (const indexToTest of indicesToTest) {\n          testFunctionSource += `\n  {\n    let index = (${indexToTest})${exprIndexAddon};`;\n          const exprZeroElement = `${_kTypeInfo.elementBaseType}()`;\n          const exprElement = `s.data[index]`;\n          const suffices = _kTypeInfo.accessSuffixes ?? [''];\n          switch (access) {\n            case 'read':\n              {\n                const exprLoadElement = isAtomic ? `atomicLoad(&${exprElement})` : exprElement;\n                let conditions = suffices.map(x => `${exprLoadElement}${x} != ${exprZeroElement}`);\n                if (containerType === 'matrix') {\n                  // The comparison is a vector bool result.\n                  // Convert that to a scalar bool.\n                  conditions = conditions.map(c => `any(${c})`);\n                }\n                conditions.forEach(c => {\n                  testFunctionSource += `\n    if (${c}) { return ${nextErrorReturnValue()}; }`;\n                });\n              }\n              break;\n\n            case 'write':\n              if (isAtomic) {\n                testFunctionSource += `\n    atomicStore(&s.data[index], ${exprZeroElement});`;\n              } else {\n                suffices.forEach(x => {\n                  testFunctionSource += `\n    s.data[index]${x} = ${exprZeroElement};`;\n                });\n              }\n              break;\n          }\n          testFunctionSource += `\n  }`;\n        }\n      }\n    }\n\n    // Check that the canaries haven't been modified\n    if (usesCanary) {\n      testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    if (s.startCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n    if (s.endCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n  }`;\n    }\n\n    // Shadowing case declarations\n    let moduleScopeShadowDecls = '';\n    let functionScopeShadowDecls = '';\n\n    switch (shadowingMode) {\n      case 'module-scope':\n        // Shadow the builtins likely used by robustness as module-scope variables\n        moduleScopeShadowDecls = `\nvar<private> min = 0;\nvar<private> max = 0;\nvar<private> arrayLength = 0;\n`;\n        // Make sure that these are referenced by the function.\n        // This ensures that compilers don't strip away unused variables.\n        functionScopeShadowDecls = `\n  _ = min;\n  _ = max;\n  _ = arrayLength;\n`;\n        break;\n      case 'function-scope':\n        // Shadow the builtins likely used by robustness as function-scope variables\n        functionScopeShadowDecls = `\n  let min = 0;\n  let max = 0;\n  let arrayLength = 0;\n`;\n        break;\n    }\n\n    // Run the test\n\n    // First aggregate the test source\n    const testSource = `\n${globalSource}\n${moduleScopeShadowDecls}\n\nfn runTest() -> u32 {\n  ${functionScopeShadowDecls}\n  ${testFunctionSource}\n  return 0u;\n}`;\n\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts: [\n        t.device.createBindGroupLayout({\n          entries: testGroupBGLEntires,\n        }),\n        t.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'uniform',\n              },\n            },\n            {\n              binding: 1,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {\n                type: 'storage',\n              },\n            },\n          ],\n        }),\n      ],\n    });\n\n    const enables = t.params.baseType === 'f16' ? 'enable f16;' : '';\n\n    // Run it.\n    if (bufferBindingSize !== undefined && baseType !== 'bool') {\n      const expectedData = new ArrayBuffer(testBufferSize);\n      const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n      testFillArrayBuffer(expectedData, baseType, {\n        zeroByteStart: bufferBindingOffset,\n        zeroByteCount: bufferBindingSize,\n      });\n\n      // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n      const testBuffer = t.makeBufferWithContents(\n        new Uint8Array(expectedData),\n        GPUBufferUsage.COPY_SRC |\n          GPUBufferUsage.UNIFORM |\n          GPUBufferUsage.STORAGE |\n          GPUBufferUsage.COPY_DST\n      );\n\n      // Run the shader, accessing the buffer.\n      await runShaderTest(\n        t,\n        enables,\n        GPUShaderStage.COMPUTE,\n        testSource,\n        layout,\n        [\n          {\n            binding: 0,\n            resource: {\n              buffer: testBuffer,\n              offset: dynamicOffset ? 0 : bufferBindingOffset,\n              size: bufferBindingSize,\n            },\n          },\n        ],\n        dynamicOffset ? [bufferBindingOffset] : undefined\n      );\n\n      // Check that content of the buffer outside of the allowed area didn't change.\n      const expectedBytes = new Uint8Array(expectedData);\n      t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n      t.expectGPUBufferValuesEqual(\n        testBuffer,\n        expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n        bufferBindingEnd\n      );\n    } else {\n      await runShaderTest(t, enables, GPUShaderStage.COMPUTE, testSource, layout, []);\n    }\n  });\n"],"mappings":"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"}