{"version":3,"file":"shadow.spec.js","names":["description","makeTestGroup","iterRange","AllFeaturesMaxLimitsGPUTest","g","runShaderTest","t","wgsl","expected","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","outputBuffer","makeBufferWithContents","Uint32Array","length","_i","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","test","desc","fn"],"sources":["../../../../src/webgpu/shader/execution/shadow.spec.ts"],"sourcesContent":["export const description = `\nExecution Tests for shadowing\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange } from '../../../common/util/util.js';\nimport { AllFeaturesMaxLimitsGPUTest, GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\n/**\n * Run a shader and check that the buffer output matches expectations.\n *\n * @param t The test object\n * @param wgsl The shader source\n * @param expected The array of expected values after running the shader\n */\nfunction runShaderTest(t: GPUTest, wgsl: string, expected: Uint32Array): void {\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  // Allocate a buffer and fill it with 0xdeadbeef words.\n  const outputBuffer = t.makeBufferWithContents(\n    new Uint32Array([...iterRange(expected.length, _i => 0xdeadbeef)]),\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  );\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  // Check that only the non-padding bytes were modified.\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\ng.test('declaration')\n  .desc(`Test that shadowing is handled correctly`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_var_start: u32,\n        my_var_block_shadow: u32,\n        my_var_unshadow: u32,\n        my_var_param_shadow: u32,\n        my_var_param_reshadow: u32,\n        my_var_after_func: u32,\n\n        my_const_start: u32,\n        my_const_block_shadow: u32,\n        my_const_unshadow: u32,\n        my_const_param_shadow: u32,\n        my_const_param_reshadow: u32,\n        my_const_after_func: u32,\n\n        my_let_block_shadow: u32,\n        my_let_param_reshadow: u32,\n        my_let_after_func: u32,\n\n        my_func_param_shadow: u32,\n        my_func_shadow: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      var<private> my_var: u32  = 1;\n      const my_const: u32 = 100;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        let my_let = 200u;\n\n        buffer.my_var_start = my_var;  // 1\n        buffer.my_const_start = my_const;  // 100\n\n        {\n            var my_var: u32 = 10;\n            const my_const: u32 = 110;\n\n            buffer.my_var_block_shadow = my_var;  // 10\n            buffer.my_const_block_shadow = my_const;  // 110\n\n            let my_let = 210u;\n            buffer.my_let_block_shadow = my_let;  // 210\n        }\n\n        buffer.my_var_unshadow = my_var;  // 1\n        buffer.my_const_unshadow = my_const;  // 100\n\n        my_func(20, 120, my_let, 300);\n\n        buffer.my_var_after_func = my_var;  // 1\n        buffer.my_const_after_func = my_const;  // 100\n        buffer.my_let_after_func = my_let;  // 200;\n      };\n\n      // Note, defined after |main|\n      fn my_func(my_var: u32, my_const: u32, my_let: u32, my_func: u32) {\n        buffer.my_var_param_shadow = my_var;  // 20\n        buffer.my_const_param_shadow = my_const;  // 120\n\n        buffer.my_func_param_shadow = my_func; // 300\n\n        // Need block here because of scoping rules for parameters\n        {\n          var my_var = 30u;\n          const my_const = 130u;\n\n          buffer.my_var_param_reshadow = my_var; // 30\n          buffer.my_const_param_reshadow = my_const; // 130\n\n          let my_let = 220u;\n          buffer.my_let_param_reshadow = my_let; // 220\n\n          let my_func: u32 = 310;\n          buffer.my_func_shadow = my_func;  // 310\n        }\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // my_var\n        1, // my_var_start\n        10, // my_var_block_shadow\n        1, // my_var_unshadow\n        20, // my_var_param_shadow\n        30, // my_var_param_reshadow\n        1, // my_var_after_func\n        // my_const\n        100, // my_const_start\n        110, // my_const_block_shadow\n        100, // my_const_unshadow\n        120, // my_const_param_shadow\n        130, // my_const_param_reshadow\n        100, // my_const_after_func\n        // my_let\n        210, // my_let_block_shadow\n        220, // my_let_param_reshadow\n        200, // my_let_after_func\n        // my_func\n        300, // my_func_param_shadow\n        310, // my_func_shadow\n      ])\n    );\n  });\n\ng.test('builtin')\n  .desc(`Test that shadowing a builtin name is handled correctly`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_max_shadow: u32,\n        max_call: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        let max = 400u;\n        buffer.my_max_shadow = max;\n\n        my_func();\n      };\n\n      fn my_func() {\n        buffer.max_call = max(310u, 410u);\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // my_max\n        400, // my_max_shadow\n        410, // max_call\n      ])\n    );\n  });\n\ng.test('for_loop')\n  .desc(`Test that shadowing is handled correctly with for loops`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 500u;\n        buffer.my_idx_before = my_idx; // 500;\n        for (var my_idx = 0u; my_idx < 2u; my_idx++) {\n          let pos = my_idx;\n          var my_idx = 501u + my_idx;\n          buffer.my_idx_loop[pos] = my_idx;  // 501, 502\n        }\n        buffer.my_idx_after = my_idx; // 500;\n      };\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        500, // my_idx_before\n        501, // my_idx_loop[0]\n        502, // my_idx_loop[1]\n        500, // my_idx_after\n      ])\n    );\n  });\n\ng.test('while')\n  .desc(`Test that shadowing is handled correctly with while loops`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        var counter = 0u;\n        while (counter < 2) {\n          var my_idx = 500u + counter;\n          buffer.my_idx_loop[counter] = my_idx;  // 500, 501\n\n          counter += 1;\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        0, // my_idx_before\n        500, // my_idx_loop[0]\n        501, // my_idx_loop[1]\n        0, // my_idx_after\n      ])\n    );\n  });\n\ng.test('loop')\n  .desc(`Test that shadowing is handled correctly with loops`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_continuing: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        var counter = 0u;\n        loop {\n          var my_idx = 500u + counter;\n          buffer.my_idx_loop[counter] = my_idx;  // 500, 501\n\n\n          continuing {\n            var my_idx = 600u + counter;\n            buffer.my_idx_continuing[counter] = my_idx; // 600, 601\n\n            counter += 1;\n            break if counter == 2;\n          }\n        }\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        0, // my_idx_before\n        500, // my_idx_loop[0]\n        501, // my_idx_loop[1]\n        600, // my_idx_continuing[0]\n        601, // my_idx_continuing[1]\n        0, // my_idx_after\n      ])\n    );\n  });\n\ng.test('switch')\n  .desc(`Test that shadowing is handled correctly with a switch`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_case: u32,\n        my_idx_default: u32,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        for (var i = 0; i < 2; i++) {\n          switch (i) {\n            case 0: {\n              var my_idx = 10u;\n              buffer.my_idx_case = my_idx; // 10\n            }\n            default: {\n              var my_idx = 20u;\n              buffer.my_idx_default = my_idx; // 20\n            }\n          }\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        0, // my_idx_before\n        10, // my_idx_case\n        20, // my_idx_default\n        0, // my_idx_after\n      ])\n    );\n  });\n\ng.test('if')\n  .desc(`Test that shadowing is handled correctly with a switch`)\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_if: u32,\n        my_idx_elseif: u32,\n        my_idx_else: u32,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        for (var i = 0; i < 3; i++) {\n          if i == 0 {\n            var my_idx = 10u;\n            buffer.my_idx_if = my_idx; // 10\n          } else if i == 1 {\n            var my_idx = 20u;\n            buffer.my_idx_elseif = my_idx; // 20\n          } else {\n            var my_idx = 30u;\n            buffer.my_idx_else = my_idx; // 30\n          }\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        0, // my_idx_before\n        10, // my_idx_if\n        20, // my_idx_elseif\n        30, // my_idx_else\n        0, // my_idx_after\n      ])\n    );\n  });\n"],"mappings":";;GAAA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA,CAAC,CAED,SAASC,aAAa,QAAQ,yCAAyC;AACvE,SAASC,SAAS,QAAQ,8BAA8B;AACxD,SAASC,2BAA2B,QAAiB,mBAAmB;;AAExE,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,2BAA2B,CAAC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,aAAaA,CAACC,CAAU,EAAEC,IAAY,EAAEC,QAAqB,EAAQ;EAC5E,MAAMC,QAAQ,GAAGH,CAAC,CAACI,MAAM,CAACC,qBAAqB,CAAC;IAC9CC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAER,CAAC,CAACI,MAAM,CAACK,kBAAkB,CAAC,EAAEC,IAAI,EAAET,IAAI,CAAC,CAAC,CAAC;MACnDU,UAAU,EAAE;IACd;EACF,CAAC,CAAC;;EAEF;EACA,MAAMC,YAAY,GAAGZ,CAAC,CAACa,sBAAsB;IAC3C,IAAIC,WAAW,CAAC,CAAC,GAAGlB,SAAS,CAACM,QAAQ,CAACa,MAAM,EAAE,CAAAC,EAAE,KAAI,UAAU,CAAC,CAAC,CAAC;IAClEC,cAAc,CAACC,OAAO,GAAGD,cAAc,CAACE;EAC1C,CAAC;EACD,MAAMC,SAAS,GAAGpB,CAAC,CAACI,MAAM,CAACiB,eAAe,CAAC;IACzCf,MAAM,EAAEH,QAAQ,CAACmB,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEd,YAAY,CAAC,CAAC,CAAC,CAAC;EAC9D,CAAC,CAAC;;EAEF;EACA,MAAMe,OAAO,GAAG3B,CAAC,CAACI,MAAM,CAACwB,oBAAoB,CAAC,CAAC;EAC/C,MAAMC,IAAI,GAAGF,OAAO,CAACG,gBAAgB,CAAC,CAAC;EACvCD,IAAI,CAACE,WAAW,CAAC5B,QAAQ,CAAC;EAC1B0B,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEZ,SAAS,CAAC;EAC/BS,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAC;EAC1BJ,IAAI,CAACK,GAAG,CAAC,CAAC;EACVlC,CAAC,CAACmC,KAAK,CAACC,MAAM,CAAC,CAACT,OAAO,CAACU,MAAM,CAAC,CAAC,CAAC,CAAC;;EAElC;EACArC,CAAC,CAACsC,0BAA0B,CAAC1B,YAAY,EAAEV,QAAQ,CAAC;AACtD;;AAEAJ,CAAC,CAACyC,IAAI,CAAC,aAAa,CAAC;AAClBC,IAAI,CAAE,0CAAyC,CAAC;AAChDC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd;IACA,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,CAAC,EAAE;IACH;IACA,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL;IACA,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL;IACA,GAAG,EAAE;IACL,GAAG,CAAE;IAAA,CACN;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,SAAS,CAAC;AACdC,IAAI,CAAE,yDAAwD,CAAC;AAC/DC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd;IACA,GAAG,EAAE;IACL,GAAG,CAAE;IAAA,CACN;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,UAAU,CAAC;AACfC,IAAI,CAAE,yDAAwD,CAAC;AAC/DC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,CAAE;IAAA,CACN;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,OAAO,CAAC;AACZC,IAAI,CAAE,2DAA0D,CAAC;AACjEC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd,CAAC,EAAE;IACH,GAAG,EAAE;IACL,GAAG,EAAE;IACL,CAAC,CAAE;IAAA,CACJ;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,MAAM,CAAC;AACXC,IAAI,CAAE,qDAAoD,CAAC;AAC3DC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd,CAAC,EAAE;IACH,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,CAAC,CAAE;IAAA,CACJ;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,QAAQ,CAAC;AACbC,IAAI,CAAE,wDAAuD,CAAC;AAC9DC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,CAAC,CAAE;IAAA,CACJ;EACH,CAAC;AACH,CAAC,CAAC;;AAEJhB,CAAC,CAACyC,IAAI,CAAC,IAAI,CAAC;AACTC,IAAI,CAAE,wDAAuD,CAAC;AAC9DC,EAAE,CAAC,CAAAzC,CAAC,KAAI;EACP,MAAMC,IAAI,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACDF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IACd,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,CAAC,CAAE;IAAA,CACJ;EACH,CAAC;AACH,CAAC,CAAC"}