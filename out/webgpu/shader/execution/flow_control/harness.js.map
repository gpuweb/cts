{"version":3,"file":"harness.js","names":["Colors","runFlowControlTest","t","build_wgsl","inputData","Array","expectations","build_wgsl_result","value","v","params","preventValueOptimizations","push","length","expect_order","expected","kind","stack","Error","values","counter","join","expect_not_reached","built_wgsl","entrypoint","extra","main_wgsl","undefined","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","GPUBufferUsage","STORAGE","maxOutputValues","outputBuffer","createBuffer","size","usage","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","eventualExpectOK","readGPUBufferRangeTyped","type","typedLength","then","outputs","outputCount","data","fail","err","dim","blue","print_output_value","subarray","expect_order_err","expectation","err_idx","out","i","green","red","event","eventValue","expectationIndex","cleanup"],"sources":["../../../../../src/webgpu/shader/execution/flow_control/harness.ts"],"sourcesContent":["import { Colors } from '../../../../common/util/colors.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\n/**\n * Options for runFlowControlTest()\n */\ninterface FlowControlTest extends GPUTest {\n  params: {\n    /**\n     * If true, then constant values will be placed into a storage buffer,\n     * preventing the shader compiler from knowing the value at compile time.\n     * This can prevent constant folding, loop unrolling, dead-code\n     * optimizations etc, which would could all affect the tests.\n     */\n    preventValueOptimizations?: boolean;\n  };\n}\n\n/**\n * The builder interface for the runFlowControlTest() callback.\n * This interface is indented to be used to inject WGSL logic into the test\n * shader.\n * @see runFlowControlTest\n */\ninterface FlowControlTestBuilder {\n  /**\n   * Emits a value into the shader.\n   * If the FlowControlTest.params.preventValueOptimizations flag is enabled,\n   * then value() emits an expression to load the given value from a storage\n   * buffer, preventing the shader compiler from knowing the value at compile\n   * time. This can prevent constant folding, loop unrolling, dead-code\n   * optimizations etc, which would could all affect the tests.\n   */\n  value(v: number | boolean): string;\n\n  /**\n   * Emits an expectation that the statement will be executed at the given\n   * chronological events.\n   * @param event one or more chronological events, the first being 0.\n   */\n  expect_order(...event: number[]): string;\n\n  /**\n   * Emits an expectation that the statement will not be reached.\n   */\n  expect_not_reached(): string;\n}\n\n/**\n * Builds, runs then checks the output of a flow control shader test.\n *\n * `build_wgsl` is a function that's called to build the WGSL shader.\n * This function takes a FlowControlTestBuilder as the single argument, and\n * returns either a string which is embedded into the WGSL entrypoint function,\n * or an object of the signature `{ entrypoint: string; extra: string }` which\n * contains the entrypoint code, along with additional module-scope code.\n *\n * The FlowControlTestBuilder should be used to insert expectations into WGSL to\n * validate control flow. FlowControlTestBuilder also can be used to add values\n * to the shader which cannot be optimized away.\n *\n * Example, testing that an if-statement behaves as expected:\n *\n * ```\n *   runFlowControlTest(t, f =>\n *   `\n *    ${f.expect_order(0)}\n *    if (${f.value(true)}) {\n *      ${f.expect_order(1)}\n *    } else {\n *      ${f.expect_not_reached()}\n *    }\n *    ${f.expect_order(2)}\n *  `);\n * ```\n *\n * @param t The test object\n * @param builder The shader builder function that takes a\n * FlowControlTestBuilder as the single argument, and returns either a WGSL\n * string which is embedded into the WGSL entrypoint function, or a structure\n * with entrypoint-scoped WGSL code and extra module-scope WGSL code.\n */\nexport function runFlowControlTest(\n  t: FlowControlTest,\n  build_wgsl: (builder: FlowControlTestBuilder) => string | { entrypoint: string; extra: string }\n) {\n  const inputData = new Array<number>();\n\n  type ExpectedEvents = {\n    kind: 'events';\n    stack: string | undefined;\n    values: number[];\n    counter: number;\n  };\n  type ExpectedNotReached = {\n    kind: 'not-reached';\n    stack: string | undefined;\n  };\n\n  const expectations = new Array<ExpectedEvents | ExpectedNotReached>();\n\n  const build_wgsl_result = build_wgsl({\n    value: v => {\n      if (t.params.preventValueOptimizations) {\n        if (typeof v === 'boolean') {\n          inputData.push(v ? 1 : 0);\n          return `inputs[${inputData.length - 1}] != 0`;\n        }\n        inputData.push(v);\n        return `inputs[${inputData.length - 1}]`;\n      } else {\n        return `${v}`;\n      }\n    },\n    expect_order: (...expected) => {\n      expectations.push({\n        kind: 'events',\n        stack: Error().stack,\n        values: expected,\n        counter: 0,\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_order(${expected.join(', ')})`;\n    },\n    expect_not_reached: () => {\n      expectations.push({\n        kind: 'not-reached',\n        stack: Error().stack,\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_not_reached()`;\n    },\n  });\n\n  const built_wgsl =\n    typeof build_wgsl_result === 'string'\n      ? { entrypoint: build_wgsl_result, extra: '' }\n      : build_wgsl_result;\n\n  const main_wgsl = built_wgsl.entrypoint !== undefined ? built_wgsl : built_wgsl.entrypoint;\n\n  const wgsl = `\nstruct Outputs {\n  count : u32,\n  data  : array<u32>,\n};\n@group(0) @binding(0) var<storage, read>       inputs  : array<i32>;\n@group(0) @binding(1) var<storage, read_write> outputs : Outputs;\n\nfn push_output(value : u32) {\n  outputs.data[outputs.count] = value;\n  outputs.count++;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = &inputs;\n  _ = &outputs;\n  ${main_wgsl.entrypoint}\n}\n${main_wgsl.extra}\n`;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  // If there are no inputs, just put a single value in the buffer to keep\n  // makeBufferWithContents() happy.\n  if (inputData.length === 0) {\n    inputData.push(0);\n  }\n\n  const inputBuffer = t.makeBufferWithContents(new Uint32Array(inputData), GPUBufferUsage.STORAGE);\n\n  const maxOutputValues = 1000;\n  const outputBuffer = t.device.createBuffer({\n    size: 4 * (1 + maxOutputValues),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  t.eventualExpectOK(\n    t\n      .readGPUBufferRangeTyped(outputBuffer, {\n        type: Uint32Array,\n        typedLength: outputBuffer.size / 4,\n      })\n      .then(outputs => {\n        // outputs[0]    is the number of outputted values\n        // outputs[1..N] holds the outputted values\n        const outputCount = outputs.data[0];\n        if (outputCount > maxOutputValues) {\n          return new Error(\n            `output data count (${outputCount}) exceeds limit of ${maxOutputValues}`\n          );\n        }\n\n        // returns an Error with the given message and WGSL source\n        const fail = (err: string) => Error(`${err}\\nWGSL:\\n${Colors.dim(Colors.blue(wgsl))}`);\n\n        // returns a string that shows the outputted values to help understand the whole trace.\n        const print_output_value = () => {\n          const subarray = outputs.data.subarray(1, outputCount + 1);\n          return `Output values (length: ${outputCount}): ${subarray.join(', ')}`;\n        };\n\n        // returns a colorized string of the expect_order() call, highlighting\n        // the event number that caused an error.\n        const expect_order_err = (expectation: ExpectedEvents, err_idx: number) => {\n          let out = 'expect_order(';\n          for (let i = 0; i < expectation.values.length; i++) {\n            if (i > 0) {\n              out += ', ';\n            }\n            if (i < err_idx) {\n              out += Colors.green(`${expectation.values[i]}`);\n            } else if (i > err_idx) {\n              out += Colors.dim(`${expectation.values[i]}`);\n            } else {\n              out += Colors.red(`${expectation.values[i]}`);\n            }\n          }\n          out += ')';\n          return out;\n        };\n\n        // Each of the outputted values represents an event\n        // Check that each event is as expected\n        for (let event = 0; event < outputCount; event++) {\n          const eventValue = outputs.data[1 + event]; // outputs.data[0] is count\n          // Expectation id starts from 1, and 0 is invalid value.\n          if (eventValue === 0) {\n            return fail(\n              `outputs.data[${event}] is initial value 0, doesn't refer to any valid expectations)\\n${print_output_value()}`\n            );\n          }\n          const expectationIndex = eventValue - 1;\n          if (expectationIndex >= expectations.length) {\n            return fail(\n              `outputs.data[${event}] value (${expectationIndex}) exceeds number of expectations (${\n                expectations.length\n              })\\n${print_output_value()}`\n            );\n          }\n          const expectation = expectations[expectationIndex];\n          switch (expectation.kind) {\n            case 'not-reached':\n              return fail(\n                `expect_not_reached() reached at event ${event}\\n${print_output_value()}\\n${\n                  expectation.stack\n                }`\n              );\n            case 'events':\n              if (expectation.counter >= expectation.values.length) {\n                return fail(\n                  `${expect_order_err(\n                    expectation,\n                    expectation.counter\n                  )}) unexpectedly reached at event ${Colors.red(\n                    `${event}`\n                  )}\\n${print_output_value()}\\n${expectation.stack}`\n                );\n              }\n              if (event !== expectation.values[expectation.counter]) {\n                return fail(\n                  `${expect_order_err(expectation, expectation.counter)} expected event ${\n                    expectation.values[expectation.counter]\n                  }, got ${event}\\n${print_output_value()}\\n${expectation.stack}`\n                );\n              }\n\n              expectation.counter++;\n              break;\n          }\n        }\n\n        // Finally check that all expect_order() calls were reached\n        for (const expectation of expectations) {\n          if (expectation.kind === 'events' && expectation.counter !== expectation.values.length) {\n            return fail(\n              `${expect_order_err(expectation, expectation.counter)} event ${\n                expectation.values[expectation.counter]\n              } was not reached\\n${expectation.stack}\\n${print_output_value()}`\n            );\n          }\n        }\n        outputs.cleanup();\n        return undefined;\n      })\n  );\n}\n"],"mappings":"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"}