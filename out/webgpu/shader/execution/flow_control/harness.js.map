{"version":3,"file":"harness.js","names":["Colors","runFlowControlTest","t","build_wgsl","inputData","Array","expectations","build_wgsl_result","value","v","params","preventValueOptimizations","push","length","expect_order","expected","kind","stack","Error","values","counter","join","expect_not_reached","built_wgsl","entrypoint","extra","main_wgsl","undefined","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","GPUBufferUsage","STORAGE","maxOutputValues","outputBuffer","createBuffer","size","usage","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","eventualExpectOK","readGPUBufferRangeTyped","type","typedLength","then","outputs","outputCount","data","fail","err","dim","blue","print_output_value","slice","expect_order_err","expectation","err_idx","out","i","green","red","event","eventValue","expectationIndex","cleanup"],"sources":["../../../../../src/webgpu/shader/execution/flow_control/harness.ts"],"sourcesContent":["import { Colors } from '../../../../common/util/colors.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\n/**\n * Options for runFlowControlTest()\n */\ninterface FlowControlTest extends GPUTest {\n  params: {\n    /**\n     * If true, then constant values will be placed into a storage buffer,\n     * preventing the shader compiler from knowing the value at compile time.\n     * This can prevent constant folding, loop unrolling, dead-code\n     * optimizations etc, which would could all affect the tests.\n     */\n    preventValueOptimizations?: boolean;\n  };\n}\n\n/**\n * The builder interface for the runFlowControlTest() callback.\n * This interface is indented to be used to inject WGSL logic into the test\n * shader.\n * @see runFlowControlTest\n */\ninterface FlowControlTestBuilder {\n  /**\n   * Emits a value into the shader.\n   * If the FlowControlTest.params.preventValueOptimizations flag is enabled,\n   * then value() emits an expression to load the given value from a storage\n   * buffer, preventing the shader compiler from knowing the value at compile\n   * time. This can prevent constant folding, loop unrolling, dead-code\n   * optimizations etc, which would could all affect the tests.\n   */\n  value(v: number | boolean): string;\n\n  /**\n   * Emits an expectation that the statement will be executed at the given\n   * chronological events.\n   * @param event one or more chronological events, the first being 0.\n   */\n  expect_order(...event: number[]): string;\n\n  /**\n   * Emits an expectation that the statement will not be reached.\n   */\n  expect_not_reached(): string;\n}\n\n/**\n * Builds, runs then checks the output of a flow control shader test.\n *\n * `build_wgsl` is a function that's called to build the WGSL shader.\n * This function takes a FlowControlTestBuilder as the single argument, and\n * returns either a string which is embedded into the WGSL entrypoint function,\n * or an object of the signature `{ entrypoint: string; extra: string }` which\n * contains the entrypoint code, along with additional module-scope code.\n *\n * The FlowControlTestBuilder should be used to insert expectations into WGSL to\n * validate control flow. FlowControlTestBuilder also can be used to add values\n * to the shader which cannot be optimized away.\n *\n * Example, testing that an if-statement behaves as expected:\n *\n * ```\n *   runFlowControlTest(t, f =>\n *   `\n *    ${f.expect_order(0)}\n *    if (${f.value(true)}) {\n *      ${f.expect_order(1)}\n *    } else {\n *      ${f.expect_not_reached()}\n *    }\n *    ${f.expect_order(2)}\n *  `);\n * ```\n *\n * @param t The test object\n * @param builder The shader builder function that takes a\n * FlowControlTestBuilder as the single argument, and returns either a WGSL\n * string which is embedded into the WGSL entrypoint function, or a structure\n * with entrypoint-scoped WGSL code and extra module-scope WGSL code.\n */\nexport function runFlowControlTest(\n  t: FlowControlTest,\n  build_wgsl: (builder: FlowControlTestBuilder) => string | { entrypoint: string; extra: string }\n) {\n  const inputData = new Array<number>();\n\n  type ExpectedEvents = {\n    kind: 'events';\n    stack: string | undefined;\n    values: number[];\n    counter: number;\n  };\n  type ExpectedNotReached = {\n    kind: 'not-reached';\n    stack: string | undefined;\n  };\n\n  const expectations = new Array<ExpectedEvents | ExpectedNotReached>();\n\n  const build_wgsl_result = build_wgsl({\n    value: v => {\n      if (t.params.preventValueOptimizations) {\n        if (typeof v === 'boolean') {\n          inputData.push(v ? 1 : 0);\n          return `inputs[${inputData.length - 1}] != 0`;\n        }\n        inputData.push(v);\n        return `inputs[${inputData.length - 1}]`;\n      } else {\n        return `${v}`;\n      }\n    },\n    expect_order: (...expected) => {\n      expectations.push({\n        kind: 'events',\n        stack: Error().stack,\n        values: expected,\n        counter: 0,\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_order(${expected.join(', ')})`;\n    },\n    expect_not_reached: () => {\n      expectations.push({\n        kind: 'not-reached',\n        stack: Error().stack,\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_not_reached()`;\n    },\n  });\n\n  const built_wgsl =\n    typeof build_wgsl_result === 'string'\n      ? { entrypoint: build_wgsl_result, extra: '' }\n      : build_wgsl_result;\n\n  const main_wgsl = built_wgsl.entrypoint !== undefined ? built_wgsl : built_wgsl.entrypoint;\n\n  const wgsl = `\nstruct Outputs {\n  count : u32,\n  data  : array<u32>,\n};\n@group(0) @binding(0) var<storage, read>       inputs  : array<i32>;\n@group(0) @binding(1) var<storage, read_write> outputs : Outputs;\n\nfn push_output(value : u32) {\n  outputs.data[outputs.count] = value;\n  outputs.count++;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = &inputs;\n  _ = &outputs;\n  ${main_wgsl.entrypoint}\n}\n${main_wgsl.extra}\n`;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  // If there are no inputs, just put a single value in the buffer to keep\n  // makeBufferWithContents() happy.\n  if (inputData.length === 0) {\n    inputData.push(0);\n  }\n\n  const inputBuffer = t.makeBufferWithContents(new Uint32Array(inputData), GPUBufferUsage.STORAGE);\n\n  const maxOutputValues = 1000;\n  const outputBuffer = t.device.createBuffer({\n    size: 4 * (1 + maxOutputValues),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  t.eventualExpectOK(\n    t\n      .readGPUBufferRangeTyped(outputBuffer, {\n        type: Uint32Array,\n        typedLength: outputBuffer.size / 4,\n      })\n      .then(outputs => {\n        // outputs[0]    is the number of outputted values\n        // outputs[1..N] holds the outputted values\n        const outputCount = outputs.data[0];\n        if (outputCount > maxOutputValues) {\n          return new Error(\n            `output data count (${outputCount}) exceeds limit of ${maxOutputValues}`\n          );\n        }\n\n        // returns an Error with the given message and WGSL source\n        const fail = (err: string) => Error(`${err}\\nWGSL:\\n${Colors.dim(Colors.blue(wgsl))}`);\n\n        // returns a string that shows the outputted values to help understand the whole trace.\n        const print_output_value = () => {\n          return `Output values (length: ${outputCount}): ${outputs.data\n            .slice(1, outputCount + 1)\n            .join(', ')}`;\n        };\n\n        // returns a colorized string of the expect_order() call, highlighting\n        // the event number that caused an error.\n        const expect_order_err = (expectation: ExpectedEvents, err_idx: number) => {\n          let out = 'expect_order(';\n          for (let i = 0; i < expectation.values.length; i++) {\n            if (i > 0) {\n              out += ', ';\n            }\n            if (i < err_idx) {\n              out += Colors.green(`${expectation.values[i]}`);\n            } else if (i > err_idx) {\n              out += Colors.dim(`${expectation.values[i]}`);\n            } else {\n              out += Colors.red(`${expectation.values[i]}`);\n            }\n          }\n          out += ')';\n          return out;\n        };\n\n        // Each of the outputted values represents an event\n        // Check that each event is as expected\n        for (let event = 0; event < outputCount; event++) {\n          const eventValue = outputs.data[1 + event]; // outputs.data[0] is count\n          // Expectation id starts from 1, and 0 is invalid value.\n          if (eventValue === 0) {\n            return fail(\n              `outputs.data[${event}] is initial value 0, doesn't refer to any valid expectations)\\n${print_output_value()}`\n            );\n          }\n          const expectationIndex = eventValue - 1;\n          if (expectationIndex >= expectations.length) {\n            return fail(\n              `outputs.data[${event}] value (${expectationIndex}) exceeds number of expectations (${\n                expectations.length\n              })\\n${print_output_value()}`\n            );\n          }\n          const expectation = expectations[expectationIndex];\n          switch (expectation.kind) {\n            case 'not-reached':\n              return fail(\n                `expect_not_reached() reached at event ${event}\\n${print_output_value()}\\n${\n                  expectation.stack\n                }`\n              );\n            case 'events':\n              if (expectation.counter >= expectation.values.length) {\n                return fail(\n                  `${expect_order_err(\n                    expectation,\n                    expectation.counter\n                  )}) unexpectedly reached at event ${Colors.red(\n                    `${event}`\n                  )}\\n${print_output_value()}\\n${expectation.stack}`\n                );\n              }\n              if (event !== expectation.values[expectation.counter]) {\n                return fail(\n                  `${expect_order_err(expectation, expectation.counter)} expected event ${\n                    expectation.values[expectation.counter]\n                  }, got ${event}\\n${print_output_value()}\\n${expectation.stack}`\n                );\n              }\n\n              expectation.counter++;\n              break;\n          }\n        }\n\n        // Finally check that all expect_order() calls were reached\n        for (const expectation of expectations) {\n          if (expectation.kind === 'events' && expectation.counter !== expectation.values.length) {\n            return fail(\n              `${expect_order_err(expectation, expectation.counter)} event ${\n                expectation.values[expectation.counter]\n              } was not reached\\n${expectation.stack}\\n${print_output_value()}`\n            );\n          }\n        }\n        outputs.cleanup();\n        return undefined;\n      })\n  );\n}\n"],"mappings":"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"}