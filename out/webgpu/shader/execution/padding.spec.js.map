{"version":3,"file":"padding.spec.js","names":["description","makeTestGroup","iterRange","GPUTest","g","runShaderTest","t","wgsl","expected","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","outputBuffer","makeBufferWithContents","Uint32Array","length","_i","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","test","desc","fn","beforeAllSubcases","selectDeviceOrSkipTestCase","params","u","combine","beginSubcases","cols","columns","use_struct","f_values","Float32Array","u_values","c","i"],"sources":["../../../../src/webgpu/shader/execution/padding.spec.ts"],"sourcesContent":["export const description = `\nExecution Tests for preservation of padding bytes in structures and arrays.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n/**\n * Run a shader and check that the buffer output matches expectations.\n *\n * @param t The test object\n * @param wgsl The shader source\n * @param expected The array of expected values after running the shader\n */\nfunction runShaderTest(t: GPUTest, wgsl: string, expected: Uint32Array): void {\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  // Allocate a buffer and fill it with 0xdeadbeef words.\n  const outputBuffer = t.makeBufferWithContents(\n    new Uint32Array([...iterRange(expected.length, _i => 0xdeadbeef)]),\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  );\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  // Check that only the non-padding bytes were modified.\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\ng.test('struct_implicit')\n  .desc(\n    `Test that padding bytes in between structure members are preserved.\n\n     This test defines a structure that has implicit padding and creates a read-write storage\n     buffer with that structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        a : u32,\n        // 12 bytes of padding\n        b : vec3<u32>,\n        // 4 bytes of padding\n        c : vec2<u32>,\n        // 8 bytes of padding\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S(0x12345678, vec3(0xabcdef01), vec2(0x98765432));\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // a : u32\n        0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // b : vec3<u32>\n        0xabcdef01, 0xabcdef01, 0xabcdef01, 0xdeadbeef,\n        // c : vec2<u32>\n        0x98765432, 0x98765432, 0xdeadbeef, 0xdeadbeef,\n      ])\n    );\n  });\n\ng.test('struct_explicit')\n  .desc(\n    `Test that padding bytes in between structure members are preserved.\n\n     This test defines a structure with explicit padding attributes and creates a read-write storage\n     buffer with that structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        a : u32,\n        // 12 bytes of padding\n        @align(16) @size(20) b : u32,\n        // 16 bytes of padding\n        @size(12) c : u32,\n        // 8 bytes of padding\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S(0x12345678, 0xabcdef01, 0x98765432);\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // a : u32\n        0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // @align(16) @size(20) b : u32\n        0xabcdef01, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // @size(12) c : u32\n        0x98765432, 0xdeadbeef, 0xdeadbeef,\n      ])\n    );\n  });\n\ng.test('struct_nested')\n  .desc(\n    `Test that padding bytes in nested structures are preserved.\n\n     This test defines a set of nested structures that have padding and creates a read-write storage\n     buffer with the root structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      // Size of S1 is 48 bytes.\n      // Alignment of S1 is 16 bytes.\n      struct S1 {\n        a : u32,\n        // 12 bytes of padding\n        b : vec3<u32>,\n        // 4 bytes of padding\n        c : vec2<u32>,\n        // 8 bytes of padding\n      }\n\n      // Size of S2 is 112 bytes.\n      // Alignment of S2 is 48 bytes.\n      struct S2 {\n        a2 : u32,\n        // 12 bytes of padding\n        b2 : S1,\n        c2 : S1,\n      }\n\n      // Size of S3 is 144 bytes.\n      // Alignment of S3 is 48 bytes.\n      struct S3 {\n        a3 : S1,\n        b3 : S2,\n        c3 : S2,\n      }\n\n      @group(0) @binding(0) var<storage, read_write> buffer : S3;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S3();\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // a3 : S1\n        // a3.a1 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // a3.b1 : vec3<u32>\n        0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n        // a3.c1 : vec2<u32>\n        0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n\n        // b3 : S2\n        // b3.a2 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // b3.b2 : S1\n        // b3.b2.a1 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // b3.b2.b1 : vec3<u32>\n        0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n        // b3.b2.c1 : vec2<u32>\n        0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n        // b3.c2 : S1\n        // b3.c2.a1 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // b3.c2.b1 : vec3<u32>\n        0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n        // b3.c2.c1 : vec2<u32>\n        0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n\n        // c3 : S2\n        // c3.a2 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // c3.b2 : S1\n        // c3.b2.a1 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // c3.b2.b1 : vec3<u32>\n        0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n        // c3.b2.c1 : vec2<u32>\n        0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n        // c3.c2 : S1\n        // c3.c2.a1 : u32\n        0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n        // c3.c2.b1 : vec3<u32>\n        0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n        // c3.c2.c1 : vec2<u32>\n        0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n      ])\n    );\n  });\n\ng.test('array_of_vec3')\n  .desc(\n    `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<vec3, 4>. The shader\n     assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<u32>, 4>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<vec3<u32>, 4>(\n          vec3(0x12345678),\n          vec3(0xabcdef01),\n          vec3(0x98765432),\n          vec3(0x0f0f0f0f),\n        );\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // buffer[0]\n        0x12345678, 0x12345678, 0x12345678, 0xdeadbeef,\n        // buffer[1]\n        0xabcdef01, 0xabcdef01, 0xabcdef01, 0xdeadbeef,\n        // buffer[2]\n        0x98765432, 0x98765432, 0x98765432, 0xdeadbeef,\n        // buffer[2]\n        0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0xdeadbeef,\n      ])\n    );\n  });\n\ng.test('array_of_vec3h')\n  .desc(\n    `Test that padding bytes in between array elements are preserved when f16 elements are used.\n\n     This test defines creates a read-write storage buffer with type array<vec3h, 4>. The shader\n     assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n  )\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  })\n  .fn(t => {\n    const wgsl = `\n      enable f16;\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<f16>, 4>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<vec3<f16>, 4>(\n          vec3(1h),\n          vec3(2h),\n          vec3(3h),\n          vec3(4h),\n        );\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // buffer[0]\n        0x3c003c00, 0xdead3c00,\n        // buffer[1]\n        0x40004000, 0xdead4000,\n        // buffer[2]\n        0x42004200, 0xdead4200,\n        // buffer[2]\n        0x44004400, 0xdead4400,\n      ])\n    );\n  });\n\ng.test('array_of_vec3h,elementwise')\n  .desc(\n    `Test that padding bytes in between array elements are preserved when f16 elements are used.\n\n     This test defines creates a read-write storage buffer with type array<vec3h, 4>. The shader\n     assigns one element per thread, and we then test that data in the padding bytes was\n     preserved.\n    `\n  )\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  })\n  .fn(t => {\n    const wgsl = `\n      enable f16;\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<f16>>;\n\n      @compute @workgroup_size(4)\n      fn main(@builtin(local_invocation_index) lid : u32) {\n        buffer[lid] = vec3h(f16(lid + 1));\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // buffer[0]\n        0x3c003c00, 0xdead3c00,\n        // buffer[1]\n        0x40004000, 0xdead4000,\n        // buffer[2]\n        0x42004200, 0xdead4200,\n        // buffer[2]\n        0x44004400, 0xdead4400,\n      ])\n    );\n  });\n\ng.test('array_of_struct')\n  .desc(\n    `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<S, 4>, where S is a\n     structure that contains padding bytes. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      struct S {\n        a : u32,\n        b : vec3<u32>,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : array<S, 3>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<S, 3>(\n          S(0x12345678, vec3(0x0f0f0f0f)),\n          S(0xabcdef01, vec3(0x7c7c7c7c)),\n          S(0x98765432, vec3(0x18181818)),\n        );\n      }\n    `;\n    runShaderTest(\n      t,\n      wgsl,\n      new Uint32Array([\n        // buffer[0]\n        0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,\n        0xdeadbeef,\n        // buffer[1]\n        0xabcdef01, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x7c7c7c7c, 0x7c7c7c7c, 0x7c7c7c7c,\n        0xdeadbeef,\n        // buffer[2]\n        0x98765432, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x18181818, 0x18181818, 0x18181818,\n        0xdeadbeef,\n      ])\n    );\n  });\n\ng.test('vec3')\n  .desc(\n    `Test padding bytes are preserved when assigning to a variable of type vec3 (without a struct).\n    `\n  )\n  .fn(t => {\n    const wgsl = `\n      @group(0) @binding(0) var<storage, read_write> buffer : vec3<u32>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = vec3<u32>(0x12345678, 0xabcdef01, 0x98765432);\n      }\n    `;\n    runShaderTest(t, wgsl, new Uint32Array([0x12345678, 0xabcdef01, 0x98765432, 0xdeadbeef]));\n  });\n\ng.test('matCx3')\n  .desc(\n    `Test padding bytes are preserved when assigning to a variable of type matCx3.\n    `\n  )\n  .params(u =>\n    u\n      .combine('columns', [2, 3, 4] as const)\n      .combine('use_struct', [true, false] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const cols = t.params.columns;\n    const wgsl = `\n      alias Mat = mat${cols}x3<f32>;\n      ${t.params.use_struct ? `struct S { m : Mat } alias Type = S;` : `alias Type = Mat;`}\n      @group(0) @binding(0) var<storage, read_write> buffer : Type;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var m : Mat;\n        for (var c = 0u; c < ${cols}; c++) {\n          m[c] = vec3(f32(c*3 + 1), f32(c*3 + 2), f32(c*3 + 3));\n        }\n        buffer = Type(m);\n      }\n    `;\n    const f_values = new Float32Array(cols * 4);\n    const u_values = new Uint32Array(f_values.buffer);\n    for (let c = 0; c < cols; c++) {\n      f_values[c * 4 + 0] = c * 3 + 1;\n      f_values[c * 4 + 1] = c * 3 + 2;\n      f_values[c * 4 + 2] = c * 3 + 3;\n      u_values[c * 4 + 3] = 0xdeadbeef;\n    }\n    runShaderTest(t, wgsl, u_values);\n  });\n\ng.test('array_of_matCx3')\n  .desc(\n    `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<matCx3<f32>, 4>. The\n     shader assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n  )\n  .params(u =>\n    u\n      .combine('columns', [2, 3, 4] as const)\n      .combine('use_struct', [true, false] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    const cols = t.params.columns;\n    const wgsl = `\n    alias Mat = mat${cols}x3<f32>;\n    ${t.params.use_struct ? `struct S { m : Mat } alias Type = S;` : `alias Type = Mat;`}\n    @group(0) @binding(0) var<storage, read_write> buffer : array<Type, 4>;\n\n    @compute @workgroup_size(1)\n    fn main() {\n      var m : Mat;\n      for (var c = 0u; c < ${cols}; c++) {\n        m[c] = vec3(f32(c*3 + 1), f32(c*3 + 2), f32(c*3 + 3));\n      }\n      buffer = array<Type, 4>(Type(m), Type(m * 2), Type(m * 3), Type(m * 4));\n    }\n  `;\n    const f_values = new Float32Array(cols * 4 * 4);\n    const u_values = new Uint32Array(f_values.buffer);\n    for (let i = 0; i < 4; i++) {\n      for (let c = 0; c < cols; c++) {\n        f_values[i * (cols * 4) + c * 4 + 0] = (c * 3 + 1) * (i + 1);\n        f_values[i * (cols * 4) + c * 4 + 1] = (c * 3 + 2) * (i + 1);\n        f_values[i * (cols * 4) + c * 4 + 2] = (c * 3 + 3) * (i + 1);\n        u_values[i * (cols * 4) + c * 4 + 3] = 0xdeadbeef;\n      }\n    }\n    runShaderTest(t, wgsl, u_values);\n  });\n"],"mappings":"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"}