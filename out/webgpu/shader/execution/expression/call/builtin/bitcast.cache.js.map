{"version":3,"file":"bitcast.cache.js","names":["assert","alwaysPass","anyOf","kBit","kValue","VectorValue","f16","f32","i32","toVector","u32","abstractFloat","abstractInt","FP","FPInterval","cartesianProduct","fullI32Range","fullU32Range","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","linearRange","scalarF16Range","scalarF32Range","reinterpretF16AsU16","reinterpretF32AsI32","reinterpretF32AsU32","reinterpretI32AsF32","reinterpretI32AsU32","reinterpretU16AsF16","reinterpretU32AsF32","reinterpretU32AsI32","makeCaseCache","numNaNs","f32InfAndNaNInU32","positive","infinity","max","negative","f32InfAndNaNInF32","map","u","f32InfAndNaNInI32","f32ZerosInU32","zero","f32ZerosInF32","f32ZerosInI32","f32ZerosInterval","f32FiniteRange","f32RangeWithInfAndNaN","f16FiniteInF16","f16FiniteInU16","f16InfAndNaNInU16","v","Math","ceil","floor","f16InfAndNaNInF16","f16ZerosInU16","f16ZerosInterval","u16x2ToU32","u16x2","length","buffer","ArrayBuffer","view","DataView","setUint16","getUint32","u32ToU16x2","setUint32","getUint16","u16x2ToVec2F16","u16x4ToVec4F16","u16x4","canU32BitcastToFiniteVec2F16","u16","reduce","a","b","slidingSlice","input","len","result","i","sub","j","push","f16Vec2InfAndNaNInU32","f16Vec2InfAndNaNInI32","f16Vec2ZerosInU32","f16Vec2ZerosInI32","u32RangeForF16Vec2FiniteInfNaN","u32RangeForF16Vec2Finite","filter","i32RangeForF16Vec2FiniteInfNaN","i32RangeForF16Vec2Finite","f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN","f32FiniteRangeForF16Vec2Finite","f16Vec2FiniteInU16x2","f16Vec2FiniteInfNanInU16x2","f16Vec2FiniteInU16x4","f16Vec2FiniteInfNanInU16x4","anyF32","anyI32","anyU32","f32UnboundedInterval","constants","unboundedInterval","f16UnboundedInterval","i32RangeForF32FiniteInfNaN","i32RangeForF32Finite","u32RangeForF32FiniteInfNaN","u32RangeForF32Finite","bitcastF32ToF32Comparator","f","acceptable","bitcastF32ToU32Comparator","bitcastF32ToI32Comparator","bitcastI32ToF32Comparator","includes","bitcastU32ToF32Comparator","generateF16ExpectationIntervals","bitcastedF16Value","exactInterval","toInterval","bitcastF16ToF16Comparator","bitcastU32ToVec2F16Comparator","bitcastedVec2F16InU16x2","expectedIntervalsCombination","bitcastI32ToVec2F16Comparator","bitcastF32ToVec2F16Comparator","bitcastVec2U32ToVec4F16Comparator","u32x2","bitcastedVec4F16InU16x4","flatMap","bitcastVec2I32ToVec4F16Comparator","i32x2","bitcastVec2F32ToVec4F16Comparator","f32x2","possibleBitsInU16FromFiniteF16InU16","f16InU16","h","possible32BitScalarIntervalsFromF16x2","f16x2InU16x2","type","reinterpretFromU32","expectationsForValue","unboundedExpectations","x","possibleExpectations","isUnbounded","possibleU16Bits","possibleBitsU16x2","bitcastVec2F16ToU32Comparator","vec2F16InU16x2","expectations","bitcastVec2F16ToI32Comparator","bitcastVec2F16ToF32Comparator","bitcastVec4F16ToVec2U32Comparator","vec4F16InU16x4","expectationsPerElement","slice","e","bitcastVec4F16ToVec2I32Comparator","bitcastVec4F16ToVec2F32Comparator","d","i32_to_i32","expected","u32_to_u32","f32_inf_nan_to_f32","f32_to_f32","f16_inf_nan_to_f16","f16_to_f16","i32_to_u32","i32_to_f32","ai_to_i32","BigInt","ai_to_u32","ai_to_f32","i32_to_f32_inf_nan","u32_to_i32","u32_to_f32","u32_to_f32_inf_nan","f32_inf_nan_to_i32","f32_to_i32","f32_inf_nan_to_u32","f32_to_u32","u32_to_vec2_f16_inf_nan","u32_to_vec2_f16","i32_to_vec2_f16_inf_nan","i32_to_vec2_f16","ai_to_vec2_f16","f32_inf_nan_to_vec2_f16_inf_nan","f32_to_vec2_f16","af_to_vec2_f16","vec2_i32_to_vec4_f16_inf_nan","vec2_i32_to_vec4_f16","vec2_ai_to_vec4_f16","n","vec2_u32_to_vec4_f16_inf_nan","vec2_u32_to_vec4_f16","vec2_f32_inf_nan_to_vec4_f16_inf_nan","vec2_f32_to_vec4_f16","vec2_af_to_vec4_f16","vec2_f16_to_u32","vec2_f16_inf_nan_to_u32","vec2_f16_to_i32","vec2_f16_inf_nan_to_i32","vec2_f16_to_f32_finite","vec2_f16_inf_nan_to_f32","vec4_f16_to_vec2_u32","vec4_f16_inf_nan_to_vec2_u32","vec4_f16_to_vec2_i32","vec4_f16_inf_nan_to_vec2_i32","vec4_f16_to_vec2_f32_finite","vec4_f16_inf_nan_to_vec2_f32"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/bitcast.cache.ts"],"sourcesContent":["import { assert } from '../../../../../../common/util/util.js';\nimport { Comparator, alwaysPass, anyOf } from '../../../../../util/compare.js';\nimport { kBit, kValue } from '../../../../../util/constants.js';\nimport {\n  ScalarValue,\n  VectorValue,\n  f16,\n  f32,\n  i32,\n  toVector,\n  u32,\n  abstractFloat,\n  abstractInt,\n} from '../../../../../util/conversion.js';\nimport { FP, FPInterval } from '../../../../../util/floating_point.js';\nimport {\n  cartesianProduct,\n  fullI32Range,\n  fullU32Range,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  linearRange,\n  scalarF16Range,\n  scalarF32Range,\n} from '../../../../../util/math.js';\nimport {\n  reinterpretF16AsU16,\n  reinterpretF32AsI32,\n  reinterpretF32AsU32,\n  reinterpretI32AsF32,\n  reinterpretI32AsU32,\n  reinterpretU16AsF16,\n  reinterpretU32AsF32,\n  reinterpretU32AsI32,\n} from '../../../../../util/reinterpret.js';\nimport { makeCaseCache } from '../../case_cache.js';\n\nconst numNaNs = 11;\nconst f32InfAndNaNInU32: number[] = [\n  // Cover NaNs evenly in integer space.\n  // The positive NaN with the lowest integer representation is the integer\n  // for infinity, plus one.\n  // The positive NaN with the highest integer representation is i32.max (!)\n  ...linearRange(kBit.f32.positive.infinity + 1, kBit.i32.positive.max, numNaNs),\n  // The negative NaN with the lowest integer representation is the integer\n  // for negative infinity, plus one.\n  // The negative NaN with the highest integer representation is u32.max (!)\n  ...linearRange(kBit.f32.negative.infinity + 1, kBit.u32.max, numNaNs),\n  kBit.f32.positive.infinity,\n  kBit.f32.negative.infinity,\n];\nconst f32InfAndNaNInF32 = f32InfAndNaNInU32.map(u => reinterpretU32AsF32(u));\nconst f32InfAndNaNInI32 = f32InfAndNaNInU32.map(u => reinterpretU32AsI32(u));\n\nconst f32ZerosInU32 = [0, kBit.f32.negative.zero];\nconst f32ZerosInF32 = f32ZerosInU32.map(u => reinterpretU32AsF32(u));\nconst f32ZerosInI32 = f32ZerosInU32.map(u => reinterpretU32AsI32(u));\nconst f32ZerosInterval: FPInterval = new FPInterval('f32', -0.0, 0.0);\n\n// f32FiniteRange is a list of finite f32s. fullF32Range() already\n// has +0, we only need to add -0.\nconst f32FiniteRange: number[] = [...scalarF32Range(), kValue.f32.negative.zero];\nconst f32RangeWithInfAndNaN: number[] = [...f32FiniteRange, ...f32InfAndNaNInF32];\n\n// Type.f16 values, finite, Inf/NaN, and zeros. Represented in float and u16.\nconst f16FiniteInF16: number[] = [...scalarF16Range(), kValue.f16.negative.zero];\nconst f16FiniteInU16: number[] = f16FiniteInF16.map(u => reinterpretF16AsU16(u));\n\nconst f16InfAndNaNInU16: number[] = [\n  // Cover NaNs evenly in integer space.\n  // The positive NaN with the lowest integer representation is the integer\n  // for infinity, plus one.\n  // The positive NaN with the highest integer representation is u16 0x7fff i.e. 32767.\n  ...linearRange(kBit.f16.positive.infinity + 1, 32767, numNaNs).map(v => Math.ceil(v)),\n  // The negative NaN with the lowest integer representation is the integer\n  // for negative infinity, plus one.\n  // The negative NaN with the highest integer representation is u16 0xffff i.e. 65535\n  ...linearRange(kBit.f16.negative.infinity + 1, 65535, numNaNs).map(v => Math.floor(v)),\n  kBit.f16.positive.infinity,\n  kBit.f16.negative.infinity,\n];\nconst f16InfAndNaNInF16 = f16InfAndNaNInU16.map(u => reinterpretU16AsF16(u));\n\nconst f16ZerosInU16 = [kBit.f16.negative.zero, 0];\n\n// f16 interval that match +/-0.0.\nconst f16ZerosInterval: FPInterval = new FPInterval('f16', -0.0, 0.0);\n\n/**\n * @returns an u32 whose lower and higher 16bits are the two elements of the\n * given array of two u16 respectively, in little-endian.\n */\nfunction u16x2ToU32(u16x2: readonly number[]): number {\n  assert(u16x2.length === 2);\n  // Create a DataView with 4 bytes buffer.\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  // Enforce little-endian.\n  view.setUint16(0, u16x2[0], true);\n  view.setUint16(2, u16x2[1], true);\n  return view.getUint32(0, true);\n}\n\n/**\n * @returns an array of two u16, respectively the lower and higher 16bits of\n * given u32 in little-endian.\n */\nfunction u32ToU16x2(u32: number): number[] {\n  // Create a DataView with 4 bytes buffer.\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  // Enforce little-endian.\n  view.setUint32(0, u32, true);\n  return [view.getUint16(0, true), view.getUint16(2, true)];\n}\n\n/**\n * @returns a vec2<f16> from an array of two u16, each reinterpreted as f16.\n */\nfunction u16x2ToVec2F16(u16x2: number[]): VectorValue {\n  assert(u16x2.length === 2);\n  return toVector(u16x2.map(reinterpretU16AsF16), f16);\n}\n\n/**\n * @returns a vec4<f16> from an array of four u16, each reinterpreted as f16.\n */\nfunction u16x4ToVec4F16(u16x4: number[]): VectorValue {\n  assert(u16x4.length === 4);\n  return toVector(u16x4.map(reinterpretU16AsF16), f16);\n}\n\n/**\n * @returns true if and only if a given u32 can bitcast to a vec2<f16> with all elements\n * being finite f16 values.\n */\nfunction canU32BitcastToFiniteVec2F16(u32: number): boolean {\n  return u32ToU16x2(u32)\n    .map(u16 => isFiniteF16(reinterpretU16AsF16(u16)))\n    .reduce((a, b) => a && b, true);\n}\n\n/**\n * @returns an array of N elements with the i-th element being an array of len elements\n * [a_i, a_((i+1)%N), ..., a_((i+len-1)%N)], for the input array of N element [a_1, ... a_N]\n * and the given len. For example, slidingSlice([1, 2, 3], 2) result in\n * [[1, 2], [2, 3], [3, 1]].\n * This helper function is used for generating vector cases from scalar values array.\n */\nfunction slidingSlice(input: number[], len: number) {\n  const result: number[][] = [];\n  for (let i = 0; i < input.length; i++) {\n    const sub: number[] = [];\n    for (let j = 0; j < len; j++) {\n      sub.push(input[(i + j) % input.length]);\n    }\n    result.push(sub);\n  }\n  return result;\n}\n\n// vec2<f16> interesting (zeros, Inf, and NaN) values for testing cases.\n// vec2<f16> values that has at least one Inf/NaN f16 element, reinterpreted as u32/i32.\nconst f16Vec2InfAndNaNInU32 = [\n  ...cartesianProduct(f16InfAndNaNInU16, [...f16InfAndNaNInU16, ...f16FiniteInU16]),\n  ...cartesianProduct(f16FiniteInU16, f16InfAndNaNInU16),\n].map(u16x2ToU32);\nconst f16Vec2InfAndNaNInI32 = f16Vec2InfAndNaNInU32.map(u => reinterpretU32AsI32(u));\n// vec2<f16> values with two f16 0.0 element, reinterpreted as u32/i32.\nconst f16Vec2ZerosInU32 = cartesianProduct(f16ZerosInU16, f16ZerosInU16).map(u16x2ToU32);\nconst f16Vec2ZerosInI32 = f16Vec2ZerosInU32.map(u => reinterpretU32AsI32(u));\n\n// i32/u32/f32 range for bitcasting to vec2<f16>\n// u32 values for bitcasting to vec2<f16> finite, Inf, and NaN.\nconst u32RangeForF16Vec2FiniteInfNaN: number[] = [\n  ...fullU32Range(),\n  ...f16Vec2ZerosInU32,\n  ...f16Vec2InfAndNaNInU32,\n];\n// u32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst u32RangeForF16Vec2Finite: number[] = u32RangeForF16Vec2FiniteInfNaN.filter(\n  canU32BitcastToFiniteVec2F16\n);\n// i32 values for bitcasting to vec2<f16> finite, zeros, Inf, and NaN.\nconst i32RangeForF16Vec2FiniteInfNaN: number[] = [\n  ...fullI32Range(),\n  ...f16Vec2ZerosInI32,\n  ...f16Vec2InfAndNaNInI32,\n];\n// i32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst i32RangeForF16Vec2Finite: number[] = i32RangeForF16Vec2FiniteInfNaN.filter(u =>\n  canU32BitcastToFiniteVec2F16(reinterpretI32AsU32(u))\n);\n// f32 values with finite/Inf/NaN f32, for bitcasting to vec2<f16> finite, zeros, Inf, and NaN.\nconst f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN: number[] = [\n  ...f32RangeWithInfAndNaN,\n  ...u32RangeForF16Vec2FiniteInfNaN.map(reinterpretU32AsF32),\n];\n// Finite f32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst f32FiniteRangeForF16Vec2Finite: number[] = f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN\n  .filter(isFiniteF32)\n  .filter(u => canU32BitcastToFiniteVec2F16(reinterpretF32AsU32(u)));\n\n// vec2<f16> cases for bitcasting to i32/u32/f32, by combining f16 values into pairs\nconst f16Vec2FiniteInU16x2 = slidingSlice(f16FiniteInU16, 2);\nconst f16Vec2FiniteInfNanInU16x2 = slidingSlice([...f16FiniteInU16, ...f16InfAndNaNInU16], 2);\n// vec4<f16> cases for bitcasting to vec2<i32/u32/f32>, by combining f16 values 4-by-4\nconst f16Vec2FiniteInU16x4 = slidingSlice(f16FiniteInU16, 4);\nconst f16Vec2FiniteInfNanInU16x4 = slidingSlice([...f16FiniteInU16, ...f16InfAndNaNInU16], 4);\n\n// alwaysPass comparator for i32/u32/f32 cases. For f32/f16 we also use unbound interval, which\n// allow per-element unbounded expectation for vector.\nconst anyF32 = alwaysPass('any f32');\nconst anyI32 = alwaysPass('any i32');\nconst anyU32 = alwaysPass('any u32');\n\n// Unbounded FPInterval\nconst f32UnboundedInterval = FP.f32.constants().unboundedInterval;\nconst f16UnboundedInterval = FP.f16.constants().unboundedInterval;\n\n// i32 and u32 cases for bitcasting to f32.\n// i32 cases for bitcasting to f32 finite, zeros, Inf, and NaN.\nconst i32RangeForF32FiniteInfNaN: number[] = [\n  ...fullI32Range(),\n  ...f32ZerosInI32,\n  ...f32InfAndNaNInI32,\n];\n// i32 cases for bitcasting to f32 finite only.\nconst i32RangeForF32Finite: number[] = i32RangeForF32FiniteInfNaN.filter(i =>\n  isFiniteF32(reinterpretI32AsF32(i))\n);\n// u32 cases for bitcasting to f32 finite, zeros, Inf, and NaN.\nconst u32RangeForF32FiniteInfNaN: number[] = [\n  ...fullU32Range(),\n  ...f32ZerosInU32,\n  ...f32InfAndNaNInU32,\n];\n// u32 cases for bitcasting to f32 finite only.\nconst u32RangeForF32Finite: number[] = u32RangeForF32FiniteInfNaN.filter(u =>\n  isFiniteF32(reinterpretU32AsF32(u))\n);\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToF32Comparator(f: number): Comparator {\n  if (!isFiniteF32(f)) return anyF32;\n  const acceptable: number[] = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns a Comparator for checking if a u32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToU32Comparator(f: number): Comparator {\n  if (!isFiniteF32(f)) return anyU32;\n  const acceptable: number[] = [\n    reinterpretF32AsU32(f),\n    ...(isSubnormalNumberF32(f) ? f32ZerosInU32 : []),\n  ];\n  return anyOf(...acceptable.map(u32));\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToI32Comparator(f: number): Comparator {\n  if (!isFiniteF32(f)) return anyI32;\n  const acceptable: number[] = [\n    reinterpretF32AsI32(f),\n    ...(isSubnormalNumberF32(f) ? f32ZerosInI32 : []),\n  ];\n  return anyOf(...acceptable.map(i32));\n}\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from i32.\n */\nfunction bitcastI32ToF32Comparator(i: number): Comparator {\n  const f: number = reinterpretI32AsF32(i);\n  if (!isFiniteF32(f)) return anyI32;\n  // Positive or negative zero bit pattern map to any zero.\n  if (f32ZerosInI32.includes(i)) return anyOf(...f32ZerosInF32.map(f32));\n  const acceptable: number[] = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from u32.\n */\nfunction bitcastU32ToF32Comparator(u: number): Comparator {\n  const f: number = reinterpretU32AsF32(u);\n  if (!isFiniteF32(f)) return anyU32;\n  // Positive or negative zero bit pattern map to any zero.\n  if (f32ZerosInU32.includes(u)) return anyOf(...f32ZerosInF32.map(f32));\n  const acceptable: number[] = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns an array of expected f16 FPInterval for the given bitcasted f16 value, which may be\n * subnormal, Inf, or NaN. Test cases that bitcasted to vector of f16 use this function to get\n * per-element expectation and build vector expectation using cartesianProduct.\n */\nfunction generateF16ExpectationIntervals(bitcastedF16Value: number): FPInterval[] {\n  // If the bitcasted f16 value is inf or nan, the result is unbounded\n  if (!isFiniteF16(bitcastedF16Value)) {\n    return [f16UnboundedInterval];\n  }\n  // If the casted f16 value is +/-0.0, the result can be one of both. Note that in JS -0.0 === 0.0.\n  if (bitcastedF16Value === 0.0) {\n    return [f16ZerosInterval];\n  }\n  const exactInterval = FP.f16.toInterval(bitcastedF16Value);\n  // If the casted f16 value is subnormal, it also may be flushed to +/-0.0.\n  return [exactInterval, ...(isSubnormalNumberF16(bitcastedF16Value) ? [f16ZerosInterval] : [])];\n}\n\n/**\n * @returns a Comparator for checking if a f16 value is a valid\n * bitcast conversion from f16.\n */\nfunction bitcastF16ToF16Comparator(f: number): Comparator {\n  if (!isFiniteF16(f)) return anyOf(f16UnboundedInterval);\n  return anyOf(...generateF16ExpectationIntervals(f));\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> is a valid bitcast\n * conversion from u32.\n */\nfunction bitcastU32ToVec2F16Comparator(u: number): Comparator {\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(u).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> value is a valid\n * bitcast conversion from i32.\n */\nfunction bitcastI32ToVec2F16Comparator(i: number): Comparator {\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(reinterpretI32AsU32(i)).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToVec2F16Comparator(f: number): Comparator {\n  // If input f32 is not finite, it can be evaluated to any value and thus any result f16 vec2 is\n  // possible.\n  if (!isFiniteF32(f)) {\n    return anyOf([f16UnboundedInterval, f16UnboundedInterval]);\n  }\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(reinterpretF32AsU32(f)).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<u32>.\n */\nfunction bitcastVec2U32ToVec4F16Comparator(u32x2: number[]): Comparator {\n  assert(u32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = u32x2.flatMap(u32ToU16x2).map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<i32>.\n */\nfunction bitcastVec2I32ToVec4F16Comparator(i32x2: number[]): Comparator {\n  assert(i32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = i32x2\n    .map(reinterpretI32AsU32)\n    .flatMap(u32ToU16x2)\n    .map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<f32>.\n */\nfunction bitcastVec2F32ToVec4F16Comparator(f32x2: number[]): Comparator {\n  assert(f32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = f32x2\n    .map(reinterpretF32AsU32)\n    .flatMap(u32ToU16x2)\n    .map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n// Structure that store the expectations of a single 32bit scalar/element bitcasted from two f16.\ninterface ExpectionFor32BitsScalarFromF16x2 {\n  // possibleExpectations is Scalar array if the expectation is for i32/u32 and FPInterval array for\n  // f32. Note that if the expectation for i32/u32 is unbound, possibleExpectations is meaningless.\n  possibleExpectations: (ScalarValue | FPInterval)[];\n  isUnbounded: boolean;\n}\n\n/**\n * @returns the array of possible 16bits, represented in u16, that bitcasted\n * from a given finite f16 represented in u16, handling the possible subnormal\n * flushing. Used to build up 32bits or larger results.\n */\nfunction possibleBitsInU16FromFiniteF16InU16(f16InU16: number): number[] {\n  const h = reinterpretU16AsF16(f16InU16);\n  assert(isFiniteF16(h));\n  return [f16InU16, ...(isSubnormalNumberF16(h) ? f16ZerosInU16 : [])];\n}\n\n/**\n * @returns the expectation for a single 32bit scalar bitcasted from given pair of\n * f16, result in ExpectionFor32BitsScalarFromF16x2.\n */\nfunction possible32BitScalarIntervalsFromF16x2(\n  f16x2InU16x2: number[],\n  type: 'i32' | 'u32' | 'f32'\n): ExpectionFor32BitsScalarFromF16x2 {\n  assert(f16x2InU16x2.length === 2);\n  let reinterpretFromU32: (x: number) => number;\n  let expectationsForValue: (x: number) => ScalarValue[] | FPInterval[];\n  let unboundedExpectations: FPInterval[] | ScalarValue[];\n  if (type === 'u32') {\n    reinterpretFromU32 = (x: number) => x;\n    expectationsForValue = x => [u32(x)];\n    // Scalar expectation can not express \"unbounded\" for i32 and u32, so use 0 here as a\n    // placeholder, and the possibleExpectations should be ignored if the result is unbounded.\n    unboundedExpectations = [u32(0)];\n  } else if (type === 'i32') {\n    reinterpretFromU32 = (x: number) => reinterpretU32AsI32(x);\n    expectationsForValue = x => [i32(x)];\n    // Scalar expectation can not express \"unbounded\" for i32 and u32, so use 0 here as a\n    // placeholder, and the possibleExpectations should be ignored if the result is unbounded.\n    unboundedExpectations = [i32(0)];\n  } else {\n    assert(type === 'f32');\n    reinterpretFromU32 = (x: number) => reinterpretU32AsF32(x);\n    expectationsForValue = x => {\n      // Handle the possible Inf/NaN/zeros and subnormal cases for f32 result.\n      if (!isFiniteF32(x)) {\n        return [f32UnboundedInterval];\n      }\n      // If the casted f16 value is +/-0.0, the result can be one of both. Note that in JS -0.0 === 0.0.\n      if (x === 0.0) {\n        return [f32ZerosInterval];\n      }\n      const exactInterval = FP.f32.toInterval(x);\n      // If the casted f16 value is subnormal, it also may be flushed to +/-0.0.\n      return [exactInterval, ...(isSubnormalNumberF32(x) ? [f32ZerosInterval] : [])];\n    };\n    unboundedExpectations = [f32UnboundedInterval];\n  }\n  // Return unbounded expection if f16 Inf/NaN occurs\n  if (\n    !isFiniteF16(reinterpretU16AsF16(f16x2InU16x2[0])) ||\n    !isFiniteF16(reinterpretU16AsF16(f16x2InU16x2[1]))\n  ) {\n    return { possibleExpectations: unboundedExpectations, isUnbounded: true };\n  }\n  const possibleU16Bits = f16x2InU16x2.map(possibleBitsInU16FromFiniteF16InU16);\n  const possibleExpectations = cartesianProduct(...possibleU16Bits).flatMap<\n    ScalarValue | FPInterval\n  >((possibleBitsU16x2: readonly number[]) => {\n    assert(possibleBitsU16x2.length === 2);\n    return expectationsForValue(reinterpretFromU32(u16x2ToU32(possibleBitsU16x2)));\n  });\n  return { possibleExpectations, isUnbounded: false };\n}\n\n/**\n * @returns a Comparator for checking if a u32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToU32Comparator(vec2F16InU16x2: number[]): Comparator {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'u32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyU32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToI32Comparator(vec2F16InU16x2: number[]): Comparator {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'i32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyI32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToF32Comparator(vec2F16InU16x2: number[]): Comparator {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'f32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyF32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a vec2 u32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2U32Comparator(vec4F16InU16x4: number[]): Comparator {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map(e =>\n    possible32BitScalarIntervalsFromF16x2(e, 'u32')\n  );\n  // Return alwaysPass if any element is expected unbounded. Although it may be only one unbounded\n  // element in the result vector, currently we don't have a way to build a comparator that expect\n  // only one element of i32/u32 vector unbounded.\n  if (expectationsPerElement.map(e => e.isUnbounded).reduce((a, b) => a || b, false)) {\n    return alwaysPass('any vec2<u32>');\n  }\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map(e => e.possibleExpectations)).map(\n      e => new VectorValue(e as ScalarValue[])\n    )\n  );\n}\n\n/**\n * @returns a Comparator for checking if a vec2 i32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2I32Comparator(vec4F16InU16x4: number[]): Comparator {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map(e =>\n    possible32BitScalarIntervalsFromF16x2(e, 'i32')\n  );\n  // Return alwaysPass if any element is expected unbounded. Although it may be only one unbounded\n  // element in the result vector, currently we don't have a way to build a comparator that expect\n  // only one element of i32/u32 vector unbounded.\n  if (expectationsPerElement.map(e => e.isUnbounded).reduce((a, b) => a || b, false)) {\n    return alwaysPass('any vec2<i32>');\n  }\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map(e => e.possibleExpectations)).map(\n      e => new VectorValue(e as ScalarValue[])\n    )\n  );\n}\n\n/**\n * @returns a Comparator for checking if a vec2 f32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2F32Comparator(vec4F16InU16x4: number[]): Comparator {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map(e =>\n    possible32BitScalarIntervalsFromF16x2(e, 'f32')\n  );\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map(e => e.possibleExpectations)).map(e => [\n      e[0] as FPInterval,\n      e[1] as FPInterval,\n    ])\n  );\n}\n\nexport const d = makeCaseCache('bitcast', {\n  // Identity Cases\n  i32_to_i32: () => fullI32Range().map(e => ({ input: i32(e), expected: i32(e) })),\n  u32_to_u32: () => fullU32Range().map(e => ({ input: u32(e), expected: u32(e) })),\n  f32_inf_nan_to_f32: () =>\n    f32RangeWithInfAndNaN.map(e => ({\n      input: f32(e),\n      expected: bitcastF32ToF32Comparator(e),\n    })),\n  f32_to_f32: () =>\n    f32FiniteRange.map(e => ({ input: f32(e), expected: bitcastF32ToF32Comparator(e) })),\n  f16_inf_nan_to_f16: () =>\n    [...f16FiniteInF16, ...f16InfAndNaNInF16].map(e => ({\n      input: f16(e),\n      expected: bitcastF16ToF16Comparator(e),\n    })),\n  f16_to_f16: () =>\n    f16FiniteInF16.map(e => ({ input: f16(e), expected: bitcastF16ToF16Comparator(e) })),\n\n  // i32,u32,f32,Abstract to different i32,u32,f32\n  i32_to_u32: () => fullI32Range().map(e => ({ input: i32(e), expected: u32(e) })),\n  i32_to_f32: () =>\n    i32RangeForF32Finite.map(e => ({\n      input: i32(e),\n      expected: bitcastI32ToF32Comparator(e),\n    })),\n  ai_to_i32: () => fullI32Range().map(e => ({ input: abstractInt(BigInt(e)), expected: i32(e) })),\n  ai_to_u32: () => fullU32Range().map(e => ({ input: abstractInt(BigInt(e)), expected: u32(e) })),\n  ai_to_f32: () =>\n    // AbstractInt is converted to i32, because there is no explicit overload\n    i32RangeForF32Finite.map(e => ({\n      input: abstractInt(BigInt(e)),\n      expected: bitcastI32ToF32Comparator(e),\n    })),\n  i32_to_f32_inf_nan: () =>\n    i32RangeForF32FiniteInfNaN.map(e => ({\n      input: i32(e),\n      expected: bitcastI32ToF32Comparator(e),\n    })),\n  u32_to_i32: () => fullU32Range().map(e => ({ input: u32(e), expected: i32(e) })),\n  u32_to_f32: () =>\n    u32RangeForF32Finite.map(e => ({\n      input: u32(e),\n      expected: bitcastU32ToF32Comparator(e),\n    })),\n  u32_to_f32_inf_nan: () =>\n    u32RangeForF32FiniteInfNaN.map(e => ({\n      input: u32(e),\n      expected: bitcastU32ToF32Comparator(e),\n    })),\n  f32_inf_nan_to_i32: () =>\n    f32RangeWithInfAndNaN.map(e => ({\n      input: f32(e),\n      expected: bitcastF32ToI32Comparator(e),\n    })),\n  f32_to_i32: () =>\n    f32FiniteRange.map(e => ({ input: f32(e), expected: bitcastF32ToI32Comparator(e) })),\n\n  f32_inf_nan_to_u32: () =>\n    f32RangeWithInfAndNaN.map(e => ({\n      input: f32(e),\n      expected: bitcastF32ToU32Comparator(e),\n    })),\n  f32_to_u32: () =>\n    f32FiniteRange.map(e => ({ input: f32(e), expected: bitcastF32ToU32Comparator(e) })),\n\n  // i32,u32,f32,AbstractInt to vec2<f16>\n  u32_to_vec2_f16_inf_nan: () =>\n    u32RangeForF16Vec2FiniteInfNaN.map(e => ({\n      input: u32(e),\n      expected: bitcastU32ToVec2F16Comparator(e),\n    })),\n  u32_to_vec2_f16: () =>\n    u32RangeForF16Vec2Finite.map(e => ({\n      input: u32(e),\n      expected: bitcastU32ToVec2F16Comparator(e),\n    })),\n  i32_to_vec2_f16_inf_nan: () =>\n    i32RangeForF16Vec2FiniteInfNaN.map(e => ({\n      input: i32(e),\n      expected: bitcastI32ToVec2F16Comparator(e),\n    })),\n  i32_to_vec2_f16: () =>\n    i32RangeForF16Vec2Finite.map(e => ({\n      input: i32(e),\n      expected: bitcastI32ToVec2F16Comparator(e),\n    })),\n  ai_to_vec2_f16: () =>\n    // AbstractInt is converted to i32, because there is no explicit overload\n    i32RangeForF16Vec2Finite.map(e => ({\n      input: abstractInt(BigInt(e)),\n      expected: bitcastI32ToVec2F16Comparator(e),\n    })),\n  f32_inf_nan_to_vec2_f16_inf_nan: () =>\n    f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN.map(e => ({\n      input: f32(e),\n      expected: bitcastF32ToVec2F16Comparator(e),\n    })),\n  f32_to_vec2_f16: () =>\n    f32FiniteRangeForF16Vec2Finite.map(e => ({\n      input: f32(e),\n      expected: bitcastF32ToVec2F16Comparator(e),\n    })),\n  af_to_vec2_f16: () =>\n    f32FiniteRangeForF16Vec2Finite.map(e => ({\n      input: abstractFloat(e),\n      expected: bitcastF32ToVec2F16Comparator(e),\n    })),\n\n  // vec2<i32>, vec2<u32>, vec2<f32>, vec2<AbstractInt> to vec4<f16>\n  vec2_i32_to_vec4_f16_inf_nan: () =>\n    slidingSlice(i32RangeForF16Vec2FiniteInfNaN, 2).map(e => ({\n      input: toVector(e, i32),\n      expected: bitcastVec2I32ToVec4F16Comparator(e),\n    })),\n  vec2_i32_to_vec4_f16: () =>\n    slidingSlice(i32RangeForF16Vec2Finite, 2).map(e => ({\n      input: toVector(e, i32),\n      expected: bitcastVec2I32ToVec4F16Comparator(e),\n    })),\n  vec2_ai_to_vec4_f16: () =>\n    // AbstractInt is converted to i32, because there is no explicit overload\n    slidingSlice(i32RangeForF16Vec2Finite, 2).map(e => ({\n      input: toVector(e, (n: number) => abstractInt(BigInt(n))),\n      expected: bitcastVec2I32ToVec4F16Comparator(e),\n    })),\n  vec2_u32_to_vec4_f16_inf_nan: () =>\n    slidingSlice(u32RangeForF16Vec2FiniteInfNaN, 2).map(e => ({\n      input: toVector(e, u32),\n      expected: bitcastVec2U32ToVec4F16Comparator(e),\n    })),\n  vec2_u32_to_vec4_f16: () =>\n    slidingSlice(u32RangeForF16Vec2Finite, 2).map(e => ({\n      input: toVector(e, u32),\n      expected: bitcastVec2U32ToVec4F16Comparator(e),\n    })),\n  vec2_f32_inf_nan_to_vec4_f16_inf_nan: () =>\n    slidingSlice(f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN, 2).map(e => ({\n      input: toVector(e, f32),\n      expected: bitcastVec2F32ToVec4F16Comparator(e),\n    })),\n  vec2_f32_to_vec4_f16: () =>\n    slidingSlice(f32FiniteRangeForF16Vec2Finite, 2).map(e => ({\n      input: toVector(e, f32),\n      expected: bitcastVec2F32ToVec4F16Comparator(e),\n    })),\n  vec2_af_to_vec4_f16: () =>\n    slidingSlice(f32FiniteRangeForF16Vec2Finite, 2).map(e => ({\n      input: toVector(e, abstractFloat),\n      expected: bitcastVec2F32ToVec4F16Comparator(e),\n    })),\n\n  // vec2<f16> to i32, u32, f32\n  vec2_f16_to_u32: () =>\n    f16Vec2FiniteInU16x2.map(e => ({\n      input: u16x2ToVec2F16(e),\n      expected: bitcastVec2F16ToU32Comparator(e),\n    })),\n  vec2_f16_inf_nan_to_u32: () =>\n    f16Vec2FiniteInfNanInU16x2.map(e => ({\n      input: u16x2ToVec2F16(e),\n      expected: bitcastVec2F16ToU32Comparator(e),\n    })),\n  vec2_f16_to_i32: () =>\n    f16Vec2FiniteInU16x2.map(e => ({\n      input: u16x2ToVec2F16(e),\n      expected: bitcastVec2F16ToI32Comparator(e),\n    })),\n  vec2_f16_inf_nan_to_i32: () =>\n    f16Vec2FiniteInfNanInU16x2.map(e => ({\n      input: u16x2ToVec2F16(e),\n      expected: bitcastVec2F16ToI32Comparator(e),\n    })),\n  vec2_f16_to_f32_finite: () =>\n    f16Vec2FiniteInU16x2\n      .filter(u16x2 => isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x2))))\n      .map(e => ({\n        input: u16x2ToVec2F16(e),\n        expected: bitcastVec2F16ToF32Comparator(e),\n      })),\n  vec2_f16_inf_nan_to_f32: () =>\n    f16Vec2FiniteInfNanInU16x2.map(e => ({\n      input: u16x2ToVec2F16(e),\n      expected: bitcastVec2F16ToF32Comparator(e),\n    })),\n\n  // vec4<f16> to vec2 of i32, u32, f32\n  vec4_f16_to_vec2_u32: () =>\n    f16Vec2FiniteInU16x4.map(e => ({\n      input: u16x4ToVec4F16(e),\n      expected: bitcastVec4F16ToVec2U32Comparator(e),\n    })),\n  vec4_f16_inf_nan_to_vec2_u32: () =>\n    f16Vec2FiniteInfNanInU16x4.map(e => ({\n      input: u16x4ToVec4F16(e),\n      expected: bitcastVec4F16ToVec2U32Comparator(e),\n    })),\n  vec4_f16_to_vec2_i32: () =>\n    f16Vec2FiniteInU16x4.map(e => ({\n      input: u16x4ToVec4F16(e),\n      expected: bitcastVec4F16ToVec2I32Comparator(e),\n    })),\n  vec4_f16_inf_nan_to_vec2_i32: () =>\n    f16Vec2FiniteInfNanInU16x4.map(e => ({\n      input: u16x4ToVec4F16(e),\n      expected: bitcastVec4F16ToVec2I32Comparator(e),\n    })),\n  vec4_f16_to_vec2_f32_finite: () =>\n    f16Vec2FiniteInU16x4\n      .filter(\n        u16x4 =>\n          isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x4.slice(0, 2)))) &&\n          isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x4.slice(2, 4))))\n      )\n      .map(e => ({\n        input: u16x4ToVec4F16(e),\n        expected: bitcastVec4F16ToVec2F32Comparator(e),\n      })),\n  vec4_f16_inf_nan_to_vec2_f32: () =>\n    f16Vec2FiniteInfNanInU16x4.map(e => ({\n      input: u16x4ToVec4F16(e),\n      expected: bitcastVec4F16ToVec2F32Comparator(e),\n    })),\n});\n"],"mappings":"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"}