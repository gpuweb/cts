{"version":3,"file":"derivatives.js","names":["Type","align","toComparator","packScalarsToVector","runDerivativeTest","t","cases","builtin","non_uniform_discard","vectorize","type","f32","undefined","packed","resultType","dir","valueStride","conversionFromInput","conversionToOutput","code","length","module","device","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","bufferSize","inputBuffer","createBufferTracked","size","usage","GPUBufferUsage","UNIFORM","mappedAtCreation","valuesData","Uint8Array","getMappedRange","i","inputs","input","copyTo","unmap","group","createBindGroup","entries","binding","resource","buffer","getBindGroupLayout","colorAttachment","createTextureTracked","width","height","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","bytesPerRow","results","encoder","createCommandEncoder","quad","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setBindGroup","draw","end","outputBuffer","COPY_DST","push","copyTextureToBuffer","texture","queue","submit","finish","forEach","quadNdx","expectGPUBufferValuesPassCheck","outputData","tx","ty","inputNdx","caseNdx","c","index","result","read","cmp","expected","compare","matched","endsWith","c0","cmp0","Error","join","typedLength"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/derivatives.ts"],"sourcesContent":["import { GPUTest } from '../../../../../gpu_test.js';\nimport { Type, Value } from '../../../../../util/conversion.js';\nimport { align } from '../../../../../util/math.js';\nimport { Case } from '../../case.js';\nimport { toComparator } from '../../expectation.js';\nimport { packScalarsToVector } from '../../expression.js';\n\n/**\n * Run a test for a derivative builtin function.\n * @param t the GPUTest\n * @param cases list of test cases to run\n * @param builtin the builtin function to test\n * @param non_uniform_discard if true, one of each pair of invocations will discard\n * @param vectorize if defined, the vector width to use (2, 3, or 4)\n */\nexport function runDerivativeTest(\n  t: GPUTest,\n  cases: Case[],\n  builtin: string,\n  non_uniform_discard: boolean,\n  vectorize?: number\n) {\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  let type: Type = Type.f32;\n  if (vectorize !== undefined) {\n    const packed = packScalarsToVector([type, type], type, cases, vectorize);\n    cases = packed.cases;\n    type = packed.resultType;\n  }\n\n  ////////////////////////////////////////////////////////////////\n  // The two input values for a given case are distributed to two different invocations in a quad.\n  // We will populate a uniform buffer with these input values laid out sequentially:\n  // [ case_0_input_1, case_0_input_0, case_1_input_1, case_1_input_0, ...]\n  //\n  // The render pipeline will be launched once per pair of cases over a viewport\n  // size of (2, 2). Each 2x2 set of calls will will exercise two test cases.\n  // Each of these draw calls will use a different instance index, which is\n  // forwarded to the fragment shader. Each invocation returns the result which\n  // is stored in a rgba32uint texture.\n  //\n  // Consider draw calls that test 4 cases (c_0, c_1, c_2, c_3).\n  //\n  // For derivatives along the 'x' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_0_i_0 |     Quad 1: | c_2_i_1 | c_2_i_0 |\n  //         | c_1_i_1 | c_1_i_0 |             | c_3_i_1 | c_3_i_0 |\n  //\n  // For derivatives along the 'y' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_1_i_1 |     Quad 1: | c_2_i_1 | c_3_i_1 |\n  //         | c_0_i_0 | c_1_i_0 |             | c_2_i_0 | c_3_i_0 |\n  //\n  ////////////////////////////////////////////////////////////////\n\n  // Determine the direction of the derivative ('x' or 'y') from the builtin name.\n  const dir = builtin[3];\n\n  // Determine the WGSL type to use in the shader, and the stride in bytes between values.\n  const valueStride = 16;\n  let conversionFromInput = 'input.x';\n  let conversionToOutput = `vec4f(v)`;\n  if (vectorize) {\n    switch (vectorize) {\n      case 2:\n        conversionFromInput = 'input.xy';\n        conversionToOutput = 'vec4f(v, 0, 0)';\n        break;\n      case 3:\n        conversionFromInput = 'input.xyz';\n        conversionToOutput = 'vec4f(v, 0)';\n        break;\n      case 4:\n        conversionFromInput = 'input';\n        conversionToOutput = 'v';\n        break;\n    }\n  }\n\n  // Define a vertex shader that draws a triangle over the full viewport, and a fragment shader that\n  // calls the derivative builtin with a value loaded from that fragment's index into the storage\n  // buffer (determined using the quad index and fragment position, as described above).\n  const code = `\nstruct CaseInfo {\n  @builtin(position) position: vec4f,\n  @location(0) @interpolate(flat, either) quad_idx: u32,\n}\n\n@vertex\nfn vert(@builtin(vertex_index) vertex_idx: u32,\n        @builtin(instance_index) instance_idx: u32) -> CaseInfo {\n  const kVertices = array(\n    vec2f(-2, -2),\n    vec2f( 2, -2),\n    vec2f( 0,  2),\n  );\n  return CaseInfo(vec4(kVertices[vertex_idx], 0, 1), instance_idx);\n}\n\n@group(0) @binding(0) var<uniform> inputs : array<vec4f, ${cases.length * 2}>;\n\n@fragment\nfn frag(info : CaseInfo) -> @location(0) vec4u {\n  let case_idx = u32(info.position.${dir === 'x' ? 'y' : 'x'});\n  let inv_idx = u32(info.position.${dir});\n  let index = info.quad_idx*4 + case_idx*2 + inv_idx;\n  let input = inputs[index];\n  ${non_uniform_discard ? 'if inv_idx == 0 { discard; }' : ''}\n  let v = ${builtin}(${conversionFromInput});\n  return bitcast<vec4u>(${conversionToOutput});\n}\n`;\n\n  // Create the render pipeline.\n  const module = t.device.createShaderModule({ code });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    fragment: { module, targets: [{ format: 'rgba32uint' }] },\n  });\n\n  // Create storage buffers to hold the inputs and outputs.\n  const bufferSize = cases.length * 2 * valueStride;\n  const inputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.UNIFORM,\n    mappedAtCreation: true,\n  });\n\n  // Populate the input uniform buffer with case input values.\n  const valuesData = new Uint8Array(inputBuffer.getMappedRange());\n  for (let i = 0; i < cases.length; i++) {\n    const inputs = cases[i].input as ReadonlyArray<Value>;\n    inputs[0].copyTo(valuesData, (i * 2 + 1) * valueStride);\n    inputs[1].copyTo(valuesData, i * 2 * valueStride);\n  }\n  inputBuffer.unmap();\n\n  // Create a bind group for the storage buffers.\n  const group = t.device.createBindGroup({\n    entries: [{ binding: 0, resource: { buffer: inputBuffer } }],\n    layout: pipeline.getBindGroupLayout(0),\n  });\n\n  const colorAttachment = t.createTextureTracked({\n    size: { width: 2, height: 2 },\n    format: 'rgba32uint',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n  });\n  const bytesPerRow = align(valueStride * colorAttachment.width, 256);\n\n  // Submit the render pass to the device.\n  const results = [];\n  const encoder = t.device.createCommandEncoder();\n  for (let quad = 0; quad < cases.length / 2; quad++) {\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachment.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, group);\n    pass.draw(3, 1, 0, quad);\n    pass.end();\n    const outputBuffer = t.createBufferTracked({\n      size: bytesPerRow * colorAttachment.height,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    results.push(outputBuffer);\n    encoder.copyTextureToBuffer(\n      { texture: colorAttachment },\n      { buffer: outputBuffer, bytesPerRow },\n      [colorAttachment.width, colorAttachment.height]\n    );\n  }\n\n  t.queue.submit([encoder.finish()]);\n\n  // Check the outputs match the expected results.\n  results.forEach((outputBuffer, quadNdx) => {\n    t.expectGPUBufferValuesPassCheck(\n      outputBuffer,\n      (outputData: Uint8Array) => {\n        for (let i = 0; i < 4; ++i) {\n          const tx = i % 2;\n          const ty = (i / 2) | 0;\n          const [inputNdx, caseNdx] = dir === 'x' ? [tx, ty] : [ty, tx];\n          const c = cases[quadNdx * 2 + caseNdx];\n\n          // Both invocations involved in the derivative should get the same result.\n          if (non_uniform_discard && inputNdx === 0) {\n            continue;\n          }\n\n          const index = ty * bytesPerRow + tx * valueStride;\n          const result = type.read(outputData, index);\n          const cmp = toComparator(c.expected).compare(result);\n          if (!cmp.matched) {\n            // If this is a coarse derivative, the implementation is also allowed to calculate only\n            // one of the two derivatives and return that result to all of the invocations.\n            if (!builtin.endsWith('Fine')) {\n              const c0 = cases[inputNdx];\n              const cmp0 = toComparator(c0.expected).compare(result);\n              if (!cmp0.matched) {\n                return new Error(`\n  1st pair: (${(c.input as Value[]).join(', ')})\n  expected: ${cmp.expected}\n\n  2nd pair: (${(c0.input as Value[]).join(', ')})\n  expected: ${cmp0.expected}\n\n  returned: ${result}`);\n              }\n            } else {\n              return new Error(`\n    inputs: (${(c.input as Value[]).join(', ')})\n  expected: ${cmp.expected}\n\n  returned: ${result}`);\n            }\n          }\n        }\n        return undefined;\n      },\n      {\n        type: Uint8Array,\n        typedLength: outputBuffer.size,\n      }\n    );\n  });\n}\n"],"mappings":"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"}