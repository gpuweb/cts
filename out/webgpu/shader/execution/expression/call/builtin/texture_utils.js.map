{"version":3,"file":"texture_utils.js","names":["keysOf","assert","range","unreachable","Float16Array","getBlockInfoForColorTextureFormat","getBlockInfoForTextureFormat","getTextureFormatType","is32Float","isColorTextureFormat","isCompressedFloatTextureFormat","isCompressedTextureFormat","isDepthOrStencilTextureFormat","isDepthTextureFormat","isEncodableTextureFormat","isSintOrUintFormat","isStencilTextureFormat","kEncodableTextureFormats","align","clamp","dotProduct","hashU32","lcm","lerp","quantizeToF32","effectiveViewDimensionForDimension","physicalMipSize","physicalMipSizeFromTexture","reifyTextureDescriptor","virtualMipSize","kTexelRepresentationInfo","TexelComponent","TexelView","copyTexelViewsToTexture","createTextureFromTexelViews","reifyExtent3D","kShortShaderStageToShaderStage","c","f","v","kShortShaderStages","kShortAddressModeToAddressMode","r","m","kShortAddressModes","kSampleTypeInfo","f32","format","i32","u32","getTextureTypeForTextureViewDimension","viewDimension","isUnencodableDepthFormat","skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable","t","filter","skipIfTextureFormatNotSupported","skipIf","type","skipIfDeviceDoesNotHaveFeature","isFillable","endsWith","isPotentiallyFilterableAndFillable","canPotentiallyFilter","result","builtinNeedsMipLevelWeights","builtin","unzip","array","num","srcStride","undefined","arrays","numEntries","Math","ceil","length","i","j","push","makeGraph","width","height","data","Uint8Array","plot","norm","x","y","floor","min","max","offset","plotValues","values","toString","conversion","lines","subarray","map","join","linear0to1OverN","n","graphWeights","weights","graph","validateWeights","stage","showWeights","rec","debugging","padStart","kMipLevelWeightSteps","kMinPercentUniqueWeights","Set","size","queryMipLevelMixWeightsForDevice","device","kNumWeightTypes","module","createShaderModule","code","texture","createTextureTracked","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","mipLevelCount","queue","writeTexture","mipLevel","bytesPerRow","sampler","createSampler","minFilter","magFilter","mipmapFilter","target","RENDER_ATTACHMENT","COPY_SRC","storageBuffer","createBufferTracked","label","GPUBufferUsage","STORAGE","resultBuffer","MAP_READ","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","encoder","createCommandEncoder","createComputePipeline","compute","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","copyBufferToBuffer","createRenderPipeline","vertex","entryPoint","fragment","targets","beginRenderPass","colorAttachments","view","loadOp","storeOp","setViewport","draw","copyTextureToBuffer","submit","finish","mapAsync","GPUMapMode","READ","Array","from","Float32Array","getMappedRange","unmap","destroy","sampleLevelWeights","gradWeights","softwareMixToGPUMixGradWeights","generateSoftwareMixToGPUMixGradWeights","getIndexAndWeight","lo","hi","w0","w1","weight","bilinearFilter","ndx","v0","v1","gpuWeights","numSteps","depthOrArrayLayers","softwareWeights","u","g","computeMipLevelFromGradients","softwareMixToGPUMixMap","mix","mapSoftwareMipLevelToGPUMipLevel","baseLevel","softwareMix","gpuMix","getMixWeightByTypeForMipLevel","euclideanModulo","s_deviceToMipLevelWeightsPromise","WeakMap","s_deviceToMipLevelWeights","initMipLevelWeightsForDevice","stageWeightsP","get","set","weightsP","then","stageWeights","catch","e","weightType","steps","w","lowerNdx","upperNdx","getWeightForMipLevel","skipIfNoStorageTexturesInStage","isCompatibility","limits","maxStorageTexturesInFragmentStage","maxStorageTexturesInVertexStage","executeTextureQueryAndExpectResult","viewDescriptor","expected","returnType","castWGSL","stageWGSL","wgsl","visibility","GPUShaderStage","COMPUTE","FRAGMENT","VERTEX","includes","externalTexture","GPUTexture","storageTexture","access","dimension","sampleType","aspect","sampleCount","multisampled","bindGroupLayouts","createBindGroupLayout","hasDynamicOffset","minBindingSize","createPipelineLayout","bindGroup0","GPUExternalTexture","renderTarget","bindGroup1","Uint32Array","expectGPUBufferValuesEqual","getLimitValue","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getMinAndMaxTexelValueForComponent","rep","component","numericRange","perComponentRanges","perComponentRange","getTexelViewFormatForTextureFormat","kTextureTypeInfo","depth","componentType","resultType","resultFormat","float","sint","uint","getTextureFormatTypeInfo","appendComponentTypeForFormatToTextureType","base","getBaseMipLevelInfo","textureInfo","baseMipLevel","descriptor","baseMipLevelSize","baseArrayLayer","arrayLayerCount","makeRandomDepthComparisonTexelGenerator","info","comparison","comparisonIsEqualOrNotEqual","fixedValues","encode","coords","texel","componentOrder","rnd","z","sampleIndex","charCodeAt","normalized","quantize","createRandomTexelViewViaColors","options","minMax","Object","fromEntries","generator","fromTexelsAsColors","createRandomTexelViewViaBytes","formatInfo","bytesPerBlock","blocksAcross","blockWidth","blocksDown","blockHeight","bytesNeeded","hashBase","sumOfCharCodesOfString","R","asFloat","asU32","fromTextureDataByReference","rowsPerImage","subrectOrigin","subrectSize","createRandomTexelView","canFillWithRandomTypedData","createRandomTexelViewMipmap","kTextureCallArgNames","isBuiltinComparison","isBuiltinGather","builtinNeedsSampler","startsWith","builtinNeedsDerivatives","isCubeViewDimension","isViewDimensionCubeOrCubeArray","s_u32","s_f32","s_i32","Int32Array","kBitCastFunctions","getCallArgType","call","argName","coordType","levelType","arrayIndexType","sampleIndexType","toArray","repl","bitsToNumber","unpackBits","pack","apply","a","b","op","getUnusedCubeCornerSampleIndex","textureSize","add","convertPerTexelComponentToResultFormat","src","effectiveFormat","components","kRGBAComponents","out","G","B","A","convertToTexelViewFormat","Depth","Stencil","convertResultFormatToTexelViewFormat","zeroValuePerTexelComponent","kSamplerFns","never","ref","less","equal","less-equal","greater","not-equal","greater-equal","always","kDefaultValueForDepthTextureComponents","applyCompareToTexel","compare","compareFn","applyCompare","depthRef","getEffectiveLodClamp","softwareTexture","lodMinClamp","lodMaxClamp","softwareTextureReadMipLevel","texels","mipLevelSize","addressMode","addressModeU","addressModeV","addressModeW","isCube","arrayIndexMult","numLayers","textureSizeForCube","load","at","zFromArrayIndex","arrayIndex","color","convertCubeCoordToNormalized3DTextureCoord","samples","p0","p1","p1W","p0W","describeTextureCall","p","round","componentNdx","forEach","sample","wrapFaceCoordToCubeFaceAtEdgeBoundaries","applyAddressModesToCoords","postV","rgba","isOutOfBoundsCall","softwareTextureReadLevel","lodClampMinMax","effectiveMipmapFilter","clampedMipLevel","rootMipLevel","nextMipLevel","t0","t1","ddx","ddy","texSize","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","computeMipLevelFromGradientsForCall","softwareTextureReadGrad","bias","weightMipLevel","derivativeBaseForCall","isDDX","derivativeForCall","dd","derivativeMult","softwareTextureRead","newCall","desc","callMipLevel","isValidOutOfBoundsValue","gotRGBA","maxFractionalDiff","mipTexels","texelsApproximatelyEqual","okBecauseOutOfBounds","kRComponent","gotFormat","expectRGBA","expectedFormat","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","rgbaComponentsToCheck","features","has","isNaN","absDiff","abs","ulpDiff","getULPFromZeroForComponents","temp","comp","ulp","getTextureViewDescription","physicalMipLevelCount","checkCallResults","textureType","calls","results","shortShaderStage","gpuTexture","haveComparisonCheckInfo","checkInfo","runner","gpuTexels","errs","getMaxFractionalDiffForTextureFormat","debug","callIdx","callSpecificMaxFractionalDiff","bad","diffs","maxAbs","relDiff","isFloatType","fix5","toFixed","fix5v","arr","rgbaToArray","lodClamp","coord","faceNdx","mipSize","slice","kFaceNames","biasStr","clampedBias","debugCalls","debugCall","debugSampler","debugRunner","createTextureCallsRunner","readTextureToTexelViews","callForSamplePoints","useTexelFormatForGPUTexture","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","createTextureFromTexelViewsLocal","run","layoutTwoColumns","Error","s","String","split","reduce","sum","makeAstcBlockFiller","makeRandomBytesBlockFiller","getBlockFiller","fillTextureWithRandomData","fillBlock","s_readTextureToRGBA32DeviceToPipeline","getEffectiveViewDimension","textureBindingViewDimension","viewDimensionToPipelineMap","Map","id","textureWGSL","loadWGSL","dimensionWGSL","textureLoadCubeWGSL","bindGroupLayout","readBuffers","uniformValues","uniformBuffer","byteLength","UNIFORM","writeBuffer","readBuffer","getAspectForTexture","bindGroup","texelViews","Ctor","modifiedDescriptor","createTextureWithRandomDataAndGetTexelsForEachAspect","d32Descriptor","stencilTexels","texelsPerAspect","createTextureWithRandomDataAndGetTexels","valueIfAllComponentsAreEqual","next","value","createCanvasWithRandomDataAndGetTexels","imageData","ImageData","canvas","OffscreenCanvas","ctx","getContext","putImageData","alpha","callForSamples","originalCall","mipLevelSizes","numTexelsPerLevel","numTexelsOfPrecedingLevels","total","numTexels","getMipLevelFromTexelId","texelId","getTexelCoordFromTexelId","texelsPerSlice","layer","xyId","convertResultAsAppropriate","sampledTexelWeights","unclassifiedStack","unclassified","pop","setA","setB","keys","texelsPerRow","isCandidate","some","levels","level","layerEntries","blockParts","top","left","fill","right","block","mid","bot","texelMid","nonBlockParts","letter","idx","fromCodePoint","idCount","rangeCat","fn","joinFn","joins","parts","makeRow","blockPaddedWidth","contents","orderedTexelIndices","unSampled","face","blockPaddedHeight","padEnd","texelIdx","outside","lineParts","pad2","pad3","formatValue","formatTexel","k","colorLines","compareLines","levelWeight","singleWeight","texelStr","compareTexel","columnA","columnB","widthA","l","line","repeat","getDepthOrArrayLayersForViewDimension","chooseTextureSize","minSize","minBlocks","blockLCM","largest","kSamplePointMethods","kCubeSamplePointMethods","generateTextureBuiltinInputsImpl","makeValue","args","method","radius","loops","PI","cos","sin","_hashInputs","hashInputs","makeRandValue","number","makeRangeValue","makeIntHashValueRepeatable","kSubdivisionsPerTexel","avoidEdgeCase","textureBuiltin","edgeRemainder","avoidTextureEdge","axis","textureDimensionUnits","inside","numComponents","quantizeMipLevel","q","isTexelEdgeCase","v2","v3","makeGradient","hashInput","_","intPart","fractPart","makeDerivativeMult","mult","pow","chooseMipLevel","innerLevelR","innerLevel","outerLevel","makeDerivativeMultForTextureSample","makeBiasAndDerivativeMult","testType","derivativeBasedMipLevel","derivatives","grad","kMipEpsilon","intMip","fractionalMip","generateTextureBuiltinInputs1D","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kFaceUVMatrices","transformMat3","normalize","sqrt","uvw","absR","negX","negY","negZ","convertNormalized3DTexCoordToCubeCoord","uvLayer","faceLayer","faceCoord","nc0","cc","nc1","fc","generateSamplePointsCube","textureWidth","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","makeIntHashValue","halfTexel","quantizedUVW","isEdgeCase","units","wgslTypeFor","isArray","wgslExpr","wgslExprFor","binKey","name","buildBinnedCalls","fields","prototype","bitcastToU32","expr","binCalls","bins","key","binIdx","derivativeWGSL","s_deviceToPipelines","structs","body","dataFields","callCount","binned","dataBuffer","isCompare","samplerType","derivativeBaseWGSL","derivativeType","pipelines","isFiltering","JSON","stringify","bindGroupLayout0","bindGroupLayout1","gpuSampler","runViewDescriptor","outIdx","bin","doTextureCalls"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["import { keysOf } from '../../../../../../common/util/data_tables.js';\nimport { assert, range, unreachable } from '../../../../../../common/util/util.js';\nimport { Float16Array } from '../../../../../../external/petamoriken/float16/float16.js';\nimport {\n  ColorTextureFormat,\n  EncodableTextureFormat,\n  getBlockInfoForColorTextureFormat,\n  getBlockInfoForTextureFormat,\n  getTextureFormatType,\n  is32Float,\n  isColorTextureFormat,\n  isCompressedFloatTextureFormat,\n  isCompressedTextureFormat,\n  isDepthOrStencilTextureFormat,\n  isDepthTextureFormat,\n  isEncodableTextureFormat,\n  isSintOrUintFormat,\n  isStencilTextureFormat,\n  kEncodableTextureFormats,\n} from '../../../../../format_info.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lcm,\n  lerp,\n  quantizeToF32,\n} from '../../../../../util/math.js';\nimport {\n  effectiveViewDimensionForDimension,\n  physicalMipSize,\n  physicalMipSizeFromTexture,\n  reifyTextureDescriptor,\n  SampleCoord,\n  virtualMipSize,\n} from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  NumericRange,\n  PerComponentNumericRange,\n  PerTexelComponent,\n  TexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { PerPixelAtLevel, TexelView } from '../../../../../util/texture/texel_view.js';\nimport {\n  copyTexelViewsToTexture,\n  createTextureFromTexelViews,\n} from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\nimport { ShaderStage } from '../../../../validation/decl/util.js';\n\n// These are needed because the list of parameters was too long when converted to a filename.\nexport const kShortShaderStageToShaderStage = {\n  c: 'compute' as ShaderStage,\n  f: 'fragment' as ShaderStage,\n  v: 'vertex' as ShaderStage,\n} as const;\nexport const kShortShaderStages = keysOf(kShortShaderStageToShaderStage);\nexport type ShortShaderStage = (typeof kShortShaderStages)[number];\n\n// These are needed because the list of parameters was too long when converted to a filename.\nexport const kShortAddressModeToAddressMode: Record<string, GPUAddressMode> = {\n  c: 'clamp-to-edge',\n  r: 'repeat',\n  m: 'mirror-repeat',\n};\n\nexport const kShortAddressModes = keysOf(kShortAddressModeToAddressMode);\n\nexport const kSampleTypeInfo = {\n  f32: {\n    format: 'rgba8unorm',\n  },\n  i32: {\n    format: 'rgba8sint',\n  },\n  u32: {\n    format: 'rgba8uint',\n  },\n} as const;\n\n/**\n * Return the texture type for a given view dimension\n */\nexport function getTextureTypeForTextureViewDimension(viewDimension: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return 'texture_1d<f32>';\n    case '2d':\n      return 'texture_2d<f32>';\n    case '2d-array':\n      return 'texture_2d_array<f32>';\n    case '3d':\n      return 'texture_3d<f32>';\n    case 'cube':\n      return 'texture_cube<f32>';\n    case 'cube-array':\n      return 'texture_cube_array<f32>';\n    default:\n      unreachable();\n  }\n}\n\nconst isUnencodableDepthFormat = (format: GPUTextureFormat) =>\n  format === 'depth24plus' ||\n  format === 'depth24plus-stencil8' ||\n  format === 'depth32float-stencil8';\n\n/**\n * Skips a subcase if the filter === 'linear' and the format is type\n * 'unfilterable-float' and we cannot enable filtering.\n */\nexport function skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(\n  t: GPUTest,\n  filter: GPUFilterMode,\n  format: GPUTextureFormat\n) {\n  t.skipIfTextureFormatNotSupported(format);\n  if (filter === 'linear') {\n    t.skipIf(isDepthTextureFormat(format), 'depth texture are unfilterable');\n\n    const type = getTextureFormatType(format);\n    if (type === 'unfilterable-float') {\n      assert(is32Float(format));\n      t.skipIfDeviceDoesNotHaveFeature('float32-filterable');\n    }\n  }\n}\n\n/**\n * Returns if a texture format can be filled with random data.\n */\nexport function isFillable(format: GPUTextureFormat) {\n  // We can't easily put random bytes into compressed textures if they are float formats\n  // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n  return !isCompressedTextureFormat(format) || !format.endsWith('float');\n}\n\n/**\n * Returns if a texture format can potentially be filtered and can be filled with random data.\n */\nexport function isPotentiallyFilterableAndFillable(format: GPUTextureFormat) {\n  const type = getTextureFormatType(format);\n  const canPotentiallyFilter =\n    type === 'float' || type === 'unfilterable-float' || type === 'depth';\n  const result = canPotentiallyFilter && isFillable(format);\n  return result;\n}\n\nconst builtinNeedsMipLevelWeights = (builtin: TextureBuiltin) =>\n  builtin !== 'textureLoad' &&\n  builtin !== 'textureGather' &&\n  builtin !== 'textureGatherCompare' &&\n  builtin !== 'textureSampleBaseClampToEdge';\n\n/**\n * Splits in array into multiple arrays where every Nth value goes to a different array\n */\nfunction unzip<T>(array: T[], num: number, srcStride?: number) {\n  srcStride = srcStride === undefined ? num : srcStride;\n  const arrays: T[][] = range(num, () => []);\n  const numEntries = Math.ceil(array.length / srcStride);\n  for (let i = 0; i < numEntries; ++i) {\n    for (let j = 0; j < num; ++j) {\n      arrays[j].push(array[i * srcStride + j]);\n    }\n  }\n  return arrays;\n}\n\ntype MipWeights = {\n  sampleLevelWeights?: number[];\n  softwareMixToGPUMixGradWeights?: number[];\n};\ntype MipWeightType = keyof MipWeights;\n\nfunction makeGraph(width: number, height: number) {\n  const data = new Uint8Array(width * height);\n\n  return {\n    plot(norm: number, x: number, c: number) {\n      const y = clamp(Math.floor(norm * height), { min: 0, max: height - 1 });\n      const offset = (height - y - 1) * width + x;\n      data[offset] = c;\n    },\n    plotValues(values: Iterable<number>, c: number) {\n      let i = 0;\n      for (const v of values) {\n        this.plot(v, i, c);\n        ++i;\n      }\n    },\n    toString(conversion = ['.', 'e', 'A']) {\n      const lines = [];\n      for (let y = 0; y < height; ++y) {\n        const offset = y * width;\n        lines.push([...data.subarray(offset, offset + width)].map(v => conversion[v]).join(''));\n      }\n      return lines.join('\\n');\n    },\n  };\n}\n\nfunction* linear0to1OverN(n: number) {\n  for (let i = 0; i <= n; ++i) {\n    yield i / n;\n  }\n}\n\n/**\n * Generates an ascii graph of weights\n */\nexport function graphWeights(height: number, weights: number[]) {\n  const graph = makeGraph(weights.length, height);\n  graph.plotValues(linear0to1OverN(weights.length - 1), 1);\n  graph.plotValues(weights, 2);\n  return graph.toString();\n}\n\n/**\n * Validates the weights go from 0 to 1 in increasing order.\n */\nfunction validateWeights(t: GPUTest, stage: string, weights: number[]) {\n  const showWeights = t.rec.debugging\n    ? () => `\n${weights.map((v, i) => `${i.toString().padStart(2)}: ${v}`).join('\\n')}\n\ne = expected\nA = actual\n${graphWeights(32, weights)}\n`\n    : () => ``;\n\n  // Validate the weights\n  assert(\n    weights[0] === 0,\n    `stage: ${stage}, weight 0 expected 0 but was ${weights[0]}\\n${showWeights()}`\n  );\n  assert(\n    weights[kMipLevelWeightSteps] === 1,\n    `stage: ${stage}, top weight expected 1 but was ${\n      weights[kMipLevelWeightSteps]\n    }\\n${showWeights()}`\n  );\n\n  // Test that we don't have a mostly flat set of weights.\n  // This is also some small guarantee that we actually read something.\n  // Note: Ideally every value is unique but 25% is about how many an Intel Mac\n  // returns in a compute stage.\n  const kMinPercentUniqueWeights = 25;\n  assert(\n    new Set(weights).size >= ((weights.length * kMinPercentUniqueWeights * 0.01) | 0),\n    `stage: ${stage}, expected at least ~${kMinPercentUniqueWeights}% unique weights\\n${showWeights()}`\n  );\n}\n\n/**\n * In an attempt to pass on more devices without lowering the tolerances\n * so low they are meaningless, we ask the hardware to tell us, for a given\n * gradient, level, what mix weights are being used.\n *\n * This is done by drawing instanced quads and using instance_index to\n * write out results into an array. We sample a 2x2 pixel texture with\n * 2 mip levels and set the 2nd mip level to white. This means the value\n * we get back represents the weight used to mix the 2 mip levels.\n *\n * Just as a record of some differences across GPUs\n *\n * level weights: mapping from the mip level\n * parameter of `textureSampleLevel` to\n * the mix weight used by the GPU\n *\n * +--------+--------+--------+--------+\n * |        |        | intel  | amd    |\n * |        |  m1    | gen-9  | rna-1  |\n * | level  |  mac   | mac    | mac    |\n * +--------+--------+--------+--------+\n * | 0.0000 | 0.0000 | 0.0000 | 0.0000 |\n * | 0.0313 | 0.0314 | 0.0313 | 0.0000 |\n * | 0.0625 | 0.0625 | 0.0625 | 0.0000 |\n * | 0.0938 | 0.0939 | 0.0938 | 0.0000 |\n * | 0.1250 | 0.1250 | 0.1250 | 0.0313 |\n * | 0.1563 | 0.1564 | 0.1563 | 0.0703 |\n * | 0.1875 | 0.1875 | 0.1875 | 0.1094 |\n * | 0.2188 | 0.2189 | 0.2188 | 0.1484 |\n * | 0.2500 | 0.2500 | 0.2500 | 0.1875 |\n * | 0.2813 | 0.2814 | 0.2813 | 0.2266 |\n * | 0.3125 | 0.3125 | 0.3125 | 0.2656 |\n * | 0.3438 | 0.3439 | 0.3438 | 0.3047 |\n * | 0.3750 | 0.3750 | 0.3750 | 0.3438 |\n * | 0.4063 | 0.4064 | 0.4063 | 0.3828 |\n * | 0.4375 | 0.4375 | 0.4375 | 0.4219 |\n * | 0.4688 | 0.4689 | 0.4688 | 0.4609 |\n * | 0.5000 | 0.5000 | 0.5000 | 0.5000 |\n * | 0.5313 | 0.5314 | 0.5313 | 0.5391 |\n * | 0.5625 | 0.5625 | 0.5625 | 0.5781 |\n * | 0.5938 | 0.5939 | 0.5938 | 0.6172 |\n * | 0.6250 | 0.6250 | 0.6250 | 0.6563 |\n * | 0.6563 | 0.6564 | 0.6563 | 0.6953 |\n * | 0.6875 | 0.6875 | 0.6875 | 0.7344 |\n * | 0.7188 | 0.7189 | 0.7188 | 0.7734 |\n * | 0.7500 | 0.7500 | 0.7500 | 0.8125 |\n * | 0.7813 | 0.7814 | 0.7813 | 0.8516 |\n * | 0.8125 | 0.8125 | 0.8125 | 0.8906 |\n * | 0.8438 | 0.8439 | 0.8438 | 0.9297 |\n * | 0.8750 | 0.8750 | 0.8750 | 0.9688 |\n * | 0.9063 | 0.9064 | 0.9063 | 1.0000 |\n * | 0.9375 | 0.9375 | 0.9375 | 1.0000 |\n * | 0.9688 | 0.9689 | 0.9688 | 1.0000 |\n * | 1.0000 | 1.0000 | 1.0000 | 1.0000 |\n * +--------+--------+--------+--------+\n *\n * grad weights: mapping from ddx value\n * passed into `textureSampleGrad` to\n * the mix weight used by the GPU\n *\n * +--------+--------+--------+--------+\n * |        |        | intel  | amd    |\n * |        |  m1    | gen-9  | rna-1  |\n * |  ddx   |  mac   | mac    | mac    |\n * +--------+--------+--------+--------+\n * | 0.5000 | 0.0000 | 0.0000 | 0.0000 |\n * | 0.5109 | 0.0390 | 0.0430 | 0.0000 |\n * | 0.5221 | 0.0821 | 0.0859 | 0.0000 |\n * | 0.5336 | 0.1211 | 0.1289 | 0.0352 |\n * | 0.5453 | 0.1600 | 0.1719 | 0.0898 |\n * | 0.5572 | 0.2032 | 0.2109 | 0.1328 |\n * | 0.5694 | 0.2422 | 0.2461 | 0.1797 |\n * | 0.5819 | 0.2814 | 0.2852 | 0.2305 |\n * | 0.5946 | 0.3203 | 0.3203 | 0.2773 |\n * | 0.6076 | 0.3554 | 0.3594 | 0.3164 |\n * | 0.6209 | 0.3868 | 0.3906 | 0.3633 |\n * | 0.6345 | 0.4218 | 0.4258 | 0.4063 |\n * | 0.6484 | 0.4532 | 0.4609 | 0.4492 |\n * | 0.6626 | 0.4882 | 0.4922 | 0.4883 |\n * | 0.6771 | 0.5196 | 0.5234 | 0.5273 |\n * | 0.6920 | 0.5507 | 0.5547 | 0.5664 |\n * | 0.7071 | 0.5860 | 0.5859 | 0.6055 |\n * | 0.7226 | 0.6132 | 0.6133 | 0.6406 |\n * | 0.7384 | 0.6407 | 0.6445 | 0.6797 |\n * | 0.7546 | 0.6679 | 0.6719 | 0.7148 |\n * | 0.7711 | 0.6953 | 0.6992 | 0.7461 |\n * | 0.7880 | 0.7225 | 0.7266 | 0.7813 |\n * | 0.8052 | 0.7500 | 0.7539 | 0.8164 |\n * | 0.8229 | 0.7814 | 0.7813 | 0.8516 |\n * | 0.8409 | 0.8086 | 0.8086 | 0.8828 |\n * | 0.8593 | 0.8321 | 0.8320 | 0.9141 |\n * | 0.8781 | 0.8554 | 0.8594 | 0.9492 |\n * | 0.8974 | 0.8789 | 0.8828 | 0.9766 |\n * | 0.9170 | 0.9025 | 0.9063 | 1.0000 |\n * | 0.9371 | 0.9297 | 0.9297 | 1.0000 |\n * | 0.9576 | 0.9532 | 0.9531 | 1.0000 |\n * | 0.9786 | 0.9765 | 0.9766 | 1.0000 |\n * | 1.0000 | 1.0000 | 1.0000 | 1.0000 |\n * +--------+--------+--------+--------+\n */\n\nexport async function queryMipLevelMixWeightsForDevice(t: GPUTest, stage: ShaderStage) {\n  const { device } = t;\n  const kNumWeightTypes = 2;\n  assert(kNumWeightTypes <= 4);\n  const module = device.createShaderModule({\n    code: `\n      @group(0) @binding(0) var tex: texture_2d<f32>;\n      @group(0) @binding(1) var smp: sampler;\n      @group(0) @binding(2) var<storage, read_write> result: array<vec4f>;\n\n      struct VSOutput {\n        @builtin(position) pos: vec4f,\n        @location(0) @interpolate(flat, either) ndx: u32,\n        @location(1) @interpolate(flat, either) result: vec4f,\n      };\n\n      fn getMixLevels(wNdx: u32) -> vec4f {\n        let mipLevel = f32(wNdx) / ${kMipLevelWeightSteps};\n        let size = textureDimensions(tex);\n        let g = mix(1.0, 2.0, mipLevel) / f32(size.x);\n        let ddx = vec2f(g, 0);\n        return vec4f(\n          textureSampleLevel(tex, smp, vec2f(0.5), mipLevel).r,\n          textureSampleGrad(tex, smp, vec2f(0.5), ddx, vec2f(0)).r,\n          0,\n          0);\n      }\n\n      fn getPosition(vNdx: u32) -> vec4f {\n        let pos = array(\n          vec2f(-1,  3),\n          vec2f( 3, -1),\n          vec2f(-1, -1),\n        );\n        let p = pos[vNdx];\n        return vec4f(p, 0, 1);\n      }\n\n      // -- for getting fragment stage weights --\n\n      @vertex fn vs(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n        return VSOutput(getPosition(vNdx), iNdx, vec4f(0));\n      }\n\n      @fragment fn fsRecord(v: VSOutput) -> @location(0) vec4u {\n        return bitcast<vec4u>(getMixLevels(v.ndx));\n      }\n\n      // -- for getting compute stage weights --\n\n      @compute @workgroup_size(1) fn csRecord(@builtin(global_invocation_id) id: vec3u) {\n        result[id.x] = getMixLevels(id.x);\n      }\n\n      // -- for getting vertex stage weights --\n\n      @vertex fn vsRecord(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n        return VSOutput(getPosition(vNdx), iNdx, getMixLevels(iNdx));\n      }\n\n      @fragment fn fsSaveVs(v: VSOutput) -> @location(0) vec4u {\n        return bitcast<vec4u>(v.result);\n      }\n    `,\n  });\n\n  const texture = t.createTextureTracked({\n    size: [2, 2, 1],\n    format: 'r8unorm',\n    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n    mipLevelCount: 2,\n  });\n\n  device.queue.writeTexture(\n    { texture, mipLevel: 1 },\n    new Uint8Array([255]),\n    { bytesPerRow: 1 },\n    [1, 1]\n  );\n\n  const sampler = device.createSampler({\n    minFilter: 'linear',\n    magFilter: 'linear',\n    mipmapFilter: 'linear',\n  });\n\n  const target = t.createTextureTracked({\n    size: [kMipLevelWeightSteps + 1, 1],\n    format: 'rgba32uint',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n  });\n\n  const storageBuffer = t.createBufferTracked({\n    label: 'queryMipLevelMixWeightsForDevice:storageBuffer',\n    size: 4 * 4 * (kMipLevelWeightSteps + 1),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n  });\n\n  const resultBuffer = t.createBufferTracked({\n    label: 'queryMipLevelMixWeightsForDevice:resultBuffer',\n    size: align(storageBuffer.size, 256), // padded for copyTextureToBuffer\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n\n  const createBindGroup = (pipeline: GPUComputePipeline | GPURenderPipeline) =>\n    device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: texture.createView() },\n        { binding: 1, resource: sampler },\n        ...(stage === 'compute' ? [{ binding: 2, resource: { buffer: storageBuffer } }] : []),\n      ],\n    });\n\n  const encoder = device.createCommandEncoder({ label: 'queryMipLevelMixWeightsForDevice' });\n  switch (stage) {\n    case 'compute': {\n      const pipeline = device.createComputePipeline({\n        layout: 'auto',\n        compute: { module },\n      });\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, createBindGroup(pipeline));\n      pass.dispatchWorkgroups(kMipLevelWeightSteps + 1);\n      pass.end();\n      encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n      break;\n    }\n    case 'fragment': {\n      const pipeline = device.createRenderPipeline({\n        layout: 'auto',\n        vertex: { module, entryPoint: 'vs' },\n        fragment: { module, entryPoint: 'fsRecord', targets: [{ format: 'rgba32uint' }] },\n      });\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: target.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, createBindGroup(pipeline));\n      for (let x = 0; x <= kMipLevelWeightSteps; ++x) {\n        pass.setViewport(x, 0, 1, 1, 0, 1);\n        pass.draw(3, 1, 0, x);\n      }\n      pass.end();\n      encoder.copyTextureToBuffer({ texture: target }, { buffer: resultBuffer }, [target.width]);\n      break;\n    }\n    case 'vertex': {\n      const pipeline = device.createRenderPipeline({\n        layout: 'auto',\n        vertex: { module, entryPoint: 'vsRecord' },\n        fragment: { module, entryPoint: 'fsSaveVs', targets: [{ format: 'rgba32uint' }] },\n      });\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: target.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, createBindGroup(pipeline));\n      for (let x = 0; x <= kMipLevelWeightSteps; ++x) {\n        pass.setViewport(x, 0, 1, 1, 0, 1);\n        pass.draw(3, 1, 0, x);\n      }\n      pass.end();\n      encoder.copyTextureToBuffer({ texture: target }, { buffer: resultBuffer }, [target.width]);\n      break;\n    }\n  }\n  device.queue.submit([encoder.finish()]);\n\n  await resultBuffer.mapAsync(GPUMapMode.READ);\n  // need to map a sub-portion since we may have padded the buffer.\n  const result = Array.from(\n    new Float32Array(resultBuffer.getMappedRange(0, (kMipLevelWeightSteps + 1) * 16))\n  );\n  resultBuffer.unmap();\n  resultBuffer.destroy();\n\n  const [sampleLevelWeights, gradWeights] = unzip(result, kNumWeightTypes, 4);\n\n  validateWeights(t, stage, sampleLevelWeights);\n  validateWeights(t, stage, gradWeights);\n\n  texture.destroy();\n  storageBuffer.destroy();\n\n  return {\n    sampleLevelWeights,\n    softwareMixToGPUMixGradWeights: generateSoftwareMixToGPUMixGradWeights(gradWeights, texture),\n  };\n}\n\n// Given an array of ascending values and a value v, finds\n// which indices in the array v is between. Returns the lower\n// index and the mix weight between the 2 indices for v.\n//\n// In other words, if values = [10, 20, 30, 40, 50]\n//\n//    getIndexAndWeight(values, 38)  -> [2, 0.8]\n//\n// Example:\n//\n//    values = [10, 20, 30, 40, 50]\n//    v = 38\n//    [ndx, weight] = getIndexAndWeight(values, v);\n//    v2 = lerp(values[ndx], values[ndx + 1], weight);\n//    assert(v === v2)\nfunction getIndexAndWeight(values: readonly number[], v: number) {\n  assert(v >= values[0] && v <= values[values.length - 1]);\n  let lo = 0;\n  let hi = values.length - 1;\n  for (;;) {\n    const i = (lo + (hi - lo) / 2) | 0;\n    const w0 = values[i];\n    const w1 = values[i + 1];\n    if (lo === hi || (v >= w0 && v <= w1)) {\n      const weight = (v - w0) / (w1 - w0);\n      return [i, weight];\n    }\n    if (v < w0) {\n      hi = i;\n    } else {\n      lo = i + 1;\n    }\n  }\n}\n\n/**\n * Given a fractional number between 0 and values.length returns the value between\n * 2 values. Effectively lerp(values[ndx], values[ndx + 1], weight)\n */\nfunction bilinearFilter(values: readonly number[], ndx: number, weight: number) {\n  const v0 = values[ndx];\n  const v1 = values[ndx + 1] ?? 0;\n  assert(ndx < values.length - 1 || (ndx === values.length - 1 && weight === 0));\n  return lerp(v0, v1, weight);\n}\n\n/**\n * Generates an array of values that maps between the software renderer's gradient computed\n * mip level and the GPUs gradient computed mip level for mip level 0 to 1.\n */\nfunction generateSoftwareMixToGPUMixGradWeights(gpuWeights: number[], texture: GPUTexture) {\n  const numSteps = gpuWeights.length - 1;\n  const size = [texture.width, texture.height, texture.depthOrArrayLayers];\n  const softwareWeights = range(numSteps + 1, i => {\n    // u goes from 0 to 1\n    const u = i / numSteps;\n    const g = lerp(1, 2, u) / texture.width;\n    const mipLevel = computeMipLevelFromGradients([g], [0], size);\n    assert(mipLevel >= 0 && mipLevel <= 1);\n    return mipLevel;\n  });\n  const softwareMixToGPUMixMap = range(numSteps + 1, i => {\n    const mix = i / numSteps;\n    const [ndx, weight] = getIndexAndWeight(softwareWeights, mix);\n    return bilinearFilter(gpuWeights, ndx, weight);\n  });\n  return softwareMixToGPUMixMap;\n}\n\nfunction mapSoftwareMipLevelToGPUMipLevel(t: GPUTest, stage: ShaderStage, mipLevel: number) {\n  const baseLevel = Math.floor(mipLevel);\n  const softwareMix = mipLevel - baseLevel;\n  const gpuMix = getMixWeightByTypeForMipLevel(\n    t,\n    stage,\n    'softwareMixToGPUMixGradWeights',\n    softwareMix\n  );\n  return baseLevel + gpuMix;\n}\n\nconst euclideanModulo = (n: number, m: number) => ((n % m) + m) % m;\n\n/**\n * Gets the mip gradient values for the current device.\n * The issue is, different GPUs have different ways of mixing between mip levels.\n * For most GPUs it's linear but for AMD GPUs on Mac in particular, it's something\n * else (which AFAICT is against all the specs).\n *\n * We seemingly have 3 options:\n *\n * 1. Increase the tolerances of tests so they pass on AMD.\n * 2. Mark AMD as failing\n * 3. Try to figure out how the GPU converts mip levels into weights\n *\n * We're doing 3.\n *\n * There's an assumption that the gradient will be the same for all formats\n * and usages.\n *\n * Note: The code below has 2 maps. One device->Promise, the other device->weights\n * device->weights is meant to be used synchronously by other code so we don't\n * want to leave initMipGradientValuesForDevice until the weights have been read.\n * But, multiple subcases will run because this function is async. So, subcase 1\n * runs, hits this init code, this code waits for the weights. Then, subcase 2\n * runs and hits this init code. The weights will not be in the device->weights map\n * yet which is why we have the device->Promise map. This is so subcase 2 waits\n * for subcase 1's \"query the weights\" step. Otherwise, all subcases would do the\n * \"get the weights\" step separately.\n */\nconst kMipLevelWeightSteps = 64;\nconst s_deviceToMipLevelWeightsPromise = new WeakMap<\n  GPUDevice,\n  Record<ShaderStage, Promise<MipWeights>>\n>();\nconst s_deviceToMipLevelWeights = new WeakMap<GPUDevice, Record<ShaderStage, MipWeights>>();\n\nasync function initMipLevelWeightsForDevice(t: GPUTest, stage: ShaderStage) {\n  const { device } = t;\n  // Get the per stage promises (or make them)\n  const stageWeightsP =\n    s_deviceToMipLevelWeightsPromise.get(device) ??\n    ({} as Record<ShaderStage, Promise<MipWeights>>);\n  s_deviceToMipLevelWeightsPromise.set(device, stageWeightsP);\n\n  let weightsP = stageWeightsP[stage];\n  if (!weightsP) {\n    // There was no promise for this weight so request it\n    // and add a then clause so the first thing that will happen\n    // when the promise resolves is that we'll record the weights for\n    // that stage.\n    weightsP = queryMipLevelMixWeightsForDevice(t, stage);\n    weightsP\n      .then(weights => {\n        const stageWeights =\n          s_deviceToMipLevelWeights.get(device) ?? ({} as Record<ShaderStage, MipWeights>);\n        s_deviceToMipLevelWeights.set(device, stageWeights);\n        stageWeights[stage] = weights;\n      })\n      .catch(e => {\n        throw e;\n      });\n    stageWeightsP[stage] = weightsP;\n  }\n  return await weightsP;\n}\n\nfunction getMixWeightByTypeForMipLevel(\n  t: GPUTest,\n  stage: ShaderStage,\n  weightType: MipWeightType | 'identity',\n  mipLevel: number\n) {\n  if (weightType === 'identity') {\n    return euclideanModulo(mipLevel, 1);\n  }\n  // linear interpolate between weights\n  const weights = s_deviceToMipLevelWeights.get(t.device)![stage][weightType];\n  assert(\n    !!weights,\n    'you must use WGSLTextureSampleTest or call initializeDeviceMipWeights before calling this function'\n  );\n  const steps = weights.length - 1;\n  const w = euclideanModulo(mipLevel, 1) * steps;\n  const lowerNdx = Math.floor(w);\n  const upperNdx = Math.ceil(w);\n  const mix = w % 1;\n  return lerp(weights[lowerNdx], weights[upperNdx], mix);\n}\n\nfunction getWeightForMipLevel(\n  t: GPUTest,\n  stage: ShaderStage,\n  weightType: MipWeightType | 'identity',\n  mipLevelCount: number,\n  mipLevel: number\n) {\n  if (mipLevel < 0 || mipLevel >= mipLevelCount) {\n    return 1;\n  }\n  return getMixWeightByTypeForMipLevel(t, stage, weightType, mipLevel);\n}\n\n/**\n * Skip a test if the specific stage doesn't support storage textures.\n */\nexport function skipIfNoStorageTexturesInStage(t: GPUTest, stage: ShaderStage) {\n  if (t.isCompatibility) {\n    t.skipIf(\n      stage === 'fragment' && !(t.device.limits.maxStorageTexturesInFragmentStage! > 0),\n      'device does not support storage textures in fragment shaders'\n    );\n    t.skipIf(\n      stage === 'vertex' && !(t.device.limits.maxStorageTexturesInVertexStage! > 0),\n      'device does not support storage textures in vertex shaders'\n    );\n  }\n}\n\n/**\n * Runs a texture query like textureDimensions, textureNumLevels and expects\n * a particular result.\n */\nexport function executeTextureQueryAndExpectResult(\n  t: GPUTest,\n  stage: ShaderStage,\n  code: string,\n  texture: GPUTexture | GPUExternalTexture,\n  viewDescriptor: GPUTextureViewDescriptor | undefined,\n  expected: number[]\n) {\n  const { device } = t;\n\n  const returnType = `vec4<u32>`;\n  const castWGSL = `${returnType}(getValue()${range(4 - expected.length, () => ', 0').join('')})`;\n  const stageWGSL =\n    stage === 'vertex'\n      ? `\n// --------------------------- vertex stage shaders --------------------------------\n@vertex fn vsVertex(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1),\n              instance_index,\n              ${castWGSL});\n}\n\n@fragment fn fsVertex(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(v.result);\n}\n`\n      : stage === 'fragment'\n      ? `\n// --------------------------- fragment stage shaders --------------------------------\n@vertex fn vsFragment(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1), instance_index, ${returnType}(0));\n}\n\n@fragment fn fsFragment(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(${castWGSL});\n}\n`\n      : `\n// --------------------------- compute stage shaders --------------------------------\n@group(1) @binding(0) var<storage, read_write> results: array<${returnType}>;\n\n@compute @workgroup_size(1) fn csCompute(@builtin(global_invocation_id) id: vec3u) {\n  results[id.x] = ${castWGSL};\n}\n`;\n  const wgsl = `\n    ${code}\n\nstruct VOut {\n  @builtin(position) pos: vec4f,\n  @location(0) @interpolate(flat, either) ndx: u32,\n  @location(1) @interpolate(flat, either) result: ${returnType},\n};\n\n    ${stageWGSL}\n  `;\n  const module = device.createShaderModule({ code: wgsl });\n\n  const visibility =\n    stage === 'compute'\n      ? GPUShaderStage.COMPUTE\n      : stage === 'fragment'\n      ? GPUShaderStage.FRAGMENT\n      : GPUShaderStage.VERTEX;\n\n  const entries: GPUBindGroupLayoutEntry[] = [];\n  if (code.includes('texture_external')) {\n    entries.push({\n      binding: 0,\n      visibility,\n      externalTexture: {},\n    });\n  } else if (code.includes('texture_storage')) {\n    assert(texture instanceof GPUTexture);\n    entries.push({\n      binding: 0,\n      visibility,\n      storageTexture: {\n        access: code.includes(', read>')\n          ? 'read-only'\n          : code.includes(', write>')\n          ? 'write-only'\n          : 'read-write',\n        viewDimension: viewDescriptor?.dimension ?? '2d',\n        format: texture.format,\n      },\n    });\n  } else {\n    assert(texture instanceof GPUTexture);\n    const sampleType =\n      viewDescriptor?.aspect === 'stencil-only'\n        ? 'uint'\n        : code.includes('texture_depth')\n        ? 'depth'\n        : isDepthTextureFormat(texture.format)\n        ? 'unfilterable-float'\n        : isStencilTextureFormat(texture.format)\n        ? 'uint'\n        : texture.sampleCount > 1 && getTextureFormatType(texture.format) === 'float'\n        ? 'unfilterable-float'\n        : getTextureFormatType(texture.format) ?? 'unfilterable-float';\n    entries.push({\n      binding: 0,\n      visibility,\n      texture: {\n        sampleType,\n        viewDimension: viewDescriptor?.dimension ?? '2d',\n        multisampled: texture.sampleCount > 1,\n      },\n    });\n  }\n\n  const bindGroupLayouts: GPUBindGroupLayout[] = [device.createBindGroupLayout({ entries })];\n\n  if (stage === 'compute') {\n    bindGroupLayouts.push(\n      device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage',\n              hasDynamicOffset: false,\n              minBindingSize: 16,\n            },\n          },\n        ],\n      })\n    );\n  }\n\n  const layout = device.createPipelineLayout({\n    bindGroupLayouts,\n  });\n\n  let pipeline: GPUComputePipeline | GPURenderPipeline;\n\n  switch (stage) {\n    case 'compute':\n      pipeline = device.createComputePipeline({\n        layout,\n        compute: { module },\n      });\n      break;\n    case 'fragment':\n    case 'vertex':\n      pipeline = device.createRenderPipeline({\n        layout,\n        vertex: { module },\n        fragment: {\n          module,\n          targets: [{ format: 'rgba32uint' }],\n        },\n      });\n      break;\n  }\n\n  const bindGroup0 = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource:\n          texture instanceof GPUExternalTexture ? texture : texture.createView(viewDescriptor),\n      },\n    ],\n  });\n\n  const renderTarget = t.createTextureTracked({\n    format: 'rgba32uint',\n    size: [expected.length, 1],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const resultBuffer = t.createBufferTracked({\n    label: 'executeAndExpectResult:resultBuffer',\n    size: align(expected.length * 4, 256),\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n  });\n\n  let storageBuffer: GPUBuffer | undefined;\n  const encoder = device.createCommandEncoder({ label: 'executeAndExpectResult' });\n\n  if (stage === 'compute') {\n    storageBuffer = t.createBufferTracked({\n      label: 'executeAndExpectResult:storageBuffer',\n      size: resultBuffer.size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup1 = device.createBindGroup({\n      layout: pipeline!.getBindGroupLayout(1),\n      entries: [{ binding: 0, resource: { buffer: storageBuffer } }],\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline! as GPUComputePipeline);\n    pass.setBindGroup(0, bindGroup0);\n    pass.setBindGroup(1, bindGroup1);\n    pass.dispatchWorkgroups(expected.length);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n  } else {\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n\n    pass.setPipeline(pipeline! as GPURenderPipeline);\n    pass.setBindGroup(0, bindGroup0);\n    for (let i = 0; i < expected.length; ++i) {\n      pass.setViewport(i, 0, 1, 1, 0, 1);\n      pass.draw(3, 1, 0, i);\n    }\n    pass.end();\n    encoder.copyTextureToBuffer(\n      { texture: renderTarget },\n      {\n        buffer: resultBuffer,\n        bytesPerRow: resultBuffer.size,\n      },\n      [renderTarget.width, 1]\n    );\n  }\n  t.device.queue.submit([encoder.finish()]);\n\n  const e = new Uint32Array(4);\n  e.set(expected);\n  t.expectGPUBufferValuesEqual(resultBuffer, e);\n}\n\n/**\n * Used to specify a range from [0, num)\n * The type is used to determine if values should be integers and if they can be negative.\n */\nexport type RangeDef = {\n  num: number;\n  type: 'f32' | 'i32' | 'u32';\n};\n\nfunction getLimitValue(v: number) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getMinAndMaxTexelValueForComponent(\n  rep: TexelRepresentationInfo,\n  component: TexelComponent\n) {\n  assert(!!rep.numericRange);\n  const perComponentRanges = rep.numericRange as PerComponentNumericRange;\n  const perComponentRange = perComponentRanges[component];\n  const range = rep.numericRange as NumericRange;\n  const { min, max } = perComponentRange ? perComponentRange : range;\n  return { min: getLimitValue(min), max: getLimitValue(max) };\n}\n\n/**\n * We need the software rendering to do the same interpolation as the hardware\n * rendered so for -srgb formats we set the TexelView to an -srgb format as\n * TexelView handles this case. Note: It might be nice to add rgba32float-srgb\n * or something similar to TexelView.\n */\nexport function getTexelViewFormatForTextureFormat(format: GPUTextureFormat) {\n  if (format.endsWith('sint')) {\n    return 'rgba32sint';\n  } else if (format.endsWith('uint')) {\n    return 'rgba32uint';\n  }\n  return format.endsWith('-srgb') ? 'rgba8unorm-srgb' : 'rgba32float';\n}\n\nconst kTextureTypeInfo = {\n  depth: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n    sampleType: 'depth',\n  },\n  float: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n    sampleType: 'float',\n  },\n  'unfilterable-float': {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float',\n    sampleType: 'unfilterable-float',\n  },\n  sint: {\n    componentType: 'i32',\n    resultType: 'vec4i',\n    resultFormat: 'rgba32sint',\n    sampleType: 'sint',\n  },\n  uint: {\n    componentType: 'u32',\n    resultType: 'vec4u',\n    resultFormat: 'rgba32uint',\n    sampleType: 'uint',\n  },\n} as const;\n\nexport function getTextureFormatTypeInfo(\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect = 'all'\n) {\n  const type = getTextureFormatType(format, aspect);\n  assert(!!type);\n  return kTextureTypeInfo[type];\n}\n\n/**\n * given a texture type 'base', returns the base with the correct component for the given texture format.\n * eg: `getTextureType('texture_2d', someUnsignedIntTextureFormat)` -> `texture_2d<u32>`\n */\nexport function appendComponentTypeForFormatToTextureType(base: string, format: GPUTextureFormat) {\n  return base.includes('depth')\n    ? base\n    : `${base}<${getTextureFormatTypeInfo(format).componentType}>`;\n}\n\ntype RandomTextureOptions = {\n  generator: PerPixelAtLevel<PerTexelComponent<number>>;\n};\n\n/**\n * Gets the baseMipLevel, mipLevelCount, size of the baseMipLevel,\n * baseArrayLayer, and arrayLayerCount\n * taking into account the texture descriptor and the view descriptor.\n */\nfunction getBaseMipLevelInfo(textureInfo: SoftwareTexture) {\n  const baseMipLevel = textureInfo.viewDescriptor.baseMipLevel ?? 0;\n  const mipLevelCount =\n    textureInfo.viewDescriptor.mipLevelCount ??\n    (textureInfo.descriptor.mipLevelCount ?? 1) - baseMipLevel;\n  const baseMipLevelSize = virtualMipSize(\n    textureInfo.descriptor.dimension ?? '2d',\n    textureInfo.descriptor.size,\n    baseMipLevel\n  );\n  const baseArrayLayer = textureInfo.viewDescriptor.baseArrayLayer ?? 0;\n  const arrayLayerCount =\n    textureInfo.viewDescriptor.arrayLayerCount ?? baseMipLevelSize[2] - baseArrayLayer;\n  baseMipLevelSize[2] = arrayLayerCount;\n  return { baseMipLevel, baseMipLevelSize, mipLevelCount, baseArrayLayer, arrayLayerCount };\n}\n\n/**\n * Make a generator for texels for depth comparison tests.\n */\nexport function makeRandomDepthComparisonTexelGenerator(\n  info: {\n    format: GPUTextureFormat;\n    size: GPUExtent3D;\n  },\n  comparison: GPUCompareFunction\n) {\n  const format = isUnencodableDepthFormat(info.format) ? 'depth32float' : info.format;\n  const rep = kTexelRepresentationInfo[format as EncodableTextureFormat];\n  const size = reifyExtent3D(info.size);\n\n  const comparisonIsEqualOrNotEqual = comparison === 'equal' || comparison === 'not-equal';\n\n  // for equal and not-equal we just want to test 0, 0.6, and 1\n  // for everything else we want 0 to 1\n  // Note: 0.6 is chosen because we'll never choose 0.6 as our depth reference\n  // value. (see generateTextureBuiltinInputsImpl and generateSamplePointsCube)\n  // The problem with comparing equal is other than 0.0 and 1.0, no other\n  // values are guaranteed to be equal.\n  const fixedValues = [0, 0.6, 1, 1];\n  const encode = comparisonIsEqualOrNotEqual\n    ? (norm: number) => fixedValues[(norm * (fixedValues.length - 1)) | 0]\n    : (norm: number) => norm;\n\n  return (coords: SampleCoord): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(\n        coords.x,\n        coords.y,\n        coords.z,\n        coords.sampleIndex ?? 0,\n        component.charCodeAt(0),\n        size.width,\n        size.height,\n        size.depthOrArrayLayers\n      );\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = encode(normalized);\n    }\n    return quantize(texel, rep);\n  };\n}\n\nfunction createRandomTexelViewViaColors(\n  info: {\n    format: GPUTextureFormat;\n    size: GPUExtent3D;\n    mipLevel: number;\n  },\n  options?: RandomTextureOptions | undefined\n): TexelView {\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  const size = reifyExtent3D(info.size);\n  const minMax = Object.fromEntries(\n    rep.componentOrder.map(component => [\n      component,\n      getMinAndMaxTexelValueForComponent(rep, component),\n    ])\n  );\n  const generator = (coords: SampleCoord): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(\n        coords.x,\n        coords.y,\n        coords.z,\n        coords.sampleIndex ?? 0,\n        component.charCodeAt(0),\n        info.mipLevel,\n        size.width,\n        size.height,\n        size.depthOrArrayLayers\n      );\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      const { min, max } = minMax[component];\n      texel[component] = lerp(min, max, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(\n    info.format as EncodableTextureFormat,\n    options?.generator ?? generator\n  );\n}\n\nfunction createRandomTexelViewViaBytes(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevel: number;\n  sampleCount: number;\n}): TexelView {\n  const { format } = info;\n  const formatInfo = getBlockInfoForTextureFormat(format);\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  assert(!!rep);\n  const { bytesPerBlock } = formatInfo;\n  assert(bytesPerBlock !== undefined && bytesPerBlock > 0);\n  const size = physicalMipSize(reifyExtent3D(info.size), info.format, '2d', 0);\n  const blocksAcross = Math.ceil(size.width / formatInfo.blockWidth);\n  const blocksDown = Math.ceil(size.height / formatInfo.blockHeight);\n  const bytesPerRow = blocksAcross * bytesPerBlock * info.sampleCount;\n  const bytesNeeded = bytesPerRow * blocksDown * size.depthOrArrayLayers;\n  const data = new Uint8Array(bytesNeeded);\n\n  const hashBase =\n    sumOfCharCodesOfString(info.format) +\n    size.width +\n    size.height +\n    size.depthOrArrayLayers +\n    info.mipLevel +\n    info.sampleCount;\n\n  if (info.format.includes('32float') || info.format.includes('16float')) {\n    const { min, max } = getMinAndMaxTexelValueForComponent(rep, TexelComponent.R);\n    const asFloat = info.format.includes('32float')\n      ? new Float32Array(data.buffer)\n      : new Float16Array(data.buffer);\n    for (let i = 0; i < asFloat.length; ++i) {\n      asFloat[i] = lerp(min, max, hashU32(hashBase + i) / 0xffff_ffff);\n    }\n  } else if (bytesNeeded % 4 === 0) {\n    const asU32 = new Uint32Array(data.buffer);\n    for (let i = 0; i < asU32.length; ++i) {\n      asU32[i] = hashU32(hashBase + i);\n    }\n  } else {\n    for (let i = 0; i < bytesNeeded; ++i) {\n      data[i] = hashU32(hashBase + i);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(info.format as EncodableTextureFormat, data, {\n    bytesPerRow,\n    rowsPerImage: size.height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: size,\n  });\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nfunction createRandomTexelView(\n  info: {\n    format: GPUTextureFormat;\n    size: GPUExtent3D;\n    mipLevel: number;\n    sampleCount: number;\n  },\n  options?: RandomTextureOptions | undefined\n): TexelView {\n  const { format } = info;\n  assert(!isCompressedTextureFormat(format));\n  const type = getTextureFormatType(format);\n  const canFillWithRandomTypedData =\n    !options &&\n    isEncodableTextureFormat(format) &&\n    ((format.includes('norm') && type !== 'depth') ||\n      format.includes('16float') ||\n      (format.includes('32float') && type !== 'depth') ||\n      type === 'sint' ||\n      type === 'uint');\n\n  return canFillWithRandomTypedData\n    ? createRandomTexelViewViaBytes(info)\n    : createRandomTexelViewViaColors(info, options);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nfunction createRandomTexelViewMipmap(\n  info: {\n    format: GPUTextureFormat;\n    size: GPUExtent3D;\n    mipLevelCount?: number;\n    dimension?: GPUTextureDimension;\n    sampleCount?: number;\n  },\n  options?: RandomTextureOptions | undefined\n): TexelView[] {\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  return range(mipLevelCount, i =>\n    createRandomTexelView(\n      {\n        format: info.format,\n        size: virtualMipSize(dimension, info.size, i),\n        mipLevel: i,\n        sampleCount: info.sampleCount ?? 1,\n      },\n      options\n    )\n  );\n}\n\nexport type vec1 = [number]; // Because it's easy to deal with if these types are all array of number\nexport type vec2 = [number, number];\nexport type vec3 = [number, number, number];\nexport type vec4 = [number, number, number, number];\nexport type Dimensionality = vec1 | vec2 | vec3;\n\ntype TextureCallArgKeys = keyof TextureCallArgs<vec1>;\nconst kTextureCallArgNames: readonly TextureCallArgKeys[] = [\n  'component',\n  'coords',\n  'derivativeMult', // NOTE: derivativeMult not an argument but is used with coords for implicit derivatives.\n  'arrayIndex',\n  'bias',\n  'sampleIndex',\n  'mipLevel',\n  'ddx',\n  'ddy',\n  'depthRef',\n  'offset',\n] as const;\n\nexport interface TextureCallArgs<T extends Dimensionality> {\n  component?: number; // Used by textureGather\n  coords?: T; // The coord passed\n  derivativeMult?: T;\n  mipLevel?: number;\n  arrayIndex?: number;\n  bias?: number;\n  sampleIndex?: number;\n  depthRef?: number;\n  ddx?: T;\n  ddy?: T;\n  offset?: T;\n}\n\nexport type TextureBuiltin =\n  | 'textureGather'\n  | 'textureGatherCompare'\n  | 'textureLoad'\n  | 'textureSample'\n  | 'textureSampleBaseClampToEdge'\n  | 'textureSampleBias'\n  | 'textureSampleCompare'\n  | 'textureSampleCompareLevel'\n  | 'textureSampleGrad'\n  | 'textureSampleLevel';\n\nexport interface TextureCall<T extends Dimensionality> extends TextureCallArgs<T> {\n  builtin: TextureBuiltin;\n  coordType: 'f' | 'i' | 'u';\n  levelType?: 'i' | 'u' | 'f';\n  arrayIndexType?: 'i' | 'u';\n  sampleIndexType?: 'i' | 'u';\n  componentType?: 'i' | 'u';\n}\n\nexport const isBuiltinComparison = (builtin: TextureBuiltin) =>\n  builtin === 'textureGatherCompare' ||\n  builtin === 'textureSampleCompare' ||\n  builtin === 'textureSampleCompareLevel';\nexport const isBuiltinGather = (builtin: TextureBuiltin | undefined) =>\n  builtin === 'textureGather' || builtin === 'textureGatherCompare';\nexport const builtinNeedsSampler = (builtin: TextureBuiltin) =>\n  builtin.startsWith('textureSample') || builtin.startsWith('textureGather');\nexport const builtinNeedsDerivatives = (builtin: TextureBuiltin) =>\n  builtin === 'textureSample' ||\n  builtin === 'textureSampleBias' ||\n  builtin === 'textureSampleCompare';\n\nconst isCubeViewDimension = (viewDescriptor?: GPUTextureViewDescriptor) =>\n  viewDescriptor?.dimension === 'cube' || viewDescriptor?.dimension === 'cube-array';\n\nconst isViewDimensionCubeOrCubeArray = (viewDimension: GPUTextureViewDimension) =>\n  viewDimension === 'cube' || viewDimension === 'cube-array';\n\nconst s_u32 = new Uint32Array(1);\nconst s_f32 = new Float32Array(s_u32.buffer);\nconst s_i32 = new Int32Array(s_u32.buffer);\n\nconst kBitCastFunctions = {\n  f: (v: number) => {\n    s_f32[0] = v;\n    return s_u32[0];\n  },\n  i: (v: number) => {\n    s_i32[0] = v;\n    assert(s_i32[0] === v, 'check we are not casting non-int or out-of-range value');\n    return s_u32[0];\n  },\n  u: (v: number) => {\n    s_u32[0] = v;\n    assert(s_u32[0] === v, 'check we are not casting non-uint or out-of-range value');\n    return s_u32[0];\n  },\n};\n\nfunction getCallArgType<T extends Dimensionality>(\n  call: TextureCall<T>,\n  argName: (typeof kTextureCallArgNames)[number]\n) {\n  switch (argName) {\n    case 'coords':\n    case 'derivativeMult':\n      return call.coordType;\n    case 'component':\n      assert(call.componentType !== undefined);\n      return call.componentType;\n    case 'mipLevel':\n      assert(call.levelType !== undefined);\n      return call.levelType;\n    case 'arrayIndex':\n      assert(call.arrayIndexType !== undefined);\n      return call.arrayIndexType;\n    case 'sampleIndex':\n      assert(call.sampleIndexType !== undefined);\n      return call.sampleIndexType;\n    case 'bias':\n    case 'depthRef':\n    case 'ddx':\n    case 'ddy':\n      return 'f';\n    default:\n      unreachable();\n  }\n}\n\nfunction toArray(coords: Dimensionality): number[] {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel: PerTexelComponent<number>, repl: TexelRepresentationInfo) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a: number[], b: number[], op: (x: number, y: number) => number) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\n/**\n * At the corner of a cubemap we need to sample just 3 texels, not 4.\n * The texels are in\n *\n *   0:  (u,v)\n *   1:  (u + 1, v)\n *   2:  (u, v + 1)\n *   3:  (u + 1, v + 1)\n *\n * We pass in the original 2d (converted from cubemap) texture coordinate.\n * If it's within half a pixel of the edge in both directions then it's\n * a corner so we return the index of the one texel that's not needed.\n * Otherwise we return -1.\n */\nfunction getUnusedCubeCornerSampleIndex(textureSize: number, coords: vec3) {\n  const u = coords[0] * textureSize;\n  const v = coords[1] * textureSize;\n  if (v < 0.5) {\n    if (u < 0.5) {\n      return 0;\n    } else if (u >= textureSize - 0.5) {\n      return 1;\n    }\n  } else if (v >= textureSize - 0.5) {\n    if (u < 0.5) {\n      return 2;\n    } else if (u >= textureSize - 0.5) {\n      return 3;\n    }\n  }\n  return -1;\n}\n\nconst add = (a: number[], b: number[]) => apply(a, b, (x, y) => x + y);\n\n/**\n * The data needed by the software rendered to simulate a texture.\n * In particular, it needs texels (the data), it needs a descriptor\n * for the size, format, and dimension, and it needs a view descriptor\n * for the viewDimension, baseMipLevel, mipLevelCount, baseArrayLayer,\n * and arrayLayerCount.\n */\nexport interface SoftwareTexture {\n  texels: TexelView[];\n  descriptor: GPUTextureDescriptor;\n  viewDescriptor: GPUTextureViewDescriptor;\n}\n\n/**\n * Converts the src texel representation to an RGBA representation.\n */\nexport function convertPerTexelComponentToResultFormat(\n  src: PerTexelComponent<number>,\n  format: GPUTextureFormat,\n  aspect: GPUTextureAspect = 'all'\n): PerTexelComponent<number> {\n  const effectiveFormat = aspect === 'stencil-only' ? 'stencil8' : format;\n  const components = isEncodableTextureFormat(effectiveFormat)\n    ? kTexelRepresentationInfo[effectiveFormat as EncodableTextureFormat].componentOrder\n    : kRGBAComponents;\n  const out: PerTexelComponent<number> = { R: 0, G: 0, B: 0, A: 1 };\n  for (const component of components) {\n    switch (component) {\n      case 'Stencil':\n      case 'Depth':\n        out.R = src[component];\n        break;\n      default:\n        assert(out[component] !== undefined); // checks that component = R, G, B or A\n        out[component] = src[component];\n    }\n  }\n  return out;\n}\n\n/**\n * Convert RGBA result format to texel view format.\n * Example, converts\n *   { R: 0.1, G: 0, B: 0, A: 1 } to { Depth: 0.1 }\n *   { R: 0.1 } to { R: 0.1, G: 0, B: 0, A: 1 }\n */\nfunction convertToTexelViewFormat(src: PerTexelComponent<number>, format: GPUTextureFormat) {\n  const componentOrder = isDepthTextureFormat(format)\n    ? [TexelComponent.Depth]\n    : isStencilTextureFormat(format)\n    ? [TexelComponent.Stencil]\n    : [TexelComponent.R, TexelComponent.G, TexelComponent.B, TexelComponent.A];\n  const out: PerTexelComponent<number> = {};\n  for (const component of componentOrder) {\n    let v = src[component];\n    if (v === undefined) {\n      if (component === 'Depth' || component === 'Stencil') {\n        v = src.R;\n      } else if (component === 'G' || component === 'B') {\n        v = 0;\n      } else {\n        v = 1;\n      }\n    }\n    out[component] = v;\n  }\n  return out;\n}\n\n/**\n * Convert RGBA result format to texel view format of src texture.\n * Effectively this converts something like { R: 0.1, G: 0, B: 0, A: 1 }\n * to { Depth: 0.1 }\n */\nfunction convertResultFormatToTexelViewFormat(\n  src: PerTexelComponent<number>,\n  format: EncodableTextureFormat\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[format];\n  const out: PerTexelComponent<number> = {};\n  for (const component of rep.componentOrder) {\n    out[component] = src[component] ?? src.R;\n  }\n  return out;\n}\n\nfunction zeroValuePerTexelComponent(components: TexelComponent[]) {\n  const out: PerTexelComponent<number> = {};\n  for (const component of components) {\n    out[component] = 0;\n  }\n  return out;\n}\n\nconst kSamplerFns: Record<GPUCompareFunction, (ref: number, v: number) => boolean> = {\n  never: (ref: number, v: number) => false,\n  less: (ref: number, v: number) => ref < v,\n  equal: (ref: number, v: number) => ref === v,\n  'less-equal': (ref: number, v: number) => ref <= v,\n  greater: (ref: number, v: number) => ref > v,\n  'not-equal': (ref: number, v: number) => ref !== v,\n  'greater-equal': (ref: number, v: number) => ref >= v,\n  always: (ref: number, v: number) => true,\n} as const;\n\nconst kDefaultValueForDepthTextureComponents: Record<TexelComponent, number> = {\n  R: 0,\n  G: 0,\n  B: 0,\n  A: 1,\n  Depth: 0,\n  Stencil: 0,\n} as const;\n\n/**\n * Applies a comparison function to each component of a texel.\n */\nexport function applyCompareToTexel(\n  components: TexelComponent[],\n  src: PerTexelComponent<number>,\n  compare: GPUCompareFunction,\n  ref: number\n): PerTexelComponent<number> {\n  const out: PerTexelComponent<number> = {};\n  const compareFn = kSamplerFns[compare];\n  for (const component of components) {\n    out[component] =\n      component === 'R' || component === 'Depth'\n        ? compareFn(ref, src[component]!)\n          ? 1\n          : 0\n        : kDefaultValueForDepthTextureComponents[component];\n  }\n  return out;\n}\n\nfunction applyCompare<T extends Dimensionality>(\n  call: TextureCall<T>,\n  sampler: GPUSamplerDescriptor | undefined,\n  components: TexelComponent[],\n  src: PerTexelComponent<number>\n): PerTexelComponent<number> {\n  if (isBuiltinComparison(call.builtin)) {\n    assert(sampler !== undefined);\n    assert(call.depthRef !== undefined);\n    return applyCompareToTexel(components, src, sampler.compare!, call.depthRef);\n  } else {\n    return src;\n  }\n}\n\nfunction getEffectiveLodClamp(\n  builtin: TextureBuiltin,\n  sampler: GPUSamplerDescriptor | undefined,\n  softwareTexture: SoftwareTexture\n) {\n  const { mipLevelCount } = getBaseMipLevelInfo(softwareTexture);\n\n  const lodMinClamp =\n    isBuiltinGather(builtin) || sampler?.lodMinClamp === undefined ? 0 : sampler.lodMinClamp;\n  const lodMaxClamp =\n    isBuiltinGather(builtin) || sampler?.lodMaxClamp === undefined\n      ? mipLevelCount - 1\n      : sampler.lodMaxClamp;\n  assert(lodMinClamp >= 0 && lodMinClamp < mipLevelCount, 'lodMinClamp in range');\n  assert(lodMaxClamp >= 0 && lodMaxClamp < mipLevelCount, 'lodMaxClamp in range');\n  assert(lodMinClamp <= lodMinClamp, 'lodMinClamp <= lodMaxClamp');\n\n  return { min: lodMinClamp, max: lodMaxClamp };\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nfunction softwareTextureReadMipLevel<T extends Dimensionality>(\n  call: TextureCall<T>,\n  softwareTexture: SoftwareTexture,\n  sampler: GPUSamplerDescriptor | undefined,\n  mipLevel: number\n): PerTexelComponent<number> {\n  assert(mipLevel % 1 === 0);\n  const { format } = softwareTexture.texels[0];\n  const rep = kTexelRepresentationInfo[format];\n  const { baseMipLevel, baseMipLevelSize, baseArrayLayer, arrayLayerCount } =\n    getBaseMipLevelInfo(softwareTexture);\n  const mipLevelSize = virtualMipSize(\n    softwareTexture.descriptor.dimension || '2d',\n    baseMipLevelSize,\n    mipLevel\n  );\n\n  const addressMode: GPUAddressMode[] =\n    call.builtin === 'textureSampleBaseClampToEdge'\n      ? ['clamp-to-edge', 'clamp-to-edge', 'clamp-to-edge']\n      : [\n          sampler?.addressModeU ?? 'clamp-to-edge',\n          sampler?.addressModeV ?? 'clamp-to-edge',\n          sampler?.addressModeW ?? 'clamp-to-edge',\n        ];\n\n  const isCube = isCubeViewDimension(softwareTexture.viewDescriptor);\n  const arrayIndexMult = isCube ? 6 : 1;\n  const numLayers = arrayLayerCount / arrayIndexMult;\n  assert(numLayers % 1 === 0);\n  const textureSizeForCube = [mipLevelSize[0], mipLevelSize[1], 6];\n\n  const load = (at: number[]) => {\n    const zFromArrayIndex =\n      call.arrayIndex !== undefined\n        ? clamp(call.arrayIndex, { min: 0, max: numLayers - 1 }) * arrayIndexMult\n        : 0;\n    return softwareTexture.texels[mipLevel + baseMipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0) + zFromArrayIndex + baseArrayLayer,\n      sampleIndex: call.sampleIndex,\n    });\n  };\n\n  switch (call.builtin) {\n    case 'textureGather':\n    case 'textureGatherCompare':\n    case 'textureSample':\n    case 'textureSampleBias':\n    case 'textureSampleBaseClampToEdge':\n    case 'textureSampleCompare':\n    case 'textureSampleCompareLevel':\n    case 'textureSampleGrad':\n    case 'textureSampleLevel': {\n      let coords = toArray(call.coords!);\n\n      if (isCube) {\n        coords = convertCubeCoordToNormalized3DTextureCoord(coords as vec3);\n      }\n\n      // convert normalized to absolute texel coordinate\n      // ┌───┬───┬───┬───┐\n      // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n      // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │ b │\n      // └───┴───┴───┴───┘\n      let at = coords.map((v, i) => v * (isCube ? textureSizeForCube : mipLevelSize)[i] - 0.5);\n\n      // Apply offset in whole texel units\n      // This means the offset is added at each mip level in texels. There's no\n      // scaling for each level.\n      if (call.offset !== undefined) {\n        at = add(at, toArray(call.offset));\n      }\n\n      const samples: { at: number[]; weight: number }[] = [];\n\n      const filter = isBuiltinGather(call.builtin) ? 'linear' : sampler?.minFilter ?? 'nearest';\n      switch (filter) {\n        case 'linear': {\n          // 'p0' is the lower texel for 'at'\n          const p0 = at.map(v => Math.floor(v));\n          // 'p1' is the higher texel for 'at'\n          // If it's cube then don't advance Z.\n          const p1 = p0.map((v, i) => v + (isCube ? (i === 2 ? 0 : 1) : 1));\n\n          // interpolation weights for p0 and p1\n          const p1W = at.map((v, i) => v - p0[i]);\n          const p0W = p1W.map(v => 1 - v);\n\n          switch (coords.length) {\n            case 1:\n              samples.push({ at: p0, weight: p0W[0] });\n              samples.push({ at: p1, weight: p1W[0] });\n              break;\n            case 2: {\n              // Note: These are ordered to match textureGather\n              samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n              samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n              samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n              samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n              break;\n            }\n            case 3: {\n              // cube sampling, here in the software renderer, is the same\n              // as 2d sampling. We'll sample at most 4 texels. The weights are\n              // the same as if it was just one plane. If the points fall outside\n              // the slice they'll be wrapped by wrapFaceCoordToCubeFaceAtEdgeBoundaries\n              // below.\n              if (isCube) {\n                // Note: These are ordered to match textureGather\n                samples.push({ at: [p0[0], p1[1], p0[2]], weight: p0W[0] * p1W[1] });\n                samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n                samples.push({ at: [p1[0], p0[1], p0[2]], weight: p1W[0] * p0W[1] });\n                samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n                const ndx = getUnusedCubeCornerSampleIndex(mipLevelSize[0], coords as vec3);\n                if (ndx >= 0) {\n                  // # Issues with corners of cubemaps\n                  //\n                  // note: I tried multiple things here\n                  //\n                  // 1. distribute 1/3 of the weight of the removed sample to each of the remaining samples\n                  // 2. distribute 1/2 of the weight of the removed sample to the 2 samples that are not the \"main\" sample.\n                  // 3. normalize the weights of the remaining 3 samples.\n                  //\n                  // none of them matched the M1 in all cases. Checking the dEQP I found this comment\n                  //\n                  // > If any of samples is out of both edges, implementations can do pretty much anything according to spec.\n                  // https://github.com/KhronosGroup/VK-GL-CTS/blob/d2d6aa65607383bb29c8398fe6562c6b08b4de57/framework/common/tcuTexCompareVerifier.cpp#L882\n                  //\n                  // If I understand this correctly it matches the OpenGL ES 3.1 spec it says\n                  // it's implementation defined.\n                  //\n                  // > OpenGL ES 3.1 section 8.12.1 Seamless Cubemap Filtering\n                  // >\n                  // > -  If a texture sample location would lie in the texture\n                  // >    border in both u and v (in one of the corners of the\n                  // >    cube), there is no unique neighboring face from which to\n                  // >    extract one texel. The recommended method to generate this\n                  // >    texel is to average the values of the three available\n                  // >    samples. However, implementations are free to construct\n                  // >    this fourth texel in another way, so long as, when the\n                  // >    three available samples have the same value, this texel\n                  // >    also has that value.\n                  //\n                  // I'm not sure what \"average the values of the three available samples\"\n                  // means. To me that would be (a+b+c)/3 or in other words, set all the\n                  // weights to 0.33333 but that's not what the M1 is doing.\n                  //\n                  // We could check that, given the 3 texels at the corner, if all 3 texels\n                  // are the same value then the result must be the same value. Otherwise,\n                  // the result must be between the 3 values. For now, the code that\n                  // chooses test coordinates avoids corners. This has the restriction\n                  // that the smallest mip level be at least 4x4 so there are some non\n                  // corners to choose from.\n                  unreachable(\n                    `corners of cubemaps are not testable:\\n   ${describeTextureCall(call)}`\n                  );\n                }\n              } else {\n                const p = [p0, p1];\n                const w = [p0W, p1W];\n                for (let z = 0; z < 2; ++z) {\n                  for (let y = 0; y < 2; ++y) {\n                    for (let x = 0; x < 2; ++x) {\n                      samples.push({\n                        at: [p[x][0], p[y][1], p[z][2]],\n                        weight: w[x][0] * w[y][1] * w[z][2],\n                      });\n                    }\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case 'nearest': {\n          const p = at.map(v => Math.round(quantizeToF32(v)));\n          samples.push({ at: p, weight: 1 });\n          break;\n        }\n        default:\n          unreachable();\n      }\n\n      if (isBuiltinGather(call.builtin)) {\n        const componentNdx = call.component ?? 0;\n        assert(componentNdx >= 0 && componentNdx < 4);\n        assert(samples.length === 4);\n        const component = kRGBAComponents[componentNdx];\n        const out: PerTexelComponent<number> = {};\n        samples.forEach((sample, i) => {\n          const c = isCube\n            ? wrapFaceCoordToCubeFaceAtEdgeBoundaries(mipLevelSize[0], sample.at as vec3)\n            : applyAddressModesToCoords(addressMode, mipLevelSize, sample.at);\n          const v = load(c);\n          const postV = applyCompare(call, sampler, rep.componentOrder, v);\n          const rgba = convertPerTexelComponentToResultFormat(postV, format);\n          out[kRGBAComponents[i]] = rgba[component];\n        });\n        return out;\n      }\n\n      const out: PerTexelComponent<number> = {};\n      for (const sample of samples) {\n        const c = isCube\n          ? wrapFaceCoordToCubeFaceAtEdgeBoundaries(mipLevelSize[0], sample.at as vec3)\n          : applyAddressModesToCoords(addressMode, mipLevelSize, sample.at);\n        const v = load(c);\n        const postV = applyCompare(call, sampler, rep.componentOrder, v);\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + postV[component]! * sample.weight;\n        }\n      }\n\n      return convertPerTexelComponentToResultFormat(out, format);\n    }\n    case 'textureLoad': {\n      const out: PerTexelComponent<number> = isOutOfBoundsCall(softwareTexture, call)\n        ? zeroValuePerTexelComponent(rep.componentOrder)\n        : load(call.coords!);\n      return convertPerTexelComponentToResultFormat(out, format);\n    }\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Reads a texture, optionally sampling between 2 mipLevels\n */\nfunction softwareTextureReadLevel<T extends Dimensionality>(\n  t: GPUTest,\n  stage: ShaderStage,\n  call: TextureCall<T>,\n  softwareTexture: SoftwareTexture,\n  sampler: GPUSamplerDescriptor | undefined,\n  mipLevel: number\n): PerTexelComponent<number> {\n  if (!sampler) {\n    return softwareTextureReadMipLevel<T>(call, softwareTexture, sampler, mipLevel);\n  }\n\n  const { mipLevelCount } = getBaseMipLevelInfo(softwareTexture);\n  const lodClampMinMax = getEffectiveLodClamp(call.builtin, sampler, softwareTexture);\n  const effectiveMipmapFilter = isBuiltinGather(call.builtin) ? 'nearest' : sampler.mipmapFilter;\n  switch (effectiveMipmapFilter) {\n    case 'linear': {\n      const clampedMipLevel = clamp(mipLevel, lodClampMinMax);\n      const rootMipLevel = Math.floor(clampedMipLevel);\n      const nextMipLevel = Math.ceil(clampedMipLevel);\n      const t0 = softwareTextureReadMipLevel<T>(call, softwareTexture, sampler, rootMipLevel);\n      const t1 = softwareTextureReadMipLevel<T>(call, softwareTexture, sampler, nextMipLevel);\n      const weightType = call.builtin === 'textureSampleLevel' ? 'sampleLevelWeights' : 'identity';\n      const mix = getWeightForMipLevel(t, stage, weightType, mipLevelCount, clampedMipLevel);\n      assert(mix >= 0 && mix <= 1);\n      const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix },\n      ];\n      const out: PerTexelComponent<number> = {};\n      for (const { v, weight } of values) {\n        for (const component of kRGBAComponents) {\n          out[component] = (out[component] ?? 0) + v[component]! * weight;\n        }\n      }\n      return out;\n    }\n    default: {\n      const baseMipLevel = Math.floor(clamp(mipLevel, lodClampMinMax) + 0.5);\n      return softwareTextureReadMipLevel<T>(call, softwareTexture, sampler, baseMipLevel);\n    }\n  }\n}\n\nfunction computeMipLevelFromGradients(\n  ddx: readonly number[],\n  ddy: readonly number[],\n  baseMipLevelSize: GPUExtent3D\n) {\n  const texSize = reifyExtent3D(baseMipLevelSize);\n  const textureSize = [texSize.width, texSize.height, texSize.depthOrArrayLayers];\n\n  // Compute the mip level the same way textureSampleGrad does according to the spec.\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n  return mipLevel;\n}\n\nfunction computeMipLevelFromGradientsForCall<T extends Dimensionality>(\n  call: TextureCall<T>,\n  baseMipLevelSize: GPUExtent3D\n) {\n  assert(!!call.ddx);\n  assert(!!call.ddy);\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx: readonly number[] = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy: readonly number[] = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  return computeMipLevelFromGradients(ddx, ddy, baseMipLevelSize);\n}\n\n/**\n * The software version of textureSampleGrad except with optional level.\n */\nfunction softwareTextureReadGrad<T extends Dimensionality>(\n  t: GPUTest,\n  stage: ShaderStage,\n  call: TextureCall<T>,\n  softwareTexture: SoftwareTexture,\n  sampler?: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  const bias = call.bias === undefined ? 0 : clamp(call.bias, { min: -16.0, max: 15.99 });\n  if (call.ddx) {\n    const { mipLevelCount, baseMipLevelSize } = getBaseMipLevelInfo(softwareTexture);\n    const mipLevel = computeMipLevelFromGradientsForCall(call, baseMipLevelSize);\n    const clampedMipLevel = clamp(mipLevel + bias, { min: 0, max: mipLevelCount - 1 });\n    const weightMipLevel = mapSoftwareMipLevelToGPUMipLevel(t, stage, clampedMipLevel);\n    return softwareTextureReadLevel(t, stage, call, softwareTexture, sampler, weightMipLevel);\n  } else {\n    return softwareTextureReadLevel(\n      t,\n      stage,\n      call,\n      softwareTexture,\n      sampler,\n      (call.mipLevel ?? 0) + bias\n    );\n  }\n}\n\n/**\n * This must match the code in doTextureCalls for derivativeBase\n *\n * Note: normal implicit derivatives are computed like this\n *\n * fn textureSample(T, S, coord) -> vec4f {\n *    return textureSampleGrad(T, S, dpdx(coord), dpdy(coord));\n * }\n *\n * dpdx and dpdy are effectively computed by,\n * getting the values of coord for 2x2 adjacent texels.\n *\n *   p0 = coord value at x, y\n *   p1 = coord value at x + 1, y\n *   p2 = coord value at x, y + 1\n *   p3 = coord value at x + 1, y + 1\n *\n * dpdx is the average delta in x and dpdy is the average delta in y\n *\n *   dpdx = (p1 - p0 + p3 - p2) / 2   // average of horizontal change\n *   dpdy = (p2 - p0 + p3 - p1) / 2   // average of vertical change\n *\n * derivativeBase is\n *\n *       '1d'    '2d'     '3d'\n *   p0 = [0]   [0, 0]  [0, 0, 0]\n *   p1 = [1]   [1, 0]  [1, 0, 0]\n *   p2 = [0]   [0, 1]  [0, 1, 0]\n *   p3 = [1]   [1, 1]  [1, 1, 0]\n *\n * But, these values are normalized texels coords so if the src texture\n * is 8x8 these would be * 0.125\n *\n * Note: to test other derivatives we add in a multiplier but,\n * this base gives us something to add that starts at 0,0 at the call\n * but who's derivatives we can easily set. We need the default\n * derivativeBase to be 1 otherwise it's 0 which makes the computed mip level\n * be -Infinity which means bias in `textureSampleBias` has no meaning.\n */\nfunction derivativeBaseForCall<T extends Dimensionality>(\n  softwareTexture: SoftwareTexture,\n  isDDX: boolean\n) {\n  const { baseMipLevelSize } = getBaseMipLevelInfo(softwareTexture);\n  if (isCubeViewDimension(softwareTexture.viewDescriptor)) {\n    return (isDDX ? [1 / baseMipLevelSize[0], 0, 1] : [0, 1 / baseMipLevelSize[1], 1]) as T;\n  } else if (softwareTexture.descriptor.dimension === '3d') {\n    return (isDDX ? [1 / baseMipLevelSize[0], 0, 0] : [0, 1 / baseMipLevelSize[1], 0]) as T;\n  } else if (softwareTexture.descriptor.dimension === '1d') {\n    return [1 / baseMipLevelSize[0]] as T;\n  } else {\n    return (isDDX ? [1 / baseMipLevelSize[0], 0] : [0, 1 / baseMipLevelSize[1]]) as T;\n  }\n}\n\n/**\n * Multiplies derivativeBase by derivativeMult or 1\n */\nfunction derivativeForCall<T extends Dimensionality>(\n  softwareTexture: SoftwareTexture,\n  call: TextureCall<T>,\n  isDDX: boolean\n) {\n  const dd = derivativeBaseForCall(softwareTexture, isDDX);\n  return dd.map((v, i) => v * (call.derivativeMult?.[i] ?? 1)) as T;\n}\n\nfunction softwareTextureRead<T extends Dimensionality>(\n  t: GPUTest,\n  stage: ShaderStage,\n  call: TextureCall<T>,\n  softwareTexture: SoftwareTexture,\n  sampler?: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  // add the implicit derivatives that we use from WGSL in doTextureCalls\n  if (builtinNeedsDerivatives(call.builtin) && !call.ddx) {\n    const newCall: TextureCall<T> = {\n      ...call,\n      ddx: call.ddx ?? derivativeForCall<T>(softwareTexture, call, true),\n      ddy: call.ddy ?? derivativeForCall<T>(softwareTexture, call, false),\n    };\n    call = newCall;\n  }\n  return softwareTextureReadGrad(t, stage, call, softwareTexture, sampler);\n}\n\nexport type TextureTestOptions<T extends Dimensionality> = {\n  ddx?: number; // the derivative we want at sample time\n  ddy?: number;\n  uvwStart?: Readonly<T>; // the starting uv value (these are used make the coordinates negative as it uncovered issues on some hardware)\n  offset?: Readonly<T>; // a constant offset\n  depthTexture?: boolean;\n  arrayIndexType?: 'i' | 'u';\n};\n\n/**\n * out of bounds is defined as any of the following being true\n *\n * * coords is outside the range [0, textureDimensions(t, level))\n * * array_index is outside the range [0, textureNumLayers(t))\n * * level is outside the range [0, textureNumLevels(t))\n * * sample_index is outside the range [0, textureNumSamples(s))\n */\nfunction isOutOfBoundsCall<T extends Dimensionality>(\n  softwareTexture: SoftwareTexture,\n  call: TextureCall<T>\n) {\n  assert(call.coords !== undefined);\n\n  const desc = reifyTextureDescriptor(softwareTexture.descriptor);\n  const { coords, mipLevel: callMipLevel, arrayIndex, sampleIndex } = call;\n  const { baseMipLevelSize, mipLevelCount, arrayLayerCount } = getBaseMipLevelInfo(softwareTexture);\n\n  if (callMipLevel !== undefined && (callMipLevel < 0 || callMipLevel >= mipLevelCount)) {\n    return true;\n  }\n\n  const size = virtualMipSize(\n    softwareTexture.descriptor.dimension || '2d',\n    baseMipLevelSize,\n    callMipLevel ?? 0\n  );\n\n  for (let i = 0; i < coords.length; ++i) {\n    const v = coords[i];\n    if (v < 0 || v >= size[i]) {\n      return true;\n    }\n  }\n\n  if (arrayIndex !== undefined) {\n    if (arrayIndex < 0 || arrayIndex >= arrayLayerCount) {\n      return true;\n    }\n  }\n\n  if (sampleIndex !== undefined) {\n    if (sampleIndex < 0 || sampleIndex >= desc.sampleCount) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isValidOutOfBoundsValue(\n  device: GPUDevice,\n  softwareTexture: SoftwareTexture,\n  gotRGBA: PerTexelComponent<number>,\n  maxFractionalDiff: number\n) {\n  // For a texture builtin with no sampler (eg textureLoad),\n  // any out of bounds access is allowed to return one of:\n  //\n  // * the value of any texel in the texture\n  // * 0,0,0,0 or 0,0,0,1 if not a depth texture\n  // * 0 if a depth texture\n  if (softwareTexture.descriptor.format.includes('depth')) {\n    if (gotRGBA.R === 0) {\n      return true;\n    }\n  } else {\n    if (\n      gotRGBA.R === 0 &&\n      gotRGBA.B === 0 &&\n      gotRGBA.G === 0 &&\n      (gotRGBA.A === 0 || gotRGBA.A === 1)\n    ) {\n      return true;\n    }\n  }\n\n  // Can be any texel value\n  for (let mipLevel = 0; mipLevel < softwareTexture.texels.length; ++mipLevel) {\n    const mipTexels = softwareTexture.texels[mipLevel];\n    const size = virtualMipSize(\n      softwareTexture.descriptor.dimension || '2d',\n      softwareTexture.descriptor.size,\n      mipLevel\n    );\n    const sampleCount = softwareTexture.descriptor.sampleCount ?? 1;\n    for (let z = 0; z < size[2]; ++z) {\n      for (let y = 0; y < size[1]; ++y) {\n        for (let x = 0; x < size[0]; ++x) {\n          for (let sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            const texel = mipTexels.color({ x, y, z, sampleIndex });\n            const rgba = convertPerTexelComponentToResultFormat(texel, mipTexels.format);\n            if (\n              texelsApproximatelyEqual(\n                device,\n                gotRGBA,\n                softwareTexture.descriptor.format,\n                rgba,\n                mipTexels.format,\n                maxFractionalDiff\n              )\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * For a texture builtin with no sampler (eg textureLoad),\n * any out of bounds access is allowed to return one of:\n *\n * * the value of any texel in the texture\n * * 0,0,0,0 or 0,0,0,1 if not a depth texture\n * * 0 if a depth texture\n */\nfunction okBecauseOutOfBounds<T extends Dimensionality>(\n  device: GPUDevice,\n  softwareTexture: SoftwareTexture,\n  call: TextureCall<T>,\n  gotRGBA: PerTexelComponent<number>,\n  maxFractionalDiff: number\n) {\n  if (!isOutOfBoundsCall(softwareTexture, call)) {\n    return false;\n  }\n\n  return isValidOutOfBoundsValue(device, softwareTexture, gotRGBA, maxFractionalDiff);\n}\n\nconst kRGBAComponents = [\n  TexelComponent.R,\n  TexelComponent.G,\n  TexelComponent.B,\n  TexelComponent.A,\n] as const;\n\nconst kRComponent = [TexelComponent.R] as const;\n\n/**\n * Compares two Texels\n */\nexport function texelsApproximatelyEqual(\n  device: GPUDevice,\n  gotRGBA: PerTexelComponent<number>,\n  gotFormat: GPUTextureFormat,\n  expectRGBA: PerTexelComponent<number>,\n  expectedFormat: EncodableTextureFormat,\n  maxFractionalDiff: number\n) {\n  const rep = kTexelRepresentationInfo[expectedFormat];\n  const got = convertResultFormatToTexelViewFormat(gotRGBA, expectedFormat);\n  const expect = convertResultFormatToTexelViewFormat(expectRGBA, expectedFormat);\n  const gULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(got)),\n    expectedFormat\n  );\n  const eULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(expect)),\n    expectedFormat\n  );\n\n  const rgbaComponentsToCheck =\n    isDepthOrStencilTextureFormat(gotFormat) && !device.features.has('texel-component-swizzle')\n      ? kRComponent\n      : kRGBAComponents;\n\n  for (const component of rgbaComponentsToCheck) {\n    const g = gotRGBA[component]!;\n    const e = expectRGBA[component]!;\n    assert(!isNaN(g), () => `got component is NaN: ${g}`);\n    assert(!isNaN(e), () => `expected component is NaN: ${e}`);\n    const absDiff = Math.abs(g - e);\n    const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n    if (ulpDiff > 3 && absDiff > maxFractionalDiff) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If it's `textureGather` then we need to convert all values to one component.\n// In other words, imagine the format is rg11b10ufloat. If it was\n// `textureSample` we'd have `r11, g11, b10, a=1` but for `textureGather`\n//\n// component = 0 => `r11, r11, r11, r11`\n// component = 1 => `g11, g11, g11, g11`\n// component = 2 => `b10, b10, b10, b10`\n//\n// etc..., each from a different texel\n//\n// The Texel utils don't handle this. So if `component = 2` we take each value,\n// copy it to the `B` component, run it through the texel utils so it returns\n// the correct ULP for a 10bit float (not an 11 bit float). Then copy it back to\n// the channel it came from.\nfunction getULPFromZeroForComponents(\n  rgba: PerTexelComponent<number>,\n  format: EncodableTextureFormat,\n  builtin: TextureBuiltin,\n  componentNdx?: number\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[format];\n  if (isBuiltinGather(builtin)) {\n    const out: PerTexelComponent<number> = {};\n    const component = kRGBAComponents[componentNdx ?? 0];\n    const temp: PerTexelComponent<number> = { R: 0, G: 0, B: 0, A: 1 };\n    for (const comp of kRGBAComponents) {\n      temp[component] = rgba[comp];\n      const texel = convertResultFormatToTexelViewFormat(temp, format);\n      const ulp = convertPerTexelComponentToResultFormat(\n        rep.bitsToULPFromZero(rep.numberToBits(texel)),\n        format\n      );\n      out[comp] = ulp[component];\n    }\n    return out;\n  } else {\n    const texel = convertResultFormatToTexelViewFormat(rgba, format);\n    return convertPerTexelComponentToResultFormat(\n      rep.bitsToULPFromZero(rep.numberToBits(texel)),\n      format\n    );\n  }\n}\n\nfunction getTextureViewDescription(softwareTexture: SoftwareTexture) {\n  const size = reifyExtent3D(softwareTexture.descriptor.size);\n  const { baseMipLevel, mipLevelCount, baseArrayLayer, arrayLayerCount, baseMipLevelSize } =\n    getBaseMipLevelInfo(softwareTexture);\n  const physicalMipLevelCount = softwareTexture.descriptor.mipLevelCount ?? 1;\n\n  return `\n   physical size: [${size.width}, ${size.height}, ${size.depthOrArrayLayers}]\n    baseMipLevel: ${baseMipLevel}\n   mipLevelCount: ${mipLevelCount}\nbaseMipLevelSize: [${baseMipLevelSize.join(', ')}]\n  baseArrayLayer: ${baseArrayLayer}\n arrayLayerCount: ${arrayLayerCount}\nphysicalMipCount: ${physicalMipLevelCount}\n  `;\n}\n/**\n * Checks the result of each call matches the expected result.\n */\nexport async function checkCallResults<T extends Dimensionality>(\n  t: GPUTest,\n  softwareTexture: SoftwareTexture,\n  textureType: string,\n  sampler: GPUSamplerDescriptor | undefined,\n  calls: TextureCall<T>[],\n  results: Awaited<ReturnType<typeof doTextureCalls<T>>>,\n  shortShaderStage: ShortShaderStage,\n  gpuTexture?: GPUTexture\n) {\n  const stage = kShortShaderStageToShaderStage[shortShaderStage];\n  if (builtinNeedsMipLevelWeights(calls[0].builtin)) {\n    await initMipLevelWeightsForDevice(t, stage);\n  }\n\n  let haveComparisonCheckInfo = false;\n  let checkInfo = {\n    runner: results.runner,\n    calls,\n    sampler,\n  };\n  // These are only read if the tests fail. They are used to get the values from the\n  // GPU texture for displaying in diagnostics.\n  let gpuTexels: TexelView[] | undefined;\n  const errs: string[] = [];\n  const format = softwareTexture.texels[0].format;\n  const size = reifyExtent3D(softwareTexture.descriptor.size);\n  const maxFractionalDiff =\n    sampler?.minFilter === 'linear' ||\n    sampler?.magFilter === 'linear' ||\n    sampler?.mipmapFilter === 'linear'\n      ? getMaxFractionalDiffForTextureFormat(softwareTexture.descriptor.format)\n      : 0;\n\n  t.debug(() => getTextureViewDescription(softwareTexture));\n\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    t.debug(`#${callIdx}: ${describeTextureCall(call)}`);\n    const gotRGBA = results.results[callIdx];\n    const expectRGBA = softwareTextureRead(t, stage, call, softwareTexture, sampler);\n    // Issues with textureSampleBias\n    //\n    // textureSampleBias tests start to get unexpected results when bias >= ~12\n    // where the mip level selected by the GPU is off by +/- 0.41.\n    //\n    // The issue is probably an internal precision issue. In order to test a bias of 12\n    // we choose a target mip level between 0 and mipLevelCount - 1. For example 0.4.\n    // We then compute what mip level we need the derivatives to select such that when\n    // we add in the bias it will result in a mip level of 0.4.  For a bias of 12\n    // that's means we need the derivatives to select mip level -11.4. That means\n    // the derivatives are `pow(2, -11.4) / textureSize` so for a texture that's 16\n    // pixels wide that's `0.00002312799936691891`. I'm just guessing some of that\n    // gets rounded off leading. For example, if we round it ourselves.\n    //\n    // | derivative             | mip level |\n    // +------------------------+-----------+\n    // | 0.00002312799936691891 | -11.4     |\n    // | 0.000022               | -11.47    |\n    // | 0.000023               | -11.408   |\n    // | 0.000024               | -11.34    |\n    // +------------------------+-----------+\n    //\n    // Note: As an example of a bad case: set `callSpecificMaxFractionalDiff = maxFractionalDiff` below\n    // then run `webgpu:shader,execution,expression,call,builtin,textureSampleBias:sampled_2d_coords:format=\"astc-6x6-unorm\";filt=\"linear\";modeU=\"m\";modeV=\"m\";offset=false`\n    // on an M1 Mac.\n    //\n    // ```\n    // EXPECTATION FAILED: subcase: samplePoints=\"spiral\"\n    // result was not as expected:\n    //       size: [18, 18, 1]\n    //   mipCount: 3\n    //       call: textureSampleBias(texture: T, sampler: S, coords: vec2f(0.1527777777777778, 1.4166666666666667) + derivativeBase * derivativeMult(vec2f(0.00002249990733551491, 0)), bias: f32(15.739721414633095))  // #32\n    //           : as texel coord @ mip level[0]: (2.750, 25.500)\n    //           : as texel coord @ mip level[1]: (1.375, 12.750)\n    //           : as texel coord @ mip level[2]: (0.611, 5.667)\n    // implicit derivative based mip level: -15.439721414633095 (without bias)\n    //                        clamped bias: 15.739721414633095\n    //                 mip level with bias: 0.3000000000000007\n    //        got: 0.555311381816864, 0.7921856045722961, 0.8004884123802185, 0.38046398758888245\n    //   expected: 0.6069580801937625, 0.7999182825318225, 0.8152446179041957, 0.335314491045024\n    //   max diff: 0.027450980392156862\n    //  abs diffs: 0.0516466983768985, 0.007732677959526368, 0.014756205523977162, 0.04514949654385847\n    //  rel diffs: 8.51%, 0.97%, 1.81%, 11.87%\n    //  ulp diffs: 866488, 129733, 247568, 1514966\n    //\n    //   sample points:\n    // expected:                                                                   | got:\n    // ...\n    // a: mip(0) at: [ 2, 10,  0], weight: 0.52740                                 | a: mip(0) at: [ 2, 10,  0], weight: 0.60931\n    // b: mip(0) at: [ 3, 10,  0], weight: 0.17580                                 | b: mip(0) at: [ 3, 10,  0], weight: 0.20319\n    // a: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788                    | a: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788\n    // b: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788                    | b: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788\n    // mip level (0) weight: 0.70320                                               | mip level (0) weight: 0.81250\n    // ```\n    //\n    // Notice above the \"expected\" level weight (0.7) matches the \"mip level with bias (0.3)\" which is\n    // the mip level we expected the GPU to select. Selecting mip level 0.3 will do `mix(level0, level1, 0.3)`\n    // which is 0.7 of level 0 and 0.3 of level 1. Notice the \"got\" level weight is 0.81 which is pretty far off.\n    //\n    // Just looking at the failures, the largest formula below makes most of the tests pass\n    //\n    // MAINTENANCE_TODO: Consider different solutions for this issue\n    //\n    // 1. Try to figure out what the exact rounding issue is the take it into account\n    //\n    // 2. The code currently samples the texture once via the GPU and once via softwareTextureRead. These values are\n    //    \"got:\" and \"expected:\" above. The test only fails if they are too different. We could rather get the bilinear\n    //    sample from every mip level and then check the \"got\" value is between 2 of the levels (or equal if nearest).\n    //    In other words.\n    //\n    //        if (bias >= 12)\n    //          colorForEachMipLevel = range(mipLevelCount, mipLevel => softwareTextureReadLevel(..., mipLevel))\n    //          if nearest\n    //            pass = got === one of colorForEachMipLevel\n    //          else // linear\n    //            pass = false;\n    //            for (i = 0; !pass && i < mipLevelCount - 1; i)\n    //              pass = got is between colorForEachMipLevel[i] and colorForEachMipLevel[i + 1]\n    //\n    //    This would check \"something\" but effectively it would no longer be checking \"bias\" for values > 12. Only that\n    //    textureSampleBias returns some possible answer vs some completely wrong answer.\n    //\n    // 3. It's possible this check is just not possible given the precision required. We could just check bias -16 to 12\n    //    and ignore values > 12. We won't be able to test clamping but maybe that's irrelevant.\n    //\n    const callSpecificMaxFractionalDiff =\n      call.bias! >= 12 ? maxFractionalDiff * (2 + call.bias! - 12) : maxFractionalDiff;\n\n    // The spec says depth and stencil have implementation defined values for G, B, and A\n    // so if this is `textureGather` and component > 0 then there's nothing to check.\n    // except if texture-component-swizzle is on. Then G = 0, B = 0, A = 1\n    if (\n      isDepthOrStencilTextureFormat(format) &&\n      isBuiltinGather(call.builtin) &&\n      call.component! > 0 &&\n      !t.device.features.has('texture-component-swizzle')\n    ) {\n      continue;\n    }\n\n    if (\n      texelsApproximatelyEqual(\n        t.device,\n        gotRGBA,\n        softwareTexture.descriptor.format,\n        expectRGBA,\n        format,\n        callSpecificMaxFractionalDiff\n      )\n    ) {\n      continue;\n    }\n\n    if (\n      !sampler &&\n      okBecauseOutOfBounds(t.device, softwareTexture, call, gotRGBA, callSpecificMaxFractionalDiff)\n    ) {\n      continue;\n    }\n\n    const gULP = getULPFromZeroForComponents(gotRGBA, format, call.builtin, call.component);\n    const eULP = getULPFromZeroForComponents(expectRGBA, format, call.builtin, call.component);\n\n    // from the spec: https://gpuweb.github.io/gpuweb/#reading-depth-stencil\n    // depth and stencil values are D, ?, ?, ? unless texture-component-swizzle is enabled\n    // in which case it's D, 0, 0, 1\n    const rgbaComponentsToCheck =\n      (isBuiltinGather(call.builtin) || !isDepthOrStencilTextureFormat(format)) &&\n      t.device.features.has('texture-component-swizzle')\n        ? kRGBAComponents\n        : kRComponent;\n\n    let bad = false;\n    const diffs = rgbaComponentsToCheck.map(component => {\n      const g = gotRGBA[component]!;\n      const e = expectRGBA[component]!;\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n      assert(!Number.isNaN(ulpDiff));\n      const maxAbs = Math.max(Math.abs(g), Math.abs(e));\n      const relDiff = maxAbs > 0 ? absDiff / maxAbs : 0;\n      if (ulpDiff > 3 && absDiff > callSpecificMaxFractionalDiff) {\n        bad = true;\n      }\n      return { absDiff, relDiff, ulpDiff };\n    });\n\n    const isFloatType = (format: GPUTextureFormat) => {\n      const type = getTextureFormatType(format);\n      return type === 'float' || type === 'depth';\n    };\n    const fix5 = (n: number) => (isFloatType(format) ? n.toFixed(5) : n.toString());\n    const fix5v = (arr: number[]) => arr.map(v => fix5(v)).join(', ');\n    const rgbaToArray = (p: PerTexelComponent<number>): number[] =>\n      rgbaComponentsToCheck.map(component => p[component]!);\n\n    if (bad) {\n      const { baseMipLevelSize } = getBaseMipLevelInfo(softwareTexture);\n      const physicalMipLevelCount = softwareTexture.descriptor.mipLevelCount ?? 1;\n      const lodClamp = getEffectiveLodClamp(call.builtin, sampler, softwareTexture);\n\n      const desc = describeTextureCall(call);\n      errs.push(`result was not as expected:${getTextureViewDescription(softwareTexture)}\n     lodMinClamp: ${lodClamp.min} (effective)\n     lodMaxClamp: ${lodClamp.max} (effective)\n            call: ${desc}  // #${callIdx}`);\n      if (isCubeViewDimension(softwareTexture.viewDescriptor)) {\n        const coord = convertCubeCoordToNormalized3DTextureCoord(call.coords as vec3);\n        const faceNdx = Math.floor(coord[2] * 6);\n        errs.push(`          : as 3D texture coord: (${coord[0]}, ${coord[1]}, ${coord[2]})`);\n        for (let mipLevel = 0; mipLevel < physicalMipLevelCount; ++mipLevel) {\n          const mipSize = virtualMipSize(\n            softwareTexture.descriptor.dimension ?? '2d',\n            softwareTexture.descriptor.size,\n            mipLevel\n          );\n          const t = coord.slice(0, 2).map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(\n            `          : as texel coord mip level[${mipLevel}]: (${t[0]}, ${t[1]}), face: ${faceNdx}(${kFaceNames[faceNdx]})`\n          );\n        }\n      } else if (call.coordType === 'f') {\n        for (let mipLevel = 0; mipLevel < physicalMipLevelCount; ++mipLevel) {\n          const mipSize = virtualMipSize(\n            softwareTexture.descriptor.dimension ?? '2d',\n            softwareTexture.descriptor.size,\n            mipLevel\n          );\n          const t = call.coords!.map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(`          : as texel coord @ mip level[${mipLevel}]: (${t.join(', ')})`);\n        }\n      }\n      if (builtinNeedsDerivatives(call.builtin)) {\n        const ddx = derivativeForCall<T>(softwareTexture, call, true);\n        const ddy = derivativeForCall<T>(softwareTexture, call, false);\n        const mipLevel = computeMipLevelFromGradients(ddx, ddy, baseMipLevelSize);\n        const biasStr = call.bias === undefined ? '' : ' (without bias)';\n        errs.push(`implicit derivative based mip level: ${fix5(mipLevel)}${biasStr}`);\n        if (call.bias) {\n          const clampedBias = clamp(call.bias ?? 0, { min: -16.0, max: 15.99 });\n          errs.push(`\\\n                       clamped bias: ${fix5(clampedBias)}\n                mip level with bias: ${fix5(mipLevel + clampedBias)}`);\n        }\n      } else if (call.ddx) {\n        const mipLevel = computeMipLevelFromGradientsForCall(call, size);\n        errs.push(`gradient based mip level: ${mipLevel}`);\n      }\n      errs.push(`\\\n       got: ${fix5v(rgbaToArray(gotRGBA))}\n  expected: ${fix5v(rgbaToArray(expectRGBA))}\n  max diff: ${callSpecificMaxFractionalDiff}\n abs diffs: ${fix5v(diffs.map(({ absDiff }) => absDiff))}\n rel diffs: ${diffs.map(({ relDiff }) => `${(relDiff * 100).toFixed(2)}%`).join(', ')}\n ulp diffs: ${diffs.map(({ ulpDiff }) => ulpDiff).join(', ')}\n`);\n\n      if (sampler) {\n        if (t.rec.debugging) {\n          // For compares, we can't use the builtin (textureXXXCompareXXX) because it only\n          // returns 0 or 1 or the average of 0 and 1 for multiple samples. And, for example,\n          // if the comparison is `always` then every sample returns 1. So we need to use the\n          // corresponding sample function to get the actual values from the textures\n          //\n          // textureSampleCompare -> textureSample\n          // textureSampleCompareLevel -> textureSampleLevel\n          // textureGatherCompare -> textureGather\n          if (isBuiltinComparison(call.builtin)) {\n            if (!haveComparisonCheckInfo) {\n              // Convert the comparison calls to their corresponding non-comparison call\n              const debugCalls = calls.map(call => {\n                const debugCall = { ...call };\n                debugCall.depthRef = undefined;\n                switch (call.builtin) {\n                  case 'textureGatherCompare':\n                    debugCall.builtin = 'textureGather';\n                    break;\n                  case 'textureSampleCompare':\n                    debugCall.builtin = 'textureSample';\n                    break;\n                  case 'textureSampleCompareLevel':\n                    debugCall.builtin = 'textureSampleLevel';\n                    debugCall.levelType = 'u';\n                    debugCall.mipLevel = 0;\n                    break;\n                  default:\n                    unreachable();\n                }\n                return debugCall;\n              });\n\n              // Convert the comparison sampler to a non-comparison sampler\n              const debugSampler = { ...sampler };\n              delete debugSampler.compare;\n\n              // Make a runner for these changed calls.\n              const debugRunner = createTextureCallsRunner(\n                t,\n                {\n                  format,\n                  dimension: softwareTexture.descriptor.dimension ?? '2d',\n                  sampleCount: softwareTexture.descriptor.sampleCount ?? 1,\n                  depthOrArrayLayers: size.depthOrArrayLayers,\n                },\n                softwareTexture.viewDescriptor,\n                textureType,\n                debugSampler,\n                debugCalls,\n                stage\n              );\n              checkInfo = {\n                runner: debugRunner,\n                sampler: debugSampler,\n                calls: debugCalls,\n              };\n              haveComparisonCheckInfo = true;\n            }\n          }\n\n          if (!gpuTexels && gpuTexture) {\n            // Read the texture back if we haven't yet. We'll use this\n            // to get values for each sample point.\n            gpuTexels = await readTextureToTexelViews(\n              t,\n              gpuTexture,\n              softwareTexture.descriptor,\n              getTexelViewFormatForTextureFormat(gpuTexture.format)\n            );\n          }\n\n          const callForSamplePoints = checkInfo.calls[callIdx];\n\n          // We're going to create textures with black and white texels\n          // but if it's a compressed texture we use an encodable texture.\n          // It's not perfect but we already know it failed. We're just hoping\n          // to get sample points.\n          const useTexelFormatForGPUTexture = isCompressedTextureFormat(\n            softwareTexture.descriptor.format\n          );\n\n          if (useTexelFormatForGPUTexture) {\n            errs.push(`\n### WARNING: sample points are derived from un-compressed textures and may not match the\nactual GPU results of sampling a compressed texture. The test itself failed at this point\n(see expected: and got: above). We're only trying to determine what the GPU sampled, but\nwe can not do that easily with compressed textures. ###\n`);\n          }\n\n          const expectedSamplePoints = [\n            'expected:',\n            ...(await identifySamplePoints(\n              softwareTexture,\n              sampler,\n              callForSamplePoints,\n              call,\n              softwareTexture.texels,\n              (texels: TexelView[]) => {\n                return Promise.resolve(\n                  softwareTextureRead(\n                    t,\n                    stage,\n                    callForSamplePoints,\n                    {\n                      texels,\n                      descriptor: softwareTexture.descriptor,\n                      viewDescriptor: softwareTexture.viewDescriptor,\n                    },\n                    checkInfo.sampler\n                  )\n                );\n              }\n            )),\n          ];\n          const gotSamplePoints = [\n            'got:',\n            ...(await identifySamplePoints(\n              softwareTexture,\n              sampler,\n              callForSamplePoints,\n              call,\n              gpuTexels,\n              async (texels: TexelView[]) => {\n                const descriptor = { ...softwareTexture.descriptor };\n                if (useTexelFormatForGPUTexture) {\n                  descriptor.format = texels[0].format;\n                }\n                const gpuTexture = createTextureFromTexelViewsLocal(t, [texels], descriptor);\n                const result = (await checkInfo.runner.run(gpuTexture))[callIdx];\n                gpuTexture.destroy();\n                return result;\n              }\n            )),\n          ];\n          errs.push('  sample points:');\n          errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n          errs.push('', '');\n        }\n\n        // this is not an else because it's common to comment out the previous `if` for running on a CQ.\n        if (!t.rec.debugging) {\n          errs.push('### turn on debugging to see sample points ###');\n        }\n      } // if (sampler)\n\n      // Don't report the other errors. There 50 sample points per subcase and\n      // 50-100 subcases so the log would get enormous if all 50 fail. One\n      // report per subcase is enough.\n      break;\n    } // if (bad)\n  } // for cellNdx\n\n  results.runner.destroy();\n  checkInfo.runner.destroy();\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\nfunction getMaxFractionalDiffForTextureFormat(format: GPUTextureFormat) {\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  if (format.includes('depth')) {\n    return 3 / 100;\n  } else if (format.includes('8unorm')) {\n    return 7 / 255;\n  } else if (format.includes('2unorm')) {\n    return 13 / 512;\n  } else if (format.includes('unorm')) {\n    return 7 / 255;\n  } else if (format.includes('8snorm')) {\n    return 7.9 / 128;\n  } else if (format.includes('snorm')) {\n    return 7.9 / 128;\n  } else if (format.endsWith('ufloat')) {\n    return 156.249;\n  } else if (format.endsWith('float')) {\n    return 44;\n  } else {\n    // It's likely an integer format. In any case, zero tolerance is passable.\n    return 0;\n  }\n}\n\nconst sumOfCharCodesOfString = (s: unknown) =>\n  String(s)\n    .split('')\n    .reduce((sum, c) => sum + c.charCodeAt(0), 0);\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random valid data\n * for an astc block.\n *\n * The astc format is fairly complicated. For now we do the simplest thing.\n * which is to set the block as a \"void-extent\" block (a solid color).\n * This makes our test have far less precision.\n *\n * MAINTENANCE_TODO: generate other types of astc blocks. One option would\n * be to randomly select from set of pre-made blocks.\n *\n * See Spec:\n * https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n */\nfunction makeAstcBlockFiller(format: ColorTextureFormat) {\n  const { bytesPerBlock } = getBlockInfoForColorTextureFormat(format);\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    // set the block to be a void-extent block\n    data.set(\n      [\n        0b1111_1100, // 0\n        0b1111_1101, // 1\n        0b1111_1111, // 2\n        0b1111_1111, // 3\n        0b1111_1111, // 4\n        0b1111_1111, // 5\n        0b1111_1111, // 6\n        0b1111_1111, // 7\n      ],\n      offset\n    );\n    // fill the rest of the block with random data\n    const end = offset + bytesPerBlock;\n    for (let i = offset + 8; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random bytes.\n */\nfunction makeRandomBytesBlockFiller(format: ColorTextureFormat) {\n  const { bytesPerBlock } = getBlockInfoForColorTextureFormat(format);\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    const end = offset + bytesPerBlock;\n    for (let i = offset; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\nfunction getBlockFiller(format: ColorTextureFormat) {\n  if (format.startsWith('astc')) {\n    return makeAstcBlockFiller(format);\n  } else {\n    return makeRandomBytesBlockFiller(format);\n  }\n}\n\n/**\n * Fills a texture with random data.\n */\nfunction fillTextureWithRandomData(device: GPUDevice, texture: GPUTexture) {\n  assert(isColorTextureFormat(texture.format));\n  assert(!isCompressedFloatTextureFormat(texture.format));\n  const info = getBlockInfoForColorTextureFormat(texture.format as ColorTextureFormat);\n  const hashBase =\n    sumOfCharCodesOfString(texture.format) +\n    sumOfCharCodesOfString(texture.dimension) +\n    texture.width +\n    texture.height +\n    texture.depthOrArrayLayers +\n    texture.mipLevelCount;\n  const bytesPerBlock = info.bytesPerBlock;\n  const fillBlock = getBlockFiller(texture.format as ColorTextureFormat);\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = physicalMipSizeFromTexture(texture, mipLevel);\n    const blocksAcross = Math.ceil(size[0] / info.blockWidth);\n    const blocksDown = Math.ceil(size[1] / info.blockHeight);\n    const bytesPerRow = blocksAcross * bytesPerBlock;\n    const bytesNeeded = bytesPerRow * blocksDown * size[2];\n    const data = new Uint8Array(bytesNeeded);\n    for (let offset = 0; offset < bytesNeeded; offset += bytesPerBlock) {\n      fillBlock(data, offset, hashBase);\n    }\n    device.queue.writeTexture(\n      { texture, mipLevel },\n      data,\n      { bytesPerRow, rowsPerImage: blocksDown },\n      size\n    );\n  }\n}\n\nconst s_readTextureToRGBA32DeviceToPipeline = new WeakMap<\n  GPUDevice,\n  Map<string, GPUComputePipeline>\n>();\n\n// MAINTENANCE_TODO: remove cast once textureBindingViewDimension is added to IDL\nfunction getEffectiveViewDimension(\n  t: GPUTest,\n  descriptor: Omit<GPUTextureDescriptor, 'format' | 'usage'>\n): GPUTextureViewDimension {\n  const size = reifyExtent3D(descriptor.size);\n  return effectiveViewDimensionForDimension(\n    descriptor.textureBindingViewDimension,\n    descriptor.dimension,\n    size.depthOrArrayLayers\n  );\n}\n\n/**\n * Reads a texture to an array of TexelViews, one per mip level.\n * format is the format of the TexelView you want. Often this is\n * same as the texture.format but if the texture.format is not\n * \"Encodable\" then you need to choose a different format.\n * Example: depth24plus -> r32float, bc1-rgba-unorm to rgba32float\n */\nexport async function readTextureToTexelViews(\n  t: GPUTest,\n  texture: GPUTexture,\n  descriptor: Omit<GPUTextureDescriptor, 'format' | 'usage'>,\n  format: EncodableTextureFormat\n) {\n  const device = t.device;\n  const viewDimensionToPipelineMap =\n    s_readTextureToRGBA32DeviceToPipeline.get(device) ??\n    new Map<GPUTextureViewDimension, GPUComputePipeline>();\n  s_readTextureToRGBA32DeviceToPipeline.set(device, viewDimensionToPipelineMap);\n\n  const { componentType, resultType } = getTextureFormatTypeInfo(texture.format);\n  const viewDimension = getEffectiveViewDimension(t, descriptor);\n  const id = `${texture.format}:${viewDimension}:${texture.sampleCount}`;\n  let pipeline = viewDimensionToPipelineMap.get(id);\n  if (!pipeline) {\n    let textureWGSL;\n    let loadWGSL;\n    let dimensionWGSL = 'textureDimensions(tex, 0)';\n    switch (viewDimension) {\n      case '2d':\n        if (texture.sampleCount > 1) {\n          textureWGSL = `texture_multisampled_2d<${componentType}>`;\n          loadWGSL = 'textureLoad(tex, coord.xy, sampleIndex)';\n          dimensionWGSL = 'textureDimensions(tex)';\n        } else {\n          textureWGSL = `texture_2d<${componentType}>`;\n          loadWGSL = 'textureLoad(tex, coord.xy, 0)';\n        }\n        break;\n      case 'cube-array': // cube-array doesn't exist in compat so we can just use 2d_array for this\n      case '2d-array':\n        textureWGSL = `texture_2d_array<${componentType}>`;\n        loadWGSL = `\n          textureLoad(\n              tex,\n              coord.xy,\n              coord.z,\n              0)`;\n        break;\n      case '3d':\n        textureWGSL = `texture_3d<${componentType}>`;\n        loadWGSL = 'textureLoad(tex, coord.xyz, 0)';\n        break;\n      case 'cube':\n        textureWGSL = `texture_cube<${componentType}>`;\n        loadWGSL = `\n          textureLoadCubeAs2DArray(tex, coord.xy, coord.z);\n        `;\n        break;\n      case '1d':\n        textureWGSL = `texture_1d<${componentType}>`;\n        loadWGSL = `textureLoad(tex, coord.x, 0)`;\n        dimensionWGSL = `vec2u(textureDimensions(tex), 1)`;\n        break;\n      default:\n        unreachable(`unsupported view: ${viewDimension}`);\n    }\n\n    const textureLoadCubeWGSL = `\n      const faceMat = array(\n        mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n        mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n        mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n        mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n        mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n        mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n      // needed for compat mode.\n      fn textureLoadCubeAs2DArray(tex: texture_cube<${componentType}>, coord: vec2u, layer: u32) -> ${resultType} {\n        // convert texel coord normalized coord\n        let size = textureDimensions(tex, 0);\n\n        // Offset by 0.75 instead of the more common 0.5 for converting from texel to normalized texture coordinate\n        // because we're using textureGather. 0.5 would indicate the center of a texel but based on precision issues\n        // the \"gather\" could go in any direction from that center. Off center it should go in an expected direction.\n        let uv = (vec2f(coord) + 0.75) / vec2f(size.xy);\n\n        // convert uv + layer into cube coord\n        let cubeCoord = faceMat[layer] * vec3f(uv, 1.0);\n\n        // We have to use textureGather as it's the only texture builtin that works on cubemaps\n        // with integer texture formats.\n        let r = textureGather(0, tex, smp, cubeCoord);\n        let g = textureGather(1, tex, smp, cubeCoord);\n        let b = textureGather(2, tex, smp, cubeCoord);\n        let a = textureGather(3, tex, smp, cubeCoord);\n\n        // element 3 is the texel corresponding to cubeCoord\n        return ${resultType}(r[3], g[3], b[3], a[3]);\n      }\n    `;\n\n    const module = device.createShaderModule({\n      code: `\n        ${isViewDimensionCubeOrCubeArray(viewDimension) ? textureLoadCubeWGSL : ''}\n        struct Uniforms {\n          sampleCount: u32,\n        };\n\n        @group(0) @binding(0) var<uniform> uni: Uniforms;\n        @group(0) @binding(1) var tex: ${textureWGSL};\n        @group(0) @binding(2) var smp: sampler;\n        @group(0) @binding(3) var<storage, read_write> data: array<${resultType}>;\n\n        @compute @workgroup_size(1) fn cs(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n          _ = smp;\n          let size = ${dimensionWGSL};\n          let ndx = global_invocation_id.z * size.x * size.y * uni.sampleCount +\n                    global_invocation_id.y * size.x * uni.sampleCount +\n                    global_invocation_id.x;\n          let coord = vec3u(global_invocation_id.x / uni.sampleCount, global_invocation_id.yz);\n          let sampleIndex = global_invocation_id.x % uni.sampleCount;\n          data[ndx] = ${loadWGSL};\n        }\n      `,\n    });\n    const type = getTextureFormatType(texture.format);\n    const sampleType = isDepthTextureFormat(texture.format)\n      ? 'unfilterable-float' // depth only supports unfilterable-float if not a comparison.\n      : isStencilTextureFormat(texture.format)\n      ? 'uint'\n      : type === 'float'\n      ? 'unfilterable-float'\n      : type;\n    const bindGroupLayout = device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: 'uniform',\n          },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          texture: {\n            sampleType,\n            viewDimension,\n            multisampled: texture.sampleCount > 1,\n          },\n        },\n        {\n          binding: 2,\n          visibility: GPUShaderStage.COMPUTE,\n          sampler: {\n            type: 'non-filtering',\n          },\n        },\n        {\n          binding: 3,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type: 'storage',\n          },\n        },\n      ],\n    });\n    const layout = device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout],\n    });\n    pipeline = device.createComputePipeline({ layout, compute: { module } });\n    viewDimensionToPipelineMap.set(id, pipeline);\n  }\n\n  const encoder = device.createCommandEncoder({ label: 'readTextureToTexelViews' });\n\n  const readBuffers = [];\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = virtualMipSize(texture.dimension, texture, mipLevel);\n\n    const uniformValues = new Uint32Array([texture.sampleCount, 0, 0, 0]); // min size is 16 bytes\n    const uniformBuffer = t.createBufferTracked({\n      label: 'readTextureToTexelViews:uniformBuffer',\n      size: uniformValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);\n\n    const storageBuffer = t.createBufferTracked({\n      label: 'readTextureToTexelViews:storageBuffer',\n      size: size[0] * size[1] * size[2] * 4 * 4 * texture.sampleCount, // rgba32float\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const readBuffer = t.createBufferTracked({\n      label: 'readTextureToTexelViews:readBuffer',\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    readBuffers.push({ size, readBuffer });\n\n    const sampler = device.createSampler();\n\n    const aspect = getAspectForTexture(texture);\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: uniformBuffer } },\n        {\n          binding: 1,\n          resource: texture.createView({\n            dimension: viewDimension,\n            aspect,\n            baseMipLevel: mipLevel,\n            mipLevelCount: 1,\n          }),\n        },\n        { binding: 2, resource: sampler },\n        { binding: 3, resource: { buffer: storageBuffer } },\n      ],\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(size[0] * texture.sampleCount, size[1], size[2]);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, readBuffer.size);\n  }\n\n  device.queue.submit([encoder.finish()]);\n\n  const texelViews: TexelView[] = [];\n\n  for (const { readBuffer, size } of readBuffers) {\n    await readBuffer.mapAsync(GPUMapMode.READ);\n\n    // need a copy of the data since unmapping will nullify the typedarray view.\n    const Ctor =\n      componentType === 'i32' ? Int32Array : componentType === 'u32' ? Uint32Array : Float32Array;\n    const data = new Ctor(readBuffer.getMappedRange()).slice();\n    readBuffer.unmap();\n\n    const { sampleCount } = texture;\n    texelViews.push(\n      TexelView.fromTexelsAsColors(format, coord => {\n        const offset =\n          ((coord.z * size[0] * size[1] + coord.y * size[0] + coord.x) * sampleCount +\n            (coord.sampleIndex ?? 0)) *\n          4;\n        return convertResultFormatToTexelViewFormat(\n          {\n            R: data[offset + 0],\n            G: data[offset + 1],\n            B: data[offset + 2],\n            A: data[offset + 3],\n          },\n          format\n        );\n      })\n    );\n  }\n\n  return texelViews;\n}\n\n/**\n * Creates a texture from an array of TexelViews.\n * @param t the current test\n * @param texelViews Array of TexelViews per aspect per mip level. Note that only depth-stencil textures\n *    have 2 aspects, in which case it's assumed the texelViews are in the order [depth, stencil]\n * @param desc description for the texture to be created\n * @returns created texture\n */\nfunction createTextureFromTexelViewsLocal(\n  t: GPUTest,\n  texelViews: TexelView[][],\n  desc: GPUTextureDescriptor\n): GPUTexture {\n  const modifiedDescriptor = { ...desc };\n  // If it's a depth or stencil texture we need to render to it to fill it with data.\n  if (isDepthOrStencilTextureFormat(desc.format) || desc.sampleCount! > 1) {\n    modifiedDescriptor.usage = desc.usage | GPUTextureUsage.RENDER_ATTACHMENT;\n  }\n  const texture = createTextureFromTexelViews(t, texelViews[0], modifiedDescriptor);\n  if (texelViews.length > 1) {\n    copyTexelViewsToTexture(t, texture, 'stencil-only', texelViews[1]);\n  }\n  return texture;\n}\n\n/**\n * Fills a texture with random data and returns that data as\n * an array of arrays of TexelView. The top level arrays are\n * per aspect. For textures with 1 aspect it would just be\n * `[[textureViewsByMipLevel]]`. For a depth-stencil textures\n * it would be [[depthViewsByMipLevel], [stencilViewsByMipLevel]]\n *\n * For compressed textures the texture is filled with random bytes\n * and then read back from the GPU by sampling so the GPU decompressed\n * the texture.\n *\n * For uncompressed textures the TexelViews are generated and then\n * copied to the texture.\n */\nexport async function createTextureWithRandomDataAndGetTexelsForEachAspect(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor,\n  options?: RandomTextureOptions\n) {\n  if (isCompressedTextureFormat(descriptor.format)) {\n    assert(!options, 'options not supported for compressed textures');\n    const texture = t.createTextureTracked(descriptor);\n\n    fillTextureWithRandomData(t.device, texture);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels: [texels] };\n  } else if (isUnencodableDepthFormat(descriptor.format)) {\n    // This is round about. We can't directly write to depth24plus, depth24plus-stencil8, depth32float-stencil8\n    // and they are not encodable. So: (1) we make random data using `depth32float`. We create a texture with\n    // that data (createTextureFromTexelViewsLocal will render the data into the texture rather than copy).\n    // We then need to read it back out but as rgba32float since that is encodable but, since it round tripped\n    // through the GPU it's now been quantized.\n    const d32Descriptor = {\n      ...descriptor,\n      format: 'depth32float' as GPUTextureFormat,\n    };\n    const stencilTexels = isStencilTextureFormat(descriptor.format)\n      ? [createRandomTexelViewMipmap({ ...descriptor, format: 'stencil8' })]\n      : [];\n    const texture = createTextureFromTexelViewsLocal(\n      t,\n      [createRandomTexelViewMipmap(d32Descriptor, options), ...stencilTexels],\n      descriptor\n    );\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    const texelsPerAspect = [texels, ...stencilTexels];\n    return { texture, texels: texelsPerAspect };\n  } else {\n    const texels = createRandomTexelViewMipmap(descriptor, options);\n    const texture = createTextureFromTexelViewsLocal(t, [texels], descriptor);\n    return { texture, texels: [texels] };\n  }\n}\n\n/**\n * Fills a texture with random data and returns that data an arrays of TexelView.\n * Note: If the texture has multiple aspects it only returns the `depth-only`\n * TexelViews. If you need views for both aspects use\n * @see {@link createTextureWithRandomDataAndGetTexelsForEachAspect}.\n */\nexport async function createTextureWithRandomDataAndGetTexels(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor,\n  options?: RandomTextureOptions\n) {\n  const { texture, texels } = await createTextureWithRandomDataAndGetTexelsForEachAspect(\n    t,\n    descriptor,\n    options\n  );\n  return { texture, texels: texels[0] };\n}\n\nfunction valueIfAllComponentsAreEqual(\n  c: PerTexelComponent<number>,\n  componentOrder: readonly TexelComponent[]\n) {\n  const s = new Set(componentOrder.map(component => c[component]!));\n  return s.size === 1 ? s.values().next().value : undefined;\n}\n\n/**\n * Creates a Canvas with random data and a TexelView with the same data.\n */\nexport function createCanvasWithRandomDataAndGetTexels(textureSize: GPUExtent3D) {\n  const size = reifyExtent3D(textureSize);\n  assert(size.depthOrArrayLayers === 1);\n\n  // Fill ImageData with random values.\n  const imageData = new ImageData(size.width, size.height);\n  const data = imageData.data;\n  const asU32 = new Uint32Array(data.buffer);\n  for (let i = 0; i < asU32.length; ++i) {\n    asU32[i] = hashU32(i);\n  }\n\n  // Put the ImageData into a canvas and make a VideoFrame\n  const canvas = new OffscreenCanvas(size.width, size.height);\n  const ctx = canvas.getContext('2d')!;\n  ctx.putImageData(imageData, 0, 0);\n\n  // Premultiply the ImageData\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3] / 255;\n    data[i + 0] = data[i + 0] * alpha;\n    data[i + 1] = data[i + 1] * alpha;\n    data[i + 2] = data[i + 2] * alpha;\n  }\n\n  // Create a TexelView from the premultiplied ImageData\n  const texels = [\n    TexelView.fromTextureDataByReference('rgba8unorm', data, {\n      bytesPerRow: size.width * 4,\n      rowsPerImage: size.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: size,\n    }),\n  ];\n\n  return { canvas, texels };\n}\n\nconst kFaceNames = ['+x', '-x', '+y', '-y', '+z', '-z'] as const;\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * It works by making a set of indices for every texel in the texture.\n * It splits the set into 2. It picks one set and generates texture data\n * using TexelView.fromTexelsAsColor with [1, 1, 1, 1] texels for members\n * of the current set.\n *\n * In then calls 'run' which renders a single `call`. `run` uses either\n * the software renderer or WebGPU. It then checks the results. If the\n * result is zero, all texels in the current had no influence when sampling\n * and can be discarded.\n *\n * If the result is > 0 then, if the set has more than one member, the\n * set is split and added to the list to sets to test. If the set only\n * had one member then the result is the weight used when sampling that texel.\n *\n * This lets you see if the weights from the software renderer match the\n * weights from WebGPU.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   +---+---+---+---+---+---+---+---+\n * 0 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 1 |   |   |   |   |   |   |   | a |\n *   +---+---+---+---+---+---+---+---+\n * 2 |   |   |   |   |   |   |   | b |\n *   +---+---+---+---+---+---+---+---+\n * 3 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 4 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 5 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 6 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 7 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints<T extends Dimensionality>(\n  softwareTexture: SoftwareTexture,\n  sampler: GPUSamplerDescriptor,\n  callForSamples: TextureCall<T>,\n  originalCall: TextureCall<T>,\n  texels: TexelView[] | undefined,\n  run: (texels: TexelView[]) => Promise<PerTexelComponent<number>>\n) {\n  const info = softwareTexture.descriptor;\n  const isCube = isCubeViewDimension(softwareTexture.viewDescriptor);\n  const mipLevelCount = softwareTexture.descriptor.mipLevelCount ?? 1;\n  const mipLevelSizes = range(mipLevelCount, mipLevel =>\n    virtualMipSize(\n      softwareTexture.descriptor.dimension ?? '2d',\n      softwareTexture.descriptor.size,\n      mipLevel\n    )\n  );\n  const numTexelsPerLevel = mipLevelSizes.map(size => size.reduce((s, v) => s * v));\n  const numTexelsOfPrecedingLevels = (() => {\n    let total = 0;\n    return numTexelsPerLevel.map(v => {\n      const num = total;\n      total += v;\n      return num;\n    });\n  })();\n  const numTexels = numTexelsPerLevel.reduce((sum, v) => sum + v);\n\n  const getMipLevelFromTexelId = (texelId: number) => {\n    for (let mipLevel = mipLevelCount - 1; mipLevel > 0; --mipLevel) {\n      if (texelId - numTexelsOfPrecedingLevels[mipLevel] >= 0) {\n        return mipLevel;\n      }\n    }\n    return 0;\n  };\n\n  const getTexelCoordFromTexelId = (texelId: number) => {\n    const mipLevel = getMipLevelFromTexelId(texelId);\n    const size = mipLevelSizes[mipLevel];\n    const texelsPerSlice = size[0] * size[1];\n    const id = texelId - numTexelsOfPrecedingLevels[mipLevel];\n    const layer = Math.floor(id / texelsPerSlice);\n    const xyId = id - layer * texelsPerSlice;\n    const y = (xyId / size[0]) | 0;\n    const x = xyId % size[0];\n    return { x, y, z: layer, mipLevel, xyId };\n  };\n\n  // This isn't perfect. We already know there was an error. We're just\n  // generating info so it seems okay it's not perfect. This format will\n  // be used to generate weights by drawing with a texture of this format\n  // with a specific pixel set to [1, 1, 1, 1]. As such, if the result\n  // is > 0 then that pixel was sampled and the results are the weights.\n  //\n  // Ideally, this texture with a single pixel set to [1, 1, 1, 1] would\n  // be the same format we were originally testing, the one we already\n  // detected an error for. This way, whatever subtle issues there are\n  // from that format will affect the weight values we're computing. But,\n  // if that format is not encodable, for example if it's a compressed\n  // texture format, then we have no way to build a texture so we use\n  // rgba8unorm instead.\n  const format = (\n    kEncodableTextureFormats.includes(info.format as EncodableTextureFormat)\n      ? info.format\n      : isDepthTextureFormat(info.format)\n      ? 'depth16unorm'\n      : 'rgba8unorm'\n  ) as EncodableTextureFormat;\n  const rep = kTexelRepresentationInfo[format];\n\n  const components = isBuiltinGather(callForSamples.builtin) ? kRGBAComponents : rep.componentOrder;\n  const convertResultAsAppropriate = isBuiltinGather(callForSamples.builtin)\n    ? <T>(v: T) => v\n    : convertResultFormatToTexelViewFormat;\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map<number, PerTexelComponent<number>>();\n  const unclassifiedStack = [new Set<number>(range(numTexels, v => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop()!;\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set<number>();\n    const setB = new Set<number>();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.0\n    const results = convertResultAsAppropriate(\n      await run(\n        range(mipLevelCount, mipLevel =>\n          TexelView.fromTexelsAsColors(\n            format,\n            (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n              const size = mipLevelSizes[mipLevel];\n              const texelsPerSlice = size[0] * size[1];\n              const texelsPerRow = size[0];\n              const texelId =\n                numTexelsOfPrecedingLevels[mipLevel] +\n                coords.x +\n                coords.y * texelsPerRow +\n                coords.z * texelsPerSlice;\n              const isCandidate = setA.has(texelId);\n              const texel: PerTexelComponent<number> = {};\n              for (const component of rep.componentOrder) {\n                texel[component] = isCandidate ? 1 : 0;\n              }\n              return texel;\n            }\n          )\n        )\n      ),\n      format\n    );\n    if (components.some(c => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach(texel => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  // separate the sampledTexelWeights by mipLevel, then by layer, within a layer the texelId only includes x and y\n  const levels: Map<number, PerTexelComponent<number>>[][] = [];\n  for (const [texelId, weight] of sampledTexelWeights.entries()) {\n    const { xyId, z, mipLevel } = getTexelCoordFromTexelId(texelId);\n    const level = levels[mipLevel] ?? [];\n    levels[mipLevel] = level;\n    const layerEntries = level[z] ?? new Map();\n    level[z] = layerEntries;\n    layerEntries.set(xyId, weight);\n  }\n\n  // example when blockWidth = 2, blockHeight = 2\n  //\n  //     0   1   2   3\n  //   ╔═══╤═══╦═══╤═══╗\n  // 0 ║ a │   ║   │   ║\n  //   ╟───┼───╫───┼───╢\n  // 1 ║   │   ║   │   ║\n  //   ╠═══╪═══╬═══╪═══╣\n  // 2 ║   │   ║   │   ║\n  //   ╟───┼───╫───┼───╢\n  // 3 ║   │   ║   │ b ║\n  //   ╚═══╧═══╩═══╧═══╝\n\n  /* prettier-ignore */\n  const blockParts = {\n    top:      { left: '╔', fill: '═══', right: '╗', block: '╦', texel: '╤' },\n    mid:      { left: '╠', fill: '═══', right: '╣', block: '╬', texel: '╪' },\n    bot:      { left: '╚', fill: '═══', right: '╝', block: '╩', texel: '╧' },\n    texelMid: { left: '╟', fill: '───', right: '╢', block: '╫', texel: '┼' },\n    value:    { left: '║', fill: '   ', right: '║', block: '║', texel: '│' },\n  } as const;\n  /* prettier-ignore */\n  const nonBlockParts = {\n    top:      { left: '┌', fill: '───', right: '┐', block: '┬', texel: '┬' },\n    mid:      { left: '├', fill: '───', right: '┤', block: '┼', texel: '┼' },\n    bot:      { left: '└', fill: '───', right: '┘', block: '┴', texel: '┴' },\n    texelMid: { left: '├', fill: '───', right: '┤', block: '┼', texel: '┼' },\n    value:    { left: '│', fill: '   ', right: '│', block: '│', texel: '│' },\n  } as const;\n\n  const lines: string[] = [];\n  const letter = (idx: number) => String.fromCodePoint(idx < 30 ? 97 + idx : idx + 9600 - 30); // 97: 'a'\n  let idCount = 0;\n\n  const { blockWidth, blockHeight } = getBlockInfoForTextureFormat(\n    softwareTexture.descriptor.format\n  );\n  // range + concatenate results.\n  const rangeCat = <T>(num: number, fn: (i: number) => T) => range(num, fn).join('');\n  const joinFn = (arr: string[], fn: (i: number) => string) => {\n    const joins = range(arr.length - 1, fn);\n    return arr.map((s, i) => `${s}${joins[i] ?? ''}`).join('');\n  };\n  const parts = Math.max(blockWidth, blockHeight) > 1 ? blockParts : nonBlockParts;\n  /**\n   * Makes a row that's [left, fill, texel, fill, block, fill, texel, fill, right]\n   * except if `contents` is supplied then it would be\n   * [left, contents[0], texel, contents[1], block, contents[2], texel, contents[3], right]\n   */\n  const makeRow = (\n    blockPaddedWidth: number,\n    width: number,\n    {\n      left,\n      fill,\n      right,\n      block,\n      texel,\n    }: {\n      left: string;\n      fill: string;\n      right: string;\n      block: string;\n      texel: string;\n    },\n    contents?: string[]\n  ) => {\n    return `${left}${joinFn(contents ?? range(blockPaddedWidth, x => fill), x => {\n      return (x + 1) % blockWidth === 0 ? block : texel;\n    })}${right}`;\n  };\n\n  for (let mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {\n    const level = levels[mipLevel];\n    if (!level) {\n      continue;\n    }\n\n    const [width, height, depthOrArrayLayers] = mipLevelSizes[mipLevel];\n    const texelsPerRow = width;\n\n    for (let layer = 0; layer < depthOrArrayLayers; ++layer) {\n      const layerEntries = level[layer];\n\n      const orderedTexelIndices: number[] = [];\n      lines.push('');\n      const unSampled = layerEntries ? '' : 'un-sampled';\n      if (isCube) {\n        const face = kFaceNames[layer % 6];\n        lines.push(\n          `layer: ${layer} mip(${mipLevel}), cube-layer: ${(layer / 6) | 0} (${face}) ${unSampled}`\n        );\n      } else {\n        lines.push(`layer: ${layer} mip(${mipLevel}) ${unSampled}`);\n      }\n\n      if (!layerEntries) {\n        continue;\n      }\n\n      const blockPaddedHeight = align(height, blockHeight);\n      const blockPaddedWidth = align(width, blockWidth);\n      lines.push(`   ${rangeCat(width, x => `  ${x.toString().padEnd(2)}`)}`);\n      lines.push(`   ${makeRow(blockPaddedWidth, width, parts.top)}`);\n      for (let y = 0; y < blockPaddedHeight; y++) {\n        lines.push(\n          `${y.toString().padStart(2)} ${makeRow(\n            blockPaddedWidth,\n            width,\n            parts.value,\n            range(blockPaddedWidth, x => {\n              const texelIdx = x + y * texelsPerRow;\n              const weight = layerEntries.get(texelIdx);\n              const outside = y >= height || x >= width;\n              if (outside || weight === undefined) {\n                return outside ? '░░░' : '   ';\n              } else {\n                const id = letter(idCount + orderedTexelIndices.length);\n                orderedTexelIndices.push(texelIdx);\n                return ` ${id} `;\n              }\n            })\n          )}`\n        );\n        // It's either a block row, a texel row, or the last row.\n        const end = y < blockPaddedHeight - 1;\n        const lineParts = end\n          ? (y + 1) % blockHeight === 0\n            ? parts.mid\n            : parts.texelMid\n          : parts.bot;\n        lines.push(`   ${makeRow(blockPaddedWidth, width, lineParts)}`);\n      }\n\n      const pad2 = (n: number) => n.toString().padStart(2);\n      const pad3 = (n: number) => n.toString().padStart(3);\n      const fix5 = (n: number) => {\n        const s = n.toFixed(5);\n        return s === '0.00000' && n !== 0 ? n.toString() : s;\n      };\n      const formatValue = isSintOrUintFormat(format) ? pad3 : fix5;\n      const formatTexel = (texel: PerTexelComponent<number> | undefined) =>\n        texel\n          ? Object.entries(texel)\n              .map(([k, v]) => `${k}: ${formatValue(v)}`)\n              .join(', ')\n          : '*texel values unavailable*';\n\n      const colorLines: string[] = [];\n      const compareLines: string[] = [];\n      let levelWeight = 0;\n      orderedTexelIndices.forEach((texelIdx, i) => {\n        const weights = layerEntries.get(texelIdx)!;\n        const y = Math.floor(texelIdx / texelsPerRow);\n        const x = texelIdx % texelsPerRow;\n        const singleWeight = valueIfAllComponentsAreEqual(weights, components)!;\n        levelWeight += singleWeight;\n        const w =\n          singleWeight !== undefined\n            ? `weight: ${fix5(singleWeight)}`\n            : `weights: [${components.map(c => `${c}: ${fix5(weights[c]!)}`).join(', ')}]`;\n        const coord = `${pad2(x)}, ${pad2(y)}, ${pad2(layer)}`;\n        const texel =\n          texels &&\n          convertToTexelViewFormat(\n            texels[mipLevel].color({ x, y, z: layer }),\n            softwareTexture.descriptor.format\n          );\n\n        const texelStr = formatTexel(texel);\n        const id = letter(idCount + i);\n        lines.push(`${id}: mip(${mipLevel}) at: [${coord}], ${w}`);\n        colorLines.push(`${id}: value: ${texelStr}`);\n        if (isBuiltinComparison(originalCall.builtin)) {\n          assert(!!texel);\n          const compareTexel = applyCompare(originalCall, sampler, [TexelComponent.Depth], texel);\n          compareLines.push(\n            `${id}: compare(${sampler.compare}) result with depthRef(${fix5(\n              originalCall.depthRef!\n            )}): ${fix5(compareTexel.Depth!)}`\n          );\n        }\n      });\n      lines.push(...colorLines);\n      lines.push(...compareLines);\n      if (!isNaN(levelWeight)) {\n        lines.push(`mip level (${mipLevel}) weight: ${fix5(levelWeight)}`);\n      }\n      idCount += orderedTexelIndices.length;\n    }\n  }\n\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA: string[], columnB: string[]) {\n  const widthA = Math.max(...columnA.map(l => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out: string[] = new Array<string>(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\n/**\n * Returns the number of layers ot test for a given view dimension\n */\nexport function getDepthOrArrayLayersForViewDimension(viewDimension?: GPUTextureViewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return 1;\n    case undefined:\n    case '2d':\n      return 1;\n    case '2d-array':\n      return 4;\n    case '3d':\n      return 8;\n    case 'cube':\n      return 6;\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Choose a texture size based on the given parameters.\n * The size will be in a multiple of blocks. If it's a cube\n * map the size will so be square.\n */\nexport function chooseTextureSize({\n  minSize,\n  minBlocks,\n  format,\n  viewDimension,\n}: {\n  minSize: number;\n  minBlocks: number;\n  format: GPUTextureFormat;\n  viewDimension?: GPUTextureViewDimension;\n}) {\n  const { blockWidth, blockHeight } = getBlockInfoForTextureFormat(format);\n  const width = align(Math.max(minSize, blockWidth * minBlocks), blockWidth);\n  const height =\n    viewDimension === '1d' ? 1 : align(Math.max(minSize, blockHeight * minBlocks), blockHeight);\n  if (viewDimension === 'cube' || viewDimension === 'cube-array') {\n    const blockLCM = lcm(blockWidth, blockHeight);\n    const largest = Math.max(width, height);\n    const size = align(largest, blockLCM);\n    return [size, size, viewDimension === 'cube-array' ? 24 : 6];\n  }\n  const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n  return [width, height, depthOrArrayLayers];\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'] as const;\nexport type SamplePointMethods = (typeof kSamplePointMethods)[number];\n\nexport const kCubeSamplePointMethods = ['cube-edges', 'texel-centre', 'spiral'] as const;\nexport type CubeSamplePointMethods = (typeof kSamplePointMethods)[number];\n\ntype TextureBuiltinInputArgs = {\n  textureBuiltin?: TextureBuiltin;\n  descriptor?: GPUTextureDescriptor;\n  softwareTexture?: SoftwareTexture;\n  sampler?: GPUSamplerDescriptor;\n  derivatives?: boolean;\n  mipLevel?: RangeDef;\n  sampleIndex?: RangeDef;\n  arrayIndex?: RangeDef;\n  grad?: boolean;\n  bias?: boolean;\n  component?: boolean;\n  depthRef?: boolean;\n  offset?: boolean;\n  hashInputs: (number | string | boolean)[];\n};\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nfunction generateTextureBuiltinInputsImpl<T extends Dimensionality>(\n  makeValue: (x: number, y: number, z: number) => T,\n  n: number,\n  args:\n    | (TextureBuiltinInputArgs & {\n        method: 'texel-centre';\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n      })\n): {\n  coords: T;\n  derivativeMult?: T;\n  ddx?: T;\n  ddy?: T;\n  mipLevel: number;\n  sampleIndex?: number;\n  arrayIndex?: number;\n  bias?: number;\n  offset?: T;\n  component?: number;\n  depthRef?: number;\n}[] {\n  const { method, descriptor, softwareTexture: info } = args;\n  // MAINTENANCE_TODO: remove descriptor from all builtin tests. use softwareTexture instead\n  assert(!!descriptor !== !!info, 'must pass descriptor or textureInfo');\n  const textureInfo: SoftwareTexture = info ?? {\n    descriptor: descriptor!,\n    texels: [],\n    viewDescriptor: {},\n  };\n\n  const { mipLevelCount, baseMipLevelSize } = getBaseMipLevelInfo(textureInfo);\n  const dimension = textureInfo.descriptor.dimension ?? '2d';\n  const coords: T[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const x = Math.floor(lerp(0, baseMipLevelSize[0] - 1, (r & 0xff) / 0xff)) + 0.5;\n        const y = Math.floor(lerp(0, baseMipLevelSize[1] - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5;\n        const z = Math.floor(lerp(0, baseMipLevelSize[2] - 1, ((r >> 16) & 0xff) / 0xff)) + 0.5;\n        coords.push(\n          makeValue(x / baseMipLevelSize[0], y / baseMipLevelSize[1], z / baseMipLevelSize[2])\n        );\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = i / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const a = loops * 2 * Math.PI * f;\n        coords.push(makeValue(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a), 0));\n      }\n      break;\n    }\n  }\n\n  const _hashInputs = args.hashInputs.map(v =>\n    typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? (v ? 1 : 0) : v\n  );\n\n  // returns a number between [0 and N)\n  const makeRandValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num;\n    const number = (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range;\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // for signed and float values returns [-1 to num]\n  // for unsigned values returns [0 to num]\n  const makeRangeValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n      (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // Generates the same values per coord instead of using all the extra `_hashInputs`.\n  const makeIntHashValueRepeatable = (min: number, max: number, ...hashInputs: number[]) => {\n    const range = max - min;\n    return min + Math.floor((hashU32(...hashInputs) / 0x1_0000_0000) * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n\n  // When filtering is nearest then we want to avoid edges of texels\n  //\n  //             U\n  //             |\n  //     +---+---+---+---+---+---+---+---+\n  //     |   | A | B |   |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // Above, coordinate U could sample either A or B\n  //\n  //               U\n  //               |\n  //     +---+---+---+---+---+---+---+---+\n  //     |   | A | B | C |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // For textureGather we want to avoid texel centers\n  // as for coordinate U could either gather A,B or B,C.\n\n  const avoidEdgeCase =\n    !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n\n  // textureGather issues for 2d/3d textures\n  //\n  // If addressModeU is repeat, then on an 8x1 texture, u = 0.01 or u = 0.99\n  // would gather these texels\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     | * |   |   |   |   |   |   | * |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // If addressModeU is clamp-to-edge or mirror-repeat,\n  // then on an 8x1 texture, u = 0.01 would gather this texel\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     | * |   |   |   |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // and 0.99 would gather this texel\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     |   |   |   |   |   |   |   | * |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // This means we have to if addressMode is not `repeat`, we\n  // need to avoid the edge of the texture.\n  //\n  // Note: we don't have these specific issues with cube maps\n  // as they ignore addressMode\n  const euclideanModulo = (n: number, m: number) => ((n % m) + m) % m;\n  const addressMode: GPUAddressMode[] =\n    args.textureBuiltin === 'textureSampleBaseClampToEdge'\n      ? ['clamp-to-edge', 'clamp-to-edge', 'clamp-to-edge']\n      : [\n          args.sampler?.addressModeU ?? 'clamp-to-edge',\n          args.sampler?.addressModeV ?? 'clamp-to-edge',\n          args.sampler?.addressModeW ?? 'clamp-to-edge',\n        ];\n  const avoidTextureEdge = (axis: number, textureDimensionUnits: number, v: number) => {\n    assert(isBuiltinGather(args.textureBuiltin));\n    if (addressMode[axis] === 'repeat') {\n      return v;\n    }\n    const inside = euclideanModulo(v, textureDimensionUnits);\n    const outside = v - inside;\n    return outside + clamp(inside, { min: 1, max: textureDimensionUnits - 1 });\n  };\n\n  const numComponents = isDepthOrStencilTextureFormat(textureInfo.descriptor.format) ? 1 : 4;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel\n      ? quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest')\n      : 0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize(dimension, baseMipLevelSize, clampedMipLevel);\n    const q = mipSize.map(v => v * kSubdivisionsPerTexel);\n\n    const coords = c.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isTexelEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isTexelEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      const v3 = isBuiltinGather(args.textureBuiltin) ? avoidTextureEdge(i, q[i], v2) : v2;\n      // Convert back to texture coords\n      return v3 / q[i];\n    }) as T;\n\n    const makeGradient = <T>(hashInput: number): T => {\n      return coords.map((_, i) => {\n        // a value between -4 and 4 integer then add +/- 0.25\n        // We want to be able to choose levels but we want to avoid the area where the\n        // gpu might choose 2 different levels than the software renderer.\n        const intPart = makeRangeValue({ num: 8, type: 'u32' }, i, hashInput) - 4;\n        const fractPart = makeRangeValue({ num: 0, type: 'f32' }, i, hashInput + 1) * 0.25;\n        assert(fractPart >= -0.25 && fractPart <= 0.25);\n        return intPart + fractPart;\n      }) as T;\n    };\n\n    // choose a derivative value that will select a mipLevel.\n    const makeDerivativeMult = (coords: T, mipLevel: number): T => {\n      // Make an identity vec (all 1s).\n      const mult = new Array(coords.length).fill(0);\n      // choose one axis to set\n      const ndx = makeRangeValue({ num: coords.length - 1, type: 'u32' }, i, 8);\n      assert(ndx < coords.length);\n      mult[ndx] = Math.pow(2, mipLevel);\n      return mult as T;\n    };\n\n    // Choose a mip level. If mipmapFilter is 'nearest' then avoid centers of levels\n    // else avoid edges.\n    const chooseMipLevel = () => {\n      const innerLevelR = makeRandValue({ num: 9, type: 'u32' }, i, 11);\n      const innerLevel =\n        args?.sampler?.mipmapFilter === 'linear'\n          ? innerLevelR + 1\n          : innerLevelR < 5\n          ? innerLevelR\n          : innerLevelR + 1;\n      const outerLevel = makeRangeValue({ num: mipLevelCount - 1, type: 'i32' }, i, 11);\n      return outerLevel + innerLevel / 10;\n    };\n\n    // for textureSample, choose a derivative value that will select a mipLevel near\n    // the range of mip levels.\n    const makeDerivativeMultForTextureSample = (coords: T): T => {\n      const mipLevel = chooseMipLevel();\n      return makeDerivativeMult(coords, mipLevel);\n    };\n\n    // for textureSampleBias we choose a mipLevel we want to sample, then a bias,\n    // and then a derivative that, given the chosen bias will arrive at the chosen mipLevel.\n    // The GPU is supposed to clamp between -16.0 and 15.99.\n    //\n    // Testing clamping with textureSampleBias is prone to precision issues. The reason is, to test\n    // that the bias is clamped, a natural thing to do is:\n    //\n    // * Create a texture with N mip levels, Eg 3. (lets do 8x8, 4x4, 2x2)\n    // * Choose a target mipLevel. Eg 1.5\n    // * Choose a bias that will need to be clamped. Eg 20.0. Clamped this will be 15.99\n    // * Choose a derivative that selects mipLevel -14.49\n    // * Check if we sampled mip level 1.5 (because -14.49 + bias(15.99) = 1.5)\n    //\n    // Unfortunately, to select a mipLevel of -14.49 via derivatives requires a small enough value\n    // (eg: 0.000005432320387256895) that based on internal precision issues in the GPU, might\n    // not calculate -14.49 but instead +/- 0.5 or worse (1 exponent change in the floating point\n    // representation worth of difference?)\n    //\n    // To work around this issue we do the following\n    //\n    // * to test negative bias is clamped\n    //\n    //   * choose a target of 4.0 (assuming 3 mips this is past the 3rd mip level and should be clamped to 3)\n    //   * choose a bias of like -25 (so should be clamped to -16)\n    //   * choose a derivative that computes a mipLevel of 20 because (-16 + 20) = 4 (our target)\n    //\n    //   If the result was clamped we should sample only mip level 3. If the result was not clamped we'll sample\n    //   mip level 0.\n    //\n    //   Note: we'll choose mipLevelCount + 1 as our target so that we have 1 unit of extra range.\n    //   This won't tell is if the bias is clamped to -16 but it will tell us it's clamped to at least -18\n    //\n    // * to test positive bias is clamped\n    //\n    //   * same as above just reverse the signs and clamp to 15.99\n    //\n    // * to test bias works in general\n    //\n    //   * test small values like +/- 3\n    //\n    const makeBiasAndDerivativeMult = (coords: T): [number, T] => {\n      const testType = makeRandValue({ num: 4, type: 'u32' }, i, 11);\n      let mipLevel;\n      let bias;\n      switch (testType) {\n        case 0:\n          // test negative bias\n          mipLevel = mipLevelCount + 1;\n          bias = -25;\n          // example:\n          //   mipLevel                = 4\n          //   bias                    = -25\n          //   clampedBias             = -16\n          //   derivativeBasedMipLevel = mipLevel - clampedBias = 4 - -16 = 20\n          //   expectedMipLevel        = derivativeBasedMipLevel + clampedBias = 20 + -16 = 4\n          //   if bias is not clamped. For example it's -18 then:\n          //   actualMipLevel =  20 + -18 = 2  // this would be an error.\n          break;\n        case 1:\n          // test positive bias\n          mipLevel = -1;\n          bias = 25;\n          // example:\n          //   mipLevel                = -1\n          //   bias                    = 25\n          //   clampedBias             = 15.99\n          //   derivativeBasedMipLevel = mipLevel - clampedBias = -1 - 15.99 = -16.99\n          //   expectedMipLevel        = derivativeBasedMipLevel + clampedBias = -16.99 + 15.99 = -1\n          //   if bias is not clamped. For example it's 18 then:\n          //   actualMipLevel =  -16.99 + 18 = 1.99  // this would be an error.\n          break;\n        default: // test small-ish middle bias\n          mipLevel = chooseMipLevel();\n          bias = makeRangeValue({ num: 6, type: 'f32' }, i, 9) - 3;\n          break;\n      }\n      const clampedBias = clamp(bias, { min: -16, max: 15.99 });\n      const derivativeBasedMipLevel = mipLevel - clampedBias;\n      const derivativeMult = makeDerivativeMult(coords, derivativeBasedMipLevel);\n      return [bias, derivativeMult];\n    };\n\n    // If bias is set this is textureSampleBias. If bias is not set but derivatives\n    // is then this is one of the other functions that needs implicit derivatives.\n    const [bias, derivativeMult] = args.bias\n      ? makeBiasAndDerivativeMult(coords)\n      : args.derivatives\n      ? [undefined, makeDerivativeMultForTextureSample(coords)]\n      : [];\n\n    return {\n      coords,\n      derivativeMult,\n      mipLevel,\n      sampleIndex: args.sampleIndex ? makeRangeValue(args.sampleIndex, i, 1) : undefined,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      // use 0.0, 0.5, or 1.0 for depthRef. We can't test for equality except for values 0 and 1\n      // The texture will be filled with random values unless our comparison is 'equal' or 'not-equal'\n      // in which case the texture will be filled with only 0, 0.6, 1. Choosing 0.0, 0.5, 1.0 here\n      // means we can test 'equal' and 'not-equal'. For other comparisons, the fact that the texture's\n      // contents is random seems enough to test all the comparison modes.\n      depthRef: args.depthRef ? makeRandValue({ num: 3, type: 'u32' }, i, 5) / 2 : undefined,\n      ddx: args.grad ? makeGradient(7) : undefined,\n      ddy: args.grad ? makeGradient(8) : undefined,\n      bias,\n      offset: args.offset\n        ? (coords.map((_, j) => makeIntHashValueRepeatable(-8, 8, i, 3 + j)) as T)\n        : undefined,\n      component: args.component ? makeIntHashValueRepeatable(0, numComponents, i, 4) : undefined,\n    };\n  });\n}\n\n/**\n * When mipmapFilter === 'nearest' we need to stay away from 0.5\n * because the GPU could decide to choose one mip or the other.\n *\n * Some example transition values, the value at which the GPU chooses\n * mip level 1 over mip level 0:\n *\n * M1 Mac: 0.515381\n * Intel Mac: 0.49999\n * AMD Mac: 0.5\n */\nconst kMipEpsilon = 0.02;\nfunction quantizeMipLevel(mipLevel: number, mipmapFilter: GPUMipmapFilterMode) {\n  if (mipmapFilter === 'linear') {\n    return mipLevel;\n  }\n  const intMip = Math.floor(mipLevel);\n  const fractionalMip = mipLevel - intMip;\n  if (fractionalMip < 0.5 - kMipEpsilon || fractionalMip > 0.5 + kMipEpsilon) {\n    return mipLevel;\n  } else {\n    return intMip + 0.5 + (fractionalMip < 0.5 ? -kMipEpsilon : +kMipEpsilon);\n  }\n}\n\n// Removes the first element from an array of types\ntype FilterFirstElement<T extends unknown[]> = T extends [unknown, ...infer R] ? R : [];\n\ntype GenerateTextureBuiltinInputsImplArgs = FilterFirstElement<\n  Parameters<typeof generateTextureBuiltinInputsImpl>\n>;\n\nexport function generateTextureBuiltinInputs1D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec1>((x: number) => [x], ...args);\n}\n\nexport function generateTextureBuiltinInputs2D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec2>((x: number, y: number) => [x, y], ...args);\n}\n\nexport function generateTextureBuiltinInputs3D(...args: GenerateTextureBuiltinInputsImplArgs) {\n  return generateTextureBuiltinInputsImpl<vec3>(\n    (x: number, y: number, z: number) => [x, y, z],\n    ...args\n  );\n}\n\ntype mat3 =\n  /* prettier-ignore */ [\n  number, number, number,\n  number, number, number,\n  number, number, number,\n];\n\nconst kFaceUVMatrices: mat3[] =\n  /* prettier-ignore */ [\n  [ 0,  0,  -2,  0, -2,   0,  1,  1,   1],   // pos-x\n  [ 0,  0,   2,  0, -2,   0, -1,  1,  -1],   // neg-x\n  [ 2,  0,   0,  0,  0,   2, -1,  1,  -1],   // pos-y\n  [ 2,  0,   0,  0,  0,  -2, -1, -1,   1],   // neg-y\n  [ 2,  0,   0,  0, -2,   0, -1,  1,   1],   // pos-z\n  [-2,  0,   0,  0, -2,   0,  1,  1,  -1],   // neg-z\n];\n\n/** multiply a vec3 by mat3 */\nfunction transformMat3(v: vec3, m: mat3): vec3 {\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  return [\n    x * m[0] + y * m[3] + z * m[6],\n    x * m[1] + y * m[4] + z * m[7],\n    x * m[2] + y * m[5] + z * m[8],\n  ];\n}\n\n/** normalize a vec3 */\nfunction normalize(v: vec3): vec3 {\n  const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  assert(length > 0);\n  return v.map(v => v / length) as vec3;\n}\n\n/**\n * Converts a cube map coordinate to a uv coordinate (0 to 1) and layer (0.5/6.0 to 5.5/6.0).\n */\nfunction convertCubeCoordToNormalized3DTextureCoord(v: vec3): vec3 {\n  let uvw;\n  let layer;\n  // normalize the coord.\n  // MAINTENANCE_TODO: handle(0, 0, 0)\n  const r = normalize(v);\n  const absR = r.map(v => Math.abs(v));\n  if (absR[0] > absR[1] && absR[0] > absR[2]) {\n    // x major\n    const negX = r[0] < 0.0 ? 1 : 0;\n    uvw = [negX ? r[2] : -r[2], -r[1], absR[0]];\n    layer = negX;\n  } else if (absR[1] > absR[2]) {\n    // y major\n    const negY = r[1] < 0.0 ? 1 : 0;\n    uvw = [r[0], negY ? -r[2] : r[2], absR[1]];\n    layer = 2 + negY;\n  } else {\n    // z major\n    const negZ = r[2] < 0.0 ? 1 : 0;\n    uvw = [negZ ? -r[0] : r[0], -r[1], absR[2]];\n    layer = 4 + negZ;\n  }\n  return [(uvw[0] / uvw[2] + 1) * 0.5, (uvw[1] / uvw[2] + 1) * 0.5, (layer + 0.5) / 6];\n}\n\n/**\n * Convert a 3d texcoord into a cube map coordinate.\n */\nfunction convertNormalized3DTexCoordToCubeCoord(uvLayer: vec3) {\n  const [u, v, faceLayer] = uvLayer;\n  return normalize(transformMat3([u, v, 1], kFaceUVMatrices[Math.min(5, faceLayer * 6) | 0]));\n}\n\n/**\n * Wrap a texel based face coord across cube faces\n *\n * We have a face texture in texels coord where U/V choose a texel and W chooses the face.\n * If U/V are outside the size of the texture then, when normalized and converted\n * to a cube map coordinate, they'll end up pointing to a different face.\n *\n * addressMode is effectively ignored for cube\n *\n * By converting from a texel based coord to a normalized coord and then to a cube map coord,\n * if the texel was outside of the face, the cube map coord will end up pointing to a different\n * face. We then convert back cube coord -> normalized face coord -> texel based coord\n */\nfunction wrapFaceCoordToCubeFaceAtEdgeBoundaries(mipLevelSize: number, faceCoord: vec3) {\n  // convert texel based face coord to normalized 2d-array coord\n  const nc0: vec3 = [\n    (faceCoord[0] + 0.5) / mipLevelSize,\n    (faceCoord[1] + 0.5) / mipLevelSize,\n    (faceCoord[2] + 0.5) / 6,\n  ];\n  const cc = convertNormalized3DTexCoordToCubeCoord(nc0);\n  const nc1 = convertCubeCoordToNormalized3DTextureCoord(cc);\n  // convert normalized 2d-array coord back texel based face coord\n  const fc = [\n    Math.floor(nc1[0] * mipLevelSize),\n    Math.floor(nc1[1] * mipLevelSize),\n    Math.floor(nc1[2] * 6),\n  ];\n\n  return fc;\n}\n\nfunction applyAddressModesToCoords(\n  addressMode: GPUAddressMode[],\n  mipLevelSize: number[],\n  coord: number[]\n) {\n  return coord.map((v, i) => {\n    switch (addressMode[i]) {\n      case 'clamp-to-edge':\n        return clamp(v, { min: 0, max: mipLevelSize[i] - 1 });\n      case 'mirror-repeat': {\n        const n = Math.floor(v / mipLevelSize[i]);\n        v = v - n * mipLevelSize[i];\n        return (n & 1) !== 0 ? mipLevelSize[i] - v - 1 : v;\n      }\n      case 'repeat':\n        return v - Math.floor(v / mipLevelSize[i]) * mipLevelSize[i];\n      default:\n        unreachable();\n    }\n  });\n}\n\n/**\n * Generates an array of coordinates at which to sample a texture for a cubemap\n */\nexport function generateSamplePointsCube(\n  n: number,\n  args:\n    | (TextureBuiltinInputArgs & {\n        method: 'texel-centre';\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n      })\n    | (TextureBuiltinInputArgs & {\n        method: 'cube-edges';\n      })\n): {\n  coords: vec3;\n  derivativeMult?: vec3;\n  ddx?: vec3;\n  ddy?: vec3;\n  mipLevel: number;\n  arrayIndex?: number;\n  bias?: number;\n  offset?: undefined;\n  component?: number;\n  depthRef?: number;\n}[] {\n  const { method, descriptor, softwareTexture: info } = args;\n  // MAINTENANCE_TODO: remove descriptor from all builtin tests. use textureInfo.\n  assert(!!descriptor !== !!info, 'must pass descriptor or textureInfo');\n  const textureInfo: SoftwareTexture = info ?? {\n    descriptor: descriptor!,\n    texels: [],\n    viewDescriptor: {},\n  };\n\n  const { mipLevelCount, baseMipLevelSize } = getBaseMipLevelInfo(textureInfo);\n  const textureWidth = baseMipLevelSize[0];\n  const coords: vec3[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const u = (Math.floor(lerp(0, textureWidth - 1, (r & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const v =\n          (Math.floor(lerp(0, textureWidth - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const face = Math.floor(lerp(0, 6, ((r >> 16) & 0xff) / 0x100));\n        coords.push(convertNormalized3DTexCoordToCubeCoord([u, v, face]));\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = (i + 1) / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const theta = loops * 2 * Math.PI * f;\n        const phi = loops * 1.3 * Math.PI * f;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n        const ux = cosTheta * sinPhi;\n        const uy = cosPhi;\n        const uz = sinTheta * sinPhi;\n        coords.push([ux * r, uy * r, uz * r]);\n      }\n      break;\n    }\n    case 'cube-edges': {\n      /* prettier-ignore */\n      coords.push(\n        // between edges\n        // +x\n        [  1   , -1.01,  0    ],  // wrap -y\n        [  1   , +1.01,  0    ],  // wrap +y\n        [  1   ,  0   , -1.01 ],  // wrap -z\n        [  1   ,  0   , +1.01 ],  // wrap +z\n        // -x\n        [ -1   , -1.01,  0    ],  // wrap -y\n        [ -1   , +1.01,  0    ],  // wrap +y\n        [ -1   ,  0   , -1.01 ],  // wrap -z\n        [ -1   ,  0   , +1.01 ],  // wrap +z\n\n        // +y\n        [ -1.01,  1   ,  0    ],  // wrap -x\n        [ +1.01,  1   ,  0    ],  // wrap +x\n        [  0   ,  1   , -1.01 ],  // wrap -z\n        [  0   ,  1   , +1.01 ],  // wrap +z\n        // -y\n        [ -1.01, -1   ,  0    ],  // wrap -x\n        [ +1.01, -1   ,  0    ],  // wrap +x\n        [  0   , -1   , -1.01 ],  // wrap -z\n        [  0   , -1   , +1.01 ],  // wrap +z\n\n        // +z\n        [ -1.01,  0   ,  1    ],  // wrap -x\n        [ +1.01,  0   ,  1    ],  // wrap +x\n        [  0   , -1.01,  1    ],  // wrap -y\n        [  0   , +1.01,  1    ],  // wrap +y\n        // -z\n        [ -1.01,  0   , -1    ],  // wrap -x\n        [ +1.01,  0   , -1    ],  // wrap +x\n        [  0   , -1.01, -1    ],  // wrap -y\n        [  0   , +1.01, -1    ],  // wrap +y\n\n        // corners (see comment \"Issues with corners of cubemaps\")\n        // for why these are commented out.\n        // [-1.01, -1.02, -1.03],\n        // [ 1.01, -1.02, -1.03],\n        // [-1.01,  1.02, -1.03],\n        // [ 1.01,  1.02, -1.03],\n        // [-1.01, -1.02,  1.03],\n        // [ 1.01, -1.02,  1.03],\n        // [-1.01,  1.02,  1.03],\n        // [ 1.01,  1.02,  1.03],\n      );\n      break;\n    }\n  }\n\n  const _hashInputs = args.hashInputs.map(v =>\n    typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? (v ? 1 : 0) : v\n  );\n\n  // returns a number between [0 and N)\n  const makeRandValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num;\n    const number = (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range;\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // for signed and float values returns [-1 to num]\n  // for unsigned values returns [0 to num]\n  const makeRangeValue = ({ num, type }: RangeDef, ...hashInputs: number[]) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n      (hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  const makeIntHashValue = (min: number, max: number, ...hashInputs: number[]) => {\n    const range = max - min;\n    return min + Math.floor((hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000) * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  //\n  // Note: When doing `textureGather...` we can't use texel centers\n  // because which 4 pixels will be gathered jumps if we're slightly under\n  // or slightly over the center\n  //\n  // Similarly, if we're using 'nearest' filtering then we don't want texel\n  // edges for the same reason.\n  //\n  // Also note that for textureGather. The way it works for cube maps is to\n  // first convert from cube map coordinate to a 2D texture coordinate and\n  // a face. Then, choose 4 texels just like normal 2D texture coordinates.\n  // If one of the 4 texels is outside the current face, wrap it to the correct\n  // face.\n  //\n  // An issue this brings up though. Imagine a 2D texture with addressMode = 'repeat'\n  //\n  //       2d texture   (same texture repeated to show 'repeat')\n  //     ┌───┬───┬───┐     ┌───┬───┬───┐\n  //     │   │   │   │     │   │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  a│     │c  │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  b│     │d  │   │   │\n  //     └───┴───┴───┘     └───┴───┴───┘\n  //\n  // Assume the texture coordinate is at the bottom right corner of a.\n  // Then textureGather will grab c, d, b, a (no idea why that order).\n  // but think of it as top-right, bottom-right, bottom-left, top-left.\n  // Similarly, if the texture coordinate is at the top left of d it\n  // will select the same 4 texels.\n  //\n  // But, in the case of a cubemap, each face is in different direction\n  // relative to the face next to it.\n  //\n  //             +-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   +y     |\n  //             |    (2)    |\n  //             |           |\n  // +-----------+-----------+-----------+-----------+\n  // |0->u       |0->u       |0->u       |0->u       |\n  // |↓          |↓          |↓          |↓          |\n  // |v   -x     |v   +z     |v   +x     |v   -z     |\n  // |    (1)    |    (4)    |    (0)    |    (5)    |\n  // |           |           |           |           |\n  // +-----------+-----------+-----------+-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   -y     |\n  //             |    (3)    |\n  //             |           |\n  //             +-----------+\n  //\n  // As an example, imagine going from the +y to the +x face.\n  // See diagram above, the right edge of the +y face wraps\n  // to the top edge of the +x face.\n  //\n  //                             +---+---+\n  //                             |  a|c  |\n  //     ┌───┬───┬───┐           ┌───┬───┬───┐\n  //     │   │   │   │           │  b│d  │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  a│ c |       │   │   │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  b│ d |       │   │   │   │\n  //     └───┴───┴───┘---+       └───┴───┴───┘\n  //        +y face                 +x face\n  //\n  // If the texture coordinate is in the bottom right corner of a,\n  // the rectangle of texels we read are a,b,c,d and, if we the\n  // texture coordinate is in the top left corner of d we also\n  // read a,b,c,d according to the 2 diagrams above.\n  //\n  // But, notice that when reading from the POV of +y vs +x,\n  // which actual a,b,c,d texels are different.\n  //\n  // From the POV of face +x: a,b are in face +x and c,d are in face +y\n  // From the POV of face +y: a,c are in face +x and b,d are in face +y\n  //\n  // This is all the long way of saying that if we're on the edge of a cube\n  // face we could get drastically different results because the orientation\n  // of the rectangle of the 4 texels we use, rotates. So, we need to avoid\n  // any values too close to the edge just in case our math is different than\n  // the GPU's.\n  //\n  const kSubdivisionsPerTexel = 4;\n  const avoidEdgeCase =\n    !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel\n      ? quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest')\n      : 0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize('2d', baseMipLevelSize, Math.ceil(clampedMipLevel));\n    const q = [\n      mipSize[0] * kSubdivisionsPerTexel,\n      mipSize[0] * kSubdivisionsPerTexel,\n      6 * kSubdivisionsPerTexel,\n    ];\n\n    const uvw = convertCubeCoordToNormalized3DTextureCoord(c);\n\n    // If this is a corner, move to in so it's not\n    // (see comment \"Issues with corners of cubemaps\")\n    const ndx = getUnusedCubeCornerSampleIndex(mipSize[0], uvw);\n    if (ndx >= 0) {\n      const halfTexel = 0.5 / mipSize[0];\n      uvw[0] = clamp(uvw[0], { min: halfTexel, max: 1 - halfTexel });\n    }\n\n    const quantizedUVW = uvw.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      // Convert back to texture coords slightly off\n      return (v2 + 1 / 16) / q[i];\n    }) as vec3;\n\n    const quantize = (v: number, units: number) => Math.floor(v * units) * units;\n\n    const makeGradient = <T>(hashInput: number): T => {\n      return coords.map((_, i) =>\n        // a value between -4 and 4, quantized to 1/3rd.\n        quantize(makeRangeValue({ num: 8, type: 'f32' }, i, hashInput) - 4, 1 / 3)\n      ) as T;\n    };\n\n    const coords = convertNormalized3DTexCoordToCubeCoord(quantizedUVW);\n\n    // choose a derivative value that will select a mipLevel.\n    const makeDerivativeMult = (coords: vec3, mipLevel: number): vec3 => {\n      // Make an identity vec (all 1s).\n      const mult = new Array(coords.length).fill(0);\n      // choose one axis to set\n      const ndx = makeRangeValue({ num: coords.length - 1, type: 'u32' }, i, 8);\n      assert(ndx < coords.length);\n      mult[ndx] = Math.pow(2, mipLevel);\n      return mult as vec3;\n    };\n\n    // Choose a mip level. If mipmapFilter is 'nearest' then avoid centers of levels\n    // else avoid edges.\n    const chooseMipLevel = () => {\n      const innerLevelR = makeRandValue({ num: 9, type: 'u32' }, i, 11);\n      const innerLevel =\n        args?.sampler?.mipmapFilter === 'linear'\n          ? innerLevelR + 1\n          : innerLevelR < 4\n          ? innerLevelR\n          : innerLevelR + 1;\n      const outerLevel = makeRangeValue({ num: mipLevelCount - 1, type: 'i32' }, i, 11);\n      return outerLevel + innerLevel / 10;\n    };\n\n    // for textureSample, choose a derivative value that will select a mipLevel near\n    // the range of mip levels.\n    const makeDerivativeMultForTextureSample = (coords: vec3): vec3 => {\n      const mipLevel = chooseMipLevel();\n      return makeDerivativeMult(coords, mipLevel);\n    };\n\n    // See makeBiasAndDerivativeMult in generateTextureBuiltinInputsImpl\n    const makeBiasAndDerivativeMult = (coords: vec3): [number, vec3] => {\n      const testType = makeRandValue({ num: 4, type: 'u32' }, i, 11);\n      let mipLevel;\n      let bias;\n      switch (testType) {\n        case 0:\n          // test negative bias\n          mipLevel = mipLevelCount + 1;\n          bias = -25;\n          break;\n        case 1:\n          // test positive bias\n          mipLevel = -1;\n          bias = 25;\n          break;\n        default: // test small-ish middle bias\n          mipLevel = chooseMipLevel();\n          bias = makeRangeValue({ num: 6, type: 'f32' }, i, 9) - 3;\n          break;\n      }\n      const clampedBias = clamp(bias, { min: -16, max: 15.99 });\n      const derivativeBasedMipLevel = mipLevel - clampedBias;\n      const derivativeMult = makeDerivativeMult(coords, derivativeBasedMipLevel);\n      return [bias, derivativeMult];\n    };\n\n    // If bias is set this is textureSampleBias. If bias is not set but derivatives\n    // is then this is one of the other functions that needs implicit derivatives.\n    const [bias, derivativeMult] = args.bias\n      ? makeBiasAndDerivativeMult(coords)\n      : args.derivatives\n      ? [undefined, makeDerivativeMultForTextureSample(coords)]\n      : [];\n\n    return {\n      coords,\n      derivativeMult,\n      ddx: args.grad ? makeGradient(7) : undefined,\n      ddy: args.grad ? makeGradient(8) : undefined,\n      mipLevel,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      bias,\n      // use 0.0, 0.5, or 1.0 for depthRef. We can't test for equality except for values 0 and 1\n      // The texture will be filled with random values unless our comparison is 'equal' or 'not-equal'\n      // in which case the texture will be filled with only 0, 0.6, 1. Choosing 0.0, 0.5, 1.0 here\n      // means we can test 'equal' and 'not-equal'. For other comparisons, the fact that the texture's\n      // contents is random seems enough to test all the comparison modes.\n      depthRef: args.depthRef ? makeRandValue({ num: 3, type: 'u32' }, i, 5) / 2 : undefined,\n      component: args.component ? makeIntHashValue(0, 4, i, 4) : undefined,\n    };\n  });\n}\n\nfunction wgslTypeFor(data: number | Dimensionality, type: 'f' | 'i' | 'u'): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}32`;\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32`;\n}\n\nfunction wgslExpr(\n  data: number | Readonly<vec1> | Readonly<vec2> | Readonly<vec3> | Readonly<vec4>\n): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return data[0].toString();\n      case 2:\n        return `vec2(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map(v => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return data.toString();\n}\n\nfunction wgslExprFor(data: number | vec1 | vec2 | vec3 | vec4, type: 'f' | 'i' | 'u'): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}(${data[0].toString()})`;\n      case 2:\n        return `vec2${type}(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3${type}(${data.map(v => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32(${data.toString()})`;\n}\n\nfunction binKey<T extends Dimensionality>(call: TextureCall<T>): string {\n  const keys: string[] = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset' || name === 'component') {\n        // offset and component must be constant expressions\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls<T extends Dimensionality>(calls: TextureCall<T>[]) {\n  const args: string[] = [];\n  const fields: string[] = [];\n  const data: number[] = [];\n  const prototype = calls[0];\n\n  if (isBuiltinGather(prototype.builtin) && prototype['componentType']) {\n    args.push(`/* component */ ${wgslExpr(prototype['component']!)}`);\n  }\n\n  // All texture builtins take a Texture\n  args.push('T');\n\n  if (builtinNeedsSampler(prototype.builtin)) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else if (name === 'component') {\n        // was handled above\n      } else {\n        const type =\n          name === 'mipLevel'\n            ? prototype.levelType!\n            : name === 'arrayIndex'\n            ? prototype.arrayIndexType!\n            : name === 'sampleIndex'\n            ? prototype.sampleIndexType!\n            : name === 'bias' || name === 'depthRef' || name === 'ddx' || name === 'ddy'\n            ? 'f'\n            : prototype.coordType;\n        if (name !== 'derivativeMult') {\n          args.push(\n            `args.${name}${\n              name === 'coords' && builtinNeedsDerivatives(prototype.builtin)\n                ? ' + derivativeBase * args.derivativeMult'\n                : ''\n            }`\n          );\n        }\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, type)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        (prototype[name] === undefined) === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset' && name !== 'component') {\n        const type = getCallArgType<T>(call, name);\n        const bitcastToU32 = kBitCastFunctions[type];\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls<T extends Dimensionality>(calls: TextureCall<T>[]): number[][] {\n  const map = new Map<string, number>(); // key to bin index\n  const bins: number[][] = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nfunction describeTextureCall<T extends Dimensionality>(call: TextureCall<T>): string {\n  const args: string[] = [];\n  if (isBuiltinGather(call.builtin) && call.componentType) {\n    args.push(`component: ${wgslExprFor(call.component!, call.componentType)}`);\n  }\n  args.push('texture: T');\n  if (builtinNeedsSampler(call.builtin)) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined && name !== 'component') {\n      if (name === 'coords') {\n        const derivativeWGSL = builtinNeedsDerivatives(call.builtin)\n          ? ` + derivativeBase * derivativeMult(${\n              call.derivativeMult ? wgslExprFor(call.derivativeMult, call.coordType) : '1'\n            })`\n          : '';\n        args.push(`${name}: ${wgslExprFor(value, call.coordType)}${derivativeWGSL}`);\n      } else if (name === 'derivativeMult') {\n        // skip this - it's covered in 'coords'\n      } else if (name === 'ddx' || name === 'ddy') {\n        args.push(`${name}: ${wgslExprFor(value, call.coordType)}`);\n      } else if (name === 'mipLevel') {\n        args.push(`${name}: ${wgslExprFor(value, call.levelType!)}`);\n      } else if (name === 'arrayIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.arrayIndexType!)}`);\n      } else if (name === 'bias') {\n        args.push(`${name}: ${wgslExprFor(value, 'f')}`);\n      } else if (name === 'sampleIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.sampleIndexType!)}`);\n      } else if (name === 'depthRef') {\n        args.push(`${name}: ${wgslExprFor(value, 'f')}`);\n      } else {\n        args.push(`${name}: ${wgslExpr(value)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\nconst getAspectForTexture = (texture: GPUTexture | GPUExternalTexture): GPUTextureAspect =>\n  texture instanceof GPUExternalTexture\n    ? 'all'\n    : isDepthTextureFormat(texture.format)\n    ? 'depth-only'\n    : isStencilTextureFormat(texture.format)\n    ? 'stencil-only'\n    : 'all';\n\nconst s_deviceToPipelines = new WeakMap<\n  GPUDevice,\n  Map<string, GPURenderPipeline | GPUComputePipeline>\n>();\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the instance_index as an index. That\n * index is then used to look up a coordinate from a storage buffer which is\n * used to call the WGSL texture function to read/sample the texture, and then\n * write to a storage buffer. We then read the storage buffer for the per \"call\"\n * results.\n *\n * We use a 1x1 target and use instance drawing, once instance per call.\n * This allows use to more easily adjust derivatives per call.\n *\n * An issue we ran into before this \"one draw call per instance\" change;\n * Before we had a single draw call and wrote the result of one call per\n * pixel rendered.\n *\n * Imagine we have code like this:\n *\n * ```\n * @group(0) @binding(0) var T: texture_2d<f32>;\n * @group(0) @binding(1) var S: sampler;\n * @group(0) @binding(2) var<storage> coords: array<vec4f>;\n * @fragment fn fs(@builtin(position) pos: vec4f) -> vec4f {\n *   let ndx = u32(pos.x) * u32(pos.y) * targetWidth;\n *   return textureSample(T, S, coords[ndx].xy);\n * }\n * ```\n *\n * T points to 8x8 pixel texture with 3 mip levels\n * S is 'nearest'\n * coords: is a storage buffer, 16 bytes long [0,0,0,0], one vec4f.\n * our render target is 1x1 pixels\n *\n * Looking above it appears `ndx` will only ever be 0 but that's\n * not what happens. Instead, the GPU will run the fragment shader for\n * a 2x2 area. It does this to compute derivatives by running the code\n * above and looking at what values it gets passed as coords to\n * textureSample. When it does this it ends up with\n *\n * ndx = 0 for invocation 0\n * ndx = 1 for invocation 1\n * ndx = 0 + 1 * targetWidth for invocation 2\n * ndx = 1 + 1 * targetWidth for invocation 3\n *\n * In 3 of those cases `ndx` is out of bounds with respect to `coords`.\n * Out of bounds access is indeterminate. That means the derivatives are\n * indeterminate so what lod it tries to read is indeterminate.\n *\n * By using instance_index for ndx we avoid this issue. ndx is the same\n * on all 4 executions.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n *\n * Note: this function returns:\n *\n * 'results': an array of results, one for each call.\n *\n * 'run': a function that accepts a texture and runs the same class pipeline with\n *        that texture as input, returning an array of results. This can be used by\n *        identifySamplePoints to query the mix-weights used. We do this so we're\n *        using the same shader that generated the original results when querying\n *        the weights.\n *\n * 'destroy': a function that cleans up the buffers used by `run`.\n */\nfunction createTextureCallsRunner<T extends Dimensionality>(\n  t: GPUTest,\n  {\n    format,\n    dimension,\n    sampleCount,\n    depthOrArrayLayers,\n  }: {\n    format: GPUTextureFormat;\n    dimension: GPUTextureDimension;\n    sampleCount: number;\n    depthOrArrayLayers: number;\n  },\n  viewDescriptor: GPUTextureViewDescriptor,\n  textureType: string,\n  sampler: GPUSamplerDescriptor | undefined,\n  calls: TextureCall<T>[],\n  stage: ShaderStage\n) {\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data: number[] = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map(callIdx => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',\\n  ')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (idx >= ${callCount}) & (idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = t.createBufferTracked({\n    label: 'createTextureCallsRunner:dataBuffer',\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n  });\n  t.device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const builtin = calls[0].builtin;\n  const isCompare = isBuiltinComparison(builtin);\n\n  const { resultType, resultFormat, componentType } = isBuiltinGather(builtin)\n    ? getTextureFormatTypeInfo(format)\n    : textureType === 'texture_external'\n    ? ({ resultType: 'vec4f', resultFormat: 'rgba32float', componentType: 'f32' } as const)\n    : textureType.includes('depth')\n    ? ({ resultType: 'f32', resultFormat: 'rgba32float', componentType: 'f32' } as const)\n    : getTextureFormatTypeInfo(format);\n  const returnType = `vec4<${componentType}>`;\n\n  const samplerType = isCompare ? 'sampler_comparison' : 'sampler';\n\n  const renderTarget = t.createTextureTracked({\n    format: 'rgba32uint',\n    size: [calls.length, 1],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  // derivativeBase is a number that starts at (0, 0, 0) and advances by 1 in x, y\n  // for each fragment shader iteration in texel space. It is then converted to normalized\n  // texture space by dividing by the textureDimensions.\n  // Since it's moving by 1 texel unit we can multiply it to get any specific lod value we want.\n  // Because it starts at (0, 0, 0) it will not affect our texture coordinate.\n  const derivativeBaseWGSL = `\n  let derivativeBase = ${\n    isCubeViewDimension(viewDescriptor)\n      ? '(v.pos.xyx - 0.5 - vec3f(f32(v.ndx), 0, f32(v.ndx))) / vec3f(vec2f(textureDimensions(T)), 1.0)'\n      : dimension === '1d'\n      ? 'f32(v.pos.x - 0.5 - f32(v.ndx)) / f32(textureDimensions(T))'\n      : dimension === '3d'\n      ? 'vec3f(v.pos.xy - 0.5 - vec2f(f32(v.ndx), 0), 0) / vec3f(textureDimensions(T))'\n      : '(v.pos.xy - 0.5 - vec2f(f32(v.ndx), 0)) / vec2f(textureDimensions(T))'\n  };`;\n  const derivativeType =\n    isCubeViewDimension(viewDescriptor) || dimension === '3d'\n      ? 'vec3f'\n      : dimension === '1d'\n      ? 'f32'\n      : 'vec2f';\n\n  const stageWGSL =\n    stage === 'vertex'\n      ? `\n// --------------------------- vertex stage shaders --------------------------------\n@vertex fn vsVertex(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1),\n              instance_index,\n              getResult(instance_index, ${derivativeType}(0)));\n}\n\n@fragment fn fsVertex(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(v.result);\n}\n`\n      : stage === 'fragment'\n      ? `\n// --------------------------- fragment stage shaders --------------------------------\n@vertex fn vsFragment(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1), instance_index, ${returnType}(0));\n}\n\n@fragment fn fsFragment(v: VOut) -> @location(0) vec4u {\n  ${derivativeBaseWGSL}\n  return bitcast<vec4u>(getResult(v.ndx, derivativeBase));\n}\n`\n      : `\n// --------------------------- compute stage shaders --------------------------------\n@group(1) @binding(0) var<storage, read_write> results: array<${returnType}>;\n\n@compute @workgroup_size(1) fn csCompute(@builtin(global_invocation_id) id: vec3u) {\n  results[id.x] = getResult(id.x, ${derivativeType}(0));\n}\n`;\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\nstruct VOut {\n  @builtin(position) pos: vec4f,\n  @location(0) @interpolate(flat, either) ndx: u32,\n  @location(1) @interpolate(flat, either) result: ${returnType},\n};\n\n@group(0) @binding(0) var          T    : ${textureType};\n${sampler ? `@group(0) @binding(1) var          S    : ${samplerType}` : ''};\n@group(0) @binding(2) var<uniform> data : Data;\n\nfn getResult(idx: u32, derivativeBase: ${derivativeType}) -> ${returnType} {\n  var result : ${resultType};\n${body}\n  return ${returnType}(result);\n}\n\n${stageWGSL}\n`;\n\n  const pipelines =\n    s_deviceToPipelines.get(t.device) ?? new Map<string, GPURenderPipeline | GPUComputePipeline>();\n  s_deviceToPipelines.set(t.device, pipelines);\n\n  // unfilterable-float textures can only be used with manually created bindGroupLayouts\n  // since the default 'auto' layout requires filterable textures/samplers.\n  // So, if we don't need filtering, don't request a filtering sampler. If we require\n  // filtering then check if the format is 32float format and if float32-filterable\n  // is enabled.\n  const type = getTextureFormatType(format ?? 'rgba8unorm');\n  const isFiltering =\n    !!sampler &&\n    (sampler.minFilter === 'linear' ||\n      sampler.magFilter === 'linear' ||\n      sampler.mipmapFilter === 'linear');\n  let sampleType: GPUTextureSampleType = textureType.startsWith('texture_depth')\n    ? 'depth'\n    : isDepthTextureFormat(format)\n    ? 'unfilterable-float'\n    : isStencilTextureFormat(format)\n    ? 'uint'\n    : type ?? 'float';\n  if (isFiltering && sampleType === 'unfilterable-float') {\n    assert(is32Float(format));\n    assert(t.device.features.has('float32-filterable'));\n    sampleType = 'float';\n  }\n  if (sampleCount > 1 && sampleType === 'float') {\n    sampleType = 'unfilterable-float';\n  }\n\n  const visibility =\n    stage === 'compute'\n      ? GPUShaderStage.COMPUTE\n      : stage === 'fragment'\n      ? GPUShaderStage.FRAGMENT\n      : GPUShaderStage.VERTEX;\n\n  const entries: GPUBindGroupLayoutEntry[] = [\n    {\n      binding: 2,\n      visibility,\n      buffer: {\n        type: 'uniform',\n      },\n    },\n  ];\n\n  const viewDimension = effectiveViewDimensionForDimension(\n    viewDescriptor.dimension,\n    dimension,\n    depthOrArrayLayers\n  );\n\n  if (textureType.includes('storage')) {\n    entries.push({\n      binding: 0,\n      visibility,\n      storageTexture: {\n        access: 'read-only',\n        viewDimension,\n        format,\n      },\n    });\n  } else if (textureType === 'texture_external') {\n    entries.push({\n      binding: 0,\n      visibility,\n      externalTexture: {},\n    });\n  } else {\n    entries.push({\n      binding: 0,\n      visibility,\n      texture: {\n        sampleType,\n        viewDimension,\n        multisampled: sampleCount > 1,\n      },\n    });\n  }\n\n  if (sampler) {\n    const type = isCompare ? 'comparison' : isFiltering ? 'filtering' : 'non-filtering';\n    entries.push({\n      binding: 1,\n      visibility,\n      sampler: { type },\n    });\n  }\n\n  const id = `${resultType}:${stage}:${JSON.stringify(entries)}:${code}`;\n  let pipeline = pipelines.get(id);\n  if (!pipeline) {\n    const module = t.device.createShaderModule({ code });\n    const bindGroupLayout0 = t.device.createBindGroupLayout({ entries });\n    const bindGroupLayouts = [bindGroupLayout0];\n\n    if (stage === 'compute') {\n      const bindGroupLayout1 = t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage',\n            },\n          },\n        ],\n      });\n      bindGroupLayouts.push(bindGroupLayout1);\n    }\n\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts,\n    });\n\n    switch (stage) {\n      case 'compute':\n        pipeline = t.device.createComputePipeline({\n          layout,\n          compute: { module },\n        });\n        break;\n      case 'fragment':\n      case 'vertex':\n        pipeline = t.device.createRenderPipeline({\n          layout,\n          vertex: { module },\n          fragment: {\n            module,\n            targets: [{ format: 'rgba32uint' }],\n          },\n        });\n        break;\n    }\n    pipelines.set(id, pipeline);\n  }\n\n  const gpuSampler = sampler ? t.device.createSampler(sampler) : undefined;\n\n  const run = async (gpuTexture: GPUTexture | GPUExternalTexture) => {\n    const resultBuffer = t.createBufferTracked({\n      label: 'createTextureCallsRunner:resultBuffer',\n      size: align(calls.length * 16, 256),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const aspect = getAspectForTexture(gpuTexture);\n    const runViewDescriptor = {\n      ...viewDescriptor,\n      aspect,\n    };\n\n    const bindGroup0 = t.device.createBindGroup({\n      layout: pipeline!.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource:\n            gpuTexture instanceof GPUExternalTexture\n              ? gpuTexture\n              : gpuTexture.createView(runViewDescriptor),\n        },\n        ...(sampler ? [{ binding: 1, resource: gpuSampler! }] : []),\n        { binding: 2, resource: { buffer: dataBuffer } },\n      ],\n    });\n\n    let storageBuffer: GPUBuffer | undefined;\n    const encoder = t.device.createCommandEncoder({ label: 'createTextureCallsRunner' });\n\n    if (stage === 'compute') {\n      storageBuffer = t.createBufferTracked({\n        label: 'createTextureCallsRunner:storageBuffer',\n        size: resultBuffer.size,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });\n\n      const bindGroup1 = t.device.createBindGroup({\n        layout: pipeline!.getBindGroupLayout(1),\n        entries: [{ binding: 0, resource: { buffer: storageBuffer } }],\n      });\n\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline! as GPUComputePipeline);\n      pass.setBindGroup(0, bindGroup0);\n      pass.setBindGroup(1, bindGroup1);\n      pass.dispatchWorkgroups(calls.length);\n      pass.end();\n      encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n    } else {\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: renderTarget.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n\n      pass.setPipeline(pipeline! as GPURenderPipeline);\n      pass.setBindGroup(0, bindGroup0);\n      for (let i = 0; i < calls.length; ++i) {\n        pass.setViewport(i, 0, 1, 1, 0, 1);\n        pass.draw(3, 1, 0, i);\n      }\n      pass.end();\n      encoder.copyTextureToBuffer(\n        { texture: renderTarget },\n        {\n          buffer: resultBuffer,\n          bytesPerRow: resultBuffer.size,\n        },\n        [renderTarget.width, 1]\n      );\n    }\n    t.device.queue.submit([encoder.finish()]);\n\n    await resultBuffer.mapAsync(GPUMapMode.READ);\n\n    const view = TexelView.fromTextureDataByReference(\n      resultFormat,\n      new Uint8Array(resultBuffer.getMappedRange()),\n      {\n        bytesPerRow: calls.length * 16,\n        rowsPerImage: 1,\n        subrectOrigin: [0, 0, 0],\n        subrectSize: [calls.length, 1],\n      }\n    );\n\n    let outIdx = 0;\n    const out = new Array<PerTexelComponent<number>>(calls.length);\n    for (const bin of binned) {\n      for (const callIdx of bin) {\n        const x = outIdx;\n        out[callIdx] = view.color({ x, y: 0, z: 0 });\n        outIdx++;\n      }\n    }\n\n    storageBuffer?.destroy();\n    resultBuffer.destroy();\n\n    return out;\n  };\n\n  return {\n    run,\n    destroy() {\n      dataBuffer.destroy();\n      renderTarget.destroy();\n    },\n  };\n}\n\nexport async function doTextureCalls<T extends Dimensionality>(\n  t: GPUTest,\n  gpuTexture: GPUTexture | GPUExternalTexture,\n  viewDescriptor: GPUTextureViewDescriptor,\n  textureType: string,\n  sampler: GPUSamplerDescriptor | undefined,\n  calls: TextureCall<T>[],\n  shortShaderStage: ShortShaderStage\n) {\n  const stage = kShortShaderStageToShaderStage[shortShaderStage];\n  const runner = createTextureCallsRunner(\n    t,\n    gpuTexture instanceof GPUExternalTexture\n      ? { format: 'rgba8unorm', dimension: '2d', depthOrArrayLayers: 1, sampleCount: 1 }\n      : gpuTexture,\n    viewDescriptor,\n    textureType,\n    sampler,\n    calls,\n    stage\n  );\n  const results = await runner.run(gpuTexture);\n\n  return {\n    runner,\n    results,\n  };\n}\n"],"mappings":"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ACb,EAAEN,OAAO,CAACL,GAAG,CAAC,CAAC5D,CAAC,EAAEsC,CAAC,KAAM,GAAEA,CAAC,CAACkB,QAAQ,CAAC,CAAC,CAACgB,QAAQ,CAAC,CAAC,CAAE,KAAIxE,CAAE,EAAC,CAAC,CAAC6D,IAAI,CAAC,IAAI,CAAE;AACxE;AACA;AACA;AACA,EAAEG,YAAY,CAAC,EAAE,EAAEC,OAAO,CAAE;AAC5B,CAAC;EACK,MAAO,EAAC;;EAEZ;EACAvG,MAAM;IACJuG,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC;IACf,UAASG,KAAM,iCAAgCH,OAAO,CAAC,CAAC,CAAE,KAAII,WAAW,CAAC,CAAE;EAC/E,CAAC;EACD3G,MAAM;IACJuG,OAAO,CAACQ,oBAAoB,CAAC,KAAK,CAAC;IAClC,UAASL,KAAM;IACdH,OAAO,CAACQ,oBAAoB;IAC7B,KAAIJ,WAAW,CAAC,CAAE;EACrB,CAAC;;EAED;EACA;EACA;EACA;EACA,MAAMK,wBAAwB,GAAG,EAAE;EACnChH,MAAM;IACJ,IAAIiH,GAAG,CAACV,OAAO,CAAC,CAACW,IAAI,KAAMX,OAAO,CAAC5B,MAAM,GAAGqC,wBAAwB,GAAG,IAAI,GAAI,CAAC,CAAC;IAChF,UAASN,KAAM,wBAAuBM,wBAAyB,qBAAoBL,WAAW,CAAC,CAAE;EACpG,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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"}