{"version":3,"file":"exp.cache.js","names":["kValue","FP","biasedRange","linearRange","makeCaseCache","f32_inputs","f32","negative","min","max","positive","f16_inputs","f16","d","f32_const","generateScalarToIntervalCases","expInterval","f32_non_const","f16_const","f16_non_const","abstract"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/exp.cache.ts"],"sourcesContent":["import { kValue } from '../../../../../util/constants.js';\nimport { FP } from '../../../../../util/floating_point.js';\nimport { biasedRange, linearRange } from '../../../../../util/math.js';\nimport { makeCaseCache } from '../../case_cache.js';\n\n// floor(ln(max f32 value)) = 88, so exp(88) will be within range of a f32, but exp(89) will not\n// floor(ln(max f64 value)) = 709, so exp(709) can be handled by the testing framework, but exp(710) will misbehave\nconst f32_inputs = [\n  0, // Returns 1 by definition\n  -89, // Returns subnormal value\n  kValue.f32.negative.min, // Closest to returning 0 as possible\n  ...biasedRange(kValue.f32.negative.max, -88, 100),\n  ...biasedRange(kValue.f32.positive.min, 88, 100),\n  ...linearRange(89, 709, 10), // Overflows f32, but not f64\n];\n\n// floor(ln(max f16 value)) = 11, so exp(11) will be within range of a f16, but exp(12) will not\nconst f16_inputs = [\n  0, // Returns 1 by definition\n  -12, // Returns subnormal value\n  kValue.f16.negative.min, // Closest to returning 0 as possible\n  ...biasedRange(kValue.f16.negative.max, -11, 100),\n  ...biasedRange(kValue.f16.positive.min, 11, 100),\n  ...linearRange(12, 709, 10), // Overflows f16, but not f64\n];\n\nexport const d = makeCaseCache('exp', {\n  f32_const: () => {\n    return FP.f32.generateScalarToIntervalCases(f32_inputs, 'finite', FP.f32.expInterval);\n  },\n  f32_non_const: () => {\n    return FP.f32.generateScalarToIntervalCases(f32_inputs, 'unfiltered', FP.f32.expInterval);\n  },\n  f16_const: () => {\n    return FP.f16.generateScalarToIntervalCases(f16_inputs, 'finite', FP.f16.expInterval);\n  },\n  f16_non_const: () => {\n    return FP.f16.generateScalarToIntervalCases(f16_inputs, 'unfiltered', FP.f16.expInterval);\n  },\n  abstract: () => {\n    // exp has an ulp accuracy, so is only expected to be as accurate as f32\n    return FP.abstract.generateScalarToIntervalCases(f32_inputs, 'finite', FP.f32.expInterval);\n  },\n});\n"],"mappings":";;GAAA,SAASA,MAAM,QAAQ,kCAAkC,CACzD,SAASC,EAAE,QAAQ,uCAAuC,CAC1D,SAASC,WAAW,EAAEC,WAAW,QAAQ,6BAA6B;AACtE,SAASC,aAAa,QAAQ,qBAAqB;;AAEnD;AACA;AACA,MAAMC,UAAU,GAAG;AACjB,CAAC,EAAE;AACH,CAAC,EAAE,EAAE;AACLL,MAAM,CAACM,GAAG,CAACC,QAAQ,CAACC,GAAG,EAAE;AACzB,GAAGN,WAAW,CAACF,MAAM,CAACM,GAAG,CAACC,QAAQ,CAACE,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC;AACjD,GAAGP,WAAW,CAACF,MAAM,CAACM,GAAG,CAACI,QAAQ,CAACF,GAAG,EAAE,EAAE,EAAE,GAAG,CAAC;AAChD,GAAGL,WAAW,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,CAAE;AAAA,CAC9B;;AAED;AACA,MAAMQ,UAAU,GAAG;AACjB,CAAC,EAAE;AACH,CAAC,EAAE,EAAE;AACLX,MAAM,CAACY,GAAG,CAACL,QAAQ,CAACC,GAAG,EAAE;AACzB,GAAGN,WAAW,CAACF,MAAM,CAACY,GAAG,CAACL,QAAQ,CAACE,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC;AACjD,GAAGP,WAAW,CAACF,MAAM,CAACY,GAAG,CAACF,QAAQ,CAACF,GAAG,EAAE,EAAE,EAAE,GAAG,CAAC;AAChD,GAAGL,WAAW,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,CAAE;AAAA,CAC9B;;AAED,OAAO,MAAMU,CAAC,GAAGT,aAAa,CAAC,KAAK,EAAE;EACpCU,SAAS,EAAEA,CAAA,KAAM;IACf,OAAOb,EAAE,CAACK,GAAG,CAACS,6BAA6B,CAACV,UAAU,EAAE,QAAQ,EAAEJ,EAAE,CAACK,GAAG,CAACU,WAAW,CAAC;EACvF,CAAC;EACDC,aAAa,EAAEA,CAAA,KAAM;IACnB,OAAOhB,EAAE,CAACK,GAAG,CAACS,6BAA6B,CAACV,UAAU,EAAE,YAAY,EAAEJ,EAAE,CAACK,GAAG,CAACU,WAAW,CAAC;EAC3F,CAAC;EACDE,SAAS,EAAEA,CAAA,KAAM;IACf,OAAOjB,EAAE,CAACW,GAAG,CAACG,6BAA6B,CAACJ,UAAU,EAAE,QAAQ,EAAEV,EAAE,CAACW,GAAG,CAACI,WAAW,CAAC;EACvF,CAAC;EACDG,aAAa,EAAEA,CAAA,KAAM;IACnB,OAAOlB,EAAE,CAACW,GAAG,CAACG,6BAA6B,CAACJ,UAAU,EAAE,YAAY,EAAEV,EAAE,CAACW,GAAG,CAACI,WAAW,CAAC;EAC3F,CAAC;EACDI,QAAQ,EAAEA,CAAA,KAAM;IACd;IACA,OAAOnB,EAAE,CAACmB,QAAQ,CAACL,6BAA6B,CAACV,UAAU,EAAE,QAAQ,EAAEJ,EAAE,CAACK,GAAG,CAACU,WAAW,CAAC;EAC5F;AACF,CAAC,CAAC"}