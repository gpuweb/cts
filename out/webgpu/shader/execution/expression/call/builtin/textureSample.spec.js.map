{"version":3,"file":"textureSample.spec.js","names":["description","makeTestGroup","isDepthTextureFormat","kDepthStencilFormats","kAllTextureFormats","textureFormatAndDimensionPossiblyCompatible","isTextureFormatPossiblyFilterableAsTextureF32","AllFeaturesMaxLimitsGPUTest","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kSamplePointMethods","kShortAddressModes","kShortAddressModeToAddressMode","doTextureCalls","checkCallResults","createTextureWithRandomDataAndGetTexels","generateSamplePointsCube","kCubeSamplePointMethods","chooseTextureSize","isPotentiallyFilterableAndFillable","skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable","getTextureTypeForTextureViewDimension","generateTextureBuiltinInputs1D","g","test","specURL","desc","params","u","combine","filter","t","format","beginSubcases","fn","samplePoints","modeU","filt","minFilter","skipIfTextureFormatAndDimensionNotCompatible","size","minSize","minBlocks","viewDimension","descriptor","dimension","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","texels","texture","sampler","addressModeU","magFilter","calls","method","derivatives","hashInputs","map","coords","derivativeMult","builtin","coordType","viewDescriptor","textureType","results","res","expectOK","modeV","offset","width","height","mipLevelCount","softwareTexture","addressModeV","mipmapFilter","combineWithParams","baseMipLevel","lodMinClamp","lodMaxClamp","dim","modeW","skipIfTextureFormatAndViewDimensionNotCompatible","isCompatibility","textureBindingViewDimension","addressModeW","skipIfTextureFormatNotSupported","skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler","A","depthOrArrayLayers","arrayIndex","num","type","arrayIndexType","mode","skipIfTextureViewDimensionNotSupported","undefined","L"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSample.spec.ts"],"sourcesContent":["export const description = `\nSamples a texture.\n\n- TODO: test cube maps with more than 1 mip level.\n- TODO: test un-encodable formats.\n\nnote: uniformity validation is covered in src/webgpu/shader/validation/uniformity/uniformity.spec.ts\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport {\n  isDepthTextureFormat,\n  kDepthStencilFormats,\n  kAllTextureFormats,\n  textureFormatAndDimensionPossiblyCompatible,\n  isTextureFormatPossiblyFilterableAsTextureF32,\n} from '../../../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../../../gpu_test.js';\n\nimport {\n  vec2,\n  vec3,\n  TextureCall,\n  generateTextureBuiltinInputs2D,\n  generateTextureBuiltinInputs3D,\n  kSamplePointMethods,\n  kShortAddressModes,\n  kShortAddressModeToAddressMode,\n  doTextureCalls,\n  checkCallResults,\n  createTextureWithRandomDataAndGetTexels,\n  generateSamplePointsCube,\n  kCubeSamplePointMethods,\n  SamplePointMethods,\n  chooseTextureSize,\n  isPotentiallyFilterableAndFillable,\n  skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable,\n  getTextureTypeForTextureViewDimension,\n  vec1,\n  generateTextureBuiltinInputs1D,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('sampled_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_1d<f32>, s: sampler, coords: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => textureFormatAndDimensionPossiblyCompatible('1d', t.format))\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .combine('modeU', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, samplePoints, modeU, filt: minFilter } = t.params;\n    t.skipIfTextureFormatAndDimensionNotCompatible(format, '1d');\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 4, format, viewDimension: '1d' });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: '1d',\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      minFilter,\n      magFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec1>[] = generateTextureBuiltinInputs1D(50, {\n      sampler,\n      method: samplePoints,\n      descriptor,\n      derivatives: true,\n      hashInputs: [format, samplePoints, modeU, minFilter],\n    }).map(({ coords, derivativeMult }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n      };\n    });\n    const viewDescriptor = {};\n    const textureType = 'texture_1d<f32>';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>) -> vec4<f32>\nfn textureSample(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, samplePoints, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const viewDescriptor = {};\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      sampler,\n      method: samplePoints,\n      softwareTexture,\n      derivatives: true,\n      offset,\n      hashInputs: [format, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        offset,\n      };\n    });\n    const textureType = 'texture_2d<f32>';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords,lodClamp')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\ntests textureSample with 2d coordinates and various combinations of\nbaseMipLevel, lodMinClamp, and lodMaxClamp, with an dwithout filtering.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combineWithParams([\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 2 },\n        { baseMipLevel: 0, lodMinClamp: 0.25, lodMaxClamp: 1.75 },\n        { baseMipLevel: 1, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 1, lodMaxClamp: 2 },\n      ])\n  )\n  .fn(async t => {\n    const {\n      format,\n      samplePoints,\n      filt: minFilter,\n      baseMipLevel,\n      lodMaxClamp,\n      lodMinClamp,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const viewDescriptor = {\n      baseMipLevel,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n      lodMinClamp,\n      lodMaxClamp,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      sampler,\n      method: samplePoints,\n      softwareTexture,\n      derivatives: true,\n      hashInputs: [format, samplePoints, minFilter, baseMipLevel, lodMinClamp, lodMaxClamp],\n    }).map(({ coords, derivativeMult, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        offset,\n      };\n    });\n    const textureType = 'texture_2d<f32>';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\nfn textureSample(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, offset: vec3<i32>) -> vec4<f32>\nfn textureSample(t: texture_cube<f32>, s: sampler, coords: vec3<f32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n\n* TODO: test 3d compressed textures formats. Just remove the filter below 'viewDimension'\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('dim', ['3d', 'cube'] as const)\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('modeW', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.dim !== 'cube' || t.offset !== true)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.dim !== '3d')\n  )\n  .fn(async t => {\n    const {\n      format,\n      dim: viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      filt: minFilter,\n      offset,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n    t.skipIfTextureFormatAndViewDimensionNotCompatible(format, viewDimension);\n\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: test derivatives with cubemaps by just always setting this to 3.\n      mipLevelCount: viewDimension === '3d' ? 3 : 1,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      addressModeW: kShortAddressModeToAddressMode[modeW],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const hashInputs = [\n      format,\n      viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      minFilter,\n      offset,\n    ];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            descriptor,\n            derivatives: true,\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            descriptor,\n            derivatives: true,\n            hashInputs,\n          })\n    ).map(({ coords, derivativeMult, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        offset,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>) -> f32\nfn textureSample(t: texture_depth_2d, s: sampler, coords: vec2<f32>, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, samplePoints, modeU, modeV, offset } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      sampler,\n      method: samplePoints,\n      descriptor,\n      derivatives: true,\n      offset,\n      hashInputs: [format, samplePoints, modeU, modeV, offset],\n    }).map(({ coords, derivativeMult, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        offset,\n      };\n    });\n\n    const viewDescriptor = {};\n    const textureType = 'texture_depth_2d';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>\nfn textureSample(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('depthOrArrayLayers', [1, 8] as const)\n  )\n  .fn(async t => {\n    const {\n      format,\n      samplePoints,\n      A,\n      modeU,\n      modeV,\n      filt: minFilter,\n      offset,\n      depthOrArrayLayers,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n      ...(t.isCompatibility && { textureBindingViewDimension: '2d-array' }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      derivatives: true,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      hashInputs: [format, samplePoints, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = 'texture_2d_array<f32>';\n    const viewDescriptor: GPUTextureViewDescriptor = { dimension: '2d-array' };\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSample(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, samplePoints, A, mode, filt: minFilter } = t.params;\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: test derivatives with cubemaps by setting this to 3.\n      mipLevelCount: 1,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      derivatives: true,\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [format, viewDimension, A, samplePoints, mode, minFilter],\n    }).map(({ coords, derivativeMult, arrayIndex }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nfn textureSample(t: texture_depth_cube, s: sampler, coords: vec3<f32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combineWithParams([\n        { viewDimension: 'cube' },\n        { viewDimension: 'cube-array', A: 'i32' },\n        { viewDimension: 'cube-array', A: 'u32' },\n      ] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, viewDimension, samplePoints, A, mode } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfTextureViewDimensionNotSupported(viewDimension);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: test derivatives with cubemaps by setting this to 3.\n      mipLevelCount: 1,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      derivatives: true,\n      arrayIndex: A ? { num: texture.depthOrArrayLayers / 6, type: A } : undefined,\n      hashInputs: [format, viewDimension, samplePoints, mode],\n    }).map(({ coords, derivativeMult, arrayIndex }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A ? (A === 'i32' ? 'i' : 'u') : undefined,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType =\n      viewDimension === 'cube' ? 'texture_depth_cube' : 'texture_depth_cube_array';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A) -> f32\nfn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combine('mode', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('L', ['i32', 'u32'] as const)\n      .combine('depthOrArrayLayers', [1, 8] as const)\n  )\n  .fn(async t => {\n    const { format, samplePoints, mode, A, L, offset, depthOrArrayLayers } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n      ...(t.isCompatibility && { textureBindingViewDimension: '2d-array' }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      derivatives: true,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      hashInputs: [format, samplePoints, mode, L, A, offset],\n    }).map(({ coords, derivativeMult, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = 'texture_depth_2d_array';\n    const viewDescriptor: GPUTextureViewDescriptor = { dimension: '2d-array' };\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesample')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: A) -> f32\n\nParameters:\n * t  The sampled, depth, or external texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, samplePoints, A, mode } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: test derivatives with cubemaps by setting this to 3.\n      mipLevelCount: 1,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      derivatives: true,\n      arrayIndex: A ? { num: texture.depthOrArrayLayers / 6, type: A } : undefined,\n      hashInputs: [format, viewDimension, samplePoints, mode],\n    }).map(({ coords, derivativeMult, arrayIndex }) => {\n      return {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A ? (A === 'i32' ? 'i' : 'u') : undefined,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = 'texture_depth_cube_array';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n"],"mappings":"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"}