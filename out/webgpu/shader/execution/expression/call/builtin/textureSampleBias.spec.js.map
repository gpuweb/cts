{"version":3,"file":"textureSampleBias.spec.js","names":["description","makeTestGroup","isTextureFormatPossiblyFilterableAsTextureF32","kAllTextureFormats","AllFeaturesMaxLimitsGPUTest","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kSamplePointMethods","kShortAddressModes","kShortAddressModeToAddressMode","doTextureCalls","checkCallResults","createTextureWithRandomDataAndGetTexels","generateSamplePointsCube","kCubeSamplePointMethods","chooseTextureSize","isPotentiallyFilterableAndFillable","getTextureTypeForTextureViewDimension","skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable","g","kMinBlocksForTextureSampleBias","test","specURL","desc","params","u","combine","filter","t","format","filt","beginSubcases","fn","samplePoints","modeU","modeV","minFilter","offset","width","height","minSize","minBlocks","descriptor","size","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","mipLevelCount","texels","texture","sampler","addressModeU","addressModeV","magFilter","mipmapFilter","calls","method","bias","hashInputs","map","coords","derivativeMult","builtin","coordType","viewDescriptor","textureType","results","res","expectOK","dim","viewDimension","modeW","skipIfTextureFormatAndViewDimensionNotCompatible","dimension","isCompatibility","textureBindingViewDimension","addressModeW","A","depthOrArrayLayers","arrayIndex","num","type","arrayIndexType","mode","skipIfTextureViewDimensionNotSupported"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSampleBias.spec.ts"],"sourcesContent":["export const description = `\nExecution tests for the 'textureSampleBias' builtin function\n\nSamples a texture with a bias to the mip level.\n\n- TODO: test cube maps with more than one mip level.\n- TODO: Test un-encodable formats.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport {\n  isTextureFormatPossiblyFilterableAsTextureF32,\n  kAllTextureFormats,\n} from '../../../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../../../gpu_test.js';\n\nimport {\n  vec2,\n  vec3,\n  TextureCall,\n  generateTextureBuiltinInputs2D,\n  generateTextureBuiltinInputs3D,\n  kSamplePointMethods,\n  kShortAddressModes,\n  kShortAddressModeToAddressMode,\n  doTextureCalls,\n  checkCallResults,\n  createTextureWithRandomDataAndGetTexels,\n  generateSamplePointsCube,\n  kCubeSamplePointMethods,\n  SamplePointMethods,\n  chooseTextureSize,\n  isPotentiallyFilterableAndFillable,\n  getTextureTypeForTextureViewDimension,\n  skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\n// See comment \"Issues with textureSampleBias\" in texture_utils.ts\n// 3 was chosen because it shows errors on M1 Mac\nconst kMinBlocksForTextureSampleBias = 3;\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nfn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, bias: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, samplePoints, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least something wide enough for 3 mip levels with more than 1 pixel at the smallest level\n    const [width, height] = chooseTextureSize({\n      minSize: 8,\n      minBlocks: kMinBlocksForTextureSampleBias,\n      format,\n    });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      sampler,\n      method: samplePoints,\n      descriptor,\n      bias: true,\n      offset,\n      hashInputs: [format, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, offset, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        bias,\n        offset,\n      };\n    });\n    const viewDescriptor = {};\n    const textureType = 'texture_2d<f32>';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nfn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, bias: f32, offset: vec3<i32>) -> vec4<f32>\nfn textureSampleBias(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('dim', ['3d', 'cube'] as const)\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('modeW', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.dim !== 'cube' || t.offset !== true)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.dim !== '3d')\n  )\n  .fn(async t => {\n    const {\n      format,\n      dim: viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      filt: minFilter,\n      offset,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n    t.skipIfTextureFormatAndViewDimensionNotCompatible(format, viewDimension);\n\n    const size = chooseTextureSize({ minSize: 8, minBlocks: 2, format, viewDimension });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size,\n      // MAINTENANCE_TODO: use 3 for cube maps when derivatives are supported for cube maps.\n      mipLevelCount: viewDimension === '3d' ? 3 : 1,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      addressModeW: kShortAddressModeToAddressMode[modeW],\n      minFilter,\n      magFilter: minFilter,\n    };\n\n    const hashInputs = [\n      format,\n      viewDimension,\n      samplePoints,\n      modeU,\n      modeV,\n      modeW,\n      minFilter,\n      offset,\n    ];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            descriptor,\n            bias: true,\n            offset,\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            descriptor,\n            bias: true,\n            hashInputs,\n          })\n    ).map(({ coords, derivativeMult, offset, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        bias,\n        offset,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('arrayed_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nA: i32, u32\n\nfn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, bias: f32) -> vec4<f32>\nfn textureSampleBias(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, bias: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index to sample.\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, samplePoints, A, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least something wide enough for 3 mip levels with more than 1 pixel at the smallest level\n    const [width, height] = chooseTextureSize({\n      minSize: 8,\n      minBlocks: kMinBlocksForTextureSampleBias,\n      format,\n    });\n    const depthOrArrayLayers = 4;\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      bias: true,\n      offset,\n      hashInputs: [format, samplePoints, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, derivativeMult, arrayIndex, bias, offset }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        bias,\n        offset,\n      };\n    });\n    const textureType = 'texture_2d_array<f32>';\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('arrayed_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplebias')\n  .desc(\n    `\nA: i32, u32\n\nfn textureSampleBias(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: A, bias: f32) -> vec4<f32>\n\nParameters:\n * t: The sampled texture to read from\n * s: The sampler type\n * coords: The texture coordinates\n * array_index: The 0-based texture array index to sample.\n * bias: The bias to apply to the mip level before sampling. bias must be between -16.0 and 15.99.\n * offset:\n    - The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n      This offset is applied before applying any texture wrapping modes.\n    - The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    - Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, samplePoints, A, mode, filt: minFilter } = t.params;\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      // MAINTENANCE_TODO: use 3 for cube maps when derivatives are supported for cube maps.\n      mipLevelCount: 1,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      bias: true,\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [format, viewDimension, A, samplePoints, mode, minFilter],\n    }).map(({ coords, derivativeMult, arrayIndex, bias }) => {\n      return {\n        builtin: 'textureSampleBias',\n        coordType: 'f',\n        coords,\n        derivativeMult,\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        bias,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      'f'\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      'f',\n      texture\n    );\n    t.expectOK(res);\n  });\n"],"mappings":"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"}