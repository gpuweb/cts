{"version":3,"file":"textureSampleLevel.spec.js","names":["description","makeTestGroup","isDepthTextureFormat","isTextureFormatPossiblyFilterableAsTextureF32","kAllTextureFormats","kDepthStencilFormats","AllFeaturesMaxLimitsGPUTest","appendComponentTypeForFormatToTextureType","checkCallResults","chooseTextureSize","createTextureWithRandomDataAndGetTexels","doTextureCalls","generateSamplePointsCube","generateTextureBuiltinInputs1D","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","getDepthOrArrayLayersForViewDimension","getTextureTypeForTextureViewDimension","isPotentiallyFilterableAndFillable","kCubeSamplePointMethods","kSamplePointMethods","kShortAddressModes","kShortAddressModeToAddressMode","kShortShaderStages","skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable","g","test","specURL","desc","params","u","combine","filter","t","format","filt","beginSubcases","fn","stage","samplePoints","modeU","modeV","minFilter","skipIfTextureFormatAndDimensionNotCompatible","width","height","minSize","minBlocks","viewDimension","descriptor","dimension","size","usage","GPUTextureUsage","COPY_DST","TEXTURE_BINDING","viewDescriptor","texels","texture","softwareTexture","sampler","addressModeU","addressModeV","magFilter","mipmapFilter","calls","method","mipLevel","num","mipLevelCount","type","hashInputs","map","coords","builtin","coordType","levelType","textureType","results","res","expectOK","offset","combineWithParams","baseMipLevel","lodMinClamp","lodMaxClamp","A","depthOrArrayLayers","isCompatibility","textureBindingViewDimension","arrayIndex","arrayIndexType","dim","mode","skipIfTextureFormatAndViewDimensionNotCompatible","addressModeW","skipIfTextureViewDimensionNotSupported","L","skipIfTextureFormatNotSupported","skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler","undefined"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/textureSampleLevel.spec.ts"],"sourcesContent":["export const description = `\nSamples a texture.\n\n- TODO: Test un-encodable formats.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport {\n  isDepthTextureFormat,\n  isTextureFormatPossiblyFilterableAsTextureF32,\n  kAllTextureFormats,\n  kDepthStencilFormats,\n} from '../../../../../format_info.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../../../gpu_test.js';\n\nimport {\n  appendComponentTypeForFormatToTextureType,\n  checkCallResults,\n  chooseTextureSize,\n  createTextureWithRandomDataAndGetTexels,\n  doTextureCalls,\n  generateSamplePointsCube,\n  generateTextureBuiltinInputs1D,\n  generateTextureBuiltinInputs2D,\n  generateTextureBuiltinInputs3D,\n  getDepthOrArrayLayersForViewDimension,\n  getTextureTypeForTextureViewDimension,\n  isPotentiallyFilterableAndFillable,\n  kCubeSamplePointMethods,\n  kSamplePointMethods,\n  kShortAddressModes,\n  kShortAddressModeToAddressMode,\n  kShortShaderStages,\n  SamplePointMethods,\n  skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable,\n  TextureCall,\n  vec1,\n  vec2,\n  vec3,\n} from './texture_utils.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\ng.test('sampled_1d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nfn textureSampleLevel(t: texture_1d<f32>, s: sampler, coords: f32, level: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, modeU, modeV, filt: minFilter } = t.params;\n    t.skipIfTextureFormatAndDimensionNotCompatible(format, '1d');\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({\n      minSize: 8,\n      minBlocks: 4,\n      format,\n      viewDimension: '1d',\n    });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: '1d',\n      size: { width, height },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const viewDescriptor = {};\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec1>[] = generateTextureBuiltinInputs1D(50, {\n      method: samplePoints,\n      sampler,\n      softwareTexture,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      hashInputs: [stage, format, samplePoints, modeU, modeV, minFilter],\n    }).map(({ coords, mipLevel }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_1d', format);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nfn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_2d<f32>, s: sampler, coords: vec2<f32>, level: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, modeU, modeV, filt: minFilter, offset } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const viewDescriptor = {};\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      softwareTexture,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      offset,\n      hashInputs: [stage, format, samplePoints, modeU, modeV, minFilter, offset],\n    }).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d', format);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_2d_coords,lodClamp')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\ntests textureSampleLevel with 2d coordinates and various combinations of\nbaseMipLevel, lodMinClamp, and lodMaxClamp, with an dwithout filtering.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combineWithParams([\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 2 },\n        { baseMipLevel: 0, lodMinClamp: 0.25, lodMaxClamp: 1.75 },\n        { baseMipLevel: 1, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 1, lodMaxClamp: 2 },\n      ])\n  )\n  .fn(async t => {\n    const {\n      format,\n      stage,\n      samplePoints,\n      filt: minFilter,\n      baseMipLevel,\n      lodMaxClamp,\n      lodMinClamp,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const viewDescriptor = { baseMipLevel };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n      lodMinClamp,\n      lodMaxClamp,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      softwareTexture,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      hashInputs: [stage, format, samplePoints, minFilter, baseMipLevel, lodMinClamp, lodMaxClamp],\n    }).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d', format);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nC is i32 or u32\n\nfn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_2d_array<f32>, s: sampler, coords: vec2<f32>, array_index: A, level: f32, offset: vec2<i32>) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('modeU', kShortAddressModes)\n      .combine('modeV', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('depthOrArrayLayers', [1, 8] as const)\n  )\n  .fn(async t => {\n    const {\n      format,\n      stage,\n      samplePoints,\n      A,\n      modeU,\n      modeV,\n      filt: minFilter,\n      offset,\n      depthOrArrayLayers,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      ...(t.isCompatibility && { textureBindingViewDimension: '2d-array' }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[modeU],\n      addressModeV: kShortAddressModeToAddressMode[modeV],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      offset,\n      hashInputs: [stage, format, samplePoints, A, modeU, modeV, minFilter, offset],\n    }).map(({ coords, mipLevel, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_2d_array', format);\n    const viewDescriptor: GPUTextureViewDescriptor = { dimension: '2d-array' };\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nfn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>\nfn textureSampleLevel(t: texture_3d<f32>, s: sampler, coords: vec3<f32>, level: f32, offset: vec3<i32>) -> vec4<f32>\nfn textureSampleLevel(t: texture_cube<f32>, s: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('dim', ['3d', 'cube'] as const)\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('mode', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .filter(t => t.dim !== 'cube' || t.offset !== true)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.dim !== '3d')\n  )\n  .fn(async t => {\n    const {\n      format,\n      dim: viewDimension,\n      stage,\n      samplePoints,\n      mode,\n      filt: minFilter,\n      offset,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n    t.skipIfTextureFormatAndViewDimensionNotCompatible(format, viewDimension);\n\n    const [width, height] = chooseTextureSize({ minSize: 32, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n    const hashInputs = [stage, format, viewDimension, samplePoints, mode, minFilter, offset];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            softwareTexture,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            offset,\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            softwareTexture,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            hashInputs,\n          })\n    ).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_3d_coords,lodClamp')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\ntests textureSampleLevel with 3d coordinates and various combinations of\nbaseMipLevel, lodMinClamp, and lodMaxClamp, with an dwithout filtering.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('dim', ['3d', 'cube'] as const)\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .filter(t => t.samplePoints !== 'cube-edges' || t.dim !== '3d')\n      .combineWithParams([\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 2 },\n        { baseMipLevel: 0, lodMinClamp: 0.25, lodMaxClamp: 1.75 },\n        { baseMipLevel: 1, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 0, lodMaxClamp: 1 },\n        { baseMipLevel: 0, lodMinClamp: 1, lodMaxClamp: 2 },\n      ])\n  )\n  .fn(async t => {\n    const {\n      format,\n      dim: viewDimension,\n      stage,\n      samplePoints,\n      filt: minFilter,\n      baseMipLevel,\n      lodMaxClamp,\n      lodMinClamp,\n    } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n    t.skipIfTextureFormatAndViewDimensionNotCompatible(format, viewDimension);\n\n    const [width, height] = chooseTextureSize({ minSize: 32, minBlocks: 2, format, viewDimension });\n    const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      dimension: viewDimension === '3d' ? '3d' : '2d',\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n      size: { width, height, depthOrArrayLayers },\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const viewDescriptor = {\n      dimension: viewDimension,\n      baseMipLevel,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const softwareTexture = { texels, descriptor, viewDescriptor };\n    const sampler: GPUSamplerDescriptor = {\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n      lodMinClamp,\n      lodMaxClamp,\n    };\n    const hashInputs = [\n      stage,\n      format,\n      viewDimension,\n      samplePoints,\n      minFilter,\n      baseMipLevel,\n      lodMinClamp,\n      lodMaxClamp,\n    ];\n    const calls: TextureCall<vec3>[] = (\n      viewDimension === '3d'\n        ? generateTextureBuiltinInputs3D(50, {\n            method: samplePoints as SamplePointMethods,\n            sampler,\n            softwareTexture,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            hashInputs,\n          })\n        : generateSamplePointsCube(50, {\n            method: samplePoints,\n            sampler,\n            softwareTexture,\n            mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n            hashInputs,\n          })\n    ).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        offset,\n      };\n    });\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('sampled_array_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nA is i32 or u32\n\nfn textureSampleLevel(t: texture_cube_array<f32>, s: sampler, coords: vec3<f32>, array_index: A, level: f32) -> vec4<f32>\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * array_index The 0-based texture array index to sample.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n\n- TODO: set mipLevelCount to 3 for cubemaps. See MAINTENANCE_TODO below\n\n  The issue is sampling a corner of a cubemap is undefined. We try to quantize coordinates\n  so we never get a corner but when sampling smaller mip levels that's more difficult.\n\n  * Solution 1: Fix the quantization\n  * Solution 2: special case checking cube corners. Expect some value between the color of the 3 corner texels.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kAllTextureFormats)\n      .filter(t => isPotentiallyFilterableAndFillable(t.format))\n      .combine('filt', ['nearest', 'linear'] as const)\n      .filter(t => t.filt === 'nearest' || isTextureFormatPossiblyFilterableAsTextureF32(t.format))\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, A, mode, filt: minFilter } = t.params;\n    skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable(t, minFilter, format);\n    t.skipIfTextureViewDimensionNotSupported('cube-array');\n\n    const viewDimension: GPUTextureViewDimension = 'cube-array';\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n      minFilter,\n      magFilter: minFilter,\n      mipmapFilter: minFilter,\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: 'f32' },\n      arrayIndex: { num: texture.depthOrArrayLayers / 6, type: A },\n      hashInputs: [stage, format, viewDimension, A, samplePoints, mode, minFilter],\n    }).map(({ coords, mipLevel, arrayIndex }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: 'f',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType = getTextureTypeForTextureViewDimension(viewDimension);\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nL is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2<f32>, level: L, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combine('mode', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('L', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, mode, L, offset } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount, type: L },\n      offset,\n      hashInputs: [stage, format, samplePoints, mode, L, offset],\n    }).map(({ coords, mipLevel, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_depth_2d', format);\n    const viewDescriptor = {};\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_array_2d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nA is i32 or u32\nL is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2<f32>, array_index: A, level: L, offset: vec2<i32>) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * array_index The 0-based texture array index to sample.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combine('mode', kShortAddressModes)\n      .combine('offset', [false, true] as const)\n      .beginSubcases()\n      .combine('samplePoints', kSamplePointMethods)\n      .combine('A', ['i32', 'u32'] as const)\n      .combine('L', ['i32', 'u32'] as const)\n      .combine('depthOrArrayLayers', [1, 8] as const)\n  )\n  .fn(async t => {\n    const { format, stage, samplePoints, mode, A, L, offset, depthOrArrayLayers } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n\n    // We want at least 4 blocks or something wide enough for 3 mip levels.\n    const [width, height] = chooseTextureSize({ minSize: 8, minBlocks: 4, format });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size: { width, height, depthOrArrayLayers },\n      mipLevelCount: 3,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      ...(t.isCompatibility && { textureBindingViewDimension: '2d-array' }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec2>[] = generateTextureBuiltinInputs2D(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      arrayIndex: { num: texture.depthOrArrayLayers, type: A },\n      mipLevel: { num: texture.mipLevelCount, type: L },\n      offset,\n      hashInputs: [stage, format, samplePoints, mode, L, A, offset],\n    }).map(({ coords, mipLevel, arrayIndex, offset }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        arrayIndex,\n        arrayIndexType: A === 'i32' ? 'i' : 'u',\n        offset,\n      };\n    });\n    const textureType = appendComponentTypeForFormatToTextureType('texture_depth_2d_array', format);\n    const viewDescriptor: GPUTextureViewDescriptor = { dimension: '2d-array' };\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n\ng.test('depth_3d_coords')\n  .specURL('https://www.w3.org/TR/WGSL/#texturesamplelevel')\n  .desc(\n    `\nL is i32 or u32\nA is i32 or u32\n\nfn textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3<f32>, level: L) -> f32\nfn textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3<f32>, array_index: A, level: L) -> f32\n\nParameters:\n * t  The sampled or depth texture to sample.\n * s  The sampler type.\n * coords The texture coordinates used for sampling.\n * level\n    * The mip level, with level 0 containing a full size version of the texture.\n    * For the functions where level is a f32, fractional values may interpolate between\n      two levels if the format is filterable according to the Texture Format Capabilities.\n    * When not specified, mip level 0 is sampled.\n * offset\n    * The optional texel offset applied to the unnormalized texture coordinate before sampling the texture.\n    * This offset is applied before applying any texture wrapping modes.\n    * The offset expression must be a creation-time expression (e.g. vec2<i32>(1, 2)).\n    * Each offset component must be at least -8 and at most 7.\n      Values outside of this range will result in a shader-creation error.\n`\n  )\n  .params(u =>\n    u\n      .combine('stage', kShortShaderStages)\n      .combine('format', kDepthStencilFormats)\n      // filter out stencil only formats\n      .filter(t => isDepthTextureFormat(t.format))\n      .combineWithParams([\n        { viewDimension: 'cube' },\n        { viewDimension: 'cube-array', A: 'i32' },\n        { viewDimension: 'cube-array', A: 'u32' },\n      ] as const)\n      .combine('mode', kShortAddressModes)\n      .beginSubcases()\n      .combine('samplePoints', kCubeSamplePointMethods)\n      .combine('L', ['i32', 'u32'] as const)\n  )\n  .fn(async t => {\n    const { format, stage, viewDimension, samplePoints, A, L, mode } = t.params;\n    t.skipIfTextureFormatNotSupported(format);\n    t.skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler();\n    t.skipIfTextureViewDimensionNotSupported(viewDimension);\n\n    const size = chooseTextureSize({\n      minSize: 32,\n      minBlocks: 4,\n      format,\n      viewDimension,\n    });\n    const descriptor: GPUTextureDescriptor = {\n      format,\n      size,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n      mipLevelCount: 3,\n      ...(t.isCompatibility && { textureBindingViewDimension: viewDimension }),\n    };\n    const { texels, texture } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n    const sampler: GPUSamplerDescriptor = {\n      addressModeU: kShortAddressModeToAddressMode[mode],\n      addressModeV: kShortAddressModeToAddressMode[mode],\n      addressModeW: kShortAddressModeToAddressMode[mode],\n    };\n\n    const calls: TextureCall<vec3>[] = generateSamplePointsCube(50, {\n      method: samplePoints,\n      sampler,\n      descriptor,\n      mipLevel: { num: texture.mipLevelCount - 1, type: L },\n      arrayIndex: A ? { num: texture.depthOrArrayLayers / 6, type: A } : undefined,\n      hashInputs: [stage, format, viewDimension, samplePoints, mode],\n    }).map(({ coords, mipLevel, arrayIndex }) => {\n      return {\n        builtin: 'textureSampleLevel',\n        coordType: 'f',\n        coords,\n        mipLevel,\n        levelType: L === 'i32' ? 'i' : 'u',\n        arrayIndex,\n        arrayIndexType: A ? (A === 'i32' ? 'i' : 'u') : undefined,\n      };\n    });\n    const viewDescriptor = {\n      dimension: viewDimension,\n    };\n    const textureType =\n      viewDimension === 'cube' ? 'texture_depth_cube' : 'texture_depth_cube_array';\n    const results = await doTextureCalls(\n      t,\n      texture,\n      viewDescriptor,\n      textureType,\n      sampler,\n      calls,\n      stage\n    );\n\n    const res = await checkCallResults(\n      t,\n      { texels, descriptor, viewDescriptor },\n      textureType,\n      sampler,\n      calls,\n      results,\n      stage,\n      texture\n    );\n    t.expectOK(res);\n  });\n"],"mappings":"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"}