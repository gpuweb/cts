{"version":3,"file":"subgroupAll.spec.js","names":["description","makeTestGroup","keysOf","iterRange","kTextureFormatInfo","align","PRNG","kWGSizes","kPredicateCases","SubgroupTest","kDataSentinel","kFramebufferSizes","runComputeTest","runFragmentTest","g","kNumCases","generateInputData","seed","num","prng","bound","Math","min","index","uniformInt","Uint32Array","x","bounded","checkAll","metadata","output","numInvs","input","filter","expected","Map","inv","size","id","subgroup_id","v","get","set","res","expected_v","Error","undefined","test","desc","params","u","combine","beginSubcases","beforeAllSubcases","t","selectDeviceOrSkipTestCase","fn","wgThreads","wgSize","wgsl","inputData","case","uintsPerOutput","testcase","predicate","cond","checkFragmentAll","data","format","width","height","blockWidth","blockHeight","bytesPerBlock","blocksPerRow","bytesPerRow","uintsPerRow","uintsPerTexel","row","col","offset","combineWithParams","numInputs","fsShader","unimplemented"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/subgroupAll.spec.ts"],"sourcesContent":["export const description = `\nExecution tests for subgroupAll.\n\nNote: There is a lack of portability for non-uniform execution so these tests\nrestrict themselves to uniform control flow.\nNote: There is no guaranteed mapping between subgroup_invocation_id and\nlocal_invocation_index. Tests should avoid assuming there is.\n`;\n\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../common/util/data_tables.js';\nimport { iterRange } from '../../../../../../common/util/util.js';\nimport { kTextureFormatInfo } from '../../../../../format_info.js';\nimport { align } from '../../../../../util/math.js';\nimport { PRNG } from '../../../../../util/prng.js';\n\nimport {\n  kWGSizes,\n  kPredicateCases,\n  SubgroupTest,\n  kDataSentinel,\n  kFramebufferSizes,\n  runComputeTest,\n  runFragmentTest,\n} from './subgroup_util.js';\n\nexport const g = makeTestGroup(SubgroupTest);\n\nconst kNumCases = 15;\n\n/**\n * Generate input data for testing.\n *\n * Data is generated in the following categories:\n * Seed 0 generates all 0 data\n * Seed 1 generates all 1 data\n * Seeds 2-9 generates all 1s except for a zero randomly once per 32 elements\n * Seeds 10+ generate all random data\n * @param seed The seed for the PRNG\n * @param num The number of data items to generate\n */\nfunction generateInputData(seed: number, num: number): Uint32Array {\n  const prng = new PRNG(seed);\n\n  const bound = Math.min(num, 32);\n  const index = prng.uniformInt(bound);\n\n  return new Uint32Array([\n    ...iterRange(num, x => {\n      if (seed === 0) {\n        return 0;\n      } else if (seed === 1) {\n        return 1;\n      } else if (seed < 10) {\n        const bounded = x % bound;\n        return bounded === index ? 0 : 1;\n      }\n      return prng.uniformInt(2);\n    }),\n  ]);\n}\n\n/**\n * Checks the result of a subgroupAll operation\n *\n * Since subgroup size depends on the pipeline compile, we calculate the expected\n * results after execution. The shader generates a subgroup id and records it for\n * each invocation. The check first calculates the expected result for each subgroup\n * and then compares to the actual result for each invocation. The filter functor\n * ensures only the correct invocations contribute to the calculation.\n * @param metadata An array of uints:\n *                 * first half containing subgroup sizes (from builtin value)\n *                 * second half subgroup invocation id\n * @param output An array of uints containing:\n *               * first half is the outputs of subgroupAll\n *               * second half is a generated subgroup id\n * @param numInvs Number of invocations executed\n * @param input The input data (equal size to output)\n * @param filter A functor to filter active invocations\n */\nfunction checkAll(\n  metadata: Uint32Array, // unused\n  output: Uint32Array,\n  numInvs: number,\n  input: Uint32Array,\n  filter: (id: number, size: number) => boolean\n): Error | undefined {\n  // First, generate expected results.\n  const expected = new Map<number, number>();\n  for (let inv = 0; inv < numInvs; inv++) {\n    const size = metadata[inv];\n    const id = metadata[inv + numInvs];\n    if (!filter(id, size)) {\n      continue;\n    }\n    const subgroup_id = output[numInvs + inv];\n    let v = expected.get(subgroup_id) ?? 1;\n    v &= input[inv];\n    expected.set(subgroup_id, v);\n  }\n\n  // Second, check against actual results.\n  for (let inv = 0; inv < numInvs; inv++) {\n    const size = metadata[inv];\n    const id = metadata[inv + numInvs];\n    const res = output[inv];\n    if (filter(id, size)) {\n      const subgroup_id = output[numInvs + inv];\n      const expected_v = expected.get(subgroup_id) ?? 0;\n      if (expected_v !== res) {\n        return new Error(`Invocation ${inv}:\n- expected: ${expected_v}\n-      got: ${res}`);\n      }\n    } else {\n      if (res !== kDataSentinel) {\n        return new Error(`Invocation ${inv} unexpected write:\n- subgroup invocation id: ${id}\n-          subgroup size: ${size}`);\n      }\n    }\n  }\n\n  return undefined;\n}\n\ng.test('compute,all_active')\n  .desc(`Test compute subgroupAll`)\n  .params(u =>\n    u\n      .combine('wgSize', kWGSizes)\n      .beginSubcases()\n      .combine('case', [...iterRange(kNumCases, x => x)])\n  )\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('subgroups' as GPUFeatureName);\n  })\n  .fn(async t => {\n    const wgThreads = t.params.wgSize[0] * t.params.wgSize[1] * t.params.wgSize[2];\n\n    const wgsl = `\nenable subgroups;\n\n@group(0) @binding(0)\nvar<storage> inputs : array<u32>;\n\n@group(0) @binding(1)\nvar<storage, read_write> outputs : array<u32>;\n\nstruct Metadata {\n  subgroup_size: array<u32, ${wgThreads}>,\n  subgroup_invocation_id: array<u32, ${wgThreads}>,\n}\n\n@group(0) @binding(2)\nvar<storage, read_write> metadata : Metadata;\n\n@compute @workgroup_size(${t.params.wgSize[0]}, ${t.params.wgSize[1]}, ${t.params.wgSize[2]})\nfn main(\n  @builtin(local_invocation_index) lid : u32,\n  @builtin(subgroup_invocation_id) id : u32,\n  @builtin(subgroup_size) subgroupSize : u32,\n) {\n  metadata.subgroup_size[lid] = subgroupSize;\n\n  metadata.subgroup_invocation_id[lid] = id;\n\n  // Record a representative subgroup id.\n  outputs[lid + ${wgThreads}] = subgroupBroadcastFirst(lid);\n\n  let res = select(0u, 1u, subgroupAll(bool(inputs[lid])));\n  outputs[lid] = res;\n}`;\n\n    const inputData = generateInputData(t.params.case, wgThreads);\n\n    const uintsPerOutput = 2;\n    await runComputeTest(\n      t,\n      wgsl,\n      [t.params.wgSize[0], t.params.wgSize[1], t.params.wgSize[2]],\n      uintsPerOutput,\n      inputData,\n      (metadata: Uint32Array, output: Uint32Array) => {\n        return checkAll(metadata, output, wgThreads, inputData, (id: number, size: number) => {\n          return true;\n        });\n      }\n    );\n  });\n\ng.test('compute,split')\n  .desc('Test that only active invocation participate')\n  .params(u =>\n    u\n      .combine('predicate', keysOf(kPredicateCases))\n      .beginSubcases()\n      .combine('wgSize', kWGSizes)\n      .combine('case', [...iterRange(kNumCases, x => x)])\n  )\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('subgroups' as GPUFeatureName);\n  })\n  .fn(async t => {\n    const testcase = kPredicateCases[t.params.predicate];\n    const wgThreads = t.params.wgSize[0] * t.params.wgSize[1] * t.params.wgSize[2];\n\n    const wgsl = `\nenable subgroups;\n\n@group(0) @binding(0)\nvar<storage> inputs : array<u32>;\n\n@group(0) @binding(1)\nvar<storage, read_write> outputs : array<u32>;\n\nstruct Metadata {\n  subgroup_size : array<u32, ${wgThreads}>,\n  subgroup_invocation_id : array<u32, ${wgThreads}>,\n}\n\n@group(0) @binding(2)\nvar<storage, read_write> metadata : Metadata;\n\n@compute @workgroup_size(${t.params.wgSize[0]}, ${t.params.wgSize[1]}, ${t.params.wgSize[2]})\nfn main(\n  @builtin(local_invocation_index) lid : u32,\n  @builtin(subgroup_invocation_id) id : u32,\n  @builtin(subgroup_size) subgroupSize : u32,\n) {\n  metadata.subgroup_size[lid] = subgroupSize;\n\n  // Record subgroup invocation id for this invocation.\n  metadata.subgroup_invocation_id[lid] = id;\n\n  // Record a generated subgroup id.\n  outputs[${wgThreads} + lid] = subgroupBroadcastFirst(lid);\n\n  if ${testcase.cond} {\n    outputs[lid] = select(0u, 1u, subgroupAll(bool(inputs[lid])));\n  } else {\n    return;\n  }\n}`;\n\n    const inputData = generateInputData(t.params.case, wgThreads);\n\n    const uintsPerOutput = 2;\n    await runComputeTest(\n      t,\n      wgsl,\n      [t.params.wgSize[0], t.params.wgSize[1], t.params.wgSize[2]],\n      uintsPerOutput,\n      inputData,\n      (metadata: Uint32Array, output: Uint32Array) => {\n        return checkAll(metadata, output, wgThreads, inputData, testcase.filter);\n      }\n    );\n  });\n\n/**\n * Checks subgroupAll results from a fragment shader.\n *\n * @param data Framebuffer output\n *             * component 0 is result\n *             * component 1 is generated subgroup id\n * @param input An array of input data\n * @param format The framebuffer format\n * @param width Framebuffer width\n * @param height Framebuffer height\n */\nfunction checkFragmentAll(\n  data: Uint32Array,\n  input: Uint32Array,\n  format: GPUTextureFormat,\n  width: number,\n  height: number\n): Error | undefined {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  const blocksPerRow = width / blockWidth;\n  // 256 minimum comes from image copy requirements.\n  const bytesPerRow = align(blocksPerRow * (bytesPerBlock ?? 1), 256);\n  const uintsPerRow = bytesPerRow / 4;\n  const uintsPerTexel = (bytesPerBlock ?? 1) / blockWidth / blockHeight / 4;\n\n  // Iteration skips last row and column to avoid helper invocations because it is not\n  // guaranteed whether or not they participate in the subgroup operation.\n  const expected = new Map<number, number>();\n  for (let row = 0; row < height - 1; row++) {\n    for (let col = 0; col < width - 1; col++) {\n      const offset = uintsPerRow * row + col * uintsPerTexel;\n      const subgroup_id = data[offset + 1];\n\n      if (subgroup_id === 0) {\n        return new Error(`Internal error: helper invocation at (${col}, ${row})`);\n      }\n\n      let v = expected.get(subgroup_id) ?? 1;\n      // First index of input is an atomic counter.\n      v &= input[row * width + col];\n      expected.set(subgroup_id, v);\n    }\n  }\n\n  for (let row = 0; row < height - 1; row++) {\n    for (let col = 0; col < width - 1; col++) {\n      const offset = uintsPerRow * row + col * uintsPerTexel;\n      const res = data[offset];\n      const subgroup_id = data[offset + 1];\n\n      if (subgroup_id === 0) {\n        // Inactive in the fragment.\n        continue;\n      }\n\n      const expected_v = expected.get(subgroup_id) ?? 0;\n      if (expected_v !== res) {\n        return new Error(`Row ${row}, col ${col}: incorrect results:\n- expected: ${expected_v}\n-      got: ${res}`);\n      }\n    }\n  }\n\n  return undefined;\n}\n\ng.test('fragment,all_active')\n  .desc('Tests subgroupAll in fragment shaders')\n  .params(u =>\n    u\n      .combine('size', kFramebufferSizes)\n      .beginSubcases()\n      .combine('case', [...iterRange(kNumCases, x => x)])\n      .combineWithParams([{ format: 'rg32uint' }] as const)\n  )\n  .beforeAllSubcases(t => {\n    t.selectDeviceOrSkipTestCase('subgroups' as GPUFeatureName);\n  })\n  .fn(async t => {\n    const numInputs = t.params.size[0] * t.params.size[1];\n    const inputData = generateInputData(t.params.case, numInputs);\n\n    const fsShader = `\nenable subgroups;\n\n@group(0) @binding(0)\nvar<storage, read_write> inputs : array<u32>;\n\n@fragment\nfn main(\n  @builtin(position) pos : vec4f,\n) -> @location(0) vec2u {\n  // Generate a subgroup id based on linearized position, but avoid 0.\n  let linear = u32(pos.x) + u32(pos.y) * ${t.params.size[0]};\n  var subgroup_id = linear + 1;\n  subgroup_id = subgroupBroadcastFirst(subgroup_id);\n\n  // Filter out possible helper invocations.\n  let x_in_range = u32(pos.x) < (${t.params.size[0]} - 1);\n  let y_in_range = u32(pos.y) < (${t.params.size[1]} - 1);\n  let in_range = x_in_range && y_in_range;\n  let input = select(1u, inputs[linear], in_range);\n\n  let res = select(0u, 1u, subgroupAll(bool(input)));\n  return vec2u(res, subgroup_id);\n}`;\n\n    await runFragmentTest(\n      t,\n      t.params.format,\n      fsShader,\n      t.params.size[0],\n      t.params.size[1],\n      inputData,\n      (data: Uint32Array) => {\n        return checkFragmentAll(\n          data,\n          inputData,\n          t.params.format,\n          t.params.size[0],\n          t.params.size[1]\n        );\n      }\n    );\n  });\n\n// Using subgroup operations in control with fragment shaders\n// quickly leads to unportable behavior.\ng.test('fragment,split').unimplemented();\n"],"mappings":"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"}