{"version":3,"file":"atomicExchange.spec.js","names":["description","makeTestGroup","keysOf","GPUTest","checkElementsEqual","dispatchSizes","workgroupSizes","typedArrayCtor","kMapId","g","test","specURL","desc","params","u","combine","fn","t","numInvocations","workgroupSize","dispatchSize","bufferNumElements","scalarType","mapId","extra","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","arrayType","inputBuffer","createBufferTracked","size","BYTES_PER_ELEMENT","usage","GPUBufferUsage","STORAGE","COPY_SRC","mappedAtCreation","data","getMappedRange","forEach","_","i","unmap","outputBuffer","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","outputExpected","expectGPUBufferValuesEqual","inputExpected","f","wgNumElements","wgCopyBuffer","wgCopyBufferExpected","inputBufferResult","readGPUBufferRangeTyped","type","typedLength","outputBufferResult","values","expected","length","sort","expectOK","wgCopyBufferResult","d","dispatchOffset","subarray"],"sources":["../../../../../../../../src/webgpu/shader/execution/expression/call/builtin/atomics/atomicExchange.spec.ts"],"sourcesContent":["export const description = `\nAtomically stores the value v in the atomic object pointed to atomic_ptr and returns the original value stored in the atomic object.\n`;\n\nimport { makeTestGroup } from '../../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../../common/util/data_tables.js';\nimport { GPUTest } from '../../../../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../../../../util/check_contents.js';\n\nimport { dispatchSizes, workgroupSizes, typedArrayCtor, kMapId } from './harness.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('exchange_storage_basic')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-rmw')\n  .desc(\n    `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T\n`\n  )\n  .params(u =>\n    u\n      .combine('workgroupSize', workgroupSizes)\n      .combine('dispatchSize', dispatchSizes)\n      .combine('mapId', keysOf(kMapId))\n      .combine('scalarType', ['u32', 'i32'] as const)\n  )\n  .fn(t => {\n    const numInvocations = t.params.workgroupSize * t.params.dispatchSize;\n    const bufferNumElements = numInvocations;\n    const scalarType = t.params.scalarType;\n    const mapId = kMapId[t.params.mapId];\n    const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n    const wgsl =\n      `\n      @group(0) @binding(0)\n      var<storage, read_write> input : array<atomic<${scalarType}>>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> output : array<${scalarType}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n          ) {\n        let id = ${scalarType}(global_invocation_id[0]);\n\n        output[id] = atomicExchange(&input[id], map_id(id * 2));\n      }\n    ` + extra;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({ code: wgsl }),\n        entryPoint: 'main',\n      },\n    });\n\n    const arrayType = typedArrayCtor(scalarType);\n\n    // Create input buffer with values [0..n]\n    const inputBuffer = t.createBufferTracked({\n      size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      mappedAtCreation: true,\n    });\n    const data = new arrayType(inputBuffer.getMappedRange());\n    data.forEach((_, i) => (data[i] = i));\n    inputBuffer.unmap();\n\n    const outputBuffer = t.createBufferTracked({\n      size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: inputBuffer } },\n        { binding: 1, resource: { buffer: outputBuffer } },\n      ],\n    });\n\n    // Run the shader.\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(t.params.dispatchSize);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // Output buffer should be the same as the initial input buffer as it contains\n    // values returned from atomicExchange\n    const outputExpected = new (typedArrayCtor(t.params.scalarType))(bufferNumElements);\n    outputExpected.forEach((_, i) => (outputExpected[i] = i));\n    t.expectGPUBufferValuesEqual(outputBuffer, outputExpected);\n\n    // And the input buffer should have been modified to a computed value\n    const inputExpected = new (typedArrayCtor(t.params.scalarType))(bufferNumElements);\n    inputExpected.forEach((_, i) => (inputExpected[i] = mapId.f(i * 2, numInvocations)));\n    t.expectGPUBufferValuesEqual(inputBuffer, inputExpected);\n  });\n\ng.test('exchange_workgroup_basic')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-load')\n  .desc(\n    `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T\n\n`\n  )\n  .params(u =>\n    u\n      .combine('workgroupSize', workgroupSizes)\n      .combine('dispatchSize', dispatchSizes)\n      .combine('mapId', keysOf(kMapId))\n      .combine('scalarType', ['u32', 'i32'] as const)\n  )\n  .fn(t => {\n    const numInvocations = t.params.workgroupSize;\n    const wgNumElements = numInvocations;\n    const scalarType = t.params.scalarType;\n    const dispatchSize = t.params.dispatchSize;\n    const mapId = kMapId[t.params.mapId];\n    const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n    const wgsl =\n      `\n      var<workgroup> wg: array<atomic<${scalarType}>, ${wgNumElements}>;\n\n      // Result of each workgroup is written to output[workgroup_id.x]\n      @group(0) @binding(0)\n      var<storage, read_write> output: array<${scalarType}, ${wgNumElements * dispatchSize}>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> wg_copy: array<${scalarType}, ${wgNumElements * dispatchSize}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(local_invocation_index) local_invocation_index: u32,\n          @builtin(workgroup_id) workgroup_id : vec3<u32>\n          ) {\n        let id = ${scalarType}(local_invocation_index);\n        let global_id = ${scalarType}(workgroup_id.x * ${wgNumElements} + local_invocation_index);\n\n        // Initialize wg[id] with this invocations global id\n        atomicStore(&wg[id], global_id);\n        workgroupBarrier();\n\n        // Test atomicExchange, storing old value into output\n        output[global_id] = atomicExchange(&wg[id], map_id(global_id * 2));\n\n        // Copy new value into wg_copy\n        wg_copy[global_id] = atomicLoad(&wg[id]);\n      }\n      ` + extra;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({ code: wgsl }),\n        entryPoint: 'main',\n      },\n    });\n\n    const arrayType = typedArrayCtor(scalarType);\n\n    const outputBuffer = t.createBufferTracked({\n      size: wgNumElements * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const wgCopyBuffer = t.createBufferTracked({\n      size: wgNumElements * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: outputBuffer } },\n        { binding: 1, resource: { buffer: wgCopyBuffer } },\n      ],\n    });\n\n    // Run the shader.\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(dispatchSize);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // Output buffer should be the same as the initial wg buffer as it contains\n    // values returned from atomicExchange\n    const outputExpected = new (typedArrayCtor(t.params.scalarType))(wgNumElements * dispatchSize);\n    outputExpected.forEach((_, i) => (outputExpected[i] = i));\n    t.expectGPUBufferValuesEqual(outputBuffer, outputExpected);\n\n    // And the wg copy buffer should have been modified to a computed value\n    const wgCopyBufferExpected = new (typedArrayCtor(t.params.scalarType))(\n      wgNumElements * dispatchSize\n    );\n    wgCopyBufferExpected.forEach(\n      (_, i) => (wgCopyBufferExpected[i] = mapId.f(i * 2, numInvocations))\n    );\n    t.expectGPUBufferValuesEqual(wgCopyBuffer, wgCopyBufferExpected);\n  });\n\ng.test('exchange_storage_advanced')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-rmw')\n  .desc(\n    `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicExchange(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T\n`\n  )\n  .params(u =>\n    u\n      .combine('workgroupSize', workgroupSizes)\n      .combine('dispatchSize', dispatchSizes)\n      .combine('mapId', keysOf(kMapId))\n      .combine('scalarType', ['u32', 'i32'] as const)\n  )\n  .fn(async t => {\n    const numInvocations = t.params.workgroupSize * t.params.dispatchSize;\n    const bufferNumElements = numInvocations;\n    const scalarType = t.params.scalarType;\n    const mapId = kMapId[t.params.mapId];\n    const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n    const wgsl =\n      `\n      @group(0) @binding(0)\n      var<storage, read_write> input : atomic<${scalarType}>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> output : array<${scalarType}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n          ) {\n        let id = ${scalarType}(global_invocation_id[0]);\n\n        // All invocations exchange with same single memory address, and we store\n        // the old value at the current invocation's location in the output buffer.\n        output[id] = atomicExchange(&input, map_id(id));\n      }\n    ` + extra;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({ code: wgsl }),\n        entryPoint: 'main',\n      },\n    });\n\n    const arrayType = typedArrayCtor(scalarType);\n\n    // Create input buffer of size 1 with initial value 0\n    const inputBuffer = t.createBufferTracked({\n      size: 1 * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputBuffer = t.createBufferTracked({\n      size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: inputBuffer } },\n        { binding: 1, resource: { buffer: outputBuffer } },\n      ],\n    });\n\n    // Run the shader.\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(t.params.dispatchSize);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // Read back buffers\n    const inputBufferResult = await t.readGPUBufferRangeTyped(inputBuffer, {\n      type: arrayType,\n      typedLength: inputBuffer.size / arrayType.BYTES_PER_ELEMENT,\n    });\n    const outputBufferResult = await t.readGPUBufferRangeTyped(outputBuffer, {\n      type: arrayType,\n      typedLength: outputBuffer.size / arrayType.BYTES_PER_ELEMENT,\n    });\n\n    // The one value in the input buffer plus all values in the output buffer\n    // should contain initial value 0 plus map_id(0..n), unsorted.\n    const values = new arrayType([...inputBufferResult.data, ...outputBufferResult.data]);\n\n    const expected = new arrayType(values.length);\n    expected.forEach((_, i) => {\n      if (i === 0) {\n        expected[0] = 0;\n      } else {\n        expected[i] = mapId.f(i - 1, numInvocations);\n      }\n    });\n\n    // Sort both arrays and compare\n    values.sort();\n    expected.sort(); // Sort because we store hashed results when mapId == 'remap'\n    t.expectOK(checkElementsEqual(values, expected));\n  });\n\ng.test('exchange_workgroup_advanced')\n  .specURL('https://www.w3.org/TR/WGSL/#atomic-load')\n  .desc(\n    `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicLoad(atomic_ptr: ptr<AS, atomic<T>, read_write>) -> T\n\n`\n  )\n  .params(u =>\n    u\n      .combine('workgroupSize', workgroupSizes)\n      .combine('dispatchSize', dispatchSizes)\n      .combine('mapId', keysOf(kMapId))\n      .combine('scalarType', ['u32', 'i32'] as const)\n  )\n  .fn(async t => {\n    const numInvocations = t.params.workgroupSize;\n    const scalarType = t.params.scalarType;\n    const dispatchSize = t.params.dispatchSize;\n    const mapId = kMapId[t.params.mapId];\n    const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n    const wgsl =\n      `\n      var<workgroup> wg: atomic<${scalarType}>;\n\n      // Will contain the atomicExchange result for each invocation at global index\n      @group(0) @binding(0)\n      var<storage, read_write> output: array<${scalarType}, ${numInvocations * dispatchSize}>;\n\n      // Will contain the final value in wg in wg_copy for this dispatch\n      @group(0) @binding(1)\n      var<storage, read_write> wg_copy: array<${scalarType}, ${dispatchSize}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(local_invocation_index) local_invocation_index: u32,\n          @builtin(workgroup_id) workgroup_id : vec3<u32>\n          ) {\n        let id = ${scalarType}(local_invocation_index);\n        let global_id = ${scalarType}(workgroup_id.x * ${numInvocations} + local_invocation_index);\n\n        // All invocations exchange with same single memory address, and we store\n        // the old value at the current invocation's location in the output buffer.\n        output[global_id] = atomicExchange(&wg, map_id(id));\n\n        // Once all invocations have completed, the first one copies the final exchanged value\n        // to wg_copy for this dispatch (workgroup_id.x)\n        workgroupBarrier();\n        if (local_invocation_index == 0u) {\n          wg_copy[workgroup_id.x] = atomicLoad(&wg);\n        }\n      }\n      ` + extra;\n\n    const pipeline = t.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({ code: wgsl }),\n        entryPoint: 'main',\n      },\n    });\n\n    const arrayType = typedArrayCtor(scalarType);\n\n    const outputBuffer = t.createBufferTracked({\n      size: numInvocations * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const wgCopyBuffer = t.createBufferTracked({\n      size: dispatchSize * arrayType.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: outputBuffer } },\n        { binding: 1, resource: { buffer: wgCopyBuffer } },\n      ],\n    });\n\n    // Run the shader.\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(dispatchSize);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n\n    // Read back buffers\n    const outputBufferResult = await t.readGPUBufferRangeTyped(outputBuffer, {\n      type: arrayType,\n      typedLength: outputBuffer.size / arrayType.BYTES_PER_ELEMENT,\n    });\n    const wgCopyBufferResult = await t.readGPUBufferRangeTyped(wgCopyBuffer, {\n      type: arrayType,\n      typedLength: wgCopyBuffer.size / arrayType.BYTES_PER_ELEMENT,\n    });\n\n    // For each dispatch, the one value in wgCopyBuffer plus all values in the output buffer\n    // should contain initial value 0 plus map_id(0..n), unsorted.\n\n    // Expected values for each dispatch\n    const expected = new arrayType(numInvocations + 1);\n    expected.forEach((_, i) => {\n      if (i === 0) {\n        expected[0] = 0;\n      } else {\n        expected[i] = mapId.f(i - 1, numInvocations);\n      }\n    });\n    expected.sort(); // Sort because we store hashed results when mapId == 'remap'\n\n    // Test values for each dispatch\n    for (let d = 0; d < dispatchSize; ++d) {\n      // Get values for this dispatch\n      const dispatchOffset = d * numInvocations;\n      const values = new arrayType([\n        wgCopyBufferResult.data[d], // Last 'wg' value for this dispatch\n        ...outputBufferResult.data.subarray(dispatchOffset, dispatchOffset + numInvocations), // Rest of the returned values\n      ]);\n\n      values.sort();\n      t.expectOK(checkElementsEqual(values, expected));\n    }\n  });\n"],"mappings":"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"}