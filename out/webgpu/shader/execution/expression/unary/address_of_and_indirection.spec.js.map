{"version":3,"file":"address_of_and_indirection.spec.js","names":["description","makeTestGroup","keysOf","AllFeaturesMaxLimitsGPUTest","scalarType","sparseScalarF32Range","allButConstInputSource","basicExpressionWithPredeclarationBuilder","run","g","kDerefCases","deref_address_of_identifier","wgsl","requires_pointer_composite_access","deref_pointer","address_of_identifier","pointer","test","specURL","desc","params","u","combine","undefined","filter","p","derefType","fn","t","skipIfDeviceDoesNotHaveFeature","ty","cases","map","e","input","create","expected","elemType","kind","type","vectorize","shaderBuilder","value","beforeAllSubcases","skipIf","hasLanguageFeature","swizzle","slice"],"sources":["../../../../../../src/webgpu/shader/execution/expression/unary/address_of_and_indirection.spec.ts"],"sourcesContent":["export const description = `\nExecution Tests for unary address-of and indirection (dereference)\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../../gpu_test.js';\nimport { ScalarKind, scalarType } from '../../../../util/conversion.js';\nimport { sparseScalarF32Range } from '../../../../util/math.js';\nimport {\n  allButConstInputSource,\n  basicExpressionWithPredeclarationBuilder,\n  run,\n} from '../expression.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\n// All the ways to deref an expression\nconst kDerefCases = {\n  deref_address_of_identifier: {\n    wgsl: '(*(&a))',\n    requires_pointer_composite_access: false,\n  },\n  deref_pointer: {\n    wgsl: '(*p)',\n    requires_pointer_composite_access: false,\n  },\n  address_of_identifier: {\n    wgsl: '(&a)',\n    requires_pointer_composite_access: true,\n  },\n  pointer: {\n    wgsl: 'p',\n    requires_pointer_composite_access: true,\n  },\n};\n\ng.test('deref')\n  .specURL('https://www.w3.org/TR/WGSL/#indirection')\n  .desc(\n    `\nExpression: *e\n\nPointer expression dereference.\n`\n  )\n  .params(u =>\n    u\n      .combine('inputSource', allButConstInputSource)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n      .combine('scalarType', ['bool', 'u32', 'i32', 'f32', 'f16'] as ScalarKind[])\n      .combine('derefType', keysOf(kDerefCases))\n      .filter(p => !kDerefCases[p.derefType].requires_pointer_composite_access)\n  )\n  .fn(async t => {\n    if (t.params.scalarType === 'f16') {\n      t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    }\n    const ty = scalarType(t.params.scalarType);\n    const cases = sparseScalarF32Range().map(e => {\n      return { input: ty.create(e), expected: ty.create(e) };\n    });\n    const elemType = ty.kind;\n    const type = t.params.vectorize ? `vec${t.params.vectorize}<${elemType}>` : elemType;\n    const shaderBuilder = basicExpressionWithPredeclarationBuilder(\n      value => `get_dereferenced_value(${value})`,\n      `fn get_dereferenced_value(value: ${type}) -> ${type} {\n        var a = value;\n        let p = &a;\n        return ${kDerefCases[t.params.derefType].wgsl};\n      }`\n    );\n    await run(t, shaderBuilder, [ty], ty, t.params, cases);\n  });\n\ng.test('deref_index')\n  .specURL('https://www.w3.org/TR/WGSL/#logical-expr')\n  .desc(\n    `\nExpression: (*e)[index]\n\nPointer expression dereference as lhs of index accessor expression\n`\n  )\n  .params(u =>\n    u\n      .combine('inputSource', allButConstInputSource)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n      .combine('scalarType', ['bool', 'u32', 'i32', 'f32', 'f16'] as ScalarKind[])\n      .combine('derefType', keysOf(kDerefCases))\n  )\n  .beforeAllSubcases(t => {\n    t.skipIf(\n      kDerefCases[t.params.derefType].requires_pointer_composite_access &&\n        !t.hasLanguageFeature('pointer_composite_access')\n    );\n  })\n  .fn(async t => {\n    if (t.params.scalarType === 'f16') {\n      t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    }\n    const ty = scalarType(t.params.scalarType);\n    const cases = sparseScalarF32Range().map(e => {\n      return { input: ty.create(e), expected: ty.create(e) };\n    });\n    const elemType = ty.kind;\n    const type = t.params.vectorize ? `vec${t.params.vectorize}<${elemType}>` : elemType;\n    const shaderBuilder = basicExpressionWithPredeclarationBuilder(\n      value => `get_dereferenced_value(${value})`,\n      `fn get_dereferenced_value(value: ${type}) -> ${type} {\n        var a = array<${type}, 1>(value);\n        let p = &a;\n        return ${kDerefCases[t.params.derefType].wgsl}[0];\n      }`\n    );\n    await run(t, shaderBuilder, [ty], ty, t.params, cases);\n  });\n\ng.test('deref_member')\n  .specURL('https://www.w3.org/TR/WGSL/#logical-expr')\n  .desc(\n    `\nExpression: (*e).member\n\nPointer expression dereference as lhs of member accessor expression\n`\n  )\n  .params(u =>\n    u\n      .combine('inputSource', allButConstInputSource)\n      .combine('vectorize', [undefined, 2, 3, 4] as const)\n      .combine('scalarType', ['bool', 'u32', 'i32', 'f32', 'f16'] as ScalarKind[])\n      .combine('derefType', keysOf(kDerefCases))\n  )\n  .beforeAllSubcases(t => {\n    t.skipIf(\n      kDerefCases[t.params.derefType].requires_pointer_composite_access &&\n        !t.hasLanguageFeature('pointer_composite_access')\n    );\n  })\n  .fn(async t => {\n    if (t.params.scalarType === 'f16') {\n      t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    }\n    const ty = scalarType(t.params.scalarType);\n    const cases = sparseScalarF32Range().map(e => {\n      return { input: ty.create(e), expected: ty.create(e) };\n    });\n    const elemType = ty.kind;\n    const type = t.params.vectorize ? `vec${t.params.vectorize}<${elemType}>` : elemType;\n    const shaderBuilder = basicExpressionWithPredeclarationBuilder(\n      value => `get_dereferenced_value(${value})`,\n      `struct S {\n        m : ${type}\n      }\n      fn get_dereferenced_value(value: ${type}) -> ${type} {\n        var a = S(value);\n        let p = &a;\n        return ${kDerefCases[t.params.derefType].wgsl}.m;\n      }`\n    );\n    await run(t, shaderBuilder, [ty], ty, t.params, cases);\n  });\n\ng.test('deref_swizzle')\n  .specURL('https://www.w3.org/TR/WGSL/#logical-expr')\n  .desc(\n    `\nExpression: (*e).swizzle\n\nPointer expression dereference as lhs of swizzle expression\n`\n  )\n  .params(u =>\n    u\n      .combine('inputSource', allButConstInputSource)\n      .combine('vectorize', [2, 3, 4] as const)\n      .combine('scalarType', ['bool', 'u32', 'i32', 'f32', 'f16'] as ScalarKind[])\n      .combine('derefType', keysOf(kDerefCases))\n  )\n  .beforeAllSubcases(t => {\n    t.skipIf(\n      kDerefCases[t.params.derefType].requires_pointer_composite_access &&\n        !t.hasLanguageFeature('pointer_composite_access')\n    );\n  })\n  .fn(async t => {\n    if (t.params.scalarType === 'f16') {\n      t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    }\n    const ty = scalarType(t.params.scalarType);\n    const cases = sparseScalarF32Range().map(e => {\n      return { input: ty.create(e), expected: ty.create(e) };\n    });\n    const elemType = ty.kind;\n    const type = `vec${t.params.vectorize}<${elemType}>`;\n    const swizzle = 'xyzw'.slice(0, t.params.vectorize);\n    const shaderBuilder = basicExpressionWithPredeclarationBuilder(\n      value => `get_dereferenced_value(${value})`,\n      `fn get_dereferenced_value(value: ${type}) -> ${type} {\n        var a = value;\n        let p = &a;\n        return ${kDerefCases[t.params.derefType].wgsl}.${swizzle};\n      }`\n    );\n    await run(t, shaderBuilder, [ty], ty, t.params, cases);\n  });\n"],"mappings":"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"}