{"version":3,"file":"vertex_builtins.spec.js","names":["description","makeTestGroup","AllFeaturesMaxLimitsGPUTest","TextureTestMixin","VertexBuiltinTest","g","test","desc","params","u","combine","fn","t","skipIfDeviceDoesNotHaveFeature","clipDistances","code","module","device","createShaderModule","renderPipeline","createRenderPipeline","layout","vertex","fragment","targets","format","kSize","outputTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","commandEncoder","createCommandEncoder","renderPassEncoder","beginRenderPass","colorAttachments","view","createView","loadOp","clearValue","r","b","a","storeOp","setPipeline","draw","end","kBytesPerRow","kBytesPerPixel","outputDataSize","outputBuffer","createBufferTracked","GPUBufferUsage","COPY_DST","copyTextureToBuffer","texture","buffer","bytesPerRow","rowsPerImage","queue","submit","finish","expectedData","Uint8Array","y","baseOffset","x","lastRed","i","j","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/shader/execution/shader_io/vertex_builtins.spec.ts"],"sourcesContent":["export const description = `Test vertex shader builtin variables\n\n* test builtin(clip_distances)\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { AllFeaturesMaxLimitsGPUTest, TextureTestMixin } from '../../../gpu_test.js';\n\nclass VertexBuiltinTest extends TextureTestMixin(AllFeaturesMaxLimitsGPUTest) {}\n\nexport const g = makeTestGroup(VertexBuiltinTest);\n\ng.test('outputs,clip_distances')\n  .desc(\n    `\n    Test vertex shader builtin(clip_distances) values.\n\n    In the tests, we draw a square with two triangles (top-right and bottom left), whose vertices\n    have different clip distances values. (Top Left: -1, Bottom Right: 1 Top Right & Bottom Left: 0)\n    1. The clip distances values of the pixels in the top-left region should be less than 0 so these\n       pixels will all be invisible\n    2. The clip distances values of the pixels on the top-right-to-bottom-left diagonal line should\n       be equal to 0\n    3. The clip distances values of the pixels in the bottom-right region should be greater than 0\n\n    -1 - - - - - 0\n     | \\\\      x x\n     |   \\\\  x x x\n     |    \\\\ x x x\n     |   x x\\\\ x x\n     | x x x x\\\\ x\n     0 x x x x x 1\n  `\n  )\n  .params(u => u.combine('clipDistances', [1, 2, 3, 4, 5, 6, 7, 8] as const))\n  .fn(t => {\n    t.skipIfDeviceDoesNotHaveFeature('clip-distances');\n    const { clipDistances } = t.params;\n\n    // Draw two triangles (top-right and bottom left) into Red, whose vertices have different clip\n    // distances values. (Top Left: -1, Bottom Right: 1 Top Right & Bottom Left: 0)\n    const code = `\n    enable clip_distances;\n    const kClipDistancesSize = ${clipDistances};\n    struct VertexOutputs {\n        @builtin(position) position : vec4f,\n        @builtin(clip_distances) clipDistances : array<f32, kClipDistancesSize>,\n    }\n    @vertex\n    fn vsMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutputs {\n          var posAndClipDistances = array(\n              vec3f(-1.0,  1.0, -1.0),\n              vec3f( 1.0, -1.0,  1.0),\n              vec3f( 1.0,  1.0,  0.0),\n              vec3f(-1.0, -1.0,  0.0),\n              vec3f( 1.0, -1.0,  1.0),\n              vec3f(-1.0,  1.0, -1.0));\n          var vertexOutput : VertexOutputs;\n          vertexOutput.position = vec4f(posAndClipDistances[vertexIndex].xy, 0.0, 1.0);\n          vertexOutput.clipDistances[kClipDistancesSize - 1] = posAndClipDistances[vertexIndex].z;\n          return vertexOutput;\n    }\n    @fragment\n    fn fsMain() -> @location(0) vec4f {\n        return vec4f(1.0, 0.0, 0.0, 1.0);\n    }`;\n    const module = t.device.createShaderModule({ code });\n    const renderPipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n      },\n      fragment: {\n        module,\n        targets: [\n          {\n            format: 'rgba8unorm',\n          },\n        ],\n      },\n    });\n\n    const kSize = 7;\n    const outputTexture = t.createTextureTracked({\n      format: 'rgba8unorm',\n      size: [kSize, kSize, 1] as const,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    // Clear outputTexture to Green\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPassEncoder = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadOp: 'clear',\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPassEncoder.setPipeline(renderPipeline);\n    renderPassEncoder.draw(6);\n    renderPassEncoder.end();\n\n    const kBytesPerRow = 256;\n    const kBytesPerPixel = 4;\n    const outputDataSize = kBytesPerRow * (kSize - 1) + kSize * kBytesPerPixel;\n    const outputBuffer = t.createBufferTracked({\n      size: outputDataSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: outputTexture,\n      },\n      {\n        buffer: outputBuffer,\n        bytesPerRow: kBytesPerRow,\n        rowsPerImage: kSize,\n      },\n      [kSize, kSize, 1]\n    );\n    t.queue.submit([commandEncoder.finish()]);\n\n    // The top-left part should be Green and the bottom-right part should be Red\n    const expectedData = new Uint8Array(outputDataSize);\n    for (let y = 0; y < kSize; ++y) {\n      const baseOffset = kBytesPerRow * y;\n      for (let x = 0; x < kSize; ++x) {\n        const lastRed = kSize - y - 1;\n        for (let i = 0; i < lastRed; ++i) {\n          expectedData[baseOffset + i * 4] = 0;\n          expectedData[baseOffset + i * 4 + 1] = 255;\n          expectedData[baseOffset + i * 4 + 2] = 0;\n          expectedData[baseOffset + i * 4 + 3] = 255;\n        }\n        for (let j = lastRed; j < kSize; ++j) {\n          expectedData[baseOffset + j * 4] = 255;\n          expectedData[baseOffset + j * 4 + 1] = 0;\n          expectedData[baseOffset + j * 4 + 2] = 0;\n          expectedData[baseOffset + j * 4 + 3] = 255;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(outputBuffer, expectedData);\n  });\n"],"mappings":"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"}