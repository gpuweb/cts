{"version":3,"file":"robust_access_vertex.spec.js","names":["description","makeTestGroup","assert","GPUTest","TextureTestMixin","kFloatTolerance","DrawCall","constructor","test","vertexArrays","vertexCount","partialLastNumber","offsetVertexBuffer","keepInstanceStepModeBufferInRange","firstVertex","vertexCountInIndexBuffer","indexCount","firstIndex","baseVertex","instanceCount","firstInstance","vertexBuffers","map","v","i","generateVertexBuffer","insertInto","pass","indexed","indirect","drawIndexedIndirect","drawIndexed","drawIndirect","draw","bindVertexBuffers","indexArray","Uint32Array","_","indexBuffer","makeBufferWithContents","GPUBufferUsage","INDEX","setIndexBuffer","generateIndirectBuffer","generateIndexedIndirectBuffer","currSlot","length","setVertexBuffer","vertexArray","size","byteLength","buffer","createBufferTracked","usage","VERTEX","COPY_DST","device","queue","writeBuffer","slice","indirectArray","Int32Array","INDIRECT","typeInfoMap","float32","wgslType","sizeInBytes","validationFunc","float32x2","float32x3","float32x4","F","generateBufferContents","numVertices","attributesPerBuffer","typeInfo","arbitraryValues","bufferCount","Float32Array","bufferContents","push","generateVertexBufferDescriptors","format","buffers","currAttribute","arrayStride","stepMode","attributes","Array","fill","shaderLocation","offset","generateVertexShaderCode","validValues","vertexIndexOffset","isIndexed","layoutStr","attributeNames","j","vertexShaderCode","join","a","createRenderPipeline","pipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","doTest","dataType","isIndirect","drawCall","colorAttachment","createTextureTracked","width","height","depthOrArrayLayers","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","colorAttachmentView","createView","encoder","createCommandEncoder","beginRenderPass","colorAttachments","view","clearValue","r","g","b","loadOp","storeOp","setPipeline","end","submit","finish","expectSinglePixelComparisonsAreOkInTexture","texture","coord","x","y","exp","Uint8Array","params","u","combineWithParams","expand","p","combine","Object","keys","beginSubcases","unless","drawCallTestParameter","errorScale","fn","t","type","additionalBuffers"],"sources":["../../../../src/webgpu/shader/execution/robust_access_vertex.spec.ts"],"sourcesContent":["export const description = `\nTest vertex attributes behave correctly (no crash / data leak) when accessed out of bounds\n\nTest coverage:\n\nThe following is parameterized (all combinations tested):\n\n1) Draw call type? (drawIndexed, drawIndirect, drawIndexedIndirect)\n  - Run the draw call using an index buffer and/or an indirect buffer.\n  - Doesn't test direct draw, as vertex buffer OOB are CPU validated and treated as validation errors.\n  - Also the instance step mode vertex buffer OOB are CPU validated for drawIndexed, so we only test\n    robustness access for vertex step mode vertex buffers.\n\n2) Draw call parameter (vertexCount, firstVertex, indexCount, firstIndex, baseVertex, instanceCount,\n   vertexCountInIndexBuffer)\n  - The parameter which goes out of bounds. Filtered depending on the draw call type.\n  - vertexCount, firstVertex: used for drawIndirect only, test for vertex step mode buffer OOB\n  - instanceCount: used for both drawIndirect and drawIndexedIndirect, test for instance step mode buffer OOB\n  - baseVertex, vertexCountInIndexBuffer: used for both drawIndexed and drawIndexedIndirect, test\n    for vertex step mode buffer OOB. vertexCountInIndexBuffer indicates how many vertices are used\n    within the index buffer, i.e. [0, 1, ..., vertexCountInIndexBuffer-1].\n  - indexCount, firstIndex: used for drawIndexedIndirect only, validate the vertex buffer access\n    when the vertex itself is OOB in index buffer. This never happens in drawIndexed as we have index\n    buffer OOB CPU validation for it.\n\n3) Attribute type (float32, float32x2, float32x3, float32x4)\n  - The input attribute type in the vertex shader\n\n4) Error scale (0, 1, 4, 10^2, 10^4, 10^6)\n  - Offset to add to the correct draw call parameter\n  - 0 For control case\n\n5) Additional vertex buffers (0, +4)\n  - Tests that no OOB occurs if more vertex buffers are used\n\n6) Partial last number and offset vertex buffer (false, true)\n  - Tricky cases that make vertex buffer OOB.\n  - With partial last number enabled, vertex buffer size will be 1 byte less than enough, making the\n    last vertex OOB with 1 byte.\n  - Offset vertex buffer will bind the vertex buffer to render pass with 4 bytes offset, causing OOB\n  - For drawIndexed, these two flags are suppressed for instance step mode vertex buffer to make sure\n    it pass the CPU validation.\n\nThe tests have one instance step mode vertex buffer bound for instanced attributes, to make sure\ninstanceCount / firstInstance are tested.\n\nThe tests include multiple attributes per vertex buffer.\n\nThe vertex buffers are filled by repeating a few values randomly chosen for each test until the\nend of the buffer.\n\nThe tests run a render pipeline which verifies the following:\n1) All vertex attribute values occur in the buffer or are 0 (for control case it can't be 0)\n2) All gl_VertexIndex values are within the index buffer or 0\n\nTODO:\nCurrently firstInstance is not tested, as for drawIndexed it is CPU validated, and for drawIndirect\nand drawIndexedIndirect it should always be 0. Once there is an extension to allow making them non-zero,\nit should be added into drawCallTestParameter list.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../gpu_test.js';\n\n// This is a tolerance that should be less strict than oneULP(X) of a f32 where X is any arbitraryValues or 0.\n// Given that in GLSL compat highp float can < 32 bit.\nconst kFloatTolerance = 0.000001;\n\n// Encapsulates a draw call (either indexed or non-indexed)\nclass DrawCall {\n  private test: GPUTest;\n  private vertexBuffers: GPUBuffer[];\n\n  // Add a float offset when binding vertex buffer\n  private offsetVertexBuffer: boolean;\n\n  // Keep instance step mode vertex buffer in range, in order to test vertex step\n  // mode buffer OOB in drawIndexed. Setting true will suppress partialLastNumber\n  // and offsetVertexBuffer for instance step mode vertex buffer.\n  private keepInstanceStepModeBufferInRange: boolean;\n\n  // Draw\n  public vertexCount: number;\n  public firstVertex: number;\n\n  // DrawIndexed\n  public vertexCountInIndexBuffer: number; // For generating index buffer in drawIndexed and drawIndexedIndirect\n  public indexCount: number; // For accessing index buffer in drawIndexed and drawIndexedIndirect\n  public firstIndex: number;\n  public baseVertex: number;\n\n  // Both Draw and DrawIndexed\n  public instanceCount: number;\n  public firstInstance: number;\n\n  constructor({\n    test,\n    vertexArrays,\n    vertexCount,\n    partialLastNumber,\n    offsetVertexBuffer,\n    keepInstanceStepModeBufferInRange,\n  }: {\n    test: GPUTest;\n    vertexArrays: Float32Array[];\n    vertexCount: number;\n    partialLastNumber: boolean;\n    offsetVertexBuffer: boolean;\n    keepInstanceStepModeBufferInRange: boolean;\n  }) {\n    this.test = test;\n\n    // Default arguments (valid call)\n    this.vertexCount = vertexCount;\n    this.firstVertex = 0;\n    this.vertexCountInIndexBuffer = vertexCount;\n    this.indexCount = vertexCount;\n    this.firstIndex = 0;\n    this.baseVertex = 0;\n    this.instanceCount = vertexCount;\n    this.firstInstance = 0;\n\n    this.offsetVertexBuffer = offsetVertexBuffer;\n    this.keepInstanceStepModeBufferInRange = keepInstanceStepModeBufferInRange;\n\n    // Since vertexInIndexBuffer is mutable, generation of the index buffer should be deferred to right before calling draw\n\n    // Generate vertex buffer\n    this.vertexBuffers = vertexArrays.map((v, i) => {\n      if (i === 0 && keepInstanceStepModeBufferInRange) {\n        // Suppress partialLastNumber for the first vertex buffer, aka the instance step mode buffer\n        return this.generateVertexBuffer(v, false);\n      } else {\n        return this.generateVertexBuffer(v, partialLastNumber);\n      }\n    });\n  }\n\n  // Insert a draw call into |pass| with specified type\n  public insertInto(pass: GPURenderPassEncoder, indexed: boolean, indirect: boolean) {\n    if (indexed) {\n      if (indirect) {\n        this.drawIndexedIndirect(pass);\n      } else {\n        this.drawIndexed(pass);\n      }\n    } else {\n      if (indirect) {\n        this.drawIndirect(pass);\n      } else {\n        this.draw(pass);\n      }\n    }\n  }\n\n  // Insert a draw call into |pass|\n  public draw(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.draw(this.vertexCount, this.instanceCount, this.firstVertex, this.firstInstance);\n  }\n\n  // Insert an indexed draw call into |pass|\n  public drawIndexed(pass: GPURenderPassEncoder) {\n    // Generate index buffer\n    const indexArray = new Uint32Array(this.vertexCountInIndexBuffer).map((_, i) => i);\n    const indexBuffer = this.test.makeBufferWithContents(indexArray, GPUBufferUsage.INDEX);\n    this.bindVertexBuffers(pass);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexed(\n      this.indexCount,\n      this.instanceCount,\n      this.firstIndex,\n      this.baseVertex,\n      this.firstInstance\n    );\n  }\n\n  // Insert an indirect draw call into |pass|\n  public drawIndirect(pass: GPURenderPassEncoder) {\n    this.bindVertexBuffers(pass);\n    pass.drawIndirect(this.generateIndirectBuffer(), 0);\n  }\n\n  // Insert an indexed indirect draw call into |pass|\n  public drawIndexedIndirect(pass: GPURenderPassEncoder) {\n    // Generate index buffer\n    const indexArray = new Uint32Array(this.vertexCountInIndexBuffer).map((_, i) => i);\n    const indexBuffer = this.test.makeBufferWithContents(indexArray, GPUBufferUsage.INDEX);\n    this.bindVertexBuffers(pass);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexedIndirect(this.generateIndexedIndirectBuffer(), 0);\n  }\n\n  // Bind all vertex buffers generated\n  private bindVertexBuffers(pass: GPURenderPassEncoder) {\n    let currSlot = 0;\n    for (let i = 0; i < this.vertexBuffers.length; i++) {\n      if (i === 0 && this.keepInstanceStepModeBufferInRange) {\n        // Keep the instance step mode buffer in range\n        pass.setVertexBuffer(currSlot++, this.vertexBuffers[i], 0);\n      } else {\n        pass.setVertexBuffer(currSlot++, this.vertexBuffers[i], this.offsetVertexBuffer ? 4 : 0);\n      }\n    }\n  }\n\n  // Create a vertex buffer from |vertexArray|\n  // If |partialLastNumber| is true, delete one byte off the end\n  private generateVertexBuffer(vertexArray: Float32Array, partialLastNumber: boolean): GPUBuffer {\n    let size = vertexArray.byteLength;\n    let length = vertexArray.length;\n    if (partialLastNumber) {\n      size -= 1; // Shave off one byte from the buffer size.\n      length -= 1; // And one whole element from the writeBuffer.\n    }\n    const buffer = this.test.createBufferTracked({\n      size,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, // Ensure that buffer can be used by writeBuffer\n    });\n    this.test.device.queue.writeBuffer(buffer, 0, vertexArray.slice(0, length));\n    return buffer;\n  }\n\n  // Create an indirect buffer containing draw call values\n  private generateIndirectBuffer(): GPUBuffer {\n    const indirectArray = new Int32Array([\n      this.vertexCount,\n      this.instanceCount,\n      this.firstVertex,\n      this.firstInstance,\n    ]);\n    return this.test.makeBufferWithContents(indirectArray, GPUBufferUsage.INDIRECT);\n  }\n\n  // Create an indirect buffer containing indexed draw call values\n  private generateIndexedIndirectBuffer(): GPUBuffer {\n    const indirectArray = new Int32Array([\n      this.indexCount,\n      this.instanceCount,\n      this.firstIndex,\n      this.baseVertex,\n      this.firstInstance,\n    ]);\n    return this.test.makeBufferWithContents(indirectArray, GPUBufferUsage.INDIRECT);\n  }\n}\n\n// Parameterize different sized types\ninterface VertexInfo {\n  wgslType: string;\n  sizeInBytes: number;\n  validationFunc: string;\n}\n\nconst typeInfoMap: { [k: string]: VertexInfo } = {\n  float32: {\n    wgslType: 'f32',\n    sizeInBytes: 4,\n    validationFunc: 'return valid(v);',\n  },\n  float32x2: {\n    wgslType: 'vec2<f32>',\n    sizeInBytes: 8,\n    validationFunc: 'return valid(v.x) && valid(v.y);',\n  },\n  float32x3: {\n    wgslType: 'vec3<f32>',\n    sizeInBytes: 12,\n    validationFunc: 'return valid(v.x) && valid(v.y) && valid(v.z);',\n  },\n  // It is valid to return (0, 0, 0, X) for an OOB access. (X can be anything)\n  // https://gpuweb.github.io/gpuweb/#security-shader\n  float32x4: {\n    wgslType: 'vec4<f32>',\n    sizeInBytes: 16,\n    validationFunc: `return (valid(v.x) && valid(v.y) && valid(v.z) && valid(v.w)) ||\n                            (abs(v.x - 0.0) <= ${kFloatTolerance} &&\n                             abs(v.y - 0.0) <= ${kFloatTolerance} &&\n                             abs(v.z - 0.0) <= ${kFloatTolerance});`,\n  },\n};\n\nclass F extends TextureTestMixin(GPUTest) {\n  generateBufferContents(\n    numVertices: number,\n    attributesPerBuffer: number,\n    typeInfo: VertexInfo,\n    arbitraryValues: number[],\n    bufferCount: number\n  ): Float32Array[] {\n    // Make an array big enough for the vertices, attributes, and size of each element\n    const vertexArray = new Float32Array(\n      numVertices * attributesPerBuffer * (typeInfo.sizeInBytes / 4)\n    );\n\n    for (let i = 0; i < vertexArray.length; ++i) {\n      vertexArray[i] = arbitraryValues[i % arbitraryValues.length];\n    }\n\n    // Only the first buffer is instance step mode, all others are vertex step mode buffer\n    assert(bufferCount >= 2);\n    const bufferContents: Float32Array[] = [];\n    for (let i = 0; i < bufferCount; i++) {\n      bufferContents.push(vertexArray);\n    }\n\n    return bufferContents;\n  }\n\n  generateVertexBufferDescriptors(\n    bufferCount: number,\n    attributesPerBuffer: number,\n    format: GPUVertexFormat\n  ) {\n    const typeInfo = typeInfoMap[format];\n    // Vertex buffer descriptors\n    const buffers: GPUVertexBufferLayout[] = [];\n    {\n      let currAttribute = 0;\n      for (let i = 0; i < bufferCount; i++) {\n        buffers.push({\n          arrayStride: attributesPerBuffer * typeInfo.sizeInBytes,\n          stepMode: i === 0 ? 'instance' : 'vertex',\n          attributes: Array(attributesPerBuffer)\n            .fill(0)\n            .map((_, i) => ({\n              shaderLocation: currAttribute++,\n              offset: i * typeInfo.sizeInBytes,\n              format,\n            })),\n        });\n      }\n    }\n    return buffers;\n  }\n\n  generateVertexShaderCode({\n    bufferCount,\n    attributesPerBuffer,\n    validValues,\n    typeInfo,\n    vertexIndexOffset,\n    numVertices,\n    isIndexed,\n  }: {\n    bufferCount: number;\n    attributesPerBuffer: number;\n    validValues: number[];\n    typeInfo: VertexInfo;\n    vertexIndexOffset: number;\n    numVertices: number;\n    isIndexed: boolean;\n  }): string {\n    // Create layout and attributes listing\n    let layoutStr = 'struct Attributes {';\n    const attributeNames = [];\n    {\n      let currAttribute = 0;\n      for (let i = 0; i < bufferCount; i++) {\n        for (let j = 0; j < attributesPerBuffer; j++) {\n          layoutStr += `@location(${currAttribute}) a_${currAttribute} : ${typeInfo.wgslType},\\n`;\n          attributeNames.push(`a_${currAttribute}`);\n          currAttribute++;\n        }\n      }\n    }\n    layoutStr += '};';\n\n    const vertexShaderCode: string = `\n      ${layoutStr}\n\n      fn valid(f : f32) -> bool {\n        return ${validValues.map(v => `abs(f - ${v}.0) <= ${kFloatTolerance}`).join(' || ')};\n      }\n\n      fn validationFunc(v : ${typeInfo.wgslType}) -> bool {\n        ${typeInfo.validationFunc}\n      }\n\n      @vertex fn main(\n        @builtin(vertex_index) VertexIndex : u32,\n        attributes : Attributes\n        ) -> @builtin(position) vec4<f32> {\n        var attributesInBounds = ${attributeNames\n          .map(a => `validationFunc(attributes.${a})`)\n          .join(' && ')};\n\n        var indexInBoundsCountFromBaseVertex =\n            (VertexIndex >= ${vertexIndexOffset}u &&\n            VertexIndex < ${vertexIndexOffset + numVertices}u);\n        var indexInBounds = VertexIndex == 0u || indexInBoundsCountFromBaseVertex;\n\n        var Position : vec4<f32>;\n        if (attributesInBounds && (${!isIndexed} || indexInBounds)) {\n          // Success case, move the vertex to the right of the viewport to show that at least one case succeed\n          Position = vec4<f32>(0.5, 0.0, 0.0, 1.0);\n        } else {\n          // Failure case, move the vertex to the left of the viewport\n          Position = vec4<f32>(-0.5, 0.0, 0.0, 1.0);\n        }\n        return Position;\n      }`;\n    return vertexShaderCode;\n  }\n\n  createRenderPipeline({\n    bufferCount,\n    attributesPerBuffer,\n    validValues,\n    typeInfo,\n    vertexIndexOffset,\n    numVertices,\n    isIndexed,\n    buffers,\n  }: {\n    bufferCount: number;\n    attributesPerBuffer: number;\n    validValues: number[];\n    typeInfo: VertexInfo;\n    vertexIndexOffset: number;\n    numVertices: number;\n    isIndexed: boolean;\n    buffers: GPUVertexBufferLayout[];\n  }): GPURenderPipeline {\n    const pipeline = this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: this.generateVertexShaderCode({\n            bufferCount,\n            attributesPerBuffer,\n            validValues,\n            typeInfo,\n            vertexIndexOffset,\n            numVertices,\n            isIndexed,\n          }),\n        }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n    return pipeline;\n  }\n\n  doTest({\n    bufferCount,\n    attributesPerBuffer,\n    dataType,\n    validValues,\n    vertexIndexOffset,\n    numVertices,\n    isIndexed,\n    isIndirect,\n    drawCall,\n  }: {\n    bufferCount: number;\n    attributesPerBuffer: number;\n    dataType: GPUVertexFormat;\n    validValues: number[];\n    vertexIndexOffset: number;\n    numVertices: number;\n    isIndexed: boolean;\n    isIndirect: boolean;\n    drawCall: DrawCall;\n  }): void {\n    // Vertex buffer descriptors\n    const buffers: GPUVertexBufferLayout[] = this.generateVertexBufferDescriptors(\n      bufferCount,\n      attributesPerBuffer,\n      dataType\n    );\n\n    // Pipeline setup, texture setup\n    const pipeline = this.createRenderPipeline({\n      bufferCount,\n      attributesPerBuffer,\n      validValues,\n      typeInfo: typeInfoMap[dataType],\n      vertexIndexOffset,\n      numVertices,\n      isIndexed,\n      buffers,\n    });\n\n    const colorAttachment = this.createTextureTracked({\n      format: 'rgba8unorm',\n      size: { width: 2, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const colorAttachmentView = colorAttachment.createView();\n\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorAttachmentView,\n          clearValue: { r: 0.0, g: 1.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.setPipeline(pipeline);\n\n    // Run the draw variant\n    drawCall.insertInto(pass, isIndexed, isIndirect);\n\n    pass.end();\n    this.device.queue.submit([encoder.finish()]);\n\n    // Validate we see green on the left pixel, showing that no failure case is detected\n    this.expectSinglePixelComparisonsAreOkInTexture({ texture: colorAttachment }, [\n      { coord: { x: 0, y: 0 }, exp: new Uint8Array([0x00, 0xff, 0x00, 0xff]) },\n    ]);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('vertex_buffer_access')\n  .params(\n    u =>\n      u\n        .combineWithParams([\n          { indexed: false, indirect: true },\n          { indexed: true, indirect: false },\n          { indexed: true, indirect: true },\n        ])\n        .expand('drawCallTestParameter', function* (p) {\n          if (p.indexed) {\n            yield* ['baseVertex', 'vertexCountInIndexBuffer'] as const;\n            if (p.indirect) {\n              yield* ['indexCount', 'instanceCount', 'firstIndex'] as const;\n            }\n          } else if (p.indirect) {\n            yield* ['vertexCount', 'instanceCount', 'firstVertex'] as const;\n          }\n        })\n        .combine('type', Object.keys(typeInfoMap) as GPUVertexFormat[])\n        .combine('additionalBuffers', [0, 4])\n        .combine('partialLastNumber', [false, true])\n        .combine('offsetVertexBuffer', [false, true])\n        .beginSubcases()\n        .combine('errorScale', [0, 1, 4, 10 ** 2, 10 ** 4, 10 ** 6])\n        .unless(p => p.drawCallTestParameter === 'instanceCount' && p.errorScale > 10 ** 4) // To avoid timeout\n  )\n  .fn(t => {\n    const p = t.params;\n    const typeInfo = typeInfoMap[p.type];\n\n    // Number of vertices to draw\n    const numVertices = 4;\n    // Each buffer is bound to this many attributes (2 would mean 2 attributes per buffer)\n    const attributesPerBuffer = 2;\n    // Some arbitrary values to fill our buffer with to avoid collisions with other tests\n    const arbitraryValues = [990, 685, 446, 175];\n\n    // A valid value is 0 or one in the buffer\n    const validValues =\n      p.errorScale === 0 && !p.offsetVertexBuffer && !p.partialLastNumber\n        ? arbitraryValues // Control case with no OOB access, must read back valid values in buffer\n        : [0, ...arbitraryValues]; // Testing case with OOB access, can be 0 for OOB data\n\n    // Generate vertex buffer contents. Only the first buffer is instance step mode, all others are vertex step mode\n    const bufferCount = p.additionalBuffers + 2; // At least one instance step mode and one vertex step mode buffer\n    const bufferContents = t.generateBufferContents(\n      numVertices,\n      attributesPerBuffer,\n      typeInfo,\n      arbitraryValues,\n      bufferCount\n    );\n\n    // Mutable draw call\n    const draw = new DrawCall({\n      test: t,\n      vertexArrays: bufferContents,\n      vertexCount: numVertices,\n      partialLastNumber: p.partialLastNumber,\n      offsetVertexBuffer: p.offsetVertexBuffer,\n      keepInstanceStepModeBufferInRange: p.indexed && !p.indirect, // keep instance step mode buffer in range for drawIndexed\n    });\n\n    // Offset the draw call parameter we are testing by |errorScale|\n    draw[p.drawCallTestParameter] += p.errorScale;\n    // Offset the range checks for gl_VertexIndex in the shader if we use BaseVertex\n    let vertexIndexOffset = 0;\n    if (p.drawCallTestParameter === 'baseVertex') {\n      vertexIndexOffset += p.errorScale;\n    }\n\n    t.doTest({\n      bufferCount,\n      attributesPerBuffer,\n      dataType: p.type,\n      validValues,\n      vertexIndexOffset,\n      numVertices,\n      isIndexed: p.indexed,\n      isIndirect: p.indirect,\n      drawCall: draw,\n    });\n  });\n"],"mappings":"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"}