{"version":3,"file":"zero_init.spec.js","names":["description","makeTestGroup","iterRange","unreachable","GPUTest","kVectorContainerTypes","kMatrixContainerTypes","supportedScalarTypes","supportsAtomics","prettyPrint","t","type","containerType","elementType","length","members","map","m","join","scalarType","isAtomic","g","test","desc","params","u","combine","expand","addressSpace","beginSubcases","expandWithParams","p","kElementCounts","kMemberCounts","memoizedTypes","generateTypesMemo","depth","undefined","Array","from","generateTypes","access","storageMode","_containerDepth","vectorType","matrixType","innerTypes","elementCount","innerType","memberCount","memberIndices","memberTypes","reverse","seenTypes","Set","typeIndex","prevTypeIndex","serializedT","has","push","shift","add","shaderTypeParam","_type","batch","fn","workgroupSize","maxComputeInvocationsPerWorkgroup","device","limits","numWorkgroupInvocations","reduce","a","b","skipIf","moduleScope","functionScope","declaredStructTypes","Map","typeDecl","ensureType","typeName","get","member","i","set","checkZeroCode","checkZero","value","indexOf","cols","rows","expected","wgsl","wg_memory_limits","maxComputeWorkgroupStorageSize","wg_x_dim","maxComputeWorkgroupSizeX","fillLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","fillPipeline","createComputePipelineAsync","layout","createPipelineLayout","bindGroupLayouts","label","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","_i","GPUBufferUsage","STORAGE","COPY_DST","trackForCleanup","outputBuffer","createBuffer","size","usage","COPY_SRC","bg","createBindGroup","getBindGroupLayout","resource","e","createCommandEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","pipeline","resultBuffer","zeroBuffer","UNIFORM","bindGroup","encoder","pass","expectGPUBufferValuesEqual"],"sources":["../../../../src/webgpu/shader/execution/zero_init.spec.ts"],"sourcesContent":["export const description = `Test that variables in the shader are zero initialized`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange, unreachable } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport {\n  ScalarType,\n  kVectorContainerTypes,\n  kVectorContainerTypeInfo,\n  kMatrixContainerTypes,\n  kMatrixContainerTypeInfo,\n  supportedScalarTypes,\n  supportsAtomics,\n} from '../types.js';\n\ntype ShaderTypeInfo =\n  | { type: 'container'; containerType: 'array'; elementType: ShaderTypeInfo; length: number }\n  | { type: 'container'; containerType: 'struct'; members: readonly ShaderTypeInfo[] }\n  | {\n      type: 'container';\n      containerType: keyof typeof kVectorContainerTypeInfo | keyof typeof kMatrixContainerTypeInfo;\n      scalarType: ScalarType;\n    }\n  | { type: 'scalar'; scalarType: ScalarType; isAtomic: boolean };\n\nfunction prettyPrint(t: ShaderTypeInfo): string {\n  switch (t.type) {\n    case 'container':\n      switch (t.containerType) {\n        case 'array':\n          return `array<${prettyPrint(t.elementType)}, ${t.length}>`;\n        case 'struct':\n          return `struct { ${t.members.map(m => prettyPrint(m)).join(', ')} }`;\n        default:\n          return `${t.containerType}<${prettyPrint({\n            type: 'scalar',\n            scalarType: t.scalarType,\n            isAtomic: false,\n          })}>`;\n      }\n      break;\n    case 'scalar':\n      if (t.isAtomic) {\n        return `atomic<${t.scalarType}>`;\n      }\n      return t.scalarType;\n  }\n}\n\nexport const g = makeTestGroup(GPUTest);\ng.test('compute,zero_init')\n  .desc(\n    `Test that uninitialized variables in workgroup, private, and function storage classes are initialized to zero.`\n  )\n  .params(u =>\n    u\n      // Only workgroup, function, and private variables can be declared without data bound to them.\n      // The implementation's shader translator should ensure these values are initialized.\n      .combine('addressSpace', ['workgroup', 'private', 'function'] as const)\n      .expand('workgroupSize', ({ addressSpace }) => {\n        switch (addressSpace) {\n          case 'workgroup':\n            return [\n              [1, 1, 1],\n              [1, 32, 1],\n              [64, 1, 1],\n              [1, 1, 48],\n              [1, 47, 1],\n              [33, 1, 1],\n              [1, 1, 63],\n              [8, 8, 2],\n              [7, 7, 3],\n            ];\n          case 'function':\n          case 'private':\n            return [[1, 1, 1]];\n        }\n      })\n      .beginSubcases()\n      // Fewer subcases: Only 0 and 2. If double-nested containers work, single-nested should too.\n      .combine('_containerDepth', [0, 2])\n      .expandWithParams(function* (p) {\n        const kElementCounts = [\n          [], // Not used. Depth 0 is always scalars.\n          [1, 3, 67], // Test something above the workgroup size.\n          [1, 3],\n        ] as const;\n        const kMemberCounts = [1, 3] as const;\n\n        const memoizedTypes: ShaderTypeInfo[][] = [];\n\n        function generateTypesMemo(depth: number): ShaderTypeInfo[] {\n          if (memoizedTypes[depth] === undefined) {\n            memoizedTypes[depth] = Array.from(generateTypes(depth));\n          }\n          return memoizedTypes[depth];\n        }\n\n        function* generateTypes(depth: number): Generator<ShaderTypeInfo> {\n          if (depth === 0) {\n            for (const isAtomic of supportsAtomics({\n              ...p,\n              access: 'read_write',\n              storageMode: undefined,\n              containerType: 'scalar',\n            })\n              ? [true, false]\n              : [false]) {\n              for (const scalarType of supportedScalarTypes({ isAtomic, ...p })) {\n                // Fewer subcases: supportedScalarTypes was expanded to include f16\n                // but that may take too much time. It would require more complex code.\n                if (scalarType === 'f16') continue;\n\n                // Fewer subcases: For nested types, skip atomic u32 and non-atomic i32.\n                if (p._containerDepth > 0) {\n                  if (scalarType === 'u32' && isAtomic) continue;\n                  if (scalarType === 'i32' && !isAtomic) continue;\n                }\n\n                yield {\n                  type: 'scalar',\n                  scalarType,\n                  isAtomic,\n                };\n                if (!isAtomic) {\n                  // Vector types\n                  for (const vectorType of kVectorContainerTypes) {\n                    // Fewer subcases: For nested types, only include\n                    // vec2<u32>, vec3<i32>, and vec4<f32>\n                    if (p._containerDepth > 0) {\n                      if (\n                        !(\n                          (vectorType === 'vec2' && scalarType === 'u32') ||\n                          (vectorType === 'vec3' && scalarType === 'i32') ||\n                          (vectorType === 'vec4' && scalarType === 'f32')\n                        )\n                      ) {\n                        continue;\n                      }\n                    }\n                    yield {\n                      type: 'container',\n                      containerType: vectorType,\n                      scalarType,\n                    };\n                  }\n                  // Matrices can only be f32.\n                  if (scalarType === 'f32') {\n                    for (const matrixType of kMatrixContainerTypes) {\n                      yield {\n                        type: 'container',\n                        containerType: matrixType,\n                        scalarType,\n                      };\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n\n          for (const containerType of ['array', 'struct']) {\n            const innerTypes = generateTypesMemo(depth - 1);\n            switch (containerType) {\n              case 'array':\n                for (const elementCount of kElementCounts[depth]) {\n                  for (const innerType of innerTypes) {\n                    yield {\n                      type: 'container',\n                      containerType,\n                      elementType: innerType,\n                      length: elementCount,\n                    };\n                  }\n                }\n                break;\n              case 'struct':\n                for (const memberCount of kMemberCounts) {\n                  const memberIndices = new Array(memberCount);\n                  for (let m = 0; m < memberCount; ++m) {\n                    memberIndices[m] = m;\n                  }\n\n                  // Don't generate all possible combinations of inner struct members,\n                  // because that's in the millions. Instead, just round-robin through\n                  // to pick member types. Loop through the types, concatenated forward\n                  // and backward, three times to produce a bounded but variable set of\n                  // types.\n                  const memberTypes = [...innerTypes, ...[...innerTypes].reverse()];\n                  const seenTypes = new Set();\n                  let typeIndex = 0;\n                  while (typeIndex < memberTypes.length * 3) {\n                    const prevTypeIndex = typeIndex;\n                    const members: ShaderTypeInfo[] = [];\n                    for (const m of memberIndices) {\n                      members[m] = memberTypes[typeIndex % memberTypes.length];\n                      typeIndex += 1;\n                    }\n\n                    const t: ShaderTypeInfo = {\n                      type: 'container',\n                      containerType,\n                      members,\n                    };\n                    const serializedT = prettyPrint(t);\n                    if (seenTypes.has(serializedT)) {\n                      // We produced an identical type. shuffle the member indices,\n                      // \"revert\" typeIndex back to where it was before this loop, and\n                      // shift it by one. This helps ensure we don't loop forever, and\n                      // that we produce a different type on the next iteration.\n                      memberIndices.push(memberIndices.shift());\n                      typeIndex = prevTypeIndex + 1;\n                      continue;\n                    }\n                    seenTypes.add(serializedT);\n                    yield t;\n                  }\n                }\n                break;\n            }\n          }\n        }\n\n        for (const t of generateTypesMemo(p._containerDepth)) {\n          yield {\n            shaderTypeParam: prettyPrint(t),\n            _type: t,\n          };\n        }\n      })\n  )\n  .batch(15)\n  .fn(async t => {\n    const { workgroupSize } = t.params;\n    const { maxComputeInvocationsPerWorkgroup } = t.device.limits;\n    const numWorkgroupInvocations = workgroupSize.reduce((a, b) => a * b);\n    t.skipIf(\n      numWorkgroupInvocations > maxComputeInvocationsPerWorkgroup,\n      `workgroupSize: ${workgroupSize} > maxComputeInvocationsPerWorkgroup: ${maxComputeInvocationsPerWorkgroup}`\n    );\n\n    let moduleScope = `\n      struct Output {\n        failed : atomic<u32>\n      }\n      @group(0) @binding(0) var<storage, read_write> output : Output;\n\n      // This uniform value that's a zero is used to prevent the shader compilers from trying to\n      // unroll the massive loops generated by these tests.\n      @group(0) @binding(1) var<uniform> zero : u32;\n    `;\n    let functionScope = '';\n\n    const declaredStructTypes = new Map<ShaderTypeInfo, string>();\n    const typeDecl = (function ensureType(\n      typeName: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `array<${ensureType(\n                `${typeName}_ArrayElement`,\n                type.elementType,\n                depth + 1\n              )}, ${type.length}>`;\n            case 'struct': {\n              if (declaredStructTypes.has(type)) {\n                return declaredStructTypes.get(type)!;\n              }\n\n              const members = type.members\n                .map((member, i) => {\n                  return `\\n    member${i} : ${ensureType(\n                    `${typeName}_Member${i}`,\n                    member,\n                    depth + 1\n                  )},`;\n                })\n                .join('');\n              declaredStructTypes.set(type, typeName);\n              moduleScope += `\\nstruct ${typeName} {`;\n              moduleScope += members;\n              moduleScope += '\\n};';\n\n              return typeName;\n            }\n            default:\n              return `${type.containerType}<${ensureType(\n                typeName,\n                {\n                  type: 'scalar',\n                  scalarType: type.scalarType,\n                  isAtomic: false,\n                },\n                depth + 1\n              )}>`;\n          }\n          break;\n        case 'scalar':\n          return type.isAtomic ? `atomic<${type.scalarType}>` : type.scalarType;\n      }\n    })('TestType', t.params._type);\n\n    switch (t.params.addressSpace) {\n      case 'workgroup':\n      case 'private':\n        moduleScope += `\\nvar<${t.params.addressSpace}> testVar: ${typeDecl};`;\n        break;\n      case 'function':\n        functionScope += `\\nvar testVar: ${typeDecl};`;\n        break;\n    }\n\n    const checkZeroCode = (function checkZero(\n      value: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `\\nfor (var i${depth} = 0u; i${depth} < ${\n                type.length\n              }u + zero; i${depth} = i${depth} + 1u) {\n                ${checkZero(`${value}[i${depth}]`, type.elementType, depth + 1)}\n              }`;\n            case 'struct':\n              return type.members\n                .map((member, i) => {\n                  return checkZero(`${value}.member${i}`, member, depth + 1);\n                })\n                .join('\\n');\n            default:\n              if (type.containerType.indexOf('vec') !== -1) {\n                const length = type.containerType[3];\n                return `\\nfor (var i${depth} = 0u; i${depth} < ${length}u + zero; i${depth} = i${depth} + 1u) {\n                  ${checkZero(\n                    `${value}[i${depth}]`,\n                    {\n                      type: 'scalar',\n                      scalarType: type.scalarType,\n                      isAtomic: false,\n                    },\n                    depth + 1\n                  )}\n                }`;\n              } else if (type.containerType.indexOf('mat') !== -1) {\n                const cols = type.containerType[3];\n                const rows = type.containerType[5];\n                return `\\nfor (var c${depth} = 0u; c${depth} < ${cols}u + zero; c${depth} = c${depth} + 1u) {\n                  for (var r${depth} = 0u; r${depth} < ${rows}u; r${depth} = r${depth} + 1u) {\n                    ${checkZero(\n                      `${value}[c${depth}][r${depth}]`,\n                      {\n                        type: 'scalar',\n                        scalarType: type.scalarType,\n                        isAtomic: false,\n                      },\n                      depth + 1\n                    )}\n                  }\n                }`;\n              } else {\n                unreachable();\n              }\n          }\n          break;\n        case 'scalar': {\n          let expected;\n          switch (type.scalarType) {\n            case 'bool':\n              expected = 'false';\n              break;\n            case 'f32':\n              expected = '0.0';\n              break;\n            case 'i32':\n              expected = '0';\n              break;\n            case 'u32':\n              expected = '0u';\n              break;\n          }\n          if (type.isAtomic) {\n            value = `atomicLoad(&${value})`;\n          }\n\n          // Note: this could have an early return, but we omit it because it makes\n          // the tests fail cause with DXGI_ERROR_DEVICE_HUNG on Windows.\n          return `\\nif (${value} != ${expected}) { atomicStore(&output.failed, 1u); }`;\n        }\n      }\n    })('testVar', t.params._type);\n\n    const wgsl = `\n      ${moduleScope}\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main() {\n        ${functionScope}\n        ${checkZeroCode}\n        _ = zero;\n      }\n    `;\n\n    if (t.params.addressSpace === 'workgroup') {\n      // Populate the maximum amount of workgroup memory with known values to\n      // ensure initialization overrides in another shader.\n      const wg_memory_limits = t.device.limits.maxComputeWorkgroupStorageSize;\n      const wg_x_dim = t.device.limits.maxComputeWorkgroupSizeX;\n\n      const wgsl = `\n      @group(0) @binding(0) var<storage, read> inputs : array<u32>;\n      @group(0) @binding(1) var<storage, read_write> outputs : array<u32>;\n      var<workgroup> wg_mem : array<u32, ${wg_memory_limits} / 4>;\n\n      @compute @workgroup_size(${wg_x_dim})\n      fn fill(@builtin(local_invocation_index) lid : u32) {\n        const num_u32_per_invocation = ${wg_memory_limits} / (4 * ${wg_x_dim});\n\n        for (var i = 0u; i < num_u32_per_invocation; i++) {\n          let idx = num_u32_per_invocation * lid + i;\n          wg_mem[idx] = inputs[idx];\n        }\n        workgroupBarrier();\n        // Copy out to avoid wg_mem being elided.\n        for (var i = 0u; i < num_u32_per_invocation; i++) {\n          let idx = num_u32_per_invocation * lid + i;\n          outputs[idx] = wg_mem[idx];\n        }\n      }\n      `;\n\n      const fillLayout = t.device.createBindGroupLayout({\n        entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'read-only-storage' },\n          },\n          {\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: 'storage' },\n          },\n        ],\n      });\n\n      const fillPipeline = await t.device.createComputePipelineAsync({\n        layout: t.device.createPipelineLayout({ bindGroupLayouts: [fillLayout] }),\n        label: 'Workgroup Fill Pipeline',\n        compute: {\n          module: t.device.createShaderModule({\n            code: wgsl,\n          }),\n          entryPoint: 'fill',\n        },\n      });\n\n      const inputBuffer = t.makeBufferWithContents(\n        new Uint32Array([...iterRange(wg_memory_limits / 4, _i => 0xdeadbeef)]),\n        GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n      );\n      t.trackForCleanup(inputBuffer);\n      const outputBuffer = t.device.createBuffer({\n        size: wg_memory_limits,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });\n      t.trackForCleanup(outputBuffer);\n\n      const bg = t.device.createBindGroup({\n        layout: fillPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: inputBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: {\n              buffer: outputBuffer,\n            },\n          },\n        ],\n      });\n\n      const e = t.device.createCommandEncoder();\n      const p = e.beginComputePass();\n      p.setPipeline(fillPipeline);\n      p.setBindGroup(0, bg);\n      p.dispatchWorkgroups(1);\n      p.end();\n      t.queue.submit([e.finish()]);\n    }\n\n    const pipeline = await t.device.createComputePipelineAsync({\n      layout: 'auto',\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const resultBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(resultBuffer);\n\n    const zeroBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n    t.trackForCleanup(zeroBuffer);\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: resultBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: zeroBuffer,\n          },\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n  });\n"],"mappings":"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"}