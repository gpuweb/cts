{"version":3,"sources":["../../../../src/webgpu/shader/execution/zero_init.spec.ts"],"names":["description","makeTestGroup","unreachable","GPUTest","kVectorContainerTypes","kMatrixContainerTypes","supportedScalarTypes","supportsAtomics","prettyPrint","t","type","containerType","elementType","length","members","map","m","join","scalarType","isAtomic","g","test","desc","params","u","combine","expand","storageClass","beginSubcases","expandWithParams","p","kElementCounts","kMemberCounts","memoizedTypes","generateTypesMemo","depth","undefined","Array","from","generateTypes","access","storageMode","_containerDepth","vectorType","matrixType","innerTypes","elementCount","innerType","memberCount","memberIndices","memberTypes","reverse","seenTypes","Set","typeIndex","prevTypeIndex","serializedT","has","push","shift","add","shaderTypeParam","_type","batch","fn","moduleScope","functionScope","declaredStructTypes","Map","typeDecl","ensureType","typeName","get","member","i","set","checkZeroCode","checkZero","value","indexOf","cols","rows","expected","wgsl","workgroupSize","pipeline","device","createComputePipeline","compute","module","createShaderModule","code","entryPoint","resultBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","trackForCleanup","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array"],"mappings":"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","sourcesContent":["export const description = `Test that variables in the shader are zero initialized`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { unreachable } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport {\n  ScalarType,\n  kVectorContainerTypes,\n  kVectorContainerTypeInfo,\n  kMatrixContainerTypes,\n  kMatrixContainerTypeInfo,\n  supportedScalarTypes,\n  supportsAtomics,\n} from '../types.js';\n\ntype ShaderTypeInfo =\n  | { type: 'container'; containerType: 'array'; elementType: ShaderTypeInfo; length: number }\n  | { type: 'container'; containerType: 'struct'; members: ShaderTypeInfo[] }\n  | {\n      type: 'container';\n      containerType: keyof typeof kVectorContainerTypeInfo | keyof typeof kMatrixContainerTypeInfo;\n      scalarType: ScalarType;\n    }\n  | { type: 'scalar'; scalarType: ScalarType; isAtomic: boolean };\n\nfunction prettyPrint(t: ShaderTypeInfo): string {\n  switch (t.type) {\n    case 'container':\n      switch (t.containerType) {\n        case 'array':\n          return `array<${prettyPrint(t.elementType)}, ${t.length}>`;\n        case 'struct':\n          return `struct { ${t.members.map(m => prettyPrint(m)).join(', ')} }`;\n        default:\n          return `${t.containerType}<${prettyPrint({\n            type: 'scalar',\n            scalarType: t.scalarType,\n            isAtomic: false,\n          })}>`;\n      }\n      break;\n    case 'scalar':\n      if (t.isAtomic) {\n        return `atomic<${t.scalarType}>`;\n      }\n      return t.scalarType;\n  }\n}\n\nexport const g = makeTestGroup(GPUTest);\ng.test('compute,zero_init')\n  .desc(\n    `Test that uninitialized variables in workgroup, private, and function storage classes are initialized to zero.\n\n    TODO: Run a shader before the test to attempt to fill memory with garbage`\n  )\n  .params(u =>\n    u\n      // Only workgroup, function, and private variables can be declared without data bound to them.\n      // The implementation's shader translator should ensure these values are initialized.\n      .combine('storageClass', ['workgroup', 'private', 'function'] as const)\n      .expand('workgroupSize', ({ storageClass }) => {\n        switch (storageClass) {\n          case 'workgroup':\n            return [\n              [1, 1, 1],\n              [1, 32, 1],\n              [64, 1, 1],\n              [1, 1, 48],\n              [1, 47, 1],\n              [33, 1, 1],\n              [1, 1, 63],\n              [8, 8, 2],\n              [7, 7, 3],\n            ];\n          case 'function':\n          case 'private':\n            return [[1, 1, 1]];\n        }\n      })\n      .beginSubcases()\n      // Fewer subases: Only 0 and 2. If double-nested containers work, single-nested should too.\n      .combine('_containerDepth', [0, 2])\n      .expandWithParams(function* (p) {\n        const kElementCounts = [\n          [], // Not used. Depth 0 is always scalars.\n          [1, 3, 67], // Test something above the workgroup size.\n          [1, 3],\n        ] as const;\n        const kMemberCounts = [1, 3] as const;\n\n        const memoizedTypes: ShaderTypeInfo[][] = [];\n\n        function generateTypesMemo(depth: number): ShaderTypeInfo[] {\n          if (memoizedTypes[depth] === undefined) {\n            memoizedTypes[depth] = Array.from(generateTypes(depth));\n          }\n          return memoizedTypes[depth];\n        }\n\n        function* generateTypes(depth: number): Generator<ShaderTypeInfo> {\n          if (depth === 0) {\n            for (const isAtomic of supportsAtomics({\n              ...p,\n              access: 'read_write',\n              storageMode: undefined,\n              containerType: 'scalar',\n            })\n              ? [true, false]\n              : [false]) {\n              for (const scalarType of supportedScalarTypes({ isAtomic, ...p })) {\n                // Fewer subcases: For nested types, skip atomic u32 and non-atomic i32.\n                if (p._containerDepth > 0) {\n                  if (scalarType === 'u32' && isAtomic) continue;\n                  if (scalarType === 'i32' && !isAtomic) continue;\n                }\n\n                yield {\n                  type: 'scalar',\n                  scalarType,\n                  isAtomic,\n                };\n                if (!isAtomic) {\n                  // Vector types\n                  for (const vectorType of kVectorContainerTypes) {\n                    // Fewer subcases: For nested types, only include\n                    // vec2<u32>, vec3<i32>, and vec4<f32>\n                    if (p._containerDepth > 0) {\n                      if (\n                        !(\n                          (vectorType === 'vec2' && scalarType === 'u32') ||\n                          (vectorType === 'vec3' && scalarType === 'i32') ||\n                          (vectorType === 'vec4' && scalarType === 'f32')\n                        )\n                      ) {\n                        continue;\n                      }\n                    }\n                    yield {\n                      type: 'container',\n                      containerType: vectorType,\n                      scalarType,\n                    };\n                  }\n                  // Matrices can only be f32.\n                  if (scalarType === 'f32') {\n                    for (const matrixType of kMatrixContainerTypes) {\n                      yield {\n                        type: 'container',\n                        containerType: matrixType,\n                        scalarType,\n                      };\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n\n          for (const containerType of ['array', 'struct']) {\n            const innerTypes = generateTypesMemo(depth - 1);\n            switch (containerType) {\n              case 'array':\n                for (const elementCount of kElementCounts[depth]) {\n                  for (const innerType of innerTypes) {\n                    yield {\n                      type: 'container',\n                      containerType,\n                      elementType: innerType,\n                      length: elementCount,\n                    };\n                  }\n                }\n                break;\n              case 'struct':\n                for (const memberCount of kMemberCounts) {\n                  const memberIndices = new Array(memberCount);\n                  for (let m = 0; m < memberCount; ++m) {\n                    memberIndices[m] = m;\n                  }\n\n                  // Don't generate all possible combinations of inner struct members,\n                  // because that's in the millions. Instead, just round-robin through\n                  // to pick member types. Loop through the types, concatenated forward\n                  // and backward, three times to produce a bounded but variable set of\n                  // types.\n                  const memberTypes = [...innerTypes, ...[...innerTypes].reverse()];\n                  const seenTypes = new Set();\n                  let typeIndex = 0;\n                  while (typeIndex < memberTypes.length * 3) {\n                    const prevTypeIndex = typeIndex;\n                    const members: ShaderTypeInfo[] = [];\n                    for (const m of memberIndices) {\n                      members[m] = memberTypes[typeIndex % memberTypes.length];\n                      typeIndex += 1;\n                    }\n\n                    const t: ShaderTypeInfo = {\n                      type: 'container',\n                      containerType,\n                      members,\n                    };\n                    const serializedT = prettyPrint(t);\n                    if (seenTypes.has(serializedT)) {\n                      // We produced an identical type. shuffle the member indices,\n                      // \"revert\" typeIndex back to where it was before this loop, and\n                      // shift it by one. This helps ensure we don't loop forever, and\n                      // that we produce a different type on the next iteration.\n                      memberIndices.push(memberIndices.shift());\n                      typeIndex = prevTypeIndex + 1;\n                      continue;\n                    }\n                    seenTypes.add(serializedT);\n                    yield t;\n                  }\n                }\n                break;\n            }\n          }\n        }\n\n        for (const t of generateTypesMemo(p._containerDepth)) {\n          yield {\n            shaderTypeParam: prettyPrint(t),\n            _type: t,\n          };\n        }\n      })\n  )\n  .batch(15)\n  .fn(async t => {\n    let moduleScope = `\n      struct Output {\n        failed : atomic<u32>\n      };\n      @group(0) @binding(0) var <storage, read_write> output : Output;\n    `;\n    let functionScope = '';\n\n    const declaredStructTypes = new Map<ShaderTypeInfo, string>();\n    const typeDecl = (function ensureType(\n      typeName: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `array<${ensureType(\n                `${typeName}_ArrayElement`,\n                type.elementType,\n                depth + 1\n              )}, ${type.length}>`;\n            case 'struct': {\n              if (declaredStructTypes.has(type)) {\n                return declaredStructTypes.get(type)!;\n              }\n\n              const members = type.members\n                .map((member, i) => {\n                  return `\\n    member${i} : ${ensureType(\n                    `${typeName}_Member${i}`,\n                    member,\n                    depth + 1\n                  )},`;\n                })\n                .join('');\n              declaredStructTypes.set(type, typeName);\n              moduleScope += `\\nstruct ${typeName} {`;\n              moduleScope += members;\n              moduleScope += '\\n};';\n\n              return typeName;\n            }\n            default:\n              return `${type.containerType}<${ensureType(\n                typeName,\n                {\n                  type: 'scalar',\n                  scalarType: type.scalarType,\n                  isAtomic: false,\n                },\n                depth + 1\n              )}>`;\n          }\n          break;\n        case 'scalar':\n          return type.isAtomic ? `atomic<${type.scalarType}>` : type.scalarType;\n      }\n    })('TestType', t.params._type);\n\n    switch (t.params.storageClass) {\n      case 'workgroup':\n      case 'private':\n        moduleScope += `\\nvar<${t.params.storageClass}> testVar: ${typeDecl};`;\n        break;\n      case 'function':\n        functionScope += `\\nvar testVar: ${typeDecl};`;\n        break;\n    }\n\n    const checkZeroCode = (function checkZero(\n      value: string,\n      type: ShaderTypeInfo,\n      depth: number = 0\n    ): string {\n      switch (type.type) {\n        case 'container':\n          switch (type.containerType) {\n            case 'array':\n              return `\\nfor (var i${depth} = 0u; i${depth} < ${\n                type.length\n              }u; i${depth} = i${depth} + 1u) {\n                ${checkZero(`${value}[i${depth}]`, type.elementType, depth + 1)}\n              }`;\n            case 'struct':\n              return type.members\n                .map((member, i) => {\n                  return checkZero(`${value}.member${i}`, member, depth + 1);\n                })\n                .join('\\n');\n            default:\n              if (type.containerType.indexOf('vec') !== -1) {\n                const length = type.containerType[3];\n                return `\\nfor (var i${depth} = 0u; i${depth} < ${length}u; i${depth} = i${depth} + 1u) {\n                  ${checkZero(\n                    `${value}[i${depth}]`,\n                    {\n                      type: 'scalar',\n                      scalarType: type.scalarType,\n                      isAtomic: false,\n                    },\n                    depth + 1\n                  )}\n                }`;\n              } else if (type.containerType.indexOf('mat') !== -1) {\n                const cols = type.containerType[3];\n                const rows = type.containerType[5];\n                return `\\nfor (var c${depth} = 0u; c${depth} < ${cols}u; c${depth} = c${depth} + 1u) {\n                  for (var r${depth} = 0u; r${depth} < ${rows}u; r${depth} = r${depth} + 1u) {\n                    ${checkZero(\n                      `${value}[c${depth}][r${depth}]`,\n                      {\n                        type: 'scalar',\n                        scalarType: type.scalarType,\n                        isAtomic: false,\n                      },\n                      depth + 1\n                    )}\n                  }\n                }`;\n              } else {\n                unreachable();\n              }\n          }\n          break;\n        case 'scalar': {\n          let expected;\n          switch (type.scalarType) {\n            case 'bool':\n              expected = 'false';\n              break;\n            case 'f32':\n              expected = '0.0';\n              break;\n            case 'i32':\n              expected = '0';\n              break;\n            case 'u32':\n              expected = '0u';\n              break;\n          }\n          if (type.isAtomic) {\n            value = `atomicLoad(&${value})`;\n          }\n\n          // Note: this could have an early return, but we omit it because it makes\n          // the tests fail cause with DXGI_ERROR_DEVICE_HUNG on Windows.\n          return `\\nif (${value} != ${expected}) { atomicStore(&output.failed, 1u); }`;\n        }\n      }\n    })('testVar', t.params._type);\n\n    const wgsl = `\n      ${moduleScope}\n      @stage(compute) @workgroup_size(${t.params.workgroupSize})\n      fn main() {\n        ${functionScope}\n        ${checkZeroCode}\n      }\n    `;\n\n    const pipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({\n          code: wgsl,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const resultBuffer = t.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    t.trackForCleanup(resultBuffer);\n\n    const bindGroup = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: resultBuffer,\n          },\n        },\n      ],\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatch(1);\n    pass.end();\n    t.queue.submit([encoder.finish()]);\n    t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n  });\n"],"file":"zero_init.spec.js"}