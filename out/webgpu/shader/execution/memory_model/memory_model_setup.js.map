{"version":3,"file":"memory_model_setup.js","names":["checkElementsPassPredicate","kAccessValueTypes","numMemLocations","numReadOutputs","numStressParams","barrierParamIndex","memStressIndex","memStressIterationsIndex","memStressPatternIndex","preStressIndex","preStressIterationsIndex","preStressPatternIndex","permuteFirstIndex","permuteSecondIndex","testingWorkgroupsIndex","memStrideIndex","memLocationOffsetIndex","bytesPerWord","shaderPreamble","accessValueType","MemoryModelTester","constructor","t","params","testShader","resultShader","test","testingThreads","workgroupSize","testingWorkgroups","testLocationsSize","memStride","testLocationsBuffer","deviceBuf","device","createBuffer","size","usage","GPUBufferUsage","COPY_DST","STORAGE","srcBuf","makeBufferWithContents","Uint32Array","fill","COPY_SRC","readResultsSize","readResultsBuffer","testResultsSize","numBehaviors","testResultsBuffer","shuffledWorkgroupsSize","maxWorkgroups","shuffledWorkgroupsBuffer","MAP_WRITE","barrierSize","barrierBuffer","scratchpadSize","scratchMemorySize","scratchpadBuffer","scratchMemoryLocationsSize","scratchMemoryLocationsBuffer","stressParamsSize","stressParamsBuffer","UNIFORM","buffers","testLocations","readResults","testResults","shuffledWorkgroups","barrier","scratchpad","scratchMemoryLocations","stressParams","testLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","testPipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","testBindGroup","createBindGroup","resource","resultLayout","resultPipeline","resultBindGroup","run","iterations","weakIndex","i","numWorkgroups","getRandomInRange","setShuffledWorkgroups","setScratchLocations","setStressParams","encoder","createCommandEncoder","copyBufferToBuffer","testPass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","resultPass","queue","submit","finish","expectGPUBufferValuesPassCheck","checkWeakIndex","typedLength","checkResult","resultPrinter","a","predicatePrinter","leftHeader","getValueForCell","v","getRandomInt","max","Math","floor","random","min","offset","shuffleArray","length","toSwap","temp","mapAsync","GPUMapMode","WRITE","getMappedRange","shuffledWorkgroupsArray","shufflePct","x","unmap","scratchLocationsArrayBuffer","scratchLocationsArray","scratchNumRegions","stressLineSize","scratchRegions","Array","keys","stressTargetLines","region","locInRegion","stressStrategyBalancePct","j","workgroupsPerLocation","stressParamsArrayBuffer","stressParamsArray","barrierPct","memStressPct","memStressIterations","memStressStoreFirst","memStressStoreFirstPct","memStressStoreSecond","memStressStoreSecondPct","memStressPattern","preStressPct","preStressIterations","preStressStoreFirst","preStressStoreFirstPct","preStressStoreSecond","preStressStoreSecondPct","preStressPattern","permuteFirst","permuteSecond","aliasedMemory","shaderMemStructures","fourBehaviorTestResultStructure","twoBehaviorTestResultStructure","commonTestShaderBindings","atomicTestShaderBindings","join","nonAtomicTestShaderBindings","resultShaderBindings","atomicWorkgroupMemory","nonAtomicWorkgroupMemory","memoryLocationFunctions","testShaderFunctions","shaderEntryPoint","testShaderCommonHeader","testShaderCommonCalculations","interWorkgroupTestShaderCode","intraWorkgroupTestShaderCode","storageIntraWorkgroupTestShaderCode","testShaderCommonFooter","resultShaderCommonCalculations","interWorkgroupResultShaderCode","intraWorkgroupResultShaderCode","resultShaderCommonFooter","storageMemoryAtomicTestShaderCode","storageMemoryNonAtomicTestShaderCode","workgroupMemoryAtomicTestShaderCode","workgroupMemoryNonAtomicTestShaderCode","resultShaderCommonCode","MemoryType","TestType","ResultType","buildTestShader","testCode","memoryType","testType","memoryTypeCode","isStorageAS","AtomicStorageClass","NonAtomicStorageClass","AtomicWorkgroupClass","NonAtomicWorkgroupClass","testTypeCode","InterWorkgroup","IntraWorkgroup","buildResultShader","resultCode","resultType","resultStructure","TwoBehavior","FourBehavior"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/memory_model_setup.ts"],"sourcesContent":["import { GPUTest } from '../../../gpu_test';\nimport { checkElementsPassPredicate } from '../../../util/check_contents.js';\n\n/* All buffer sizes are counted in units of 4-byte words. */\n\n/**\n * The value type loaded and stored from memory.\n * This is what the WGSL spec calls 'store type' for the locations being accessed.\n * The GPU buffers are sized assuming this type is at most 4 bytes.\n *\n * 'u32' is the default case; it can be atomically loaded and stored.\n * 'f16' is interesting because it is not 32-bits, and can't be the store type\n * for atomic accesses.\n */\nexport type AccessValueType = 'f16' | 'u32';\nexport const kAccessValueTypes = ['f16', 'u32'] as const;\n\n/* Parameter values are set heuristically, typically by a time-intensive search. */\nexport type MemoryModelTestParams = {\n  /* Number of invocations per workgroup. The workgroups are 1-dimensional. */\n  workgroupSize: number;\n  /** The number of workgroups to assign to running the test. */\n  testingWorkgroups: number;\n  /**\n   * Run no more than this many workgroups. Must be >= the number of testing workgroups. Non-testing workgroups are used\n   * to stress other memory locations.\n   */\n  maxWorkgroups: number;\n  /** The percentage of iterations to shuffle the workgroup ids. */\n  shufflePct: number;\n  /** The percentage of iterations to run the bounded spin-loop barrier. */\n  barrierPct: number;\n  /** The percentage of iterations to run memory stress using non-testing workgroups. */\n  memStressPct: number;\n  /** The number of iterations to run the memory stress pattern. */\n  memStressIterations: number;\n  /** The percentage of iterations the first instruction in the stress pattern should be a store. */\n  memStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the stress pattern should be a store. */\n  memStressStoreSecondPct: number;\n  /** The percentage of iterations for testing threads to run stress before running the test. */\n  preStressPct: number;\n  /** Same as for memStressIterations. */\n  preStressIterations: number;\n  /** The percentage of iterations the first instruction in the pre-stress pattern should be a store. */\n  preStressStoreFirstPct: number;\n  /** The percentage of iterations the second instruction in the pre-stress pattern should be a store. */\n  preStressStoreSecondPct: number;\n  /** The size of the scratch memory region, used for stressing threads. */\n  scratchMemorySize: number;\n  /** The size of each block of memory stressing threads access. */\n  stressLineSize: number;\n  /** The number of blocks of memory to assign stressing threads to. */\n  stressTargetLines: number;\n  /** How non-testing threads are assigned to stressing locations. 100 means all iterations use a round robin approach, 0 means all use a chunking approach. */\n  stressStrategyBalancePct: number;\n  /** Used to permute thread ids within a workgroup, so more random pairings are created between threads coordinating on a test. */\n  permuteFirst: number;\n  /** Used to create distance between memory locations used in a test. Set this to 1 for memory that should be aliased. */\n  permuteSecond: number;\n  /** The distance (in number of 4 byte intervals) between any two memory locations used for testing. */\n  memStride: number;\n  /** For tests that access one memory location, but use dynamic addresses to avoid compiler optimization, aliased memory should be set to true. */\n  aliasedMemory: boolean;\n  /** The number of possible behaviors that a test can have. */\n  numBehaviors: number;\n};\n\n/** The number of memory locations accessed by a test. Currently, only tests with up to 2 memory locations are supported. */\nconst numMemLocations = 2;\n\n/** The number of read outputs per test that need to be analyzed in the result aggregation shader. Currently, only tests with up to 2 read outputs are supported. */\nconst numReadOutputs = 2;\n\n/** Represents a device buffer and a utility buffer for resetting memory and copying parameters. */\ntype BufferWithSource = {\n  /** Buffer used by shader code. */\n  deviceBuf: GPUBuffer;\n  /** Buffer populated from the host size, data is copied to device buffer for use by shader. */\n  srcBuf: GPUBuffer;\n  /** Size in bytes of the buffer. */\n  size: number;\n};\n\n/** Specifies the buffers used during a memory model test. */\ntype MemoryModelBuffers = {\n  /** This is the memory region that testing threads read from and write to. */\n  testLocations: BufferWithSource;\n  /** This buffer collects the results of reads for analysis in the result aggregation shader. */\n  readResults: BufferWithSource;\n  /** This buffer is the aggregated results of every testing thread, and is used to check for test success/failure. */\n  testResults: BufferWithSource;\n  /** This buffer stores the shuffled workgroup ids for use during testing. Read-only in the shader. */\n  shuffledWorkgroups: BufferWithSource;\n  /** This is the bounded spin-loop barrier, used to temporally align testing threads. */\n  barrier: BufferWithSource;\n  /** Memory region for stressing threads to read to and write from. */\n  scratchpad: BufferWithSource;\n  /** The memory locations in the scratch region that stressing threads access. */\n  scratchMemoryLocations: BufferWithSource;\n  /** Parameters that are used by the shader to calculate memory locations and perform stress. */\n  stressParams: BufferWithSource;\n};\n\n/** The number of stress params to add to the stress params buffer. */\nconst numStressParams = 12;\nconst barrierParamIndex = 0;\nconst memStressIndex = 1;\nconst memStressIterationsIndex = 2;\nconst memStressPatternIndex = 3;\nconst preStressIndex = 4;\nconst preStressIterationsIndex = 5;\nconst preStressPatternIndex = 6;\nconst permuteFirstIndex = 7;\nconst permuteSecondIndex = 8;\nconst testingWorkgroupsIndex = 9;\nconst memStrideIndex = 10;\nconst memLocationOffsetIndex = 11;\n\n/**\n * All memory used in these consists of a four byte word, so this value is used to correctly set the byte size of buffers that\n * are read to/written from during tests and for storing test results.\n */\nconst bytesPerWord = 4;\n\n/**\n * Returns the shader preamble based on the access value type:\n *  - enable directives, if necessary\n *  - the type alias for AccessValueType\n */\nfunction shaderPreamble(accessValueType: AccessValueType): string {\n  if (accessValueType === 'f16') {\n    return 'enable f16;\\nalias AccessValueTy = f16;\\n';\n  }\n  return `alias AccessValueTy = ${accessValueType};\\n`;\n}\n\n/**\n * Implements setup code necessary to run a memory model test. A test consists of two parts:\n *  1.) A test shader that runs a specified memory model litmus test and attempts to reveal a weak (disallowed) behavior.\n *      At a high level, a test shader consists of a set of testing workgroups where every invocation executes the litmus test\n *      on a set of test locations, and a set of stressing workgroups where every invocation accesses a specified memory location\n *      in a random pattern.\n *\n *      The main buffer variables are:\n *\n *        `test_locations`: invocations access entries in this array, trying to\n *          evoke weak behaviours.\n *\n *          This is array<AccessValueTy> or array<atomic<u32>>.\n *          AccessValueTy is either f16 or u32.\n *          Note that atomic<u32> is only used when AccessValueTy is u32.\n *\n *        `results`: holds the observed values, which is where we can see\n *          whether a weak behaviour was observed.\n *\n *          This is an array<atomic<u32>>.\n *\n *      The others are used to parameterize and stress the main activity.\n *\n *  2.) A result shader that takes the output of the test shader, which consists of the memory locations accessed during the test\n *      and the results of any reads made during the test, and aggregate the results based on the possible behaviors of the test.\n *\n *      The first two buffer variables are the same buffers as for the test shader:\n *\n *        `test_locations` is the same as `test_locations` from the test shader,\n *        but is mapped as array<AccessValueTy>.\n *\n *        `read_results` is the same buffer as `results` from the test shader.\n *\n *      The other variables are used to accumulate a summary that counts the weak behaviours stimulated and recorded by the\n *      test shader.\n */\nexport class MemoryModelTester {\n  protected test: GPUTest;\n  protected params: MemoryModelTestParams;\n  protected buffers: MemoryModelBuffers;\n  protected testPipeline: GPUComputePipeline;\n  protected testBindGroup: GPUBindGroup;\n  protected resultPipeline: GPUComputePipeline;\n  protected resultBindGroup: GPUBindGroup;\n\n  /** Sets up a memory model test by initializing buffers and pipeline layouts. */\n  constructor(\n    t: GPUTest,\n    params: MemoryModelTestParams,\n    testShader: string,\n    resultShader: string,\n    accessValueType: AccessValueType = 'u32'\n  ) {\n    this.test = t;\n    this.params = params;\n\n    testShader = shaderPreamble(accessValueType) + testShader;\n    resultShader = shaderPreamble(accessValueType) + resultShader;\n\n    // set up buffers\n    const testingThreads = this.params.workgroupSize * this.params.testingWorkgroups;\n    const testLocationsSize =\n      testingThreads * numMemLocations * this.params.memStride * bytesPerWord;\n    const testLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(testLocationsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: testLocationsSize,\n    };\n\n    const readResultsSize = testingThreads * numReadOutputs * bytesPerWord;\n    const readResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(readResultsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: readResultsSize,\n    };\n\n    const testResultsSize = this.params.numBehaviors * bytesPerWord;\n    const testResultsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(testResultsSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: testResultsSize,\n    };\n\n    const shuffledWorkgroupsSize = this.params.maxWorkgroups * bytesPerWord;\n    const shuffledWorkgroupsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: shuffledWorkgroupsSize,\n    };\n\n    const barrierSize = bytesPerWord;\n    const barrierBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: barrierSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(barrierSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: barrierSize,\n    };\n\n    const scratchpadSize = this.params.scratchMemorySize * bytesPerWord;\n    const scratchpadBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: scratchpadSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.makeBufferWithContents(\n        new Uint32Array(scratchpadSize).fill(0),\n        GPUBufferUsage.COPY_SRC\n      ),\n      size: scratchpadSize,\n    };\n\n    const scratchMemoryLocationsSize = this.params.maxWorkgroups * bytesPerWord;\n    const scratchMemoryLocationsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: scratchMemoryLocationsSize,\n    };\n\n    const stressParamsSize = numStressParams * bytesPerWord;\n    const stressParamsBuffer: BufferWithSource = {\n      deviceBuf: this.test.device.createBuffer({\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n      }),\n      srcBuf: this.test.device.createBuffer({\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n      }),\n      size: stressParamsSize,\n    };\n\n    this.buffers = {\n      testLocations: testLocationsBuffer,\n      readResults: readResultsBuffer,\n      testResults: testResultsBuffer,\n      shuffledWorkgroups: shuffledWorkgroupsBuffer,\n      barrier: barrierBuffer,\n      scratchpad: scratchpadBuffer,\n      scratchMemoryLocations: scratchMemoryLocationsBuffer,\n      stressParams: stressParamsBuffer,\n    };\n\n    // set up pipeline layouts\n    const testLayout = this.test.device.createBindGroupLayout({\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 6, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.testPipeline = this.test.device.createComputePipeline({\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [testLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: testShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.testBindGroup = this.test.device.createBindGroup({\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.shuffledWorkgroups.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.barrier.deviceBuf } },\n        { binding: 4, resource: { buffer: this.buffers.scratchpad.deviceBuf } },\n        { binding: 5, resource: { buffer: this.buffers.scratchMemoryLocations.deviceBuf } },\n        { binding: 6, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: testLayout,\n    });\n\n    const resultLayout = this.test.device.createBindGroupLayout({\n      entries: [\n        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n      ],\n    });\n    this.resultPipeline = this.test.device.createComputePipeline({\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [resultLayout],\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: resultShader,\n        }),\n        entryPoint: 'main',\n      },\n    });\n    this.resultBindGroup = this.test.device.createBindGroup({\n      entries: [\n        { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n        { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n        { binding: 2, resource: { buffer: this.buffers.testResults.deviceBuf } },\n        { binding: 3, resource: { buffer: this.buffers.stressParams.deviceBuf } },\n      ],\n      layout: resultLayout,\n    });\n  }\n\n  /**\n   * Run the test for the specified number of iterations. Checks the testResults buffer on the weakIndex; if\n   * this value is not 0 then the test has failed. The number of iterations is chosen per test so that the\n   * full set of tests meets some time budget while still being reasonably effective at uncovering issues.\n   * Currently, we aim for each test to complete in under one second.\n   */\n  async run(iterations: number, weakIndex: number): Promise<void> {\n    for (let i = 0; i < iterations; i++) {\n      const numWorkgroups = this.getRandomInRange(\n        this.params.testingWorkgroups,\n        this.params.maxWorkgroups\n      );\n      await this.setShuffledWorkgroups(numWorkgroups);\n      await this.setScratchLocations(numWorkgroups);\n      await this.setStressParams();\n      const encoder = this.test.device.createCommandEncoder();\n      this.copyBufferToBuffer(encoder, this.buffers.testLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.readResults);\n      this.copyBufferToBuffer(encoder, this.buffers.testResults);\n      this.copyBufferToBuffer(encoder, this.buffers.barrier);\n      this.copyBufferToBuffer(encoder, this.buffers.shuffledWorkgroups);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchpad);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchMemoryLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.stressParams);\n\n      const testPass = encoder.beginComputePass();\n      testPass.setPipeline(this.testPipeline);\n      testPass.setBindGroup(0, this.testBindGroup);\n      testPass.dispatchWorkgroups(numWorkgroups);\n      testPass.end();\n\n      const resultPass = encoder.beginComputePass();\n      resultPass.setPipeline(this.resultPipeline);\n      resultPass.setBindGroup(0, this.resultBindGroup);\n      resultPass.dispatchWorkgroups(this.params.testingWorkgroups);\n      resultPass.end();\n\n      this.test.device.queue.submit([encoder.finish()]);\n      this.test.expectGPUBufferValuesPassCheck(\n        this.buffers.testResults.deviceBuf,\n        this.checkWeakIndex(weakIndex),\n        {\n          type: Uint32Array,\n          typedLength: this.params.numBehaviors,\n        }\n      );\n    }\n  }\n\n  /** Returns a function that checks whether the test passes, given a weak index and the test results buffer. */\n  protected checkWeakIndex(weakIndex: number): (a: Uint32Array) => Error | undefined {\n    const checkResult = this.checkResult(weakIndex);\n    const resultPrinter = this.resultPrinter(weakIndex);\n    return function (a: Uint32Array): Error | undefined {\n      return checkElementsPassPredicate(a, checkResult, {\n        predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: resultPrinter }],\n      });\n    };\n  }\n\n  /**\n   * Returns a function that checks whether the specified weak index's value is not equal to 0.\n   * If the weak index's value is not 0, it means the test has observed a behavior disallowed by the memory model and\n   * is considered a test failure.\n   */\n  protected checkResult(weakIndex: number): (i: number, v: number) => boolean {\n    return function (i: number, v: number): boolean {\n      if (i === weakIndex && v > 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /** Returns a printer function that visualizes the results of checking the test results. */\n  protected resultPrinter(weakIndex: number): (i: number) => string | number {\n    return function (i: number): string | number {\n      if (i === weakIndex) {\n        return 0;\n      } else {\n        return 'any value';\n      }\n    };\n  }\n\n  /** Utility method that simplifies copying source buffers to device buffers. */\n  protected copyBufferToBuffer(encoder: GPUCommandEncoder, buffer: BufferWithSource): void {\n    encoder.copyBufferToBuffer(buffer.srcBuf, 0, buffer.deviceBuf, 0, buffer.size);\n  }\n\n  /** Returns a random integer between 0 and the max. */\n  protected getRandomInt(max: number): number {\n    return Math.floor(Math.random() * max);\n  }\n\n  /** Returns a random number in between the min and max values. */\n  protected getRandomInRange(min: number, max: number): number {\n    if (min === max) {\n      return min;\n    } else {\n      const offset = this.getRandomInt(max - min);\n      return min + offset;\n    }\n  }\n\n  /** Returns a permuted array using a simple Fisher-Yates shuffle algorithm. */\n  protected shuffleArray(a: number[]): void {\n    for (let i = a.length - 1; i >= 0; i--) {\n      const toSwap = this.getRandomInt(i + 1);\n      const temp = a[toSwap];\n      a[toSwap] = a[i];\n      a[i] = temp;\n    }\n  }\n\n  /**\n   * Shuffles the order of workgroup ids, so that threads operating on the same memory location are not always in\n   * consecutive workgroups.\n   */\n  protected async setShuffledWorkgroups(numWorkgroups: number): Promise<void> {\n    await this.buffers.shuffledWorkgroups.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const shuffledWorkgroupsBuffer = this.buffers.shuffledWorkgroups.srcBuf.getMappedRange();\n    const shuffledWorkgroupsArray = new Uint32Array(shuffledWorkgroupsBuffer);\n    for (let i = 0; i < numWorkgroups; i++) {\n      shuffledWorkgroupsArray[i] = i;\n    }\n    if (this.getRandomInt(100) < this.params.shufflePct) {\n      for (let i = numWorkgroups - 1; i > 0; i--) {\n        const x = this.getRandomInt(i + 1);\n        const temp = shuffledWorkgroupsArray[i];\n        shuffledWorkgroupsArray[i] = shuffledWorkgroupsArray[x];\n        shuffledWorkgroupsArray[x] = temp;\n      }\n    }\n    this.buffers.shuffledWorkgroups.srcBuf.unmap();\n  }\n\n  /** Sets the memory locations that stressing workgroups will access. Uses either a chunking or round robin assignment strategy. */\n  protected async setScratchLocations(numWorkgroups: number): Promise<void> {\n    await this.buffers.scratchMemoryLocations.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const scratchLocationsArrayBuffer = this.buffers.scratchMemoryLocations.srcBuf.getMappedRange();\n    const scratchLocationsArray = new Uint32Array(scratchLocationsArrayBuffer);\n    const scratchNumRegions = this.params.scratchMemorySize / this.params.stressLineSize;\n    const scratchRegions = [...Array(scratchNumRegions).keys()];\n    this.shuffleArray(scratchRegions);\n    for (let i = 0; i < this.params.stressTargetLines; i++) {\n      const region = scratchRegions[i];\n      const locInRegion = this.getRandomInt(this.params.stressLineSize);\n      if (this.getRandomInt(100) < this.params.stressStrategyBalancePct) {\n        // In the round-robin case, the current scratch location is striped across all workgroups.\n        for (let j = i; j < numWorkgroups; j += this.params.stressTargetLines) {\n          scratchLocationsArray[j] = region * this.params.stressLineSize + locInRegion;\n        }\n      } else {\n        // In the chunking case, the current scratch location is assigned to a block of workgroups. The final scratch\n        // location may be assigned to more workgroups, if the number of scratch locations does not cleanly divide the\n        // number of workgroups.\n        const workgroupsPerLocation = numWorkgroups / this.params.stressTargetLines;\n        for (let j = 0; j < workgroupsPerLocation; j++) {\n          scratchLocationsArray[i * workgroupsPerLocation + j] =\n            region * this.params.stressLineSize + locInRegion;\n        }\n        if (\n          i === this.params.stressTargetLines - 1 &&\n          numWorkgroups % this.params.stressTargetLines !== 0\n        ) {\n          for (let j = 0; j < numWorkgroups % this.params.stressTargetLines; j++) {\n            scratchLocationsArray[numWorkgroups - j - 1] =\n              region * this.params.stressLineSize + locInRegion;\n          }\n        }\n      }\n    }\n    this.buffers.scratchMemoryLocations.srcBuf.unmap();\n  }\n\n  /** Sets the parameters that are used by the shader to calculate memory locations and perform stress. */\n  protected async setStressParams(): Promise<void> {\n    await this.buffers.stressParams.srcBuf.mapAsync(GPUMapMode.WRITE);\n    const stressParamsArrayBuffer = this.buffers.stressParams.srcBuf.getMappedRange();\n    const stressParamsArray = new Uint32Array(stressParamsArrayBuffer);\n    if (this.getRandomInt(100) < this.params.barrierPct) {\n      stressParamsArray[barrierParamIndex] = 1;\n    } else {\n      stressParamsArray[barrierParamIndex] = 0;\n    }\n    if (this.getRandomInt(100) < this.params.memStressPct) {\n      stressParamsArray[memStressIndex] = 1;\n    } else {\n      stressParamsArray[memStressIndex] = 0;\n    }\n    stressParamsArray[memStressIterationsIndex] = this.params.memStressIterations;\n    const memStressStoreFirst = this.getRandomInt(100) < this.params.memStressStoreFirstPct;\n    const memStressStoreSecond = this.getRandomInt(100) < this.params.memStressStoreSecondPct;\n    let memStressPattern;\n    if (memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 0;\n    } else if (memStressStoreFirst && !memStressStoreSecond) {\n      memStressPattern = 1;\n    } else if (!memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 2;\n    } else {\n      memStressPattern = 3;\n    }\n    stressParamsArray[memStressPatternIndex] = memStressPattern;\n    if (this.getRandomInt(100) < this.params.preStressPct) {\n      stressParamsArray[preStressIndex] = 1;\n    } else {\n      stressParamsArray[preStressIndex] = 0;\n    }\n    stressParamsArray[preStressIterationsIndex] = this.params.preStressIterations;\n    const preStressStoreFirst = this.getRandomInt(100) < this.params.preStressStoreFirstPct;\n    const preStressStoreSecond = this.getRandomInt(100) < this.params.preStressStoreSecondPct;\n    let preStressPattern;\n    if (preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 0;\n    } else if (preStressStoreFirst && !preStressStoreSecond) {\n      preStressPattern = 1;\n    } else if (!preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 2;\n    } else {\n      preStressPattern = 3;\n    }\n    stressParamsArray[preStressPatternIndex] = preStressPattern;\n    stressParamsArray[permuteFirstIndex] = this.params.permuteFirst;\n    stressParamsArray[permuteSecondIndex] = this.params.permuteSecond;\n    stressParamsArray[testingWorkgroupsIndex] = this.params.testingWorkgroups;\n    stressParamsArray[memStrideIndex] = this.params.memStride;\n    if (this.params.aliasedMemory) {\n      stressParamsArray[memLocationOffsetIndex] = 0;\n    } else {\n      stressParamsArray[memLocationOffsetIndex] = this.params.memStride;\n    }\n    this.buffers.stressParams.srcBuf.unmap();\n  }\n}\n\n/** Defines common data structures used in memory model test shaders. */\nconst shaderMemStructures = `\n  struct Memory {\n    value: array<AccessValueTy>\n  };\n\n  struct AtomicMemory {\n    value: array<atomic<u32>>\n  };\n\n  struct IndexMemory {\n    value: array<u32>\n  };\n\n  struct ReadResult {\n    r0: atomic<u32>,\n    r1: atomic<u32>,\n  };\n\n  struct ReadResults {\n    value: array<ReadResult>\n  };\n\n  struct StressParamsMemory {\n    do_barrier: u32,\n    mem_stress: u32,\n    mem_stress_iterations: u32,\n    mem_stress_pattern: u32,\n    pre_stress: u32,\n    pre_stress_iterations: u32,\n    pre_stress_pattern: u32,\n    permute_first: u32,\n    permute_second: u32,\n    testing_workgroups: u32,\n    mem_stride: u32,\n    location_offset: u32,\n  };\n`;\n\n/**\n * Structure to hold the counts of occurrences of the possible behaviors of a two-thread, four-instruction test.\n * \"seq0\" means the first invocation's instructions are observed to have occurred before the second invocation's instructions.\n * \"seq1\" means the second invocation's instructions are observed to have occurred before the first invocation's instructions.\n * \"interleaved\" means there was an observation of some interleaving of instructions between the two invocations.\n * \"weak\" means there was an observation of some ordering of instructions that is inconsistent with the WebGPU memory model.\n */\nconst fourBehaviorTestResultStructure = `\n  struct TestResults {\n    seq0: atomic<u32>,\n    seq1: atomic<u32>,\n    interleaved: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/**\n * Defines the possible behaviors of a two instruction test. Used to test the behavior of non-atomic memory with barriers and\n * one-thread coherence tests.\n * \"seq\" means that the expected, sequential behavior occurred.\n * \"weak\" means that an unexpected, inconsistent behavior occurred.\n */\nconst twoBehaviorTestResultStructure = `\n  struct TestResults {\n    seq: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/** Common bindings used in the test shader phase of a test. */\nconst commonTestShaderBindings = `\n  @group(0) @binding(1) var<storage, read_write> results : ReadResults;\n  @group(0) @binding(2) var<storage, read> shuffled_workgroups : IndexMemory;\n  @group(0) @binding(3) var<storage, read_write> barrier : AtomicMemory;\n  @group(0) @binding(4) var<storage, read_write> scratchpad : IndexMemory;\n  @group(0) @binding(5) var<storage, read_write> scratch_locations : IndexMemory;\n  @group(0) @binding(6) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/** The combined bindings for a test on atomic memory. */\nconst atomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** The combined bindings for a test on non-atomic memory. */\nconst nonAtomicTestShaderBindings = [\n  `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n`,\n  commonTestShaderBindings,\n].join('\\n');\n\n/** Bindings used in the result aggregation phase of the test. */\nconst resultShaderBindings = `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n  @group(0) @binding(1) var<storage, read_write> read_results : ReadResults;\n  @group(0) @binding(2) var<storage, read_write> test_results : TestResults;\n  @group(0) @binding(3) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/**\n * For tests that operate on workgroup memory, include this definition. 3584 memory locations is\n * large enough to accommodate the maximum memory size needed per workgroup for testing, which is\n * 256 invocations per workgroup x 2 memory locations x 7 (memStride, or max stride between successive memory locations).\n * Should change to a pipeline overridable constant when possible.\n */\nconst atomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<atomic<u32>, 3584>;\n`;\n\n/**\n * For tests that operate on non-atomic workgroup memory, include this definition. 3584 memory locations\n * is large enough to accommodate the maximum memory size needed per workgroup for testing.\n */\nconst nonAtomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<AccessValueTy, 3584>;\n`;\n\n/**\n * Functions used to calculate memory locations for each invocation, for both testing and result aggregation.\n * The permute function ensures a random permutation based on multiplying and modding by coprime numbers. The stripe\n * workgroup function ensures that invocations coordinating on a test are spread out across different workgroups.\n */\nconst memoryLocationFunctions = `\n  fn permute_id(id: u32, factor: u32, mask: u32) -> u32 {\n    return (id * factor) % mask;\n  }\n\n  fn stripe_workgroup(workgroup_id: u32, local_id: u32) -> u32 {\n    return (workgroup_id + 1u + local_id % (stress_params.testing_workgroups - 1u)) % stress_params.testing_workgroups;\n  }\n`;\n\n/** Functions that help add stress to the test. */\nconst testShaderFunctions = `\n  //Force the invocations in the workgroup to wait for each other, but without the general memory ordering\n  // effects of a control barrier. The barrier spins until either all invocations have incremented the atomic\n  // variable or 1024 loops have occurred. 1024 was chosen because it gives more time for invocations to enter\n  // the barrier but does not overly reduce testing throughput.\n  fn spin(limit: u32) {\n    var i : u32 = 0u;\n    var bar_val : u32 = atomicAdd(&barrier.value[0], 1u);\n    loop {\n      if (i == 1024u || bar_val >= limit) {\n        break;\n      }\n      bar_val = atomicAdd(&barrier.value[0], 0u);\n      i = i + 1u;\n    }\n  }\n\n  // Perform iterations of stress, depending on the specified pattern. Pattern 0 is store-store, pattern 1 is store-load,\n  // pattern 2 is load-store, and pattern 3 is load-load. The extra if condition (if tmpX > 100000u), is used to avoid\n  // the compiler optimizing out unused loads, where 100,000 is larger than the maximum number of stress iterations used\n  // in any test.\n  fn do_stress(iterations: u32, pattern: u32, workgroup_id: u32) {\n    let addr = scratch_locations.value[workgroup_id];\n    switch(pattern) {\n      case 0u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          scratchpad.value[addr] = i;\n          scratchpad.value[addr] = i + 1u;\n        }\n      }\n      case 1u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          scratchpad.value[addr] = i;\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      case 2u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n          scratchpad.value[addr] = i;\n        }\n      }\n      case 3u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n          let tmp2: u32 = scratchpad.value[addr];\n          if (tmp2 > 100000u) {\n            scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      default: {\n      }\n    }\n  }\n`;\n\n/**\n * Entry point to both test and result shaders. One-dimensional workgroup size is hardcoded to 256, until\n * pipeline overridable constants are supported.\n */\nconst shaderEntryPoint = `\n  // Change to pipeline overridable constant when possible.\n  const workgroupXSize = 256u;\n  @compute @workgroup_size(workgroupXSize) fn main(\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>) {\n`;\n\n/** All test shaders first calculate the shuffled workgroup. */\nconst testShaderCommonHeader = `\n    let shuffled_workgroup = shuffled_workgroups.value[workgroup_id[0]];\n    if (shuffled_workgroup < stress_params.testing_workgroups) {\n`;\n\n/**\n * All test shaders must calculate addresses for memory locations used in the test. Not all these addresses are\n * used in every test, but no test uses more than these addresses.\n */\nconst testShaderCommonCalculations = `\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = id_1 * stress_params.mem_stride * 2u;\n  let y_1 = permute_id(id_1, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n`;\n\n/**\n * An inter-workgroup test calculates two sets of memory locations that are guaranteed to be in separate workgroups.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in all workgroups.\n */\nconst interWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let id_0 = shuffled_workgroup * workgroupXSize + local_invocation_id[0];\n  let new_workgroup = stripe_workgroup(shuffled_workgroup, local_invocation_id[0]);\n  let id_1 = new_workgroup * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize * stress_params.testing_workgroups);\n  }\n`,\n].join('\\n');\n\n/**\n * An intra-workgroup test calculates two set of memory locations that are guaranteed to be in the same workgroup.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in the same workgroup.\n */\nconst intraWorkgroupTestShaderCode = [\n  `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\n  testShaderCommonCalculations,\n  `\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`,\n].join('\\n');\n\n/**\n * Tests that operate on storage memory and communicate with invocations in the same workgroup must offset their locations\n * relative to global memory.\n */\nconst storageIntraWorkgroupTestShaderCode = `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n  let x_0 = (shuffled_workgroup * workgroupXSize + id_0) * stress_params.mem_stride * 2u;\n  let y_0 = (shuffled_workgroup * workgroupXSize + permute_id(id_0, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = (shuffled_workgroup * workgroupXSize + id_1) * stress_params.mem_stride * 2u;\n  let y_1 = (shuffled_workgroup * workgroupXSize + permute_id(id_1, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`;\n\n/** All test shaders may perform stress with non-testing threads. */\nconst testShaderCommonFooter = `\n    } else if (stress_params.mem_stress == 1u) {\n      do_stress(stress_params.mem_stress_iterations, stress_params.mem_stress_pattern, shuffled_workgroup);\n    }\n  }\n`;\n\n/**\n * All result shaders must calculate memory locations used in the test. Not all these locations are\n * used in every result shader, but no result shader uses more than these locations.\n *\n * Each value read from test_locations is converted from AccessValueTy to u32\n * before storing it in the read result.  This assumes u32(AccessValueTy)\n * is either an identity function u32(u32) or a value-converting overload such\n * as u32(f16).\n */\nconst resultShaderCommonCalculations = `\n  let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let mem_x_0 = u32(test_locations.value[x_0]);\n  let r0 = atomicLoad(&read_results.value[id_0].r0);\n  let r1 = atomicLoad(&read_results.value[id_0].r1);\n`;\n\n/** Common result shader code for an inter-workgroup test. */\nconst interWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Common result shader code for an intra-workgroup test. */\nconst intraWorkgroupResultShaderCode = [\n  resultShaderCommonCalculations,\n  `\n  let total_ids = workgroupXSize;\n  let y_0 = (workgroup_id[0] * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`,\n].join('\\n');\n\n/** Ending bracket for result shaders. */\nconst resultShaderCommonFooter = `\n}\n`;\n\n/** The common shader code for test shaders that perform atomic storage class memory litmus tests. */\nconst storageMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic storage class memory litmus tests. */\nconst storageMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform atomic workgroup class memory litmus tests. */\nconst workgroupMemoryAtomicTestShaderCode = [\n  shaderMemStructures,\n  atomicTestShaderBindings,\n  atomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for test shaders that perform non-atomic workgroup class memory litmus tests. */\nconst workgroupMemoryNonAtomicTestShaderCode = [\n  shaderMemStructures,\n  nonAtomicTestShaderBindings,\n  nonAtomicWorkgroupMemory,\n  memoryLocationFunctions,\n  testShaderFunctions,\n  shaderEntryPoint,\n  testShaderCommonHeader,\n].join('\\n');\n\n/** The common shader code for all result shaders. */\nconst resultShaderCommonCode = [\n  shaderMemStructures,\n  resultShaderBindings,\n  memoryLocationFunctions,\n  shaderEntryPoint,\n].join('\\n');\n\n/**\n * Defines the types of possible memory a test is operating on. Used as part of the process of building shader code from\n * its composite parts.\n */\nexport enum MemoryType {\n  /** Atomic memory in the storage address space. */\n  AtomicStorageClass = 'atomic_storage',\n  /** Non-atomic memory in the storage address space. */\n  NonAtomicStorageClass = 'non_atomic_storage',\n  /** Atomic memory in the workgroup address space. */\n  AtomicWorkgroupClass = 'atomic_workgroup',\n  /** Non-atomic memory in the workgroup address space. */\n  NonAtomicWorkgroupClass = 'non_atomic_workgroup',\n}\n\n/**\n * Defines the relative positions of two invocations coordinating on a test. Used as part of the process of building shader\n * code from its composite parts.\n */\nexport enum TestType {\n  /** A test consists of two invocations in different workgroups. */\n  InterWorkgroup = 'inter_workgroup',\n  /** A test consists of two invocations in the same workgroup. */\n  IntraWorkgroup = 'intra_workgroup',\n}\n\n/** Defines the number of behaviors a test may have. */\nexport enum ResultType {\n  TwoBehavior,\n  FourBehavior,\n}\n\n/**\n * Given test code that performs the actual sequence of loads and stores, as well as a memory type and test type, returns\n * a complete test shader.\n */\nexport function buildTestShader(\n  testCode: string,\n  memoryType: MemoryType,\n  testType: TestType\n): string {\n  let memoryTypeCode;\n  let isStorageAS = false;\n  switch (memoryType) {\n    case MemoryType.AtomicStorageClass:\n      memoryTypeCode = storageMemoryAtomicTestShaderCode;\n      isStorageAS = true;\n      break;\n    case MemoryType.NonAtomicStorageClass:\n      memoryTypeCode = storageMemoryNonAtomicTestShaderCode;\n      isStorageAS = true;\n      break;\n    case MemoryType.AtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryNonAtomicTestShaderCode;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupTestShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      if (isStorageAS) {\n        testTypeCode = storageIntraWorkgroupTestShaderCode;\n      } else {\n        testTypeCode = intraWorkgroupTestShaderCode;\n      }\n  }\n  return [memoryTypeCode, testTypeCode, testCode, testShaderCommonFooter].join('\\n');\n}\n\n/**\n * Given result code that aggregates the possible behaviors of a test across all instances, as well as a test type and\n * number of behaviors, returns a complete result shader.\n */\nexport function buildResultShader(\n  resultCode: string,\n  testType: TestType,\n  resultType: ResultType\n): string {\n  let resultStructure;\n  switch (resultType) {\n    case ResultType.TwoBehavior:\n      resultStructure = twoBehaviorTestResultStructure;\n      break;\n    case ResultType.FourBehavior:\n      resultStructure = fourBehaviorTestResultStructure;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupResultShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupResultShaderCode;\n  }\n  return [\n    resultStructure,\n    resultShaderCommonCode,\n    testTypeCode,\n    resultCode,\n    resultShaderCommonFooter,\n  ].join('\\n');\n}\n"],"mappings":"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AkB,CAAC,GAAG,IAAI,CAACU,MAAM,CAAC8J,aAAa;IACjEjB,iBAAiB,CAACtJ,sBAAsB,CAAC,GAAG,IAAI,CAACS,MAAM,CAACM,iBAAiB;IACzEuI,iBAAiB,CAACrJ,cAAc,CAAC,GAAG,IAAI,CAACQ,MAAM,CAACQ,SAAS;IACzD,IAAI,IAAI,CAACR,MAAM,CAAC+J,aAAa,EAAE;MAC7BlB,iBAAiB,CAACpJ,sBAAsB,CAAC,GAAG,CAAC;IAC/C,CAAC,MAAM;MACLoJ,iBAAiB,CAACpJ,sBAAsB,CAAC,GAAG,IAAI,CAACO,MAAM,CAACQ,SAAS;IACnE;IACA,IAAI,CAACkC,OAAO,CAACQ,YAAY,CAAChC,MAAM,CAAC4G,KAAK,EAAE;EAC1C;AACF;;AAEA;AACA,MAAMkC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAG;AAC9B;AACH;AACA,CAAC;AACCD,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMC,2BAA2B,GAAG;AACjC;AACH;AACA,CAAC;AACCH,wBAAwB,CACzB;AAACE,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAME,oBAAoB,GAAI;AAC9B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAI;AAC/B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAI;AAClC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,mBAAmB,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAI;AAChC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAG;AAClC;AACH;AACA;AACA;AACA;AACA,CAAC;AACCD,4BAA4B;AAC3B;AACH;AACA;AACA;AACA,CAAC,CACA;AAACT,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA;AACA;AACA;AACA,MAAMW,4BAA4B,GAAG;AAClC;AACH;AACA;AACA;AACA,CAAC;AACCF,4BAA4B;AAC3B;AACH;AACA;AACA;AACA,CAAC,CACA;AAACT,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA;AACA;AACA;AACA,MAAMY,mCAAmC,GAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAI;AAChC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAI;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,8BAA8B,GAAG;AACrCD,8BAA8B;AAC7B;AACH;AACA;AACA;AACA,CAAC,CACA;AAACd,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMgB,8BAA8B,GAAG;AACrCF,8BAA8B;AAC7B;AACH;AACA;AACA;AACA,CAAC,CACA;AAACd,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMiB,wBAAwB,GAAI;AAClC;AACA,CAAC;;AAED;AACA,MAAMC,iCAAiC,GAAG;AACxCvB,mBAAmB;AACnBI,wBAAwB;AACxBM,uBAAuB;AACvBC,mBAAmB;AACnBC,gBAAgB;AAChBC,sBAAsB,CACvB;AAACR,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMmB,oCAAoC,GAAG;AAC3CxB,mBAAmB;AACnBM,2BAA2B;AAC3BI,uBAAuB;AACvBC,mBAAmB;AACnBC,gBAAgB;AAChBC,sBAAsB,CACvB;AAACR,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMoB,mCAAmC,GAAG;AAC1CzB,mBAAmB;AACnBI,wBAAwB;AACxBI,qBAAqB;AACrBE,uBAAuB;AACvBC,mBAAmB;AACnBC,gBAAgB;AAChBC,sBAAsB,CACvB;AAACR,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMqB,sCAAsC,GAAG;AAC7C1B,mBAAmB;AACnBM,2BAA2B;AAC3BG,wBAAwB;AACxBC,uBAAuB;AACvBC,mBAAmB;AACnBC,gBAAgB;AAChBC,sBAAsB,CACvB;AAACR,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA,MAAMsB,sBAAsB,GAAG;AAC7B3B,mBAAmB;AACnBO,oBAAoB;AACpBG,uBAAuB;AACvBE,gBAAgB,CACjB;AAACP,IAAI,CAAC,IAAI,CAAC;;AAEZ;AACA;AACA;AACA;AACA,WAAYuB,UAAU;;;;;;;;;;;AAWtB;AACA;AACA;AACA,GAHA,WAXYA,UAAU,GAAVA,UAAU,0CAAVA,UAAU,iDAAVA,UAAU,8CAAVA,UAAU,wDAAVA,UAAU,KAAVA,UAAU;AAetB,WAAYC,QAAQ;;;;;;;AAOpB,kEAPYA,QAAQ,GAARA,QAAQ,uCAARA,QAAQ,0CAARA,QAAQ,KAARA,QAAQ;AAQpB,WAAYC,UAAU;;;;;AAKtB;AACA;AACA;AACA,GAHA,WALYA,UAAU,GAAVA,UAAU,CAAVA,UAAU,qCAAVA,UAAU,CAAVA,UAAU,0CAAVA,UAAU,KAAVA,UAAU;AAStB,OAAO,SAASC,eAAe;AAC7BC,QAAgB;AAChBC,UAAsB;AACtBC,QAAkB;AACV;EACR,IAAIC,cAAc;EAClB,IAAIC,WAAW,GAAG,KAAK;EACvB,QAAQH,UAAU;IAChB,KAAKL,UAAU,CAACS,kBAAkB;MAChCF,cAAc,GAAGZ,iCAAiC;MAClDa,WAAW,GAAG,IAAI;MAClB;IACF,KAAKR,UAAU,CAACU,qBAAqB;MACnCH,cAAc,GAAGX,oCAAoC;MACrDY,WAAW,GAAG,IAAI;MAClB;IACF,KAAKR,UAAU,CAACW,oBAAoB;MAClCJ,cAAc,GAAGV,mCAAmC;MACpD;IACF,KAAKG,UAAU,CAACY,uBAAuB;MACrCL,cAAc,GAAGT,sCAAsC,CAAC;;EAE5D,IAAIe,YAAY;EAChB,QAAQP,QAAQ;IACd,KAAKL,QAAQ,CAACa,cAAc;MAC1BD,YAAY,GAAG1B,4BAA4B;MAC3C;IACF,KAAKc,QAAQ,CAACc,cAAc;MAC1B,IAAIP,WAAW,EAAE;QACfK,YAAY,GAAGxB,mCAAmC;MACpD,CAAC,MAAM;QACLwB,YAAY,GAAGzB,4BAA4B;MAC7C,CAAC;;EAEL,OAAO,CAACmB,cAAc,EAAEM,YAAY,EAAET,QAAQ,EAAEd,sBAAsB,CAAC,CAACb,IAAI,CAAC,IAAI,CAAC;AACpF;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASuC,iBAAiB;AAC/BC,UAAkB;AAClBX,QAAkB;AAClBY,UAAsB;AACd;EACR,IAAIC,eAAe;EACnB,QAAQD,UAAU;IAChB,KAAKhB,UAAU,CAACkB,WAAW;MACzBD,eAAe,GAAG7C,8BAA8B;MAChD;IACF,KAAK4B,UAAU,CAACmB,YAAY;MAC1BF,eAAe,GAAG9C,+BAA+B,CAAC;;EAEtD,IAAIwC,YAAY;EAChB,QAAQP,QAAQ;IACd,KAAKL,QAAQ,CAACa,cAAc;MAC1BD,YAAY,GAAGrB,8BAA8B;MAC7C;IACF,KAAKS,QAAQ,CAACc,cAAc;MAC1BF,YAAY,GAAGpB,8BAA8B,CAAC;;EAElD,OAAO;EACL0B,eAAe;EACfpB,sBAAsB;EACtBc,YAAY;EACZI,UAAU;EACVvB,wBAAwB,CACzB;EAACjB,IAAI,CAAC,IAAI,CAAC;AACd"}