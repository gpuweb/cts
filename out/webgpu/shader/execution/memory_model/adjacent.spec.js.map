{"version":3,"file":"adjacent.spec.js","names":["description","makeTestGroup","AllFeaturesMaxLimitsGPUTest","PRNG","g","kAddressSpaces","kPatterns","kNumValues","kWorkgroupSize","randomFiniteF16","prng","exponent_bits","candidate","randomU32","fillWithRandomFiniteF16","arr","i","length","getDstIndexExpression","pattern","computeReference","src","dst","isEven","makeShaderText","p","dstBuf","addressSpace","parts","push","join","runTest","t","seed","params","expected","Uint16Array","bytesPerScalar","bufByteSize","hostSrcBuf","createBufferTracked","size","usage","GPUBufferUsage","COPY_SRC","MAP_WRITE","mappedAtCreation","hostSrcUint16","getMappedRange","unmap","srcBuf","COPY_DST","STORAGE","shaderText","shader","device","createShaderModule","code","pipeline","createComputePipeline","layout","compute","module","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","copyBufferToBuffer","computeEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","commands","finish","queue","submit","expectGPUBufferValuesEqual","test","desc","u","combine","fn","skipIfDeviceDoesNotHaveFeature"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/adjacent.spec.ts"],"sourcesContent":["export const description = `\nTests writes from different invocations to adjacent scalars do not interfere.\nThis is especially interesting when the scalar type is narrower than 32-bits.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { AllFeaturesMaxLimitsGPUTest } from '../../../gpu_test.js';\nimport { PRNG } from '../../../util/prng.js';\n\nexport const g = makeTestGroup(AllFeaturesMaxLimitsGPUTest);\n\n// Algorithm: with N invocations, N is even:\n//     srcBuffer: An array of random scalar values.  Avoids unsupported values like infinity and NaN.\n//     resultBuffer: A result array\n//     pattern: 0|1|2|3\n//       Pattern 0: Identity: invocation i: dst[i] = src[i]\n//       Pattern 1: Try to prevent write coalescing.\n//          Even elements stay in place.\n//          Reverse order of odd elements.\n//          invocation 2k:   dst[2k] = src[2k]\n//          invocation 2k+1: dst[2k+1] = src[N - (2k+1)]\n//          Example: with N=6\n//             dst[0] = src[0]\n//             dst[1] = src[5]\n//             dst[2] = src[2]\n//             dst[3] = src[3]\n//             dst[4] = src[4]\n//             dst[5] = src[1]\n//       Pattern 2: Try to prevent write coalescing.\n//          Reverse order of even elements.\n//          Odd elements stay in place.\n//          invocation 2k:   dst[2k] = src[N - 2 - 2k]\n//          invocation 2k+1: dst[2k+1] = src[2k+1]\n//          Example: with N=6\n//             dst[0] = src[4]\n//             dst[1] = src[1]\n//             dst[2] = src[2]\n//             dst[3] = src[3]\n//             dst[4] = src[0]\n//             dst[5] = src[5]\n//       Pattern 3: Reverse elements: dst[i] = src[N-1-i]\n//     addressSpace: workgroup|storage\n//          Where dst is allocated.\n\ntype AddressSpace = 'workgroup' | 'storage';\ntype Pattern = 0 | 1 | 2 | 3;\nconst kAddressSpaces = ['workgroup', 'storage'] as const;\nconst kPatterns = [0, 1, 2, 3] as const;\n\ninterface AdjacentWritesTest extends AllFeaturesMaxLimitsGPUTest {\n  params: {\n    pattern: Pattern;\n    addressSpace: AddressSpace;\n  };\n}\n\n// For simplicity, make the entire source (and destination) array fit\n// in workgroup memory.\n// We can count on up to 16384 bytes in workgroup memory.\nconst kNumValues = 4096; // Assumed even\nconst kWorkgroupSize = 128; // Use 1-dimensional workgroups.\n\n/**\n * @returns an integer for the bit pattern of a random finite f16 value.\n * Consumes values from `prng`.\n *\n * @param prng - a pseudo-random number generator.\n */\nfunction randomFiniteF16(prng: PRNG): number {\n  const exponent_bits = 0x7c00;\n  // With any reasonable random number stream, the average number\n  // of trips around this loop is < 1 + 1/32 because there are 5\n  // exponent bits.\n  let candidate: number;\n  do {\n    candidate = prng.randomU32() & 0xffff;\n    // Non-finite f16 values have all 1 bits in the exponent.\n  } while ((candidate & exponent_bits) === exponent_bits);\n  return candidate;\n}\n\n/**\n * Fills array `arr` with random finite f16 values.\n * Consumes values from `prng`.\n *\n * @param prng - a pseudo-random number generator.\n * @param arr - the array to fill. Assume it is already correctly sized.\n */\nfunction fillWithRandomFiniteF16(prng: PRNG, arr: Uint16Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = randomFiniteF16(prng);\n  }\n}\n\n/**\n * @returns the expression for the destination index, based on `pattern`.\n *\n * @param i the WGSL string for the source index\n * @param pattern the indexing pattern\n */\nfunction getDstIndexExpression(i: string, pattern: Pattern): string {\n  switch (pattern) {\n    case 0:\n      return `${i}`;\n    case 1:\n      // Even elements map to themselves.\n      // Odd elements map to the reversed order of odd elements.\n      return `select(${kNumValues} - ${i}, ${i}, (${i} & 1) == 0)`;\n    case 2:\n      // Even elements map to the reversed order of odd elements.\n      // Since N is even, element 0 should get index N-2. (!)\n      // Odd elements map to themselves.\n      return `select(${i}, ${kNumValues} - 2 - ${i}, (${i} & 1) == 0)`;\n    case 3:\n      return `${kNumValues} - 1 -${i}`;\n  }\n}\n\n/**\n * Computes the reference (correct) result for the given source array and indexing pattern.\n *\n * @param pattern the indexing pattern\n * @param src the source array\n * @param dst the array to fill with values transferred from `src`\n */\nfunction computeReference(pattern: Pattern, src: Uint16Array, dst: Uint16Array) {\n  for (let i = 0; i < src.length; i++) {\n    const isEven = (i & 1) === 0;\n    switch (pattern) {\n      case 0:\n        dst[i] = src[i];\n        break;\n      case 1:\n        if (isEven) {\n          dst[i] = src[i];\n        } else {\n          dst[src.length - i] = src[i];\n        }\n        break;\n      case 2:\n        if (isEven) {\n          dst[kNumValues - 2 - i] = src[i];\n        } else {\n          dst[i] = src[i];\n        }\n        break;\n      case 3:\n        dst[src.length - 1 - i] = src[i];\n        break;\n    }\n  }\n}\n\n/**\n * @returns the source text for a shader that copies elements from a source\n * buffer to a destination buffer, while remapping indices according to the\n * specified pattern.\n *\n * @param p contains the address space and pattern\n */\nfunction makeShaderText(p: { addressSpace: AddressSpace; pattern: Pattern }): string {\n  // When the destination buffer is in 'storage', then write directly to it.\n  // Otherwise, destination is in workgroup memory, and we need to name the\n  // output buffer differently.\n  const dstBuf = p.addressSpace === 'storage' ? 'dst' : 'dstBuf';\n\n  const parts: string[] = [];\n\n  parts.push(`\n    enable f16;\n    @group(0) @binding(0) var<storage> src: array<f16>;\n    @group(0) @binding(1) var<storage,read_write> ${dstBuf}: array<f16>;\n    `);\n\n  if (p.addressSpace === 'workgroup') {\n    parts.push(`var<workgroup> dst: array<f16,${kNumValues}>;`);\n  }\n\n  parts.push(`\n    @compute @workgroup_size(${kWorkgroupSize})\n    fn adjacent_writes(@builtin(global_invocation_id) gid: vec3u) {\n        let srcIndex = gid.x;\n        let dstIndex = ${getDstIndexExpression('srcIndex', p.pattern)};\n        dst[dstIndex] = src[srcIndex];\n    `);\n\n  if (p.addressSpace === 'workgroup') {\n    // Copy to the output buffer.\n    // The barrier is not necessary here, but it should prevent\n    // the compiler from being clever and optimizing away the\n    // intermediate write to workgroup memory.\n    parts.push(`        workgroupBarrier();`);\n    parts.push(`        ${dstBuf}[dstIndex] = dst[dstIndex];`);\n  }\n  parts.push('}');\n\n  return parts.join('\\n');\n}\n\n/**\n * Runs the test on the GPU, generating random source data and\n * checking the results against the expected permutation of that data.\n *\n * @param t the AdjacentWritesTest specification.\n */\nfunction runTest(t: AdjacentWritesTest) {\n  const seed = ((t.params.pattern as number) + 1) * (t.params.addressSpace as string).length;\n  const prng = new PRNG(seed);\n\n  const expected = new Uint16Array(kNumValues);\n\n  const bytesPerScalar = 2; // f16 is 2 bytes wide.\n  const bufByteSize = kNumValues * bytesPerScalar;\n  const hostSrcBuf = t.createBufferTracked({\n    size: bufByteSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,\n    mappedAtCreation: true,\n  });\n  {\n    const hostSrcUint16 = new Uint16Array(hostSrcBuf.getMappedRange());\n    fillWithRandomFiniteF16(prng, hostSrcUint16);\n    computeReference(t.params.pattern, hostSrcUint16, expected);\n    hostSrcBuf.unmap();\n  }\n\n  const srcBuf = t.createBufferTracked({\n    size: bufByteSize,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  const dstBuf = t.createBufferTracked({\n    size: bufByteSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n  });\n\n  const shaderText = makeShaderText(t.params);\n  const shader = t.device.createShaderModule({ code: shaderText });\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: { module: shader, entryPoint: 'adjacent_writes' },\n  });\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: srcBuf } },\n      { binding: 1, resource: { buffer: dstBuf } },\n    ],\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  encoder.copyBufferToBuffer(hostSrcBuf, 0, srcBuf, 0, bufByteSize);\n\n  const computeEncoder = encoder.beginComputePass();\n  computeEncoder.setPipeline(pipeline);\n  computeEncoder.setBindGroup(0, bindGroup);\n  computeEncoder.dispatchWorkgroups(kNumValues / kWorkgroupSize);\n  computeEncoder.end();\n\n  const commands = encoder.finish();\n  t.device.queue.submit([commands]);\n\n  t.expectGPUBufferValuesEqual(dstBuf, expected);\n}\n\ng.test('f16')\n  .desc(\n    `Check that writes by different invocations to adjacent f16 values in an array do not interfere with each other.`\n  )\n  .params(u => u.combine('addressSpace', kAddressSpaces).combine('pattern', kPatterns))\n  .fn(t => {\n    t.skipIfDeviceDoesNotHaveFeature('shader-f16');\n    runTest(t);\n  });\n"],"mappings":"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"}