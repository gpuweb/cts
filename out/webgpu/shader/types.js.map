{"version":3,"file":"types.js","names":["keysOf","assert","align","kDefaultArrayLength","HostSharableTypes","kScalarTypeInfo","layout","alignment","size","supportsAtomics","arrayLength","innerLength","feature","undefined","kScalarTypes","kVectorContainerTypeInfo","kVectorContainerTypes","vectorLayout","vectorContainer","baseType","n","scalarLayout","kMatrixContainerTypeInfo","kMatrixContainerTypes","kMatrixContainerTypeLayoutInfo","kAccessModeInfo","read","write","read_write","kAddressSpaceInfo","storage","scope","binding","spell","accessModes","spellAccessMode","uniform","private","workgroup","function","handle","TexelFormats","format","_shaderType","generateTypes","addressSpace","containerType","isAtomic","scalarInfo","scalarType","isHostSharable","toString","type","_kTypeInfo","elementBaseType","vectorType","matrixType","matrixDimInfo","matrixLayoutInfo","arrayElemType","arrayElementCount","accessSuffixes","validLayoutForAddressSpace","arrayElemLayout","arrayByteSize","stride","arrayStride","arrayTypeInfo","elementLayout","sharableType","p","storageMode","supportedScalarTypes","info","isHostShared"],"sources":["../../../src/webgpu/shader/types.ts"],"sourcesContent":["import { keysOf } from '../../common/util/data_tables.js';\nimport { assert } from '../../common/util/util.js';\nimport { align } from '../util/math.js';\n\nconst kDefaultArrayLength = 3;\n\nexport type Requirement = 'never' | 'may' | 'must'; // never is the same as \"must not\"\nexport type ContainerType = 'scalar' | 'vector' | 'matrix' | 'array';\nexport type ScalarType = 'i32' | 'u32' | 'f16' | 'f32' | 'bool';\n\nexport const HostSharableTypes = ['i32', 'u32', 'f16', 'f32'] as const;\n\n// The alignment and size of a host shareable type.\n// See  \"Alignment and Size\" in the WGSL spec.  https://w3.org/TR/WGSL/#alignment-and-size\n// Note this is independent of the address space that values of this type might appear in.\n// See RequiredAlignOf(...) for the 16-byte granularity requirement when\n// values of a type are placed in the uniform address space.\ntype AlignmentAndSize = {\n  // AlignOf(T) for generated type T\n  alignment: number;\n  // SizeOf(T) for generated type T\n  size: number;\n};\n\n/** Info for each plain scalar type. */\nexport const kScalarTypeInfo =\n  /* prettier-ignore */ {\n  'i32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'u32':    { layout: { alignment:  4, size:  4 }, supportsAtomics:  true, arrayLength: 1, innerLength: 0 },\n  'f16':    { layout: { alignment:  2, size:  2 }, supportsAtomics: false, arrayLength: 1, innerLength: 0, feature: 'shader-f16' },\n  'f32':    { layout: { alignment:  4, size:  4 }, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n  'bool':   { layout:                   undefined, supportsAtomics: false, arrayLength: 1, innerLength: 0 },\n} as const;\n/** List of all plain scalar types. */\nexport const kScalarTypes = keysOf(kScalarTypeInfo);\n\n/** Info for each vecN<> container type. */\nexport const kVectorContainerTypeInfo =\n  /* prettier-ignore */ {\n  'vec2':   { arrayLength: 2 , innerLength: 0 },\n  'vec3':   { arrayLength: 3 , innerLength: 0 },\n  'vec4':   { arrayLength: 4 , innerLength: 0 },\n} as const;\n/** List of all vecN<> container types. */\nexport const kVectorContainerTypes = keysOf(kVectorContainerTypeInfo);\n\n/** Returns the vector layout for a given vector container and base type, or undefined if that base type has no layout */\nfunction vectorLayout(\n  vectorContainer: 'vec2' | 'vec3' | 'vec4',\n  baseType: ScalarType\n): undefined | AlignmentAndSize {\n  const n = kVectorContainerTypeInfo[vectorContainer].arrayLength;\n  const scalarLayout = kScalarTypeInfo[baseType].layout;\n  if (scalarLayout === undefined) {\n    return undefined;\n  }\n  if (n === 3) {\n    return { alignment: scalarLayout.alignment * 4, size: scalarLayout.size * 3 };\n  }\n  return { alignment: scalarLayout.alignment * n, size: scalarLayout.size * n };\n}\n\n/** Info for each matNxN<> container type. */\nexport const kMatrixContainerTypeInfo =\n  /* prettier-ignore */ {\n  'mat2x2': { arrayLength: 2, innerLength: 2 },\n  'mat3x2': { arrayLength: 3, innerLength: 2 },\n  'mat4x2': { arrayLength: 4, innerLength: 2 },\n  'mat2x3': { arrayLength: 2, innerLength: 3 },\n  'mat3x3': { arrayLength: 3, innerLength: 3 },\n  'mat4x3': { arrayLength: 4, innerLength: 3 },\n  'mat2x4': { arrayLength: 2, innerLength: 4 },\n  'mat3x4': { arrayLength: 3, innerLength: 4 },\n  'mat4x4': { arrayLength: 4, innerLength: 4 },\n} as const;\n/** List of all matNxN<> container types. */\nexport const kMatrixContainerTypes = keysOf(kMatrixContainerTypeInfo);\n\nexport const kMatrixContainerTypeLayoutInfo =\n  /* prettier-ignore */ {\n  'f16': {\n    'mat2x2': { layout: { alignment:  4, size:  8 } },\n    'mat3x2': { layout: { alignment:  4, size: 12 } },\n    'mat4x2': { layout: { alignment:  4, size: 16 } },\n    'mat2x3': { layout: { alignment:  8, size: 16 } },\n    'mat3x3': { layout: { alignment:  8, size: 24 } },\n    'mat4x3': { layout: { alignment:  8, size: 32 } },\n    'mat2x4': { layout: { alignment:  8, size: 16 } },\n    'mat3x4': { layout: { alignment:  8, size: 24 } },\n    'mat4x4': { layout: { alignment:  8, size: 32 } },\n  },\n  'f32': {\n    'mat2x2': { layout: { alignment:  8, size: 16 } },\n    'mat3x2': { layout: { alignment:  8, size: 24 } },\n    'mat4x2': { layout: { alignment:  8, size: 32 } },\n    'mat2x3': { layout: { alignment: 16, size: 32 } },\n    'mat3x3': { layout: { alignment: 16, size: 48 } },\n    'mat4x3': { layout: { alignment: 16, size: 64 } },\n    'mat2x4': { layout: { alignment: 16, size: 32 } },\n    'mat3x4': { layout: { alignment: 16, size: 48 } },\n    'mat4x4': { layout: { alignment: 16, size: 64 } },\n  }\n} as const;\n\nexport type AddressSpace = 'storage' | 'uniform' | 'private' | 'function' | 'workgroup' | 'handle';\nexport type AccessMode = 'read' | 'write' | 'read_write';\nexport type Scope = 'module' | 'function';\n\nexport const kAccessModeInfo = {\n  read: { read: true, write: false },\n  write: { read: false, write: true },\n  read_write: { read: true, write: true },\n} as const;\n\nexport type AddressSpaceInfo = {\n  // Variables in this address space must be declared in what scope?\n  scope: Scope;\n\n  // True if a variable in this address space requires a binding.\n  binding: boolean;\n\n  // Spell the address space in var declarations?\n  spell: Requirement;\n\n  // Access modes for ordinary accesses (loads, stores).\n  // The first one is the default.\n  // This is empty for the 'handle' address space where access is opaque.\n  accessModes: readonly AccessMode[];\n\n  // Spell the access mode in var declarations?\n  //   7.3 var Declarations\n  //   The access mode always has a default value, and except for variables\n  //   in the storage address space, must not be specified in the WGSL source.\n  //   See ยง13.3 Address Spaces.\n  spellAccessMode: Requirement;\n};\n\nexport const kAddressSpaceInfo: Record<string, AddressSpaceInfo> = {\n  storage: {\n    scope: 'module',\n    binding: true,\n    spell: 'must',\n    accessModes: ['read', 'read_write'],\n    spellAccessMode: 'may',\n  },\n  uniform: {\n    scope: 'module',\n    binding: true,\n    spell: 'must',\n    accessModes: ['read'],\n    spellAccessMode: 'never',\n  },\n  private: {\n    scope: 'module',\n    binding: false,\n    spell: 'must',\n    accessModes: ['read_write'],\n    spellAccessMode: 'never',\n  },\n  workgroup: {\n    scope: 'module',\n    binding: false,\n    spell: 'must',\n    accessModes: ['read_write'],\n    spellAccessMode: 'never',\n  },\n  function: {\n    scope: 'function',\n    binding: false,\n    spell: 'may',\n    accessModes: ['read_write'],\n    spellAccessMode: 'never',\n  },\n  handle: {\n    scope: 'module',\n    binding: true,\n    spell: 'never',\n    accessModes: [],\n    spellAccessMode: 'never',\n  },\n} as const;\n\n/**\n * List of texel formats and their shader representation\n * MAINTENANCE_TODO: It's not clear what this table is used for but being static we should\n * check that it's used correctly and not missing formats. For example the textureLoad tests\n * were using this table and then manually adding in bgra8unorm but doing that at every\n * test means that if a new format is added it will have to be added at every test.\n * If this table is useful, say for a list of storage texture formats, it should probably\n * be validated with the data in format_info.ts and visa versa so that adding a new format\n * to one or the other asserts if it's missing in the other. Marking as deprecated for now\n * to highlight where it's used.\n */\n/** @deprecated */\nexport const TexelFormats = [\n  { format: 'rgba8unorm', _shaderType: 'f32' },\n  { format: 'rgba8snorm', _shaderType: 'f32' },\n  { format: 'rgba8uint', _shaderType: 'u32' },\n  { format: 'rgba8sint', _shaderType: 'i32' },\n  { format: 'rgba16uint', _shaderType: 'u32' },\n  { format: 'rgba16sint', _shaderType: 'i32' },\n  { format: 'rgba16float', _shaderType: 'f32' },\n  { format: 'r32uint', _shaderType: 'u32' },\n  { format: 'r32sint', _shaderType: 'i32' },\n  { format: 'r32float', _shaderType: 'f32' },\n  { format: 'rg32uint', _shaderType: 'u32' },\n  { format: 'rg32sint', _shaderType: 'i32' },\n  { format: 'rg32float', _shaderType: 'f32' },\n  { format: 'rgba32uint', _shaderType: 'u32' },\n  { format: 'rgba32sint', _shaderType: 'i32' },\n  { format: 'rgba32float', _shaderType: 'f32' },\n] as const;\n\n/**\n * Generate a bunch types (vec, mat, sized/unsized array) for testing.\n */\nexport function* generateTypes({\n  addressSpace,\n  baseType,\n  containerType,\n  isAtomic = false,\n}: {\n  addressSpace: AddressSpace;\n  /** Base scalar type (i32/u32/f16/f32/bool). */\n  baseType: ScalarType;\n  /** Container type (scalar/vector/matrix/array) */\n  containerType: ContainerType;\n  /** Whether to wrap the baseType in `atomic<>`. */\n  isAtomic?: boolean;\n}): Generator<\n  {\n    /** WGSL name for the generated type */\n    type: string;\n    _kTypeInfo: {\n      /**\n       * WGSL name for:\n       * - the generated type if it is scalar or atomic\n       * - the column vector type if the generated type is a matrix\n       * - the base type if the generated type is an array\n       */\n      elementBaseType: string;\n      /** Layout details if host-shareable, and undefined otherwise. */\n      layout: undefined | AlignmentAndSize;\n      supportsAtomics: boolean;\n      /** The number of elementBaseType items in the container. */\n      arrayLength: number;\n      /**\n       * 0 for scalar and vector.\n       * For a matrix type, this is the number of rows in the matrix.\n       */\n      innerLength?: number;\n      /**\n       * If defined, the list of array access suffixes to use to access all\n       * the elements of the array, each yielding an elementBaseType value.\n       */\n      accessSuffixes?: string[];\n    };\n  },\n  void\n> {\n  const scalarInfo = kScalarTypeInfo[baseType];\n  if (isAtomic) {\n    assert(scalarInfo.supportsAtomics, 'type does not support atomics');\n    assert(\n      containerType === 'scalar' || containerType === 'array',\n      \"can only generate atomic inner types with containerType 'scalar' or 'array'\"\n    );\n  }\n  const scalarType = isAtomic ? `atomic<${baseType}>` : baseType;\n\n  // Storage and uniform require host-sharable types.\n  if (addressSpace === 'storage' || addressSpace === 'uniform') {\n    assert(isHostSharable(baseType), 'type ' + baseType.toString() + ' is not host sharable');\n  }\n\n  // Scalar types\n  if (containerType === 'scalar') {\n    yield {\n      type: `${scalarType}`,\n      _kTypeInfo: {\n        elementBaseType: `${scalarType}`,\n        ...scalarInfo,\n      },\n    };\n  }\n\n  // Vector types\n  if (containerType === 'vector') {\n    for (const vectorType of kVectorContainerTypes) {\n      yield {\n        type: `${vectorType}<${scalarType}>`,\n        _kTypeInfo: {\n          elementBaseType: baseType,\n          ...kVectorContainerTypeInfo[vectorType],\n          layout: vectorLayout(vectorType, scalarType as ScalarType),\n          supportsAtomics: false,\n        },\n      };\n    }\n  }\n\n  if (containerType === 'matrix') {\n    // Matrices can only be f16 or f32.\n    if (baseType === 'f16' || baseType === 'f32') {\n      for (const matrixType of kMatrixContainerTypes) {\n        const matrixDimInfo = kMatrixContainerTypeInfo[matrixType];\n        const matrixLayoutInfo = kMatrixContainerTypeLayoutInfo[baseType][matrixType];\n        yield {\n          type: `${matrixType}<${scalarType}>`,\n          _kTypeInfo: {\n            elementBaseType: `vec${matrixDimInfo.innerLength}<${scalarType}>`,\n            ...matrixDimInfo,\n            ...matrixLayoutInfo,\n            supportsAtomics: false,\n          },\n        };\n      }\n    }\n  }\n\n  // Array types\n  if (containerType === 'array') {\n    let arrayElemType: string = scalarType;\n    let arrayElementCount: number = kDefaultArrayLength;\n    let supportsAtomics = scalarInfo.supportsAtomics;\n    let layout: undefined | AlignmentAndSize = undefined;\n    let accessSuffixes: undefined | string[] = undefined;\n    let validLayoutForAddressSpace = true;\n    if (scalarInfo.layout) {\n      // Compute the layout of the array type.\n      // Adjust the array element count or element type as needed.\n      if (addressSpace === 'uniform') {\n        // Use a vec4 of the scalar type, to achieve a 16 byte alignment without internal padding.\n        // This works for 4-byte scalar types, and does not work for f16.\n        // It is the caller's responsibility to filter out the f16 case.\n        assert(!isAtomic, 'the uniform case is making vec4 of scalar, which cannot handle atomics');\n        arrayElemType = `vec4<${baseType}>`;\n        supportsAtomics = false;\n        accessSuffixes = ['.x', '.y', '.z', '.w'];\n        const arrayElemLayout = vectorLayout('vec4', baseType) as AlignmentAndSize;\n        // Arrays in uniform address space have to be 16 byte-aligned.\n        // An array of vec4<f16> is only 8byte aligned.\n        validLayoutForAddressSpace = arrayElemLayout.alignment % 16 === 0;\n        arrayElementCount = align(arrayElementCount, 4) / 4;\n        const arrayByteSize = arrayElementCount * arrayElemLayout.size;\n        layout = { alignment: arrayElemLayout.alignment, size: arrayByteSize };\n      } else {\n        // The ordinary case.  Use scalarType as the element type.\n        const stride = arrayStride(scalarInfo.layout);\n        let arrayByteSize = arrayElementCount * stride;\n        if (addressSpace === 'storage') {\n          // The buffer effective binding size must be a multiple of 4.\n          // Adjust the array element count as needed.\n          while (arrayByteSize % 4 > 0) {\n            arrayElementCount++;\n            arrayByteSize = arrayElementCount * stride;\n          }\n        }\n        layout = { alignment: scalarInfo.layout.alignment, size: arrayByteSize };\n      }\n    }\n\n    const arrayTypeInfo = {\n      elementBaseType: `${baseType}`,\n      arrayLength: arrayElementCount,\n      layout,\n      supportsAtomics,\n      accessSuffixes,\n    };\n\n    if (validLayoutForAddressSpace) {\n      // Sized\n      yield { type: `array<${arrayElemType},${arrayElementCount}>`, _kTypeInfo: arrayTypeInfo };\n      // Unsized\n      if (addressSpace === 'storage') {\n        yield { type: `array<${arrayElemType}>`, _kTypeInfo: arrayTypeInfo };\n      }\n    }\n  }\n\n  function arrayStride(elementLayout: AlignmentAndSize) {\n    return align(elementLayout.size, elementLayout.alignment);\n  }\n\n  function isHostSharable(baseType: ScalarType) {\n    for (const sharableType of HostSharableTypes) {\n      if (sharableType === baseType) return true;\n    }\n    return false;\n  }\n}\n\n/** Atomic access requires scalar/array container type and storage/workgroup memory. */\nexport function supportsAtomics(p: {\n  addressSpace: string;\n  storageMode: AccessMode | undefined;\n  access: string;\n  containerType: ContainerType;\n}) {\n  return (\n    ((p.addressSpace === 'storage' && p.storageMode === 'read_write') ||\n      p.addressSpace === 'workgroup') &&\n    (p.containerType === 'scalar' || p.containerType === 'array')\n  );\n}\n\n/** Generates an iterator of supported base types (i32/u32/f16/f32/bool) */\nexport function* supportedScalarTypes(p: { isAtomic: boolean; addressSpace: string }) {\n  for (const scalarType of kScalarTypes) {\n    const info = kScalarTypeInfo[scalarType];\n\n    // Test atomics only on supported scalar types.\n    if (p.isAtomic && !info.supportsAtomics) continue;\n\n    // Storage and uniform require host-sharable types.\n    const isHostShared = p.addressSpace === 'storage' || p.addressSpace === 'uniform';\n    if (isHostShared && info.layout === undefined) continue;\n\n    yield scalarType;\n  }\n}\n"],"mappings":"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"}