{"version":3,"file":"values.js","names":["description","assert","uint32ToFloat32","subnormalF32Examples","result_as_bits","max_mantissa","sign_bits","sign_bit","sign_and_exponent","push","lower_bits","length","toString","map","u","normalF32Examples","result","max_mantissa_as_bits","min_exponent_as_bits","max_exponent_as_bits","e","nanF32BitsExamples","exponent_bit","bits","quiet_signalling"],"sources":["../../../src/webgpu/shader/values.ts"],"sourcesContent":["export const description = `Special and sample values for WGSL scalar types`;\n\nimport { assert } from '../../common/util/util.js';\nimport { uint32ToFloat32 } from '../util/conversion.js';\n\n/** Returns an array of subnormal f32 numbers.\n * Subnormals are non-zero finite numbers with the minimum representable\n * exponent.\n */\nexport function subnormalF32Examples(): Array<number> {\n  // The results, as uint32 values.\n  const result_as_bits: number[] = [];\n\n  const max_mantissa = 0x7f_ffff;\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    // exponent bits must be zero.\n    const sign_and_exponent = sign_bit;\n\n    // Set all bits\n    result_as_bits.push(sign_and_exponent | max_mantissa);\n\n    // Set each of the lower bits individually.\n    for (let lower_bits = 1; lower_bits <= max_mantissa; lower_bits <<= 1) {\n      result_as_bits.push(sign_and_exponent | lower_bits);\n    }\n  }\n  assert(\n    result_as_bits.length === 2 * (1 + 23),\n    'subnormal number sample count is ' + result_as_bits.length.toString()\n  );\n  return result_as_bits.map(u => uint32ToFloat32(u));\n}\n\n/** Returns an array of normal f32 numbers.\n * Normal numbers are not: zero, Nan, infinity, subnormal.\n */\nexport function normalF32Examples(): Array<number> {\n  const result: number[] = [1.0, -2.0];\n\n  const max_mantissa_as_bits = 0x7f_ffff;\n  const min_exponent_as_bits = 0x0080_0000;\n  const max_exponent_as_bits = 0x7f00_0000; // Max normal exponent\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    for (let e = min_exponent_as_bits; e <= max_exponent_as_bits; e += min_exponent_as_bits) {\n      const sign_and_exponent = sign_bit | e;\n\n      // Set zero mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent));\n      // Set all mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent | max_mantissa_as_bits));\n\n      // Set each of the lower bits individually.\n      for (let lower_bits = 1; lower_bits <= max_mantissa_as_bits; lower_bits <<= 1) {\n        result.push(uint32ToFloat32(sign_and_exponent | lower_bits));\n      }\n    }\n  }\n  assert(\n    result.length === 2 + 2 * 254 * 25,\n    'normal number sample count is ' + result.length.toString()\n  );\n  return result;\n}\n\n/** Returns an array of 32-bit NaNs, as Uint32 bit patterns.\n * NaNs have: maximum exponent, but the mantissa is not zero.\n */\nexport function nanF32BitsExamples(): Array<number> {\n  const result: number[] = [];\n  const exponent_bit = 0x7f80_0000;\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit of sign_bits) {\n    const sign_and_exponent = sign_bit | exponent_bit;\n    const bits = sign_and_exponent | 0x40_0000;\n    // Only the most significant bit of the mantissa is set.\n    result.push(bits);\n\n    // Quiet and signalling NaNs differ based on the most significant bit\n    // of the mantissa. Try both.\n    for (const quiet_signalling of [0, 0x40_0000]) {\n      // Set each of the lower bits.\n      for (let lower_bits = 1; lower_bits < 0x40_0000; lower_bits <<= 1) {\n        const bits = sign_and_exponent | quiet_signalling | lower_bits;\n        result.push(bits);\n      }\n    }\n  }\n  return result;\n}\n"],"mappings":"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"}