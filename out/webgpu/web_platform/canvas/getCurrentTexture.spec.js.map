{"version":3,"file":"getCurrentTexture.spec.js","names":["description","SkipTestCase","makeTestGroup","timeout","assert","unreachable","GPUTest","kAllCanvasTypes","createCanvas","kFormat","GPUContextTest","initCanvasContext","canvasType","canvas","onscreencanvas","style","position","top","left","opacity","document","body","appendChild","trackForCleanup","close","removeChild","ctx","getContext","GPUCanvasContext","configure","device","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","expectTextureDestroyed","texture","expectDestroyed","expectValidationError","encoder","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","end","queue","submit","finish","g","test","desc","params","u","combine","fn","t","shouldThrow","getCurrentTexture","prevTexture","currentTexture","expect","unconfigure","frameTexture","clearValue","expectSingleColor","size","width","height","exp","R","G","B","A","destroy","beginSubcases","beforeAllSubcases","OffscreenCanvas","prototype","clearTexture","Promise","resolve","frameCount","frameCheck","requestAnimationFrame","transferToImageBitmap","prevFrameCallsite","getCurrentTextureAgain","bgl","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","runInNewCanvasFrame","checkGetCurrentTexture","queueMicrotask","prevTextureView","createBindGroup","layout","resource"],"sources":["../../../../src/webgpu/web_platform/canvas/getCurrentTexture.spec.ts"],"sourcesContent":["export const description = `\nTests for GPUCanvasContext.getCurrentTexture.\n`;\n\nimport { SkipTestCase } from '../../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { timeout } from '../../../common/util/timeout.js';\nimport { assert, unreachable } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { kAllCanvasTypes, createCanvas, CanvasType } from '../../util/create_elements.js';\n\nconst kFormat = 'bgra8unorm';\n\nclass GPUContextTest extends GPUTest {\n  initCanvasContext(canvasType: CanvasType = 'onscreen'): GPUCanvasContext {\n    const canvas = createCanvas(this, canvasType, 2, 2);\n    if (canvasType === 'onscreen') {\n      // To make sure onscreen canvas are visible\n      const onscreencanvas = canvas as HTMLCanvasElement;\n      onscreencanvas.style.position = 'fixed';\n      onscreencanvas.style.top = '0';\n      onscreencanvas.style.left = '0';\n      // Set it to transparent so that if multiple canvas are created, they are still visible.\n      onscreencanvas.style.opacity = '50%';\n      document.body.appendChild(onscreencanvas);\n      this.trackForCleanup({\n        close() {\n          document.body.removeChild(onscreencanvas);\n        },\n      });\n    }\n    const ctx = canvas.getContext('webgpu');\n    assert(ctx instanceof GPUCanvasContext, 'Failed to get WebGPU context from canvas');\n\n    ctx.configure({\n      device: this.device,\n      format: kFormat,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    });\n\n    return ctx;\n  }\n\n  expectTextureDestroyed(texture: GPUTexture, expectDestroyed = true) {\n    this.expectValidationError(() => {\n      // Try using the texture in a render pass. Because it's a canvas texture\n      // it should have RENDER_ATTACHMENT usage.\n      assert((texture.usage & GPUTextureUsage.RENDER_ATTACHMENT) !== 0);\n      const encoder = this.device.createCommandEncoder();\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: texture.createView(),\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      });\n      pass.end();\n      // Submitting should generate a validation error if the texture is destroyed.\n      this.queue.submit([encoder.finish()]);\n    }, expectDestroyed);\n  }\n}\n\nexport const g = makeTestGroup(GPUContextTest);\n\ng.test('configured')\n  .desc(\n    `Checks that calling getCurrentTexture requires the context to be configured first, and\n  that each call to configure causes getCurrentTexture to return a new texture.`\n  )\n  .params(u =>\n    u //\n      .combine('canvasType', kAllCanvasTypes)\n  )\n  .fn(t => {\n    const canvas = createCanvas(t, t.params.canvasType, 2, 2);\n    const ctx = canvas.getContext('webgpu');\n    assert(ctx instanceof GPUCanvasContext, 'Failed to get WebGPU context from canvas');\n\n    // Calling getCurrentTexture prior to configuration should throw an InvalidStateError exception.\n    t.shouldThrow('InvalidStateError', () => {\n      ctx.getCurrentTexture();\n    });\n\n    // Once the context has been configured getCurrentTexture can be called.\n    ctx.configure({\n      device: t.device,\n      format: kFormat,\n    });\n\n    let prevTexture = ctx.getCurrentTexture();\n\n    // Calling configure again with different values will change the texture returned.\n    ctx.configure({\n      device: t.device,\n      format: 'bgra8unorm',\n    });\n\n    let currentTexture = ctx.getCurrentTexture();\n    t.expect(prevTexture !== currentTexture);\n    prevTexture = currentTexture;\n\n    // Calling configure again with the same values will still change the texture returned.\n    ctx.configure({\n      device: t.device,\n      format: 'bgra8unorm',\n    });\n\n    currentTexture = ctx.getCurrentTexture();\n    t.expect(prevTexture !== currentTexture);\n    prevTexture = currentTexture;\n\n    // Calling getCurrentTexture after calling unconfigure should throw an InvalidStateError exception.\n    ctx.unconfigure();\n\n    t.shouldThrow('InvalidStateError', () => {\n      ctx.getCurrentTexture();\n    });\n  });\n\ng.test('single_frames')\n  .desc(`Checks that the value of getCurrentTexture is consistent within a single frame.`)\n  .params(u =>\n    u //\n      .combine('canvasType', kAllCanvasTypes)\n  )\n  .fn(t => {\n    const ctx = t.initCanvasContext(t.params.canvasType);\n    const frameTexture = ctx.getCurrentTexture();\n\n    // Calling getCurrentTexture a second time returns the same texture.\n    t.expect(frameTexture === ctx.getCurrentTexture());\n\n    const encoder = t.device.createCommandEncoder();\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: frameTexture.createView(),\n          clearValue: [1.0, 0.0, 0.0, 1.0],\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n    pass.end();\n    t.device.queue.submit([encoder.finish()]);\n\n    // Calling getCurrentTexture after performing some work on the texture returns the same texture.\n    t.expect(frameTexture === ctx.getCurrentTexture());\n\n    // Ensure that getCurrentTexture does not clear the texture.\n    t.expectSingleColor(frameTexture, frameTexture.format, {\n      size: [frameTexture.width, frameTexture.height, 1],\n      exp: { R: 1, G: 0, B: 0, A: 1 },\n    });\n\n    frameTexture.destroy();\n\n    // Calling getCurrentTexture after destroying the texture still returns the same texture.\n    t.expect(frameTexture === ctx.getCurrentTexture());\n  });\n\ng.test('multiple_frames')\n  .desc(`Checks that the value of getCurrentTexture differs across multiple frames.`)\n  .params(u =>\n    u //\n      .combine('canvasType', kAllCanvasTypes)\n      .beginSubcases()\n      .combine('clearTexture', [true, false])\n  )\n  .beforeAllSubcases(t => {\n    const { canvasType } = t.params;\n    if (canvasType === 'offscreen' && !('transferToImageBitmap' in OffscreenCanvas.prototype)) {\n      throw new SkipTestCase('transferToImageBitmap not supported');\n    }\n  })\n  .fn(t => {\n    const { canvasType, clearTexture } = t.params;\n\n    return new Promise(resolve => {\n      const ctx = t.initCanvasContext(canvasType);\n      let prevTexture: GPUTexture | undefined;\n      let frameCount = 0;\n\n      function frameCheck() {\n        const currentTexture = ctx.getCurrentTexture();\n\n        if (prevTexture) {\n          // Ensure that each frame a new texture object is returned.\n          t.expect(currentTexture !== prevTexture);\n\n          // Ensure that the texture's initial contents are transparent black.\n          t.expectSingleColor(currentTexture, currentTexture.format, {\n            size: [currentTexture.width, currentTexture.height, 1],\n            exp: { R: 0, G: 0, B: 0, A: 0 },\n          });\n        }\n\n        if (clearTexture) {\n          // Fill the texture with a non-zero color, to test that texture\n          // contents don't carry over from frame to frame.\n          const encoder = t.device.createCommandEncoder();\n          const pass = encoder.beginRenderPass({\n            colorAttachments: [\n              {\n                view: currentTexture.createView(),\n                clearValue: [1.0, 0.0, 0.0, 1.0],\n                loadOp: 'clear',\n                storeOp: 'store',\n              },\n            ],\n          });\n          pass.end();\n          t.device.queue.submit([encoder.finish()]);\n        }\n\n        prevTexture = currentTexture;\n\n        if (frameCount++ < 5) {\n          // Which method will be used to begin a new \"frame\"?\n          switch (canvasType) {\n            case 'onscreen':\n              requestAnimationFrame(frameCheck);\n              break;\n            case 'offscreen': {\n              (ctx.canvas as OffscreenCanvas).transferToImageBitmap();\n              frameCheck();\n              break;\n            }\n            default:\n              unreachable();\n          }\n        } else {\n          resolve();\n        }\n      }\n\n      // Render the first frame immediately. The rest will be triggered recursively.\n      frameCheck();\n    });\n  });\n\ng.test('resize')\n  .desc(`Checks the value of getCurrentTexture differs when the canvas is resized.`)\n  .params(u =>\n    u //\n      .combine('canvasType', kAllCanvasTypes)\n  )\n  .fn(t => {\n    const ctx = t.initCanvasContext(t.params.canvasType);\n    let prevTexture = ctx.getCurrentTexture();\n\n    // Trigger a resize by changing the width.\n    ctx.canvas.width = 4;\n\n    t.expectTextureDestroyed(prevTexture);\n\n    // When the canvas resizes the texture returned by getCurrentTexture should immediately begin\n    // returning a new texture matching the update dimensions.\n    let currentTexture = ctx.getCurrentTexture();\n    t.expect(prevTexture !== currentTexture);\n    t.expect(currentTexture.width === ctx.canvas.width);\n    t.expect(currentTexture.height === ctx.canvas.height);\n\n    // The width and height of the previous texture should remain unchanged.\n    t.expect(prevTexture.width === 2);\n    t.expect(prevTexture.height === 2);\n    prevTexture = currentTexture;\n\n    // Ensure that texture contents are transparent black.\n    t.expectSingleColor(currentTexture, currentTexture.format, {\n      size: [currentTexture.width, currentTexture.height, 1],\n      exp: { R: 0, G: 0, B: 0, A: 0 },\n    });\n\n    // Trigger a resize by changing the height.\n    ctx.canvas.height = 4;\n\n    // Check to ensure the texture is resized again.\n    currentTexture = ctx.getCurrentTexture();\n    t.expect(prevTexture !== currentTexture);\n    t.expect(currentTexture.width === ctx.canvas.width);\n    t.expect(currentTexture.height === ctx.canvas.height);\n    t.expect(prevTexture.width === 4);\n    t.expect(prevTexture.height === 2);\n\n    // Ensure that texture contents are transparent black.\n    t.expectSingleColor(currentTexture, currentTexture.format, {\n      size: [currentTexture.width, currentTexture.height, 1],\n      exp: { R: 0, G: 0, B: 0, A: 0 },\n    });\n\n    // HTMLCanvasElement behaves differently than OffscreenCanvas\n    if (t.params.canvasType === 'onscreen') {\n      // Ensure canvas goes back to defaults when set to negative numbers.\n      ctx.canvas.width = -1;\n      currentTexture = ctx.getCurrentTexture();\n      t.expect(currentTexture.width === 300);\n      t.expect(currentTexture.height === 4);\n\n      ctx.canvas.height = -1;\n      currentTexture = ctx.getCurrentTexture();\n      t.expect(currentTexture.width === 300);\n      t.expect(currentTexture.height === 150);\n\n      // Setting the canvas width and height values to their current values should\n      // still trigger a change in the texture.\n      prevTexture = ctx.getCurrentTexture();\n      const { width, height } = ctx.canvas;\n      ctx.canvas.width = width;\n      ctx.canvas.height = height;\n\n      t.expectTextureDestroyed(prevTexture);\n\n      currentTexture = ctx.getCurrentTexture();\n      t.expect(prevTexture !== currentTexture);\n    }\n  });\n\ng.test('expiry')\n  .desc(\n    `\nTest automatic WebGPU canvas texture expiry on all canvas types with the following requirements:\n- getCurrentTexture returns the same texture object until the next task:\n  - after previous frame update the rendering\n  - before current frame update the rendering\n  - in a microtask off the current frame task\n- getCurrentTexture returns a new texture object and the old texture object becomes invalid\n  as soon as possible after HTML update the rendering.\n\nTODO: test more canvas types, and ways to update the rendering\n- if on a different thread, expiry happens when the worker updates its rendering (worker \"rPAF\") OR transferToImageBitmap is called\n- [draw, transferControlToOffscreen, then canvas is displayed] on either {main thread, or transferred to worker}\n- [draw, canvas is displayed, then transferControlToOffscreen] on either {main thread, or transferred to worker}\n- reftests for the above 2 (what gets displayed when the canvas is displayed)\n- with canvas element added to DOM or not (applies to other canvas tests as well)\n  - canvas is added to DOM after being rendered\n  - canvas is already in DOM but becomes visible after being rendered\n  `\n  )\n  .params(u =>\n    u //\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('prevFrameCallsite', ['runInNewCanvasFrame', 'requestAnimationFrame'] as const)\n      .combine('getCurrentTextureAgain', [true, false] as const)\n  )\n  .beforeAllSubcases(t => {\n    if (\n      t.params.prevFrameCallsite === 'requestAnimationFrame' &&\n      typeof requestAnimationFrame === 'undefined'\n    ) {\n      throw new SkipTestCase('requestAnimationFrame not available');\n    }\n  })\n  .fn(t => {\n    const { canvasType, prevFrameCallsite, getCurrentTextureAgain } = t.params;\n    const ctx = t.initCanvasContext(t.params.canvasType);\n    // Create a bindGroupLayout to test invalid texture view usage later.\n    const bgl = t.device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          texture: {},\n        },\n      ],\n    });\n\n    // The fn is called immediately after previous frame updating the rendering.\n    // Polyfill by calling the callback by setTimeout, in the requestAnimationFrame callback (for onscreen canvas)\n    // or after transferToImageBitmap (for offscreen canvas).\n    function runInNewCanvasFrame(fn: () => void) {\n      switch (canvasType) {\n        case 'onscreen':\n          requestAnimationFrame(() => timeout(fn));\n          break;\n        case 'offscreen':\n          // for offscreen canvas, after calling transferToImageBitmap, we are in a new frame immediately\n          (ctx.canvas as OffscreenCanvas).transferToImageBitmap();\n          fn();\n          break;\n        default:\n          unreachable();\n      }\n    }\n\n    function checkGetCurrentTexture() {\n      // Call getCurrentTexture on previous frame.\n      const prevTexture = ctx.getCurrentTexture();\n\n      // Call getCurrentTexture immediately after the frame, the texture object should stay the same.\n      queueMicrotask(() => {\n        if (getCurrentTextureAgain) {\n          t.expect(prevTexture === ctx.getCurrentTexture());\n        }\n\n        // Call getCurrentTexture in a new frame.\n        // It should expire the previous texture object return a new texture object by the next frame by then.\n        // Call runInNewCanvasFrame in the micro task to make sure the new frame run after the getCurrentTexture in the micro task for offscreen canvas.\n        runInNewCanvasFrame(() => {\n          if (getCurrentTextureAgain) {\n            t.expect(prevTexture !== ctx.getCurrentTexture());\n          }\n\n          // Event when prevTexture expired, createView should still succeed anyway.\n          const prevTextureView = prevTexture.createView();\n          // Using the invalid view should fail if it expires.\n          t.expectValidationError(() => {\n            t.device.createBindGroup({\n              layout: bgl,\n              entries: [{ binding: 0, resource: prevTextureView }],\n            });\n          });\n        });\n      });\n    }\n\n    switch (prevFrameCallsite) {\n      case 'runInNewCanvasFrame':\n        runInNewCanvasFrame(checkGetCurrentTexture);\n        break;\n      case 'requestAnimationFrame':\n        requestAnimationFrame(checkGetCurrentTexture);\n        break;\n      default:\n        break;\n    }\n  });\n"],"mappings":"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"}