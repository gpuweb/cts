{"version":3,"file":"canvas.spec.js","names":["description","makeTestGroup","skipTestCase","kCanvasAlphaModes","kTextureFormatInfo","kValidTextureFormatsForCopyE2T","TextureUploadingUtils","kAllCanvasTypes","createCanvas","F","init2DCanvasContentWithColorSpace","width","height","colorSpace","canvas","canvasContext","getContext","skip","getContextAttributes","SOURCE_PIXEL_BYTES","imagePixels","Uint8ClampedArray","rectWidth","Math","floor","rectHeight","alphaValue","pixelStartPos","i","j","imageData","ImageData","ctx","putImageData","expectedSourceData","getExpectedReadbackFor2DCanvas","init2DCanvasContent","canvasType","paint2DCanvas","fillStyle","fillRect","initGLCanvasContent","contextName","premultiplied","gl","premultipliedAlpha","trackForCleanup","colorValue","enable","SCISSOR_TEST","scissor","clearColor","clear","COLOR_BUFFER_BIT","getExpectedReadbackForWebGLCanvas","getDataToInitSourceWebGPUCanvas","alphaMode","initialData","maxRectHeightIndex","pixelIndex","length","index","initSourceWebGPUCanvas","device","gpuContext","GPUCanvasContext","configure","format","usage","GPUTextureUsage","COPY_DST","COPY_SRC","canvasTexture","getCurrentTexture","queue","writeTexture","texture","bytesPerRow","rowsPerImage","depthOrArrayLayers","getExpectedReadbackForWebGPUCanvas","context","getImageData","data","bytesPerPixel","sourcePixels","readPixels","RGBA","UNSIGNED_BYTE","doFlipY","rgbaPixels","pixelPos","r","doCopyContentsTest","source","expectedSourceImage","p","dst","createTextureTracked","size","dstColorFormat","RENDER_ATTACHMENT","info","expFormat","baseFormat","expectedDestinationImage","getExpectedDstPixelsFromSrcPixels","srcPixels","srcOrigin","srcSize","dstOrigin","dstSize","subRectSize","flipSrcBeforeCopy","srcDoFlipYDuringCopy","conversion","srcPremultiplied","dstPremultiplied","doTestAndCheckResult","origin","x","y","flipY","maxDiffULPsForNormFormat","maxDiffULPsForFloatFormat","g","test","desc","params","u","combine","beginSubcases","beforeAllSubcases","t","skipIfTextureFormatNotSupported","fn","dstAlphaMode","selectMismatchedDeviceOrSkipTestCase","undefined","srcAndDstInSameGPUDevice","srcAlphaMode","mismatchedDevice","imageBitmapRenderingContext","ImageBitmapRenderingContext","sourceContentCanvas","imageBitmap","createImageBitmap","premultiplyAlpha","transferFromImageBitmap","srcColorSpace","dstColorSpace","texelCompareOptions","maxFractionalDiff"],"sources":["../../../../src/webgpu/web_platform/copyToTexture/canvas.spec.ts"],"sourcesContent":["export const description = `\ncopyToTexture with HTMLCanvasElement and OffscreenCanvas sources.\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { skipTestCase } from '../../../common/util/util.js';\nimport { kCanvasAlphaModes } from '../../capability_info.js';\nimport {\n  kTextureFormatInfo,\n  kValidTextureFormatsForCopyE2T,\n  RegularTextureFormat,\n} from '../../format_info.js';\nimport { TextureUploadingUtils } from '../../util/copy_to_texture.js';\nimport { CanvasType, kAllCanvasTypes, createCanvas } from '../../util/create_elements.js';\nimport { TexelCompareOptions } from '../../util/texture/texture_ok.js';\n\nclass F extends TextureUploadingUtils {\n  init2DCanvasContentWithColorSpace({\n    width,\n    height,\n    colorSpace,\n  }: {\n    width: number;\n    height: number;\n    colorSpace: 'srgb' | 'display-p3';\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    expectedSourceData: Uint8ClampedArray;\n  } {\n    const canvas = createCanvas(this, 'onscreen', width, height);\n\n    let canvasContext = null;\n    canvasContext = canvas.getContext('2d', { colorSpace });\n\n    if (canvasContext === null) {\n      this.skip('onscreen canvas 2d context not available');\n    }\n\n    if (\n      typeof canvasContext.getContextAttributes === 'undefined' ||\n      typeof canvasContext.getContextAttributes().colorSpace === 'undefined'\n    ) {\n      this.skip('color space attr is not supported for canvas 2d context');\n    }\n\n    const SOURCE_PIXEL_BYTES = 4;\n    const imagePixels = new Uint8ClampedArray(SOURCE_PIXEL_BYTES * width * height);\n\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    const alphaValue = 153;\n\n    let pixelStartPos = 0;\n    // Red;\n    for (let i = 0; i < rectHeight; ++i) {\n      for (let j = 0; j < rectWidth; ++j) {\n        pixelStartPos = (i * width + j) * SOURCE_PIXEL_BYTES;\n        imagePixels[pixelStartPos] = 255;\n        imagePixels[pixelStartPos + 1] = 0;\n        imagePixels[pixelStartPos + 2] = 0;\n        imagePixels[pixelStartPos + 3] = alphaValue;\n      }\n    }\n\n    // Lime;\n    for (let i = 0; i < rectHeight; ++i) {\n      for (let j = rectWidth; j < width; ++j) {\n        pixelStartPos = (i * width + j) * SOURCE_PIXEL_BYTES;\n        imagePixels[pixelStartPos] = 0;\n        imagePixels[pixelStartPos + 1] = 255;\n        imagePixels[pixelStartPos + 2] = 0;\n        imagePixels[pixelStartPos + 3] = alphaValue;\n      }\n    }\n\n    // Blue\n    for (let i = rectHeight; i < height; ++i) {\n      for (let j = 0; j < rectWidth; ++j) {\n        pixelStartPos = (i * width + j) * SOURCE_PIXEL_BYTES;\n        imagePixels[pixelStartPos] = 0;\n        imagePixels[pixelStartPos + 1] = 0;\n        imagePixels[pixelStartPos + 2] = 255;\n        imagePixels[pixelStartPos + 3] = alphaValue;\n      }\n    }\n\n    // Fuchsia\n    for (let i = rectHeight; i < height; ++i) {\n      for (let j = rectWidth; j < width; ++j) {\n        pixelStartPos = (i * width + j) * SOURCE_PIXEL_BYTES;\n        imagePixels[pixelStartPos] = 255;\n        imagePixels[pixelStartPos + 1] = 0;\n        imagePixels[pixelStartPos + 2] = 255;\n        imagePixels[pixelStartPos + 3] = alphaValue;\n      }\n    }\n\n    const imageData = new ImageData(imagePixels, width, height, { colorSpace });\n    if (typeof imageData.colorSpace === 'undefined') {\n      this.skip('color space attr is not supported for ImageData');\n    }\n\n    const ctx = canvasContext as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n    ctx.putImageData(imageData, 0, 0);\n\n    return {\n      canvas,\n      expectedSourceData: this.getExpectedReadbackFor2DCanvas(canvasContext, width, height),\n    };\n  }\n\n  // MAINTENANCE_TODO: Cache the generated canvas to avoid duplicated initialization.\n  init2DCanvasContent({\n    canvasType,\n    width,\n    height,\n  }: {\n    canvasType: CanvasType;\n    width: number;\n    height: number;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    expectedSourceData: Uint8ClampedArray;\n  } {\n    const canvas = createCanvas(this, canvasType, width, height);\n\n    let canvasContext = null;\n    canvasContext = canvas.getContext('2d');\n\n    if (canvasContext === null) {\n      this.skip(canvasType + ' canvas 2d context not available');\n    }\n\n    const ctx = canvasContext;\n    this.paint2DCanvas(ctx, width, height, 0.6);\n\n    return {\n      canvas,\n      expectedSourceData: this.getExpectedReadbackFor2DCanvas(canvasContext, width, height),\n    };\n  }\n\n  private paint2DCanvas(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    width: number,\n    height: number,\n    alphaValue: number\n  ) {\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    // Red\n    ctx.fillStyle = `rgba(255, 0, 0, ${alphaValue})`;\n    ctx.fillRect(0, 0, rectWidth, rectHeight);\n    // Lime\n    ctx.fillStyle = `rgba(0, 255, 0, ${alphaValue})`;\n    ctx.fillRect(rectWidth, 0, width - rectWidth, rectHeight);\n    // Blue\n    ctx.fillStyle = `rgba(0, 0, 255, ${alphaValue})`;\n    ctx.fillRect(0, rectHeight, rectWidth, height - rectHeight);\n    // Fuchsia\n    ctx.fillStyle = `rgba(255, 0, 255, ${alphaValue})`;\n    ctx.fillRect(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n  }\n\n  // MAINTENANCE_TODO: Cache the generated canvas to avoid duplicated initialization.\n  initGLCanvasContent({\n    canvasType,\n    contextName,\n    width,\n    height,\n    premultiplied,\n  }: {\n    canvasType: CanvasType;\n    contextName: 'webgl' | 'webgl2';\n    width: number;\n    height: number;\n    premultiplied: boolean;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    expectedSourceData: Uint8ClampedArray;\n  } {\n    const canvas = createCanvas(this, canvasType, width, height);\n\n    // MAINTENANCE_TODO: Workaround for @types/offscreencanvas missing an overload of\n    // `OffscreenCanvas.getContext` that takes `string` or a union of context types.\n    const gl = (canvas as HTMLCanvasElement).getContext(contextName, {\n      premultipliedAlpha: premultiplied,\n    }) as WebGLRenderingContext | WebGL2RenderingContext | null;\n\n    if (gl === null) {\n      this.skip(canvasType + ' canvas ' + contextName + ' context not available');\n    }\n    this.trackForCleanup(gl);\n\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    const alphaValue = 0.6;\n    const colorValue = premultiplied ? alphaValue : 1.0;\n\n    // For webgl/webgl2 context canvas, if the context created with premultipliedAlpha attributes,\n    // it means that the value in drawing buffer is premultiplied or not. So we should set\n    // premultipliedAlpha value for premultipliedAlpha true gl context and unpremultipliedAlpha value\n    // for the premultipliedAlpha false gl context.\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(0, 0, rectWidth, rectHeight);\n    gl.clearColor(colorValue, 0.0, 0.0, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(rectWidth, 0, width - rectWidth, rectHeight);\n    gl.clearColor(0.0, colorValue, 0.0, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(0, rectHeight, rectWidth, height - rectHeight);\n    gl.clearColor(0.0, 0.0, colorValue, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.scissor(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n    gl.clearColor(colorValue, colorValue, colorValue, alphaValue);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return {\n      canvas,\n      expectedSourceData: this.getExpectedReadbackForWebGLCanvas(gl, width, height),\n    };\n  }\n\n  private getDataToInitSourceWebGPUCanvas(\n    width: number,\n    height: number,\n    alphaMode: GPUCanvasAlphaMode\n  ): Uint8ClampedArray {\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n\n    const alphaValue = 153;\n    // Always output [153, 153, 153, 153]. When the alphaMode is...\n    //   - premultiplied: the readback is CSS `rgba(255, 255, 255, 60%)`.\n    //   - opaque: the readback is CSS `rgba(153, 153, 153, 100%)`.\n    // getExpectedReadbackForWebGPUCanvas matches this.\n    const colorValue = alphaValue;\n\n    // BGRA8Unorm texture\n    const initialData = new Uint8ClampedArray(4 * width * height);\n    const maxRectHeightIndex = width * rectHeight;\n    for (let pixelIndex = 0; pixelIndex < initialData.length / 4; ++pixelIndex) {\n      const index = pixelIndex * 4;\n\n      // Top-half two rectangles\n      if (pixelIndex < maxRectHeightIndex) {\n        // top-left side rectangle\n        if (pixelIndex % width < rectWidth) {\n          // top-left side rectangle\n          initialData[index] = colorValue;\n          initialData[index + 1] = 0;\n          initialData[index + 2] = 0;\n          initialData[index + 3] = alphaValue;\n        } else {\n          // top-right side rectangle\n          initialData[index] = 0;\n          initialData[index + 1] = colorValue;\n          initialData[index + 2] = 0;\n          initialData[index + 3] = alphaValue;\n        }\n      } else {\n        // Bottom-half two rectangles\n        // bottom-left side rectangle\n        if (pixelIndex % width < rectWidth) {\n          initialData[index] = 0;\n          initialData[index + 1] = 0;\n          initialData[index + 2] = colorValue;\n          initialData[index + 3] = alphaValue;\n        } else {\n          // bottom-right side rectangle\n          initialData[index] = colorValue;\n          initialData[index + 1] = colorValue;\n          initialData[index + 2] = colorValue;\n          initialData[index + 3] = alphaValue;\n        }\n      }\n    }\n    return initialData;\n  }\n\n  initSourceWebGPUCanvas({\n    device,\n    canvasType,\n    width,\n    height,\n    alphaMode,\n  }: {\n    device: GPUDevice;\n    canvasType: CanvasType;\n    width: number;\n    height: number;\n    alphaMode: GPUCanvasAlphaMode;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    expectedSourceData: Uint8ClampedArray;\n  } {\n    const canvas = createCanvas(this, canvasType, width, height);\n\n    const gpuContext = canvas.getContext('webgpu');\n\n    if (!(gpuContext instanceof GPUCanvasContext)) {\n      this.skip(canvasType + ' canvas webgpu context not available');\n    }\n\n    gpuContext.configure({\n      device,\n      format: 'bgra8unorm',\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      alphaMode,\n    });\n\n    // BGRA8Unorm texture\n    const initialData = this.getDataToInitSourceWebGPUCanvas(width, height, alphaMode);\n    const canvasTexture = gpuContext.getCurrentTexture();\n    device.queue.writeTexture(\n      { texture: canvasTexture },\n      initialData,\n      {\n        bytesPerRow: width * 4,\n        rowsPerImage: height,\n      },\n      {\n        width,\n        height,\n        depthOrArrayLayers: 1,\n      }\n    );\n\n    return {\n      canvas,\n      expectedSourceData: this.getExpectedReadbackForWebGPUCanvas(width, height, alphaMode),\n    };\n  }\n\n  private getExpectedReadbackFor2DCanvas(\n    context: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    width: number,\n    height: number\n  ): Uint8ClampedArray {\n    // Always read back the raw data from canvas\n    return context.getImageData(0, 0, width, height).data;\n  }\n\n  private getExpectedReadbackForWebGLCanvas(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    width: number,\n    height: number\n  ): Uint8ClampedArray {\n    const bytesPerPixel = 4;\n\n    const sourcePixels = new Uint8ClampedArray(width * height * bytesPerPixel);\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, sourcePixels);\n\n    return this.doFlipY(sourcePixels, width, height, bytesPerPixel);\n  }\n\n  private getExpectedReadbackForWebGPUCanvas(\n    width: number,\n    height: number,\n    alphaMode: GPUCanvasAlphaMode\n  ): Uint8ClampedArray {\n    const bytesPerPixel = 4;\n\n    const rgbaPixels = this.getDataToInitSourceWebGPUCanvas(width, height, alphaMode);\n\n    // The source canvas has bgra8unorm back resource. We\n    // swizzle the channels to align with 2d/webgl canvas and\n    // clear alpha to 255 (1.0) when context alphaMode\n    // is set to opaque (follow webgpu spec).\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const pixelPos = i * width + j;\n        const r = rgbaPixels[pixelPos * bytesPerPixel + 2];\n        if (alphaMode === 'opaque') {\n          rgbaPixels[pixelPos * bytesPerPixel + 3] = 255;\n        }\n\n        rgbaPixels[pixelPos * bytesPerPixel + 2] = rgbaPixels[pixelPos * bytesPerPixel];\n        rgbaPixels[pixelPos * bytesPerPixel] = r;\n      }\n    }\n\n    return rgbaPixels;\n  }\n\n  doCopyContentsTest(\n    source: HTMLCanvasElement | OffscreenCanvas,\n    expectedSourceImage: Uint8ClampedArray,\n    p: {\n      width: number;\n      height: number;\n      dstColorFormat: RegularTextureFormat;\n      srcDoFlipYDuringCopy: boolean;\n      srcPremultiplied: boolean;\n      dstPremultiplied: boolean;\n    }\n  ) {\n    const dst = this.createTextureTracked({\n      size: {\n        width: p.width,\n        height: p.height,\n        depthOrArrayLayers: 1,\n      },\n      format: p.dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Construct expected value for different dst color format\n    const info = kTextureFormatInfo[p.dstColorFormat];\n    const expFormat = info.baseFormat ?? p.dstColorFormat;\n\n    // For 2d canvas, get expected pixels with getImageData(), which returns unpremultiplied\n    // values.\n    const expectedDestinationImage = this.getExpectedDstPixelsFromSrcPixels({\n      srcPixels: expectedSourceImage,\n      srcOrigin: [0, 0],\n      srcSize: [p.width, p.height],\n      dstOrigin: [0, 0],\n      dstSize: [p.width, p.height],\n      subRectSize: [p.width, p.height],\n      format: expFormat,\n      flipSrcBeforeCopy: false,\n      srcDoFlipYDuringCopy: p.srcDoFlipYDuringCopy,\n      conversion: {\n        srcPremultiplied: p.srcPremultiplied,\n        dstPremultiplied: p.dstPremultiplied,\n      },\n    });\n\n    this.doTestAndCheckResult(\n      { source, origin: { x: 0, y: 0 }, flipY: p.srcDoFlipYDuringCopy },\n      {\n        texture: dst,\n        origin: { x: 0, y: 0 },\n        colorSpace: 'srgb',\n        premultipliedAlpha: p.dstPremultiplied,\n      },\n      expectedDestinationImage,\n      { width: p.width, height: p.height, depthOrArrayLayers: 1 },\n      // 1.0 and 0.6 are representable precisely by all formats except rgb10a2unorm, but\n      // allow diffs of 1ULP since that's the generally-appropriate threshold.\n      { maxDiffULPsForNormFormat: 1, maxDiffULPsForFloatFormat: 1 }\n    );\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('copy_contents_from_2d_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with 2d context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with '2d'.\n  Use fillRect(2d context) to render red rect for top-left,\n  green rect for top-right, blue rect for bottom-left and white for bottom-right.\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  Provide premultiplied input if 'premultipliedAlpha' in 'GPUImageCopyTextureTagged'\n  is set to 'true' and unpremultiplied input if it is set to 'false'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid 2d context type\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage' (named 'srcDoFlipYDuringCopy' in cases)\n  - TODO(#913): color space tests need to be added\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('dstAlphaMode', kCanvasAlphaModes)\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15])\n      .combine('height', [1, 2, 4, 15])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n  })\n  .fn(t => {\n    const { width, height, canvasType, dstAlphaMode } = t.params;\n\n    const { canvas, expectedSourceData } = t.init2DCanvasContent({\n      canvasType,\n      width,\n      height,\n    });\n\n    t.doCopyContentsTest(canvas, expectedSourceData, {\n      srcPremultiplied: false,\n      dstPremultiplied: dstAlphaMode === 'premultiplied',\n      ...t.params,\n    });\n  });\n\ng.test('copy_contents_from_gl_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with webgl/webgl2 context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with webgl'/'webgl2'.\n  Use scissor + clear to render red rect for top-left, green rect\n  for top-right, blue rect for bottom-left and white for bottom-right.\n  And do premultiply alpha in advance if the webgl/webgl2 context is created\n  with premultipliedAlpha : true.\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  Provide premultiplied input if 'premultipliedAlpha' in 'GPUImageCopyTextureTagged'\n  is set to 'true' and unpremultiplied input if it is set to 'false'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid webgl/webgl2 context type\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - Valid source image alphaMode\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage'(named 'srcDoFlipYDuringCopy' in cases)\n  - TODO: color space tests need to be added\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('contextName', ['webgl', 'webgl2'] as const)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('srcPremultiplied', [true, false])\n      .combine('dstAlphaMode', kCanvasAlphaModes)\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15])\n      .combine('height', [1, 2, 4, 15])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n  })\n  .fn(t => {\n    const { width, height, canvasType, contextName, srcPremultiplied, dstAlphaMode } = t.params;\n\n    const { canvas, expectedSourceData } = t.initGLCanvasContent({\n      canvasType,\n      contextName,\n      width,\n      height,\n      premultiplied: srcPremultiplied,\n    });\n\n    t.doCopyContentsTest(canvas, expectedSourceData, {\n      dstPremultiplied: dstAlphaMode === 'premultiplied',\n      ...t.params,\n    });\n  });\n\ng.test('copy_contents_from_gpu_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with webgpu context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with 'webgpu'.\n  Use writeTexture to copy pixels to back buffer. The results are:\n  red rect for top-left, green rect for top-right, blue rect for bottom-left\n  and white for bottom-right.\n\n  TODO: Actually test alphaMode = opaque.\n  And do premultiply alpha in advance if the webgpu context is created\n  with alphaMode=\"premultiplied\".\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  Provide premultiplied input if 'premultipliedAlpha' in 'GPUImageCopyTextureTagged'\n  is set to 'true' and unpremultiplied input if it is set to 'false'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped.\n\n  The tests covers:\n  - Valid canvas type\n  - Source WebGPU Canvas lives in the same GPUDevice or different GPUDevice as test\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - TODO: test more source image alphaMode\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage'(named 'srcDoFlipYDuringCopy' in cases)\n  - TODO: color space tests need to be added\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('srcAndDstInSameGPUDevice', [true, false])\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      // .combine('srcAlphaMode', kCanvasAlphaModes)\n      .combine('srcAlphaMode', ['premultiplied'] as const)\n      .combine('dstAlphaMode', kCanvasAlphaModes)\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15])\n      .combine('height', [1, 2, 4, 15])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n    t.selectMismatchedDeviceOrSkipTestCase(undefined);\n  })\n  .fn(t => {\n    const { width, height, canvasType, srcAndDstInSameGPUDevice, srcAlphaMode, dstAlphaMode } =\n      t.params;\n\n    const device = srcAndDstInSameGPUDevice ? t.device : t.mismatchedDevice;\n    const { canvas: source, expectedSourceData } = t.initSourceWebGPUCanvas({\n      device,\n      canvasType,\n      width,\n      height,\n      alphaMode: srcAlphaMode,\n    });\n\n    t.doCopyContentsTest(source, expectedSourceData, {\n      srcPremultiplied: srcAlphaMode === 'premultiplied',\n      dstPremultiplied: dstAlphaMode === 'premultiplied',\n      ...t.params,\n    });\n  });\n\ng.test('copy_contents_from_bitmaprenderer_context_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with ImageBitmapRenderingContext\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with 'bitmaprenderer'.\n  First, use fillRect(2d context) to render red rect for top-left,\n  green rect for top-right, blue rect for bottom-left and white for bottom-right on a\n  2d context canvas and create imageBitmap with that canvas. Use transferFromImageBitmap()\n  to render the imageBitmap to source canvas.\n\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  Provide premultiplied input if 'premultipliedAlpha' in 'GPUImageCopyTextureTagged'\n  is set to 'true' and unpremultiplied input if it is set to 'false'.\n\n  If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n  is flipped.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid ImageBitmapRendering context type\n  - Valid dstColorFormat of copyExternalImageToTexture()\n  - Valid dest alphaMode\n  - Valid 'flipY' config in 'GPUImageCopyExternalImage' (named 'srcDoFlipYDuringCopy' in cases)\n  - TODO(#913): color space tests need to be added\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', kAllCanvasTypes)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('dstAlphaMode', kCanvasAlphaModes)\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15])\n      .combine('height', [1, 2, 4, 15])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n  })\n  .fn(async t => {\n    const { width, height, canvasType, dstAlphaMode } = t.params;\n\n    const canvas = createCanvas(t, canvasType, width, height);\n\n    const imageBitmapRenderingContext = canvas.getContext('bitmaprenderer');\n\n    if (!(imageBitmapRenderingContext instanceof ImageBitmapRenderingContext)) {\n      skipTestCase(canvasType + ' canvas imageBitmap rendering context not available');\n    }\n\n    const { canvas: sourceContentCanvas, expectedSourceData } = t.init2DCanvasContent({\n      canvasType,\n      width,\n      height,\n    });\n\n    const imageBitmap = await createImageBitmap(sourceContentCanvas, { premultiplyAlpha: 'none' });\n    imageBitmapRenderingContext.transferFromImageBitmap(imageBitmap);\n\n    t.doCopyContentsTest(canvas, expectedSourceData, {\n      srcPremultiplied: false,\n      dstPremultiplied: dstAlphaMode === 'premultiplied',\n      ...t.params,\n    });\n  });\n\ng.test('color_space_conversion')\n  .desc(\n    `\n    Test HTMLCanvasElement with 2d context can created with 'colorSpace' attribute.\n    Using CopyExternalImageToTexture to copy from such type of canvas needs\n    to do color space converting correctly.\n\n    It creates HTMLCanvasElement/OffscreenCanvas with '2d' and 'colorSpace' attributes.\n    Use fillRect(2d context) to render red rect for top-left,\n    green rect for top-right, blue rect for bottom-left and white for bottom-right.\n\n    Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n    of dst texture, and read the contents out to compare with the canvas contents.\n\n    Provide premultiplied input if 'premultipliedAlpha' in 'GPUImageCopyTextureTagged'\n    is set to 'true' and unpremultiplied input if it is set to 'false'.\n\n    If 'flipY' in 'GPUImageCopyExternalImage' is set to 'true', copy will ensure the result\n    is flipped.\n\n    If color space from source input and user defined dstTexture color space are different, the\n    result must convert the content to user defined color space\n\n    The tests covers:\n    - Valid dstColorFormat of copyExternalImageToTexture()\n    - Valid dest alphaMode\n    - Valid 'flipY' config in 'GPUImageCopyExternalImage' (named 'srcDoFlipYDuringCopy' in cases)\n    - Valid 'colorSpace' config in 'dstColorSpace'\n\n    And the expected results are all passed.\n\n    TODO: Enhance test data with colors that aren't always opaque and fully saturated.\n    TODO: Consider refactoring src data setup with TexelView.writeTextureData.\n  `\n  )\n  .params(u =>\n    u\n      .combine('srcColorSpace', ['srgb', 'display-p3'] as const)\n      .combine('dstColorSpace', ['srgb', 'display-p3'] as const)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyE2T)\n      .combine('dstPremultiplied', [true, false])\n      .combine('srcDoFlipYDuringCopy', [true, false])\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15, 255, 256])\n      .combine('height', [1, 2, 4, 15, 255, 256])\n  )\n  .beforeAllSubcases(t => {\n    t.skipIfTextureFormatNotSupported(t.params.dstColorFormat);\n  })\n  .fn(t => {\n    const {\n      width,\n      height,\n      srcColorSpace,\n      dstColorSpace,\n      dstColorFormat,\n      dstPremultiplied,\n      srcDoFlipYDuringCopy,\n    } = t.params;\n    const { canvas, expectedSourceData } = t.init2DCanvasContentWithColorSpace({\n      width,\n      height,\n      colorSpace: srcColorSpace,\n    });\n\n    const dst = t.createTextureTracked({\n      size: { width, height },\n      format: dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const expectedDestinationImage = t.getExpectedDstPixelsFromSrcPixels({\n      srcPixels: expectedSourceData,\n      srcOrigin: [0, 0],\n      srcSize: [width, height],\n      dstOrigin: [0, 0],\n      dstSize: [width, height],\n      subRectSize: [width, height],\n      // copyExternalImageToTexture does not perform gamma-encoding into `-srgb` formats.\n      format: kTextureFormatInfo[dstColorFormat].baseFormat ?? dstColorFormat,\n      flipSrcBeforeCopy: false,\n      srcDoFlipYDuringCopy,\n      conversion: {\n        srcPremultiplied: false,\n        dstPremultiplied,\n        srcColorSpace,\n        dstColorSpace,\n      },\n    });\n\n    const texelCompareOptions: TexelCompareOptions = {\n      maxFractionalDiff: 0,\n      maxDiffULPsForNormFormat: 1,\n    };\n    if (srcColorSpace !== dstColorSpace) {\n      // Color space conversion seems prone to errors up to about 0.0003 on f32, 0.0007 on f16.\n      texelCompareOptions.maxFractionalDiff = 0.001;\n    } else {\n      texelCompareOptions.maxDiffULPsForFloatFormat = 1;\n    }\n\n    t.doTestAndCheckResult(\n      { source: canvas, origin: { x: 0, y: 0 }, flipY: srcDoFlipYDuringCopy },\n      {\n        texture: dst,\n        origin: { x: 0, y: 0 },\n        colorSpace: dstColorSpace,\n        premultipliedAlpha: dstPremultiplied,\n      },\n      expectedDestinationImage,\n      { width, height, depthOrArrayLayers: 1 },\n      texelCompareOptions\n    );\n  });\n"],"mappings":"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"}