{"version":3,"file":"test_group.js","names":["SkipTestCase","UnexpectedPassError","builderIterateCasesWithSubcases","kUnitCaseParamsBuilder","globalTestConfig","TestCaseRecorder","extractPublicParams","mergeParams","compareQueries","Ordering","TestQueryMultiTest","TestQuerySingleCase","kPathSeparator","stringifyPublicParams","stringifyPublicParamsUniquely","validQueryPart","assert","unreachable","logToWebSocket","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","kQueryMaxLength","kBatchParamName","seen","Set","tests","constructor","iterate","checkName","name","decodeURIComponent","has","add","test","testCreationStack","Error","parts","split","p","TestBuilder","push","validate","fileQuery","testQuery","suite","filePathParts","testPath","collectNonEmptyTests","testPaths","computeCaseCount","testCases","undefined","batchSize","isUnimplemented","desc","description","trim","specURL","_url","beforeAllSubcases","fn","beforeFn","testFn","batch","b","unimplemented","testPathString","join","s","stack","toString","length","caseParams","subcases","caseQuery","testPathParts","subcaseParams","params","testcaseString","e","testcaseStringUnique","caseCount","_caseParams","_subcases","cases","Function","paramsSimple","combineWithParams","paramsSubcasesOnly","beginSubcases","makeCaseSpecific","RunCaseSpecific","caseFilter","filterToBatch","caseFilterWithoutBatch","batchParam","subcaseArray","Array","from","makeCaseForBatch","sliceStart","slice","Math","min","id","computeSubcaseCount","count","_subcase","runTest","rec","sharedState","throwSkip","expectedStatus","beginSubCase","inst","init","passed","finalize","ex","threw","endSubCase","message","warn","run","selfQuery","expectations","getExpectedStatus","selfQueryWithSubParams","didSeeFail","exp","ordering","query","Unordered","StrictSubset","expectation","testHeartbeatCallback","maxSubcasesInFlight","start","MakeSharedState","postInit","allPreviousSubcasesFinalizedPromise","Promise","resolve","totalCount","skipCount","subcasesInFlight","resolvePromiseBlockingSubcase","subcaseFinishedCallback","subParams","subcasePrefix","subRec","Proxy","get","target","k","prop","prototype","args","then","arg","rv","apply","subcaseQuery","finalizePromise","info","catch","finally","skipped","finish","msg","q","timems","result","nonskippedSubcaseCount","JSON","stringify"],"sources":["../../../src/common/internal/test_group.ts"],"sourcesContent":["import {\n  Fixture,\n  SubcaseBatchState,\n  SkipTestCase,\n  TestParams,\n  UnexpectedPassError,\n  SubcaseBatchStateFromFixture,\n  FixtureClass,\n} from '../framework/fixture.js';\nimport {\n  CaseParamsBuilder,\n  builderIterateCasesWithSubcases,\n  kUnitCaseParamsBuilder,\n  ParamsBuilderBase,\n  SubcaseParamsBuilder,\n} from '../framework/params_builder.js';\nimport { globalTestConfig } from '../framework/test_config.js';\nimport { Expectation } from '../internal/logging/result.js';\nimport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { extractPublicParams, Merged, mergeParams } from '../internal/params_utils.js';\nimport { compareQueries, Ordering } from '../internal/query/compare.js';\nimport {\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n  TestQuerySingleCase,\n  TestQueryWithExpectation,\n} from '../internal/query/query.js';\nimport { kPathSeparator } from '../internal/query/separators.js';\nimport {\n  stringifyPublicParams,\n  stringifyPublicParamsUniquely,\n} from '../internal/query/stringify_params.js';\nimport { validQueryPart } from '../internal/query/validQueryPart.js';\nimport { DeepReadonly } from '../util/types.js';\nimport { assert, unreachable } from '../util/util.js';\n\nimport { logToWebSocket } from './websocket_logger.js';\n\nexport type RunFn = (\n  rec: TestCaseRecorder,\n  expectations?: TestQueryWithExpectation[]\n) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: TestParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  readonly isUnimplemented: boolean;\n  computeSubcaseCount(): number;\n  run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void>;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<F extends Fixture> {\n  test(name: string): TestBuilderWithName<F>;\n}\nexport function makeTestGroup<F extends Fixture>(fixture: FixtureClass<F>): TestGroupBuilder<F> {\n  return new TestGroup(fixture as unknown as FixtureClass);\n}\n\n// Interfaces for running tests\nexport interface IterableTestGroup {\n  iterate(): Iterable<IterableTest>;\n  validate(fileQuery: TestQueryMultiFile): void;\n  /** Returns the file-relative test paths of tests which have >0 cases. */\n  collectNonEmptyTests(): { testPath: string[] }[];\n}\nexport interface IterableTest {\n  testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n  iterate(caseFilter: TestParams | null): Iterable<RunCase>;\n}\n\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<F>\n): TestGroup<F> {\n  return new TestGroup(fixture);\n}\n\n/** The maximum allowed length of a test query string. Checked by tools/validate. */\nexport const kQueryMaxLength = 375;\n\n/** Parameter name for batch number (see also TestBuilder.batch). */\nconst kBatchParamName = 'batch__';\n\ntype TestFn<F extends Fixture, P extends {}> = (\n  t: F & { params: DeepReadonly<P> }\n) => Promise<void> | void;\ntype BeforeAllSubcasesFn<S extends SubcaseBatchState, P extends {}> = (\n  s: S & { params: DeepReadonly<P> }\n) => Promise<void> | void;\n\nexport class TestGroup<F extends Fixture> implements TestGroupBuilder<F> {\n  private fixture: FixtureClass;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<SubcaseBatchStateFromFixture<F>, F>> = [];\n\n  constructor(fixture: FixtureClass) {\n    this.fixture = fixture;\n  }\n\n  iterate(): Iterable<IterableTest> {\n    return this.tests;\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treating\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  test(name: string): TestBuilderWithName<F> {\n    const testCreationStack = new Error(`Test created: ${name}`);\n\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder(parts, this.fixture, testCreationStack);\n    this.tests.push(test);\n    return test as unknown as TestBuilderWithName<F>;\n  }\n\n  validate(fileQuery: TestQueryMultiFile): void {\n    for (const test of this.tests) {\n      const testQuery = new TestQueryMultiTest(\n        fileQuery.suite,\n        fileQuery.filePathParts,\n        test.testPath\n      );\n      test.validate(testQuery);\n    }\n  }\n\n  collectNonEmptyTests(): { testPath: string[] }[] {\n    const testPaths = [];\n    for (const test of this.tests) {\n      if (test.computeCaseCount() > 0) {\n        testPaths.push({ testPath: test.testPath });\n      }\n    }\n    return testPaths;\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture> extends TestBuilderWithParams<F, {}, {}> {\n  desc(description: string): this;\n  /**\n   * A noop function to associate a test with the relevant part of the specification.\n   *\n   * @param url a link to the spec where test is extracted from.\n   */\n  specURL(url: string): this;\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * The `unit` value passed to the `cases` callback is an immutable constant\n   * `CaseParamsBuilder<{}>` representing the \"unit\" builder `[ {} ]`,\n   * provided for convenience. The non-callback overload can be used if `unit` is not needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: (unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<F, CaseP, SubcaseP>;\n  /**\n   * Parameterize the test, generating multiple cases, each possibly having subcases.\n   *\n   * Use the callback overload of this method if a \"unit\" builder is needed.\n   */\n  params<CaseP extends {}, SubcaseP extends {}>(\n    cases: ParamsBuilderBase<CaseP, SubcaseP>\n  ): TestBuilderWithParams<F, CaseP, SubcaseP>;\n\n  /**\n   * Parameterize the test, generating multiple cases, without subcases.\n   */\n  paramsSimple<P extends {}>(cases: Iterable<P>): TestBuilderWithParams<F, P, {}>;\n\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   */\n  paramsSubcasesOnly<P extends {}>(subcases: Iterable<P>): TestBuilderWithParams<F, {}, P>;\n  /**\n   * Parameterize the test, generating one case with multiple subcases.\n   *\n   * The `unit` value passed to the `subcases` callback is an immutable constant\n   * `SubcaseParamsBuilder<{}>`, with one empty case `{}` and one empty subcase `{}`.\n   */\n  paramsSubcasesOnly<P extends {}>(\n    subcases: (unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, P>\n  ): TestBuilderWithParams<F, {}, P>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, CaseP extends {}, SubcaseP extends {}> {\n  /**\n   * Limit subcases to a maximum number of per testcase.\n   * @param b the maximum number of subcases per testcase.\n   *\n   * If the number of subcases exceeds `b`, add an internal\n   * numeric, incrementing `batch__` param to split subcases\n   * into groups of at most `b` subcases.\n   */\n  batch(b: number): this;\n  /**\n   * Run a function on shared subcase batch state before each\n   * batch of subcases.\n   * @param fn the function to run. It is called with the test\n   * fixture's shared subcase batch state.\n   *\n   * Generally, this function should be careful to avoid mutating\n   * any state on the shared subcase batch state which could result\n   * in unexpected order-dependent test behavior.\n   */\n  beforeAllSubcases(fn: BeforeAllSubcasesFn<SubcaseBatchStateFromFixture<F>, CaseP>): this;\n  /**\n   * Set the test function.\n   * @param fn the test function.\n   */\n  fn(fn: TestFn<F, Merged<CaseP, SubcaseP>>): void;\n  /**\n   * Mark the test as unimplemented.\n   */\n  unimplemented(): void;\n}\n\nclass TestBuilder<S extends SubcaseBatchState, F extends Fixture> {\n  readonly testPath: string[];\n  isUnimplemented: boolean;\n  description: string | undefined;\n  readonly testCreationStack: Error;\n\n  private readonly fixture: FixtureClass;\n  private testFn: TestFn<Fixture, {}> | undefined;\n  private beforeFn: BeforeAllSubcasesFn<SubcaseBatchState, {}> | undefined;\n  private testCases?: ParamsBuilderBase<{}, {}> = undefined;\n  private batchSize: number = 0;\n\n  constructor(testPath: string[], fixture: FixtureClass, testCreationStack: Error) {\n    this.testPath = testPath;\n    this.isUnimplemented = false;\n    this.fixture = fixture;\n    this.testCreationStack = testCreationStack;\n  }\n\n  desc(description: string): this {\n    this.description = description.trim();\n    return this;\n  }\n\n  specURL(_url: string): this {\n    return this;\n  }\n\n  beforeAllSubcases(fn: BeforeAllSubcasesFn<SubcaseBatchState, {}>): this {\n    assert(this.beforeFn === undefined);\n    this.beforeFn = fn;\n    return this;\n  }\n\n  fn(fn: TestFn<Fixture, {}>): void {\n    // eslint-disable-next-line no-warning-comments\n    // MAINTENANCE_TODO: add \"TODO\" if there's no description? (and make sure it only ends up on\n    // actual tests, not on test parents in the tree, which is what happens if you do it here, not\n    // sure why)\n    assert(this.testFn === undefined);\n    this.testFn = fn;\n  }\n\n  batch(b: number): this {\n    this.batchSize = b;\n    return this;\n  }\n\n  unimplemented(): void {\n    assert(this.testFn === undefined);\n\n    this.description =\n      (this.description ? this.description + '\\n\\n' : '') + 'TODO: .unimplemented()';\n    this.isUnimplemented = true;\n\n    // Use the beforeFn to skip the test, so we don't have to iterate the subcases.\n    this.beforeFn = () => {\n      throw new SkipTestCase('test unimplemented');\n    };\n    this.testFn = () => {};\n  }\n\n  /** Perform various validation/\"lint\" chenks. */\n  validate(testQuery: TestQueryMultiTest): void {\n    const testPathString = this.testPath.join(kPathSeparator);\n    assert(this.testFn !== undefined, () => {\n      let s = `Test is missing .fn(): ${testPathString}`;\n      if (this.testCreationStack.stack) {\n        s += `\\n-> test created at:\\n${this.testCreationStack.stack}`;\n      }\n      return s;\n    });\n\n    assert(\n      testQuery.toString().length <= kQueryMaxLength,\n      () =>\n        `Test query ${testQuery} is too long. Max length is ${kQueryMaxLength} characters. Please shorten names or reduce parameters.`\n    );\n\n    if (this.testCases === undefined) {\n      return;\n    }\n\n    const seen = new Set<string>();\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(this.testCases, null)) {\n      const caseQuery = new TestQuerySingleCase(\n        testQuery.suite,\n        testQuery.filePathParts,\n        testQuery.testPathParts,\n        caseParams\n      ).toString();\n      assert(\n        caseQuery.length <= kQueryMaxLength,\n        () =>\n          `Case query ${caseQuery} is too long. Max length is ${kQueryMaxLength} characters. Please shorten names or reduce parameters.`\n      );\n\n      for (const subcaseParams of subcases ?? [{}]) {\n        const params = mergeParams(caseParams, subcaseParams);\n        assert(this.batchSize === 0 || !(kBatchParamName in params));\n\n        // stringifyPublicParams also checks for invalid params values\n        let testcaseString;\n        try {\n          testcaseString = stringifyPublicParams(params);\n        } catch (e) {\n          throw new Error(`${e}: ${testPathString}`);\n        }\n\n        // A (hopefully) unique representation of a params value.\n        const testcaseStringUnique = stringifyPublicParamsUniquely(params);\n        assert(\n          !seen.has(testcaseStringUnique),\n          `Duplicate public test case+subcase params for test ${testPathString}: ${testcaseString} (${caseQuery})`\n        );\n        seen.add(testcaseStringUnique);\n      }\n    }\n  }\n\n  computeCaseCount(): number {\n    if (this.testCases === undefined) {\n      return 1;\n    }\n\n    let caseCount = 0;\n    for (const [_caseParams, _subcases] of builderIterateCasesWithSubcases(this.testCases, null)) {\n      caseCount++;\n    }\n    return caseCount;\n  }\n\n  params(\n    cases: ((unit: CaseParamsBuilder<{}>) => ParamsBuilderBase<{}, {}>) | ParamsBuilderBase<{}, {}>\n  ): TestBuilder<S, F> {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    if (cases instanceof Function) {\n      this.testCases = cases(kUnitCaseParamsBuilder);\n    } else {\n      this.testCases = cases;\n    }\n    return this;\n  }\n\n  paramsSimple(cases: Iterable<{}>): TestBuilder<S, F> {\n    assert(this.testCases === undefined, 'test case is already parameterized');\n    this.testCases = kUnitCaseParamsBuilder.combineWithParams(cases);\n    return this;\n  }\n\n  paramsSubcasesOnly(\n    subcases: Iterable<{}> | ((unit: SubcaseParamsBuilder<{}, {}>) => SubcaseParamsBuilder<{}, {}>)\n  ): TestBuilder<S, F> {\n    if (subcases instanceof Function) {\n      return this.params(subcases(kUnitCaseParamsBuilder.beginSubcases()));\n    } else {\n      return this.params(kUnitCaseParamsBuilder.beginSubcases().combineWithParams(subcases));\n    }\n  }\n\n  private makeCaseSpecific(params: {}, subcases: Iterable<{}> | undefined) {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    return new RunCaseSpecific(\n      this.testPath,\n      params,\n      this.isUnimplemented,\n      subcases,\n      this.fixture,\n      this.testFn,\n      this.beforeFn,\n      this.testCreationStack\n    );\n  }\n\n  *iterate(caseFilter: TestParams | null): IterableIterator<RunCase> {\n    this.testCases ??= kUnitCaseParamsBuilder;\n\n    // Remove the batch__ from the caseFilter because the params builder doesn't\n    // know about it (we don't add it until later in this function).\n    let filterToBatch: number | undefined;\n    const caseFilterWithoutBatch = caseFilter ? { ...caseFilter } : null;\n    if (caseFilterWithoutBatch && kBatchParamName in caseFilterWithoutBatch) {\n      const batchParam = caseFilterWithoutBatch[kBatchParamName];\n      assert(typeof batchParam === 'number');\n      filterToBatch = batchParam;\n      delete caseFilterWithoutBatch[kBatchParamName];\n    }\n\n    for (const [caseParams, subcases] of builderIterateCasesWithSubcases(\n      this.testCases,\n      caseFilterWithoutBatch\n    )) {\n      // If batches are not used, yield just one case.\n      if (this.batchSize === 0 || subcases === undefined) {\n        yield this.makeCaseSpecific(caseParams, subcases);\n        continue;\n      }\n\n      // Same if there ends up being only one batch.\n      const subcaseArray = Array.from(subcases);\n      if (subcaseArray.length <= this.batchSize) {\n        yield this.makeCaseSpecific(caseParams, subcaseArray);\n        continue;\n      }\n\n      // There are multiple batches. Helper function for this case:\n      const makeCaseForBatch = (batch: number) => {\n        const sliceStart = batch * this.batchSize;\n        return this.makeCaseSpecific(\n          { ...caseParams, [kBatchParamName]: batch },\n          subcaseArray.slice(sliceStart, Math.min(subcaseArray.length, sliceStart + this.batchSize))\n        );\n      };\n\n      // If we filter to just one batch, yield it.\n      if (filterToBatch !== undefined) {\n        yield makeCaseForBatch(filterToBatch);\n        continue;\n      }\n\n      // Finally, if not, yield all of the batches.\n      for (let batch = 0; batch * this.batchSize < subcaseArray.length; ++batch) {\n        yield makeCaseForBatch(batch);\n      }\n    }\n  }\n}\n\nclass RunCaseSpecific implements RunCase {\n  readonly id: TestCaseID;\n  readonly isUnimplemented: boolean;\n\n  private readonly params: {};\n  private readonly subcases: Iterable<{}> | undefined;\n  private readonly fixture: FixtureClass;\n  private readonly fn: TestFn<Fixture, {}>;\n  private readonly beforeFn?: BeforeAllSubcasesFn<SubcaseBatchState, {}>;\n  private readonly testCreationStack: Error;\n\n  constructor(\n    testPath: string[],\n    params: {},\n    isUnimplemented: boolean,\n    subcases: Iterable<{}> | undefined,\n    fixture: FixtureClass,\n    fn: TestFn<Fixture, {}>,\n    beforeFn: BeforeAllSubcasesFn<SubcaseBatchState, {}> | undefined,\n    testCreationStack: Error\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.isUnimplemented = isUnimplemented;\n    this.params = params;\n    this.subcases = subcases;\n    this.fixture = fixture;\n    this.fn = fn;\n    this.beforeFn = beforeFn;\n    this.testCreationStack = testCreationStack;\n  }\n\n  computeSubcaseCount(): number {\n    if (this.subcases) {\n      let count = 0;\n      for (const _subcase of this.subcases) {\n        count++;\n      }\n      return count;\n    } else {\n      return 1;\n    }\n  }\n\n  async runTest(\n    rec: TestCaseRecorder,\n    sharedState: SubcaseBatchState,\n    params: TestParams,\n    throwSkip: boolean,\n    expectedStatus: Expectation\n  ): Promise<void> {\n    try {\n      rec.beginSubCase();\n      if (expectedStatus === 'skip') {\n        throw new SkipTestCase('Skipped by expectations');\n      }\n\n      const inst = new this.fixture(sharedState, rec, params);\n      try {\n        await inst.init();\n        await this.fn(inst as Fixture & { params: {} });\n        rec.passed();\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n      if (throwSkip && ex instanceof SkipTestCase) {\n        throw ex;\n      }\n    } finally {\n      try {\n        rec.endSubCase(expectedStatus);\n      } catch (ex) {\n        assert(ex instanceof UnexpectedPassError);\n        ex.message = `Testcase passed unexpectedly.`;\n        ex.stack = this.testCreationStack.stack;\n        rec.warn(ex);\n      }\n    }\n  }\n\n  async run(\n    rec: TestCaseRecorder,\n    selfQuery: TestQuerySingleCase,\n    expectations: TestQueryWithExpectation[]\n  ): Promise<void> {\n    const getExpectedStatus = (selfQueryWithSubParams: TestQuerySingleCase) => {\n      let didSeeFail = false;\n      for (const exp of expectations) {\n        const ordering = compareQueries(exp.query, selfQueryWithSubParams);\n        if (ordering === Ordering.Unordered || ordering === Ordering.StrictSubset) {\n          continue;\n        }\n\n        switch (exp.expectation) {\n          // Skip takes precedence. If there is any expectation indicating a skip,\n          // signal it immediately.\n          case 'skip':\n            return 'skip';\n          case 'fail':\n            // Otherwise, indicate that we might expect a failure.\n            didSeeFail = true;\n            break;\n          default:\n            unreachable();\n        }\n      }\n      return didSeeFail ? 'fail' : 'pass';\n    };\n\n    const { testHeartbeatCallback, maxSubcasesInFlight } = globalTestConfig;\n    try {\n      rec.start();\n      const sharedState = this.fixture.MakeSharedState(rec, this.params);\n      try {\n        await sharedState.init();\n        if (this.beforeFn) {\n          await this.beforeFn(sharedState);\n        }\n        await sharedState.postInit();\n        testHeartbeatCallback();\n\n        let allPreviousSubcasesFinalizedPromise: Promise<void> = Promise.resolve();\n        if (this.subcases) {\n          let totalCount = 0;\n          let skipCount = 0;\n\n          // If there are too many subcases in flight, starting the next subcase will register\n          // `resolvePromiseBlockingSubcase` and wait until `subcaseFinishedCallback` is called.\n          let subcasesInFlight = 0;\n          let resolvePromiseBlockingSubcase: (() => void) | undefined = undefined;\n          const subcaseFinishedCallback = () => {\n            subcasesInFlight -= 1;\n            // If there is any subcase waiting on a previous subcase to finish,\n            // unblock it now, and clear the resolve callback.\n            if (resolvePromiseBlockingSubcase) {\n              resolvePromiseBlockingSubcase();\n              resolvePromiseBlockingSubcase = undefined;\n            }\n          };\n\n          for (const subParams of this.subcases) {\n            // Make a recorder that will defer all calls until `allPreviousSubcasesFinalizedPromise`\n            // resolves. Waiting on `allPreviousSubcasesFinalizedPromise` ensures that\n            // logs from all the previous subcases have been flushed before flushing new logs.\n            const subcasePrefix = 'subcase: ' + stringifyPublicParams(subParams);\n            const subRec = new Proxy(rec, {\n              get: (target, k: keyof TestCaseRecorder) => {\n                const prop = TestCaseRecorder.prototype[k];\n                if (typeof prop === 'function') {\n                  testHeartbeatCallback();\n                  return function (...args: Parameters<typeof prop>) {\n                    void allPreviousSubcasesFinalizedPromise.then(() => {\n                      // Prepend the subcase name to all error messages.\n                      for (const arg of args) {\n                        if (arg instanceof Error) {\n                          try {\n                            arg.message = subcasePrefix + '\\n' + arg.message;\n                          } catch {\n                            // If that fails (e.g. on DOMException), try to put it in the stack:\n                            let stack = subcasePrefix;\n                            if (arg.stack) stack += '\\n' + arg.stack;\n                            try {\n                              arg.stack = stack;\n                            } catch {\n                              // If that fails too, just silence it.\n                            }\n                          }\n                        }\n                      }\n\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      const rv = (prop as any).apply(target, args);\n                      // Because this proxy executes functions in a deferred manner,\n                      // it should never be used for functions that need to return a value.\n                      assert(rv === undefined);\n                    });\n                  };\n                }\n                return prop;\n              },\n            });\n\n            const params = mergeParams(this.params, subParams);\n            const subcaseQuery = new TestQuerySingleCase(\n              selfQuery.suite,\n              selfQuery.filePathParts,\n              selfQuery.testPathParts,\n              params\n            );\n\n            // Limit the maximum number of subcases in flight.\n            if (subcasesInFlight >= maxSubcasesInFlight) {\n              await new Promise<void>(resolve => {\n                // There should only be one subcase waiting at a time.\n                assert(resolvePromiseBlockingSubcase === undefined);\n                resolvePromiseBlockingSubcase = resolve;\n              });\n            }\n\n            subcasesInFlight += 1;\n            // Runs async without waiting so that subsequent subcases can start.\n            // All finalization steps will be waited on at the end of the testcase.\n            const finalizePromise = this.runTest(\n              subRec,\n              sharedState,\n              params,\n              /* throwSkip */ true,\n              getExpectedStatus(subcaseQuery)\n            )\n              .then(() => {\n                subRec.info(new Error('OK'));\n              })\n              .catch(ex => {\n                if (ex instanceof SkipTestCase) {\n                  // Convert SkipTestCase to info messages\n                  ex.message = 'subcase skipped: ' + ex.message;\n                  subRec.info(ex);\n                  ++skipCount;\n                } else {\n                  // Since we are catching all error inside runTest(), this should never happen\n                  subRec.threw(ex);\n                }\n              })\n              .finally(subcaseFinishedCallback);\n\n            allPreviousSubcasesFinalizedPromise = allPreviousSubcasesFinalizedPromise.then(\n              () => finalizePromise\n            );\n            ++totalCount;\n          }\n\n          // Wait for all subcases to finalize and report their results.\n          await allPreviousSubcasesFinalizedPromise;\n\n          if (skipCount === totalCount) {\n            rec.skipped(new SkipTestCase('all subcases were skipped'));\n          }\n        } else {\n          await this.runTest(\n            rec,\n            sharedState,\n            this.params,\n            /* throwSkip */ false,\n            getExpectedStatus(selfQuery)\n          );\n        }\n      } finally {\n        testHeartbeatCallback();\n        // Runs as long as the shared state constructor succeeded, even if initialization or a test failed.\n        await sharedState.finalize();\n        testHeartbeatCallback();\n      }\n    } catch (ex) {\n      // There was an exception from sharedState/fixture constructor, init, beforeFn, or test.\n      // An error from beforeFn may have been SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n    } finally {\n      rec.finish();\n\n      const msg: CaseTimingLogLine = {\n        q: selfQuery.toString(),\n        timems: rec.result.timems,\n        nonskippedSubcaseCount: rec.nonskippedSubcaseCount,\n      };\n      logToWebSocket(JSON.stringify(msg));\n    }\n  }\n}\n\nexport type CaseTimingLogLine = {\n  q: string;\n  /** Total time it took to execute the case. */\n  timems: number;\n  /**\n   * Number of subcases that ran in the case (excluding skipped subcases, so\n   * they don't dilute the average per-subcase time.\n   */\n  nonskippedSubcaseCount: number;\n};\n"],"mappings":"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"}