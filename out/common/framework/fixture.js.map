{"version":3,"file":"fixture.js","names":["assert","unreachable","SkipTestCase","Error","UnexpectedPassError","TestCaseRecorder","SubcaseBatchState","constructor","recorder","params","init","postInit","finalize","skip","msg","skipIf","cond","Fixture","eventualExpectations","numOutstandingAsyncExpectations","objectsToCleanUp","MakeSharedState","sharedState","rec","_sharedState","_params","length","p","shift","ex","threw","o","WEBGL_lose_context","getExtension","loseContext","destroy","destroyAsync","close","src","srcObject","trackForCleanup","Promise","eventualAsyncExpectation","then","GPUDevice","push","lost","tryTrackForCleanup","WebGLRenderingContext","WebGL2RenderingContext","requestDeviceTracked","adapter","desc","undefined","requestDevice","debug","info","warn","fail","expectationFailed","immediateAsyncExpectation","fn","ret","promise","expectErrorValue","expectedError","niceStack","message","actualName","name","shouldResolve","m","shouldReject","expectedName","allowMissingStack","stack","exMessage","shouldThrow","expect","expectOK","error","mode","handleError","Array","isArray","e","eventualExpectOK"],"sources":["../../../src/common/framework/fixture.ts"],"sourcesContent":["import { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\nimport { JSONWithUndefined } from '../internal/params_utils.js';\nimport { assert, ExceptionCheckOptions, unreachable } from '../util/util.js';\n\nexport class SkipTestCase extends Error {}\nexport class UnexpectedPassError extends Error {}\n\nexport { TestCaseRecorder } from '../internal/logging/test_case_recorder.js';\n\n/** The fully-general type for params passed to a test function invocation. */\nexport type TestParams = {\n  readonly [k: string]: JSONWithUndefined;\n};\n\ntype DestroyableObject =\n  | { destroy(): void }\n  | { destroyAsync(): Promise<void> }\n  | { close(): void }\n  | { getExtension(extensionName: 'WEBGL_lose_context'): WEBGL_lose_context }\n  | HTMLVideoElement;\n\nexport class SubcaseBatchState {\n  constructor(\n    protected readonly recorder: TestCaseRecorder,\n    /** The case parameters for this test fixture shared state. Subcase params are not included. */\n    public readonly params: TestParams\n  ) {}\n\n  /**\n   * Runs before the `.before()` function.\n   * @internal MAINTENANCE_TODO: Make this not visible to test code?\n   */\n  async init() {}\n  /**\n   * Runs between the `.before()` function and the subcases.\n   * @internal MAINTENANCE_TODO: Make this not visible to test code?\n   */\n  async postInit() {}\n  /**\n   * Runs after all subcases finish.\n   * @internal MAINTENANCE_TODO: Make this not visible to test code?\n   */\n  async finalize() {}\n\n  /** Throws an exception marking the subcase as skipped. */\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  /** Throws an exception making the subcase as skipped if condition is true */\n  skipIf(cond: boolean, msg: string | (() => string) = '') {\n    if (cond) {\n      this.skip(typeof msg === 'function' ? msg() : msg);\n    }\n  }\n}\n\n/**\n * A Fixture is a class used to instantiate each test sub/case at run time.\n * A new instance of the Fixture is created for every single test subcase\n * (i.e. every time the test function is run).\n */\nexport class Fixture<S extends SubcaseBatchState = SubcaseBatchState> {\n  private _params: unknown;\n  private _sharedState: S;\n  /**\n   * Interface for recording logs and test status.\n   *\n   * @internal\n   */\n  readonly rec: TestCaseRecorder;\n  private eventualExpectations: Array<Promise<unknown>> = [];\n  private numOutstandingAsyncExpectations = 0;\n  private objectsToCleanUp: DestroyableObject[] = [];\n\n  public static MakeSharedState(recorder: TestCaseRecorder, params: TestParams): SubcaseBatchState {\n    return new SubcaseBatchState(recorder, params);\n  }\n\n  /** @internal */\n  constructor(sharedState: S, rec: TestCaseRecorder, params: TestParams) {\n    this._sharedState = sharedState;\n    this.rec = rec;\n    this._params = params;\n  }\n\n  /**\n   * Returns the (case+subcase) parameters for this test function invocation.\n   */\n  get params(): unknown {\n    return this._params;\n  }\n\n  /**\n   * Gets the test fixture's shared state. This object is shared between subcases\n   * within the same testcase.\n   */\n  get sharedState(): S {\n    return this._sharedState;\n  }\n\n  /**\n   * Override this to do additional pre-test-function work in a derived fixture.\n   * This has to be a member function instead of an async `createFixture` function, because\n   * we need to be able to ergonomically override it in subclasses.\n   *\n   * @internal MAINTENANCE_TODO: Make this not visible to test code?\n   */\n  async init(): Promise<void> {}\n\n  /**\n   * Override this to do additional post-test-function work in a derived fixture.\n   *\n   * Called even if init was unsuccessful.\n   *\n   * @internal MAINTENANCE_TODO: Make this not visible to test code?\n   */\n  async finalize(): Promise<void> {\n    assert(\n      this.numOutstandingAsyncExpectations === 0,\n      'there were outstanding immediateAsyncExpectations (e.g. expectUncapturedError) at the end of the test'\n    );\n\n    // Loop to exhaust the eventualExpectations in case they chain off each other.\n    while (this.eventualExpectations.length) {\n      const p = this.eventualExpectations.shift()!;\n      try {\n        await p;\n      } catch (ex) {\n        this.rec.threw(ex);\n      }\n    }\n\n    // And clean up any objects now that they're done being used.\n    for (const o of this.objectsToCleanUp) {\n      if ('getExtension' in o) {\n        const WEBGL_lose_context = o.getExtension('WEBGL_lose_context');\n        if (WEBGL_lose_context) WEBGL_lose_context.loseContext();\n      } else if ('destroy' in o) {\n        o.destroy();\n      } else if ('destroyAsync' in o) {\n        await o.destroyAsync();\n      } else if ('close' in o) {\n        o.close();\n      } else {\n        // HTMLVideoElement\n        o.src = '';\n        o.srcObject = null;\n      }\n    }\n  }\n\n  /**\n   * Tracks an object to be cleaned up after the test finishes.\n   *\n   * Usually when creating buffers/textures/query sets, you can use the helpers in GPUTest instead.\n   */\n  trackForCleanup<T extends DestroyableObject | Promise<DestroyableObject>>(o: T): T {\n    if (o instanceof Promise) {\n      this.eventualAsyncExpectation(() =>\n        o.then(\n          o => this.trackForCleanup(o),\n          () => {}\n        )\n      );\n      return o;\n    }\n\n    if (o instanceof GPUDevice) {\n      this.objectsToCleanUp.push({\n        async destroyAsync() {\n          o.destroy();\n          await o.lost;\n        },\n      });\n    } else {\n      this.objectsToCleanUp.push(o);\n    }\n    return o;\n  }\n\n  /** Tracks an object, if it's destroyable, to be cleaned up after the test finishes. */\n  tryTrackForCleanup<T>(o: T): T {\n    if (typeof o === 'object' && o !== null) {\n      if (\n        'destroy' in o ||\n        'close' in o ||\n        o instanceof WebGLRenderingContext ||\n        o instanceof WebGL2RenderingContext\n      ) {\n        this.objectsToCleanUp.push(o as unknown as DestroyableObject);\n      }\n    }\n    return o;\n  }\n\n  /** Call requestDevice() and track the device for cleanup. */\n  requestDeviceTracked(adapter: GPUAdapter, desc: GPUDeviceDescriptor | undefined = undefined) {\n    // eslint-disable-next-line no-restricted-syntax\n    return this.trackForCleanup(adapter.requestDevice(desc));\n  }\n\n  /** Log a debug message. */\n  debug(msg: string): void {\n    this.rec.debug(new Error(msg));\n  }\n\n  /**\n   * Log an info message.\n   * **Use sparingly. Use `debug()` instead if logs are only needed with debug logging enabled.**\n   */\n  info(msg: string): void {\n    this.rec.info(new Error(msg));\n  }\n\n  /** Throws an exception marking the subcase as skipped. */\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  /** Throws an exception marking the subcase as skipped if condition is true */\n  skipIf(cond: boolean, msg: string | (() => string) = '') {\n    if (cond) {\n      this.skip(typeof msg === 'function' ? msg() : msg);\n    }\n  }\n\n  /** Log a warning and increase the result status to \"Warn\". */\n  warn(msg?: string): void {\n    this.rec.warn(new Error(msg));\n  }\n\n  /** Log an error and increase the result status to \"ExpectFailed\". */\n  fail(msg?: string): void {\n    this.rec.expectationFailed(new Error(msg));\n  }\n\n  /**\n   * Wraps an async function. Tracks its status to fail if the test tries to report a test status\n   * before the async work has finished.\n   */\n  protected async immediateAsyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  /**\n   * Wraps an async function, passing it an `Error` object recording the original stack trace.\n   * The async work will be implicitly waited upon before reporting a test status.\n   */\n  protected eventualAsyncExpectation<T>(fn: (niceStack: Error) => Promise<T>): void {\n    const promise = fn(new Error());\n    this.eventualExpectations.push(promise);\n  }\n\n  private expectErrorValue(expectedError: string | true, ex: unknown, niceStack: Error): void {\n    if (!(ex instanceof Error)) {\n      niceStack.message = `THREW non-error value, of type ${typeof ex}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n      return;\n    }\n    const actualName = ex.name;\n    if (expectedError !== true && actualName !== expectedError) {\n      niceStack.message = `THREW ${actualName}, instead of ${expectedError}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n    } else {\n      niceStack.message = `OK: threw ${actualName}: ${ex.message}`;\n      this.rec.debug(niceStack);\n    }\n  }\n\n  /** Expect that the provided promise resolves (fulfills). */\n  shouldResolve(p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'resolved as expected' + m;\n      } catch (ex) {\n        niceStack.message = `REJECTED${m}`;\n        if (ex instanceof Error) {\n          niceStack.message += '\\n' + ex.message;\n        }\n        this.rec.expectationFailed(niceStack);\n      }\n    });\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  shouldReject(\n    expectedName: string,\n    p: Promise<unknown>,\n    { allowMissingStack = false, message }: ExceptionCheckOptions = {}\n  ): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = message ? ': ' + message : '';\n      try {\n        await p;\n        niceStack.message = 'DID NOT REJECT' + m;\n        this.rec.expectationFailed(niceStack);\n      } catch (ex) {\n        this.expectErrorValue(expectedName, ex, niceStack);\n        if (!allowMissingStack) {\n          if (!(ex instanceof Error && typeof ex.stack === 'string')) {\n            const exMessage = ex instanceof Error ? ex.message : '?';\n            niceStack.message = `rejected as expected, but missing stack (${exMessage})${m}`;\n            this.rec.expectationFailed(niceStack);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Expect that the provided function throws (if `true` or `string`) or not (if `false`).\n   * If a string is provided, expect that the throw exception has that name.\n   *\n   * MAINTENANCE_TODO: Change to `string | false` so the exception name is always checked.\n   */\n  shouldThrow(\n    expectedError: string | boolean,\n    fn: () => void,\n    { allowMissingStack = false, message }: ExceptionCheckOptions = {}\n  ) {\n    const m = message ? ': ' + message : '';\n    try {\n      fn();\n      if (expectedError === false) {\n        this.rec.debug(new Error('did not throw, as expected' + m));\n      } else {\n        this.rec.expectationFailed(new Error('unexpectedly did not throw' + m));\n      }\n    } catch (ex) {\n      if (expectedError === false) {\n        this.rec.expectationFailed(new Error('threw unexpectedly' + m));\n      } else {\n        this.expectErrorValue(expectedError, ex, new Error(m));\n        if (!allowMissingStack) {\n          if (!(ex instanceof Error && typeof ex.stack === 'string')) {\n            this.rec.expectationFailed(new Error('threw as expected, but missing stack' + m));\n          }\n        }\n      }\n    }\n  }\n\n  /** Expect that a condition is true. */\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      const m = msg ? ': ' + msg : '';\n      this.rec.debug(new Error('expect OK' + m));\n    } else {\n      this.rec.expectationFailed(new Error(msg));\n    }\n    return cond;\n  }\n\n  /**\n   * If the argument is an `Error`, fail (or warn). If it's `undefined`, no-op.\n   * If the argument is an array, apply the above behavior on each of elements.\n   */\n  expectOK(\n    error: Error | undefined | (Error | undefined)[],\n    { mode = 'fail', niceStack }: { mode?: 'fail' | 'warn'; niceStack?: Error } = {}\n  ): void {\n    const handleError = (error: Error | undefined) => {\n      if (error instanceof Error) {\n        if (niceStack) {\n          error.stack = niceStack.stack;\n        }\n        if (mode === 'fail') {\n          this.rec.expectationFailed(error);\n        } else if (mode === 'warn') {\n          this.rec.warn(error);\n        } else {\n          unreachable();\n        }\n      }\n    };\n\n    if (Array.isArray(error)) {\n      for (const e of error) {\n        handleError(e);\n      }\n    } else {\n      handleError(error);\n    }\n  }\n\n  eventualExpectOK(\n    error: Promise<Error | undefined | (Error | undefined)[]>,\n    { mode = 'fail' }: { mode?: 'fail' | 'warn' } = {}\n  ) {\n    this.eventualAsyncExpectation(async niceStack => {\n      this.expectOK(await error, { mode, niceStack });\n    });\n  }\n}\n\nexport type SubcaseBatchStateFromFixture<F> = F extends Fixture<infer S> ? S : never;\n\n/**\n * FixtureClass encapsulates a constructor for fixture and a corresponding\n * shared state factory function. An interface version of the type is also\n * defined for mixin declaration use ONLY. The interface version is necessary\n * because mixin classes need a constructor with a single any[] rest\n * parameter.\n */\nexport type FixtureClass<F extends Fixture = Fixture> = {\n  new (sharedState: SubcaseBatchStateFromFixture<F>, log: TestCaseRecorder, params: TestParams): F;\n  MakeSharedState(recorder: TestCaseRecorder, params: TestParams): SubcaseBatchStateFromFixture<F>;\n};\nexport type FixtureClassInterface<F extends Fixture = Fixture> = {\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  new (...args: any[]): F;\n  MakeSharedState(recorder: TestCaseRecorder, params: TestParams): SubcaseBatchStateFromFixture<F>;\n};\nexport type FixtureClassWithMixin<FC, M> = FC extends FixtureClass<infer F>\n  ? FixtureClass<F & M>\n  : never;\n"],"mappings":"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"}