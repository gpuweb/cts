{"version":3,"file":"options.js","names":["unreachable","windowURL","undefined","getWindowURL","URL","window","location","toString","optionEnabled","opt","searchParams","val","get","optionString","optionWorkerMode","value","kDefaultCTSOptions","worker","debug","compatibility","forceFallbackAdapter","enforceDefaultLimits","unrollConstEvalLoops","powerPreference","logToWebSocket","kCTSOptionsInfo","description","parser","selectValueDescriptions","camelCaseToSnakeCase","id","replace","toLowerCase","getOptionsInfoFromSearchString","optionsInfos","searchString","URLSearchParams","optionValues","optionName","info","Object","entries","parseSearchParamLikeWithOptions","query","includes","startsWith","queries","getAll","options","parseSearchParamLikeWithCTSOptions"],"sources":["../../../../src/common/runtime/helper/options.ts"],"sourcesContent":["import { unreachable } from '../../util/util.js';\n\nlet windowURL: URL | undefined = undefined;\nfunction getWindowURL() {\n  if (windowURL === undefined) {\n    windowURL = new URL(window.location.toString());\n  }\n  return windowURL;\n}\n\n/** Parse a runner option that is always boolean-typed. False if missing or '0'. */\nexport function optionEnabled(\n  opt: string,\n  searchParams: URLSearchParams = getWindowURL().searchParams\n): boolean {\n  const val = searchParams.get(opt);\n  return val !== null && val !== '0';\n}\n\n/** Parse a runner option that is string-typed. If the option is missing, returns `null`. */\nexport function optionString(\n  opt: string,\n  searchParams: URLSearchParams = getWindowURL().searchParams\n): string | null {\n  return searchParams.get(opt);\n}\n\n/** Runtime modes for running tests in different types of workers. */\nexport type WorkerMode = 'dedicated' | 'service' | 'shared';\n/** Parse a runner option for different worker modes (as in `?worker=shared`). Null if no worker. */\nexport function optionWorkerMode(\n  opt: string,\n  searchParams: URLSearchParams = getWindowURL().searchParams\n): WorkerMode | null {\n  const value = searchParams.get(opt);\n  if (value === null || value === '0') {\n    return null;\n  } else if (value === 'service') {\n    return 'service';\n  } else if (value === 'shared') {\n    return 'shared';\n  } else if (value === '' || value === '1' || value === 'dedicated') {\n    return 'dedicated';\n  }\n  unreachable('invalid worker= option value');\n}\n\n/**\n * The possible options for the tests.\n */\nexport interface CTSOptions {\n  worker: WorkerMode | null;\n  debug: boolean;\n  compatibility: boolean;\n  forceFallbackAdapter: boolean;\n  enforceDefaultLimits: boolean;\n  unrollConstEvalLoops: boolean;\n  powerPreference: GPUPowerPreference | null;\n  logToWebSocket: boolean;\n}\n\nexport const kDefaultCTSOptions: CTSOptions = {\n  worker: null,\n  debug: true,\n  compatibility: false,\n  forceFallbackAdapter: false,\n  enforceDefaultLimits: false,\n  unrollConstEvalLoops: false,\n  powerPreference: null,\n  logToWebSocket: false,\n};\n\n/**\n * Extra per option info.\n */\nexport interface OptionInfo {\n  description: string;\n  parser?: (key: string, searchParams?: URLSearchParams) => boolean | string | null;\n  selectValueDescriptions?: { value: string | null; description: string }[];\n}\n\n/**\n * Type for info for every option. This definition means adding an option\n * will generate a compile time error if no extra info is provided.\n */\nexport type OptionsInfos<Type> = Record<keyof Type, OptionInfo>;\n\n/**\n * Options to the CTS.\n */\nexport const kCTSOptionsInfo: OptionsInfos<CTSOptions> = {\n  worker: {\n    description: 'run in a worker',\n    parser: optionWorkerMode,\n    selectValueDescriptions: [\n      { value: null, description: 'no worker' },\n      { value: 'dedicated', description: 'dedicated worker' },\n      { value: 'shared', description: 'shared worker' },\n      { value: 'service', description: 'service worker' },\n    ],\n  },\n  debug: { description: 'show more info' },\n  compatibility: { description: 'request adapters with featureLevel: \"compatibility\"' },\n  forceFallbackAdapter: { description: 'pass forceFallbackAdapter: true to requestAdapter' },\n  enforceDefaultLimits: {\n    description: `force the adapter limits to the default limits.\nNote: May fail on tests for low-power/high-performance`,\n  },\n  unrollConstEvalLoops: { description: 'unroll const eval loops in WGSL' },\n  powerPreference: {\n    description: 'set default powerPreference for some tests',\n    parser: optionString,\n    selectValueDescriptions: [\n      { value: null, description: 'default' },\n      { value: 'low-power', description: 'low-power' },\n      { value: 'high-performance', description: 'high-performance' },\n    ],\n  },\n  logToWebSocket: { description: 'send some logs to ws://localhost:59497/' },\n};\n\n/**\n * Converts camel case to snake case.\n * Examples:\n *    fooBar -> foo_bar\n *    parseHTMLFile -> parse_html_file\n */\nexport function camelCaseToSnakeCase(id: string) {\n  return id\n    .replace(/(.)([A-Z][a-z]+)/g, '$1_$2')\n    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')\n    .toLowerCase();\n}\n\n/**\n * Creates a Options from search parameters.\n */\nfunction getOptionsInfoFromSearchString<Type extends CTSOptions>(\n  optionsInfos: OptionsInfos<Type>,\n  searchString: string\n): Type {\n  const searchParams = new URLSearchParams(searchString);\n  const optionValues: Record<string, boolean | string | null> = {};\n  for (const [optionName, info] of Object.entries(optionsInfos)) {\n    const parser = info.parser || optionEnabled;\n    optionValues[optionName] = parser(camelCaseToSnakeCase(optionName), searchParams);\n  }\n  return optionValues as unknown as Type;\n}\n\n/**\n * Given a test query string in the form of `suite:foo,bar,moo&opt1=val1&opt2=val2\n * returns the query and the options.\n */\nexport function parseSearchParamLikeWithOptions<Type extends CTSOptions>(\n  optionsInfos: OptionsInfos<Type>,\n  query: string\n): {\n  queries: string[];\n  options: Type;\n} {\n  const searchString = query.includes('q=') || query.startsWith('?') ? query : `q=${query}`;\n  const queries = new URLSearchParams(searchString).getAll('q');\n  const options = getOptionsInfoFromSearchString(optionsInfos, searchString);\n  return { queries, options };\n}\n\n/**\n * Given a test query string in the form of `suite:foo,bar,moo&opt1=val1&opt2=val2\n * returns the query and the common options.\n */\nexport function parseSearchParamLikeWithCTSOptions(query: string) {\n  return parseSearchParamLikeWithOptions(kCTSOptionsInfo, query);\n}\n"],"mappings":";;GAAA,SAASA,WAAW,QAAQ,oBAAoB,CAEhD,IAAIC,SAA0B,GAAGC,SAAS;AAC1C,SAASC,YAAYA,CAAA,EAAG;EACtB,IAAIF,SAAS,KAAKC,SAAS,EAAE;IAC3BD,SAAS,GAAG,IAAIG,GAAG,CAACC,MAAM,CAACC,QAAQ,CAACC,QAAQ,CAAC,CAAC,CAAC;EACjD;EACA,OAAON,SAAS;AAClB;;AAEA;AACA,OAAO,SAASO,aAAaA;AAC3BC,GAAW;AACXC,YAA6B,GAAGP,YAAY,CAAC,CAAC,CAACO,YAAY;AAClD;EACT,MAAMC,GAAG,GAAGD,YAAY,CAACE,GAAG,CAACH,GAAG,CAAC;EACjC,OAAOE,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,GAAG;AACpC;;AAEA;AACA,OAAO,SAASE,YAAYA;AAC1BJ,GAAW;AACXC,YAA6B,GAAGP,YAAY,CAAC,CAAC,CAACO,YAAY;AAC5C;EACf,OAAOA,YAAY,CAACE,GAAG,CAACH,GAAG,CAAC;AAC9B;;AAEA;;AAEA;AACA,OAAO,SAASK,gBAAgBA;AAC9BL,GAAW;AACXC,YAA6B,GAAGP,YAAY,CAAC,CAAC,CAACO,YAAY;AACxC;EACnB,MAAMK,KAAK,GAAGL,YAAY,CAACE,GAAG,CAACH,GAAG,CAAC;EACnC,IAAIM,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,GAAG,EAAE;IACnC,OAAO,IAAI;EACb,CAAC,MAAM,IAAIA,KAAK,KAAK,SAAS,EAAE;IAC9B,OAAO,SAAS;EAClB,CAAC,MAAM,IAAIA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAO,QAAQ;EACjB,CAAC,MAAM,IAAIA,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,WAAW,EAAE;IACjE,OAAO,WAAW;EACpB;EACAf,WAAW,CAAC,8BAA8B,CAAC;AAC7C;;AAEA;AACA;AACA;;;;;;;;;;;;AAYA,OAAO,MAAMgB,kBAA8B,GAAG;EAC5CC,MAAM,EAAE,IAAI;EACZC,KAAK,EAAE,IAAI;EACXC,aAAa,EAAE,KAAK;EACpBC,oBAAoB,EAAE,KAAK;EAC3BC,oBAAoB,EAAE,KAAK;EAC3BC,oBAAoB,EAAE,KAAK;EAC3BC,eAAe,EAAE,IAAI;EACrBC,cAAc,EAAE;AAClB,CAAC;;AAED;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,OAAO,MAAMC,eAAyC,GAAG;EACvDR,MAAM,EAAE;IACNS,WAAW,EAAE,iBAAiB;IAC9BC,MAAM,EAAEb,gBAAgB;IACxBc,uBAAuB,EAAE;IACvB,EAAEb,KAAK,EAAE,IAAI,EAAEW,WAAW,EAAE,WAAW,CAAC,CAAC;IACzC,EAAEX,KAAK,EAAE,WAAW,EAAEW,WAAW,EAAE,kBAAkB,CAAC,CAAC;IACvD,EAAEX,KAAK,EAAE,QAAQ,EAAEW,WAAW,EAAE,eAAe,CAAC,CAAC;IACjD,EAAEX,KAAK,EAAE,SAAS,EAAEW,WAAW,EAAE,gBAAgB,CAAC,CAAC;;EAEvD,CAAC;EACDR,KAAK,EAAE,EAAEQ,WAAW,EAAE,gBAAgB,CAAC,CAAC;EACxCP,aAAa,EAAE,EAAEO,WAAW,EAAE,qDAAqD,CAAC,CAAC;EACrFN,oBAAoB,EAAE,EAAEM,WAAW,EAAE,mDAAmD,CAAC,CAAC;EAC1FL,oBAAoB,EAAE;IACpBK,WAAW,EAAG;AAClB;EACE,CAAC;EACDJ,oBAAoB,EAAE,EAAEI,WAAW,EAAE,iCAAiC,CAAC,CAAC;EACxEH,eAAe,EAAE;IACfG,WAAW,EAAE,4CAA4C;IACzDC,MAAM,EAAEd,YAAY;IACpBe,uBAAuB,EAAE;IACvB,EAAEb,KAAK,EAAE,IAAI,EAAEW,WAAW,EAAE,SAAS,CAAC,CAAC;IACvC,EAAEX,KAAK,EAAE,WAAW,EAAEW,WAAW,EAAE,WAAW,CAAC,CAAC;IAChD,EAAEX,KAAK,EAAE,kBAAkB,EAAEW,WAAW,EAAE,kBAAkB,CAAC,CAAC;;EAElE,CAAC;EACDF,cAAc,EAAE,EAAEE,WAAW,EAAE,yCAAyC,CAAC;AAC3E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,oBAAoBA,CAACC,EAAU,EAAE;EAC/C,OAAOA,EAAE;EACNC,OAAO,CAAC,mBAAmB,EAAE,OAAO,CAAC;EACrCA,OAAO,CAAC,oBAAoB,EAAE,OAAO,CAAC;EACtCC,WAAW,CAAC,CAAC;AAClB;;AAEA;AACA;AACA;AACA,SAASC,8BAA8BA;AACrCC,YAAgC;AAChCC,YAAoB;AACd;EACN,MAAMzB,YAAY,GAAG,IAAI0B,eAAe,CAACD,YAAY,CAAC;EACtD,MAAME,YAAqD,GAAG,CAAC,CAAC;EAChE,KAAK,MAAM,CAACC,UAAU,EAAEC,IAAI,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACP,YAAY,CAAC,EAAE;IAC7D,MAAMP,MAAM,GAAGY,IAAI,CAACZ,MAAM,IAAInB,aAAa;IAC3C6B,YAAY,CAACC,UAAU,CAAC,GAAGX,MAAM,CAACE,oBAAoB,CAACS,UAAU,CAAC,EAAE5B,YAAY,CAAC;EACnF;EACA,OAAO2B,YAAY;AACrB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASK,+BAA+BA;AAC7CR,YAAgC;AAChCS,KAAa;;;;AAIb;EACA,MAAMR,YAAY,GAAGQ,KAAK,CAACC,QAAQ,CAAC,IAAI,CAAC,IAAID,KAAK,CAACE,UAAU,CAAC,GAAG,CAAC,GAAGF,KAAK,GAAI,KAAIA,KAAM,EAAC;EACzF,MAAMG,OAAO,GAAG,IAAIV,eAAe,CAACD,YAAY,CAAC,CAACY,MAAM,CAAC,GAAG,CAAC;EAC7D,MAAMC,OAAO,GAAGf,8BAA8B,CAACC,YAAY,EAAEC,YAAY,CAAC;EAC1E,OAAO,EAAEW,OAAO,EAAEE,OAAO,CAAC,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,kCAAkCA,CAACN,KAAa,EAAE;EAChE,OAAOD,+BAA+B,CAACjB,eAAe,EAAEkB,KAAK,CAAC;AAChE"}