export const description = `
Converts two floating point values to half-precision floating point numbers, and then combines them into one u32 value.
Component e[i] of the input is converted to a IEEE-754 binary16 value,
which is then placed in bits 16 × i through 16 × i + 15 of the result.
`;

import { makeTestGroup } from '../../../../../../common/framework/test_group.js';
import { assert } from '../../../../../../common/util/util.js';
import { Float16Array } from '../../../../../../external/petamoriken/float16/float16.js';
import { GPUTest } from '../../../../../gpu_test.js';
import { anyOf, Comparator } from '../../../../../util/compare.js';
import {
  f32,
  Scalar,
  TypeF32,
  TypeU32,
  TypeVec,
  u32,
  vec2,
} from '../../../../../util/conversion.js';
import {
  cartesianProduct,
  correctlyRoundedF16,
  fullF32Range,
  isFiniteF16,
  quantizeToF32,
} from '../../../../../util/math.js';
import { allInputSources, Case, run } from '../../expression.js';

import { builtin } from './builtin.js';

export const g = makeTestGroup(GPUTest);

/**
 * Quantize two f32s to f16 and then packs them in a u32
 *
 * This should implement the same behaviour as the builtin `pack2x16float` from
 * WGSL.
 * Caller is responsible to ensuring inputs are f32s
 *
 * @param x first f32 to be packed
 * @param y second f32 to be packed
 * @returns an array of possible results for pack2x16float. Elements are either
 *          a number or undefined.
 *          undefined indicates that any value is valid, since the input went
 *          out of bounds.
 */
export function pack2x16float(x: number, y: number): (number | undefined)[] {
  if (!isFiniteF16(x) || !isFiniteF16(y)) {
    // This indicates any value is valid, so it isn't worth bothering
    // calculating the more restrictive possibilities.
    return [undefined];
  }

  // f32s are not guaranteed to be precisely expressible as a f16, so quantizing
  // down may have two possible options, which are returned by
  // correctlyRounded16.
  const f16_pairs = cartesianProduct(correctlyRoundedF16(x), correctlyRoundedF16(y));
  const results = new Array<number>();
  f16_pairs.forEach(p => {
    const buf = new ArrayBuffer(4);
    const buf_f16 = new Float16Array(buf);
    assert(p.length === 2, 'cartesianProduct of 2 arrays returned an entry with not 2 elements');
    buf_f16[0] = p[0];
    buf_f16[1] = p[1];

    results.push(new Uint32Array(buf)[0].valueOf());
  });
  return results;
}

/**
 * @returns a custom comparator for a possible result from pack2x16float
 * @param expectation element of the array generated by pack2x16float
 */
export function cmp(expectation: number | undefined): Comparator {
  return got => {
    assert(got instanceof Scalar, `Received non-Scalar Value in pack2x16float comparator`);
    let matched = true;
    if (expectation !== undefined) {
      matched = (got.value as number) === expectation;
    }

    return {
      matched,
      got: `${got}`,
      expected: `${expectation !== undefined ? u32(expectation) : 'Any'}`,
    };
  };
}

g.test('pack')
  .specURL('https://www.w3.org/TR/WGSL/#pack-builtin-functions')
  .desc(
    `
@const fn pack2x16float(e: vec2<f32>) -> u32
`
  )
  .params(u => u.combine('inputSource', allInputSources))
  .fn(async t => {
    const makeCase = (x: number, y: number): Case => {
      x = quantizeToF32(x);
      y = quantizeToF32(y);
      const results = pack2x16float(x, y);
      return { input: [vec2(f32(x), f32(y))], expected: anyOf(...results.map(cmp)) };
    };

    const numeric_range = fullF32Range();
    const cases: Array<Case> = [];
    numeric_range.forEach(x => {
      numeric_range.forEach(y => {
        cases.push(makeCase(x, y));
      });
    });

    await run(t, builtin('pack2x16float'), [TypeVec(2, TypeF32)], TypeU32, t.params, cases);
  });
